<html>
<head>
<meta charset="UTF-8">
<title>Untranslate-for-execution</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____UNTRANSLATE-FOR-EXECUTION">Click for Untranslate-for-execution in the Full Manual</a></h3>

<p>Attempt to do a kind of untranslation of a <a href="ACL2____UTE-TERM-P.html">ute-term-p</a> in 
order to restore any <a href="ACL2____MV-LET.html">mv-let</a> and <a href="ACL2____MV.html">mv</a> forms, ideally so that the 
term can be executed.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(untranslate-for-execution x stobjs-out world) 
  → 
(mv errmsg new-x)</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">x</span> — The term to untranslate.<br>    <font color="#606060">Guard <span class="v">(<a href="ACL2____UTE-TERM-P.html">ute-term-p</a> x)</span>.</font>
</dd> 
  <dd>
<span class="tt">stobjs-out</span> — The expected stobjs-out for this term.<br>    <font color="#606060">Guard <span class="v">(<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> stobjs-out) (<a href="COMMON-LISP____CONSP.html">consp</a> stobjs-out))</span>.</font>
</dd> 
  <dd>
<span class="tt">world</span> — The current ACL2 world, needed for signature lookups.<br>    <font color="#606060">Guard <span class="v">(<a href="ACL2____PLIST-WORLDP.html">plist-worldp</a> world)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">errmsg</span> — NIL on success or an error <a href="ACL2____MSG.html">msg</a> on failure.</dd> 
<dd>
<span class="tt">new-x</span> — New version of <span class="v">x</span>, with MVs restored.</dd> 
 
</dl></div> 
<p>When <a href="ACL2____TERM.html">term</a>s are translated into <a href="ACL2____UTE-TERM-P.html">ute-term-p</a>s, 
information about their <a href="ACL2____MV.html">mv</a> and <a href="ACL2____STOBJ.html">stobj</a> nature can be lost.  For 
instance, suppose we start with a simple definition, <span class="v">f</span>:</p> 
 
<pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> f (a b) (<a href="ACL2____MV.html">mv</a> a b))</pre> 
 
<p>Since <a href="ACL2____MV.html">mv</a> is logically just <a href="COMMON-LISP____LIST.html">list</a>, the logical definition of 
<span class="v">f</span> ends up being <span class="v">(<a href="COMMON-LISP____CONS.html">cons</a> a (<a href="COMMON-LISP____CONS.html">cons</a> b 'nil))</span>.  Suppose we want to use this 
logical definition to derive some new function, <span class="v">g</span>,</p> 
 
<pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> g (a b) (<a href="COMMON-LISP____CONS.html">cons</a> a (<a href="COMMON-LISP____CONS.html">cons</a> b 'nil)))</pre> 
 
<p>Although <span class="v">f</span> and <span class="v">g</span> are logically identical, they are practically 
incompatible: <span class="v">f</span> returns two values but <span class="v">g</span> only returns one.  This kind 
of mismatch can sometimes cause problems when you are writing code that 
modifies existing ACL2 functions.</p> 
 
<p>The <span class="v">untranslate-for-execution</span> tool tries to allow you to recover 
something like the true original definition.  For example, if we run:</p> 
 
<pre class="code">(<a href="ACL2____UNTRANSLATE-FOR-EXECUTION.html">untranslate-for-execution</a>
 '(<a href="COMMON-LISP____CONS.html">cons</a> a (<a href="COMMON-LISP____CONS.html">cons</a> b 'nil))   ;; unnormalized-body property of F
 '(nil nil)                ;; stobjs-out property of F
 (<a href="ACL2____W.html">w</a> state))</pre> 
 
<p>Then we get back <span class="v">(<a href="ACL2____MV.html">mv</a> a b)</span>, i.e., the <span class="v">cons</span> nest has been 
``properly'' converted back into an <a href="ACL2____MV.html">mv</a> form.</p> 
 
<p>In general, we try to ``smartly'' walk through the term and restore <a href="ACL2____MV.html">mv</a> and <a href="ACL2____MV-LET.html">mv-let</a> forms throughout it.  However, note that this is an 
experimental tool and it may not yet be particularly robust.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>untranslate-for-execution</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> untranslate-for-execution
       (x stobjs-out world)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____UTE-TERM-P.html">ute-term-p</a> x)
                                   (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> stobjs-out)
                                        (<a href="COMMON-LISP____CONSP.html">consp</a> stobjs-out))
                                   (<a href="ACL2____PLIST-WORLDP.html">plist-worldp</a> world))))
       (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'untranslate-for-execution))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
            (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> err x-fix1)
                  (<a href="ACL2____REINCARNATE-MVS.html">reincarnate-mvs</a> x world))
                 ((when err) (<a href="ACL2____MV.html">mv</a> err x))
                 (n (<a href="ACL2____LEN.html">len</a> stobjs-out))
                 ((when (<a href="COMMON-LISP____EQL.html">eql</a> n 1)) (<a href="ACL2____MV.html">mv</a> nil x-fix1))
                 ((<a href="ACL2____MV.html">mv</a> err new-x)
                  (<a href="ACL2____CONVERT-SUBEXPRESSION-TO-MV.html">convert-subexpression-to-mv</a> n x-fix1 world))
                 ((when err) (<a href="ACL2____MV.html">mv</a> err x)))
                (<a href="ACL2____MV.html">mv</a> nil new-x))))</pre> 

</body>
</html>
