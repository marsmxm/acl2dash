<html>
<head>
<meta charset="UTF-8">
<title>Guard-miscellany</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____GUARD-MISCELLANY">Click for Guard-miscellany in the Full Manual</a></h3>

<p>Miscellaneous remarks about guards</p><p>The discussion of guards concludes here with a few miscellaneous 
 remarks.  (Presumably you found this documentation by following a link; see 
 <a href="ACL2____GUARDS-FOR-SPECIFICATION.html">guards-for-specification</a>.)  For further information related to guards 
 other than what you find under ``<a href="ACL2____GUARD.html">guard</a>,'' see any of the following 
 documentation topics: <a href="ACL2____GUARD-EXAMPLE.html">guard-example</a>, <span class="tt"><a href="ACL2____SET-VERIFY-GUARDS-EAGERNESS.html">set-verify-guards-eagerness</a></span>, <span class="tt"><a href="ACL2____SET-GUARD-CHECKING.html">set-guard-checking</a></span>, <span class="tt"><a href="ACL2____VERIFY-GUARDS.html">verify-guards</a></span>, and (for a discussion of keyword <span class="v">:split-types</span>) <span class="tt"><a href="ACL2____XARGS.html">xargs</a></span>.</p> 
 
 <p><span class="tt"><a href="COMMON-LISP____DEFUN.html">Defun</a></span> can be made to try to verify the guards on a function.  This 
 is controlled by the ``<a href="ACL2____DEFUN-MODE.html">defun-mode</a>'' of the <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span>; see <a href="ACL2____DEFUN-MODE.html">defun-mode</a>.  The <a href="ACL2____DEFUN-MODE.html">defun-mode</a> is either as specified with the <span class="v">:mode</span> 
 <span class="v">xarg</span> of the <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> or else defaults to the default <a href="ACL2____DEFUN-MODE.html">defun-mode</a>.  See <a href="ACL2____DEFAULT-DEFUN-MODE.html">default-defun-mode</a>.  If the <a href="ACL2____DEFUN-MODE.html">defun-mode</a> of the 
 <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> is <span class="v">:</span><span class="tt"><a href="ACL2____LOGIC.html">logic</a></span> and either a <a href="ACL2____GUARD.html">guard</a> is specified 
 explicitly or <span class="v">:</span><span class="tt"><a href="ACL2____VERIFY-GUARDS.html">verify-guards</a></span> <span class="v">t</span> is specified in the <span class="tt"><a href="ACL2____XARGS.html">xargs</a></span>, then we attempt to verify the guards of the function.  Otherwise we do 
 not.  (But see <a href="ACL2____SET-VERIFY-GUARDS-EAGERNESS.html">set-verify-guards-eagerness</a> for how to modify this 
 behavior.)</p> 
 
 <p>It is sometimes impossible for the system to verify the guards of a 
 recursive function at definition time.  For example, the guard conjectures 
 might require the invention and proof of some inductively derived property of 
 the function (as often happens when the value of a recursive call is fed to a 
 guarded subroutine).  So sometimes it is necessary to define the function 
 using <span class="v">:verify-guards nil</span> then to state and prove key theorems about the 
 function, and only then have the system attempt guard verification. 
 Post-<span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> guard verification is achieved via the event <span class="tt"><a href="ACL2____VERIFY-GUARDS.html">verify-guards</a></span>.  See <a href="ACL2____VERIFY-GUARDS.html">verify-guards</a>.</p> 
 
 <p>It should be emphasized that guard verification affects only two things: 
 how fast ACL2 can evaluate the function and whether the function is executed 
 correctly by raw Common Lisp, without guard violations.  Since ACL2 does not 
 use the raw Common Lisp definition of a function to evaluate its calls unless 
 that function's guards have been verified, the latter effect is felt only if 
 you run functions in raw Common Lisp rather than via ACL2's command loop.</p> 
 
 <p>Guard verification does not otherwise affect the theorem prover or the 
 semantics of a definition.  If you are not planning on running your function 
 on ``big'' inputs and you don't care if your function runs correctly in raw 
 Common Lisp (e.g., you have formalized some abstract mathematical property and 
 just happened to use ACL2 as your language), there is no need to suffer 
 through guard verification.  Often users start by not doing guard verification 
 and address that problem later.  Sometimes you are driven to it, even in 
 mathematical projects, because you find that you want to run your functions 
 particularly fast or in raw Common Lisp.</p> 
 
 <p>If <span class="tt"><a href="ACL2____CERTIFY-BOOK.html">certify-book</a></span> is used to compile a file, and the file contains 
 functions with unverified guard conjectures, then you will be warned that the 
 compiled file cannot be loaded into raw Common Lisp with the expectation that 
 the functions will run correctly.  This is just the same point we have been 
 making: ACL2 and Common Lisp agree only on the restricted domains specified by 
 our guards.  When guards are violated, Common Lisp can do anything.  When you 
 call a compiled function on arguments violating its guards, the chances are 
 only increased that Common Lisp will go berserk, because compiled functions 
 generally check fewer things at runtime and tend to be more fragile than 
 interpreted ones.</p> 
 
 <p>Finally, we note that ACL2 collects up <a href="ACL2____GUARD.html">guard</a>s from <span class="tt"><a href="COMMON-LISP____DECLARE.html">declare</a></span> 
 forms in order of appearance.  So for example, the <span class="tt"><a href="COMMON-LISP____DECLARE.html">declare</a></span> form</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (foo x))
         (<a href="COMMON-LISP____TYPE.html">type</a> string x)</pre> 
 
 <p>will generate the guard <span class="v">(<a href="COMMON-LISP____AND.html">and</a> (foo x) (<a href="COMMON-LISP____STRINGP.html">stringp</a> x))</span>, while the form</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> string x)
         (<a href="ACL2____XARGS.html">xargs</a> :guard (foo x))</pre> 
 
 <p>will generate the guard <span class="v">(<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____STRINGP.html">stringp</a> x) (foo x))</span>.  The only exception 
 to this rule is the case that <span class="v">:guard</span> and <span class="v">:stobjs</span> are both specified 
 in which case all <span class="v">:stobjs</span> declarations will be treated as through they 
 precede all <span class="v">:guard</span> and <span class="v">type</span> declarations.</p>
</body>
</html>
