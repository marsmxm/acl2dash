<html>
<head>
<meta charset="UTF-8">
<title>Def-gl-param-thm</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____DEF-GL-PARAM-THM">Click for Def-gl-param-thm in the Full Manual</a></h3>

<p>Prove a theorem using GL symbolic simulation with parametrized 
case-splitting.</p><p>Usage:</p> 
 
<pre class="code">(<a href="ACL2____DEF-GL-PARAM-THM.html">def-gl-param-thm</a> &lt;theorem-name&gt;
  :hyp &lt;hypotheses&gt;
  :concl &lt;conclusion&gt;
  :param-hyp &lt;parametrized hypotheses&gt;
  :cov-bindings &lt;bindings for parametrization coverage&gt;
  :param-bindings &lt;bindings for the individual cases&gt;

  :rule-classes &lt;rule classes expression&gt;

  :hyp-clk &lt;number&gt; :concl-clk &lt;number&gt;
  :clause-proc &lt;clause processor name&gt;

  :n-counterexamples &lt;number&gt;
  :abort-indeterminate &lt;t or nil&gt;
  :run-before-cases &lt;term with side effects&gt;
  :run-after-cases &lt;term with side effects&gt;

  ;; Hints for coverage goals:
  :cov-theory-add &lt;theory expression&gt;
  :do-not-expand &lt;list of functions&gt;
  :cov-hints &lt;computed hints&gt;
  :cov-hints-position &lt;:replace, :before, or :after&gt;

  :test-side-goals &lt;t or nil&gt;)</pre> 
 
<p>This form submits a <a href="ACL2____DEFTHM.html">defthm</a> event for the theorem <span class="v">(<a href="ACL2____IMPLIES.html">implies</a> &lt;hyp&gt;
&lt;concl&gt;)</span> and the specified rule classes, and gives a hint to attempt to prove 
it using a GL clause processor with parametrized case-splitting.  See <a href="ACL2____DEF-GL-THM.html">def-gl-thm</a> for a simpler version that does not do case splitting.</p> 
 
<p>Out of the list of keyword arguments recognized by this macro, five are 
necessary: <span class="v">:hyp</span>, <span class="v">:concl</span>, <span class="v">param-hyp</span>, <span class="v">:cov-bindings</span>, and 
<span class="v">:param-bindings</span>.  As noted, the theorem to be proved takes the form 
<span class="v">(<a href="ACL2____IMPLIES.html">implies</a> &lt;hyp&gt; &lt;concl&gt;)</span>.  The theorem is split into cases based on the 
<span class="v">param-hyp</span>, a term containing some free variables of the theorem and some 
additional variables used in case splitting.  Values are assigned to these 
variables based on the entries in the <span class="v">param-bindings</span>, an alist of the 
following form:</p> 
 
<pre class="code">((&lt;case-bindings1&gt; &lt;var-bindings1&gt;)
 (&lt;case-bindings2&gt; &lt;var-bindings2&gt;)
 ...)</pre> 
 
<p>Each of the case-bindings is, in turn, an alist of the following form:</p> 
 
<pre class="code">((&lt;case-var1&gt; &lt;obj1&gt;)
 (&lt;case-var2&gt; &lt;obj2&gt;)
 ...)</pre> 
 
<p>and each of the var-bindings is an alist of the following form:</p> 
 
<pre class="code">((&lt;thm-var1&gt; &lt;shape-spec1&gt;)
 (&lt;thm-var2&gt; &lt;shape-spec2&gt;)
 ...)</pre> 
 
<p>For each entry in the <span class="v">param-bindings</span>, the <span class="v">param-hyp</span> is 
instantiated with the case variables bound to the objects specified in the 
entry's case-bindings.  This term gives a hypothesis about the free variables 
of the theorem, and the set of these terms generated from the param-bindings 
gives the full case-split.  The case split must cover the theorem's hypotheses; 
that is, the theorem's hypothesis must imply the disjunction of the case 
hypotheses.  To prove this, we symbolically simulate this disjunction using the 
shape specs given in the <span class="v">cov-bindings</span>, which are formatted like the 
var-bindings above.  Note that this case-split coverage step is not done as 
part of <span class="v">:test-side-goals</span>, but it happens first otherwise, so it's easy to 
tell if it's successful.</p> 
 
<p>A simple example is as follows:</p> 
 
<pre class="code">(<a href="ACL2____DEF-GL-PARAM-THM.html">def-gl-param-thm</a> addititive-inverse-for-5-bits
  :hyp (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n) (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> -16 n) (<a href="COMMON-LISP_____C3.html">&lt;</a> n 16))
  :concl (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____-.html">-</a> n n) 0)
  :param-hyp (<a href="COMMON-LISP____IF.html">if</a> sign
                 (<a href="COMMON-LISP_____C3.html">&lt;</a> n 0)
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 0 n)
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____LOGAND.html">logand</a> n 3) lower-bits)))
  :cov-bindings
  '((n (:g-number (0 1 2 5 6))))
  :param-bindings
  '((((sign t) (lower-bits nil)) ((n (:g-number (1 2 3 4 5)))))
    (((sign nil) (lower-bits 0)) ((n (:g-number (0 2 3 4 5)))))
    (((sign nil) (lower-bits 1)) ((n (:g-number (0 1 2 4 5)))))
    (((sign nil) (lower-bits 2)) ((n (:g-number (0 1 2 3 5)))))
    (((sign nil) (lower-bits 3)) ((n (:g-number (0 1 2 3 4)))))))</pre> 
 
<p>This theorem is proved by symbolic simulation of five cases, in each of 
which the param-hyp is assumed with a different setting of the sign and 
lower-bits case variables; in one case <span class="v">N</span> is required to be negative, and 
in the others it is required to be positive and have a given value on its two 
low-order bits.  To show that the case-split is complete, another symbolic 
simulation is performed (using the given <span class="v">:cov-bindings</span>) which proves that 
the disjunction of the case assumptions is complete; effectively,</p> 
 
<pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n) (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> -16 n) (<a href="COMMON-LISP_____C3.html">&lt;</a> n 16))
         (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> n 0)
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 0 n) (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____LOGAND.html">logand</a> n 3) 0))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 0 n) (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____LOGAND.html">logand</a> n 3) 1))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 0 n) (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____LOGAND.html">logand</a> n 3) 2))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 0 n) (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____LOGAND.html">logand</a> n 3) 3))))</pre> 
 
<p>Most of the remaining keyword arguments to <span class="v">DEF-GL-PARAM-THM</span> are also 
available in <a href="ACL2____DEF-GL-THM.html">def-gl-thm</a> and are documented there.  The rest are as 
follows:</p> 
 
<p><span class="v">:RUN-BEFORE-CASES</span> and <span class="v">:RUN-AFTER-CASES</span> cause a user-specified form to 
be run between the parametrized symbolic simulations.  These may use the 
variable <span class="v">id</span>, which is bound to the current assignment of the case-splitting 
variables.  These can be used to print a message before and after running each 
case so that the user can monitor the theorem's progress.</p> 
 
<p>By default, if a counterexample is encountered on any of the cases, the proof 
will abort.  Setting <span class="v">:ABORT-CTREX</span> to <span class="v">NIL</span> causes it to go on; the proof 
will fail after the clause processor returns because it will produce a goal of 
<span class="v">NIL</span>.</p> 
 
<p>By default, if any case hypothesis is unsatisfiable, the proof will abort. 
Setting <span class="v">:ABORT-VACUOUS</span> to <span class="v">NIL</span> causes it to go on.</p> 
 

</body>
</html>
