<html>
<head>
<meta charset="UTF-8">
<title>Induction</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____INDUCTION">Click for Induction in the Full Manual</a></h3>

<p>Make a rule that suggests a certain induction</p><pre class="code">Example:
(<a href="ACL2____DEFTHM.html">defthm</a> recursion-by-sub2-induction-rule
  t
  :rule-classes ((:induction :pattern (<a href="COMMON-LISP_____A2.html">*</a> 1/2 i)
                             :condition (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> i) (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> i 0))
                             :scheme (recursion-by-sub2 i))))</pre> 
 
 <p>In ACL2, as in Nqthm, the functions in a conjecture ``suggest'' the 
 inductions considered by the system.  Because every recursively defined 
 function must be admitted with a justification in terms of a measure that 
 decreases in a well-founded way on a given set of ``controlling'' arguments, 
 every recursive definition suggests a dual induction scheme that ``unwinds'' 
 the function from a given application.</p> 
 
 <p>For example, since <span class="tt"><a href="COMMON-LISP____APPEND.html">append</a></span> (actually <span class="tt"><a href="ACL2____BINARY-APPEND.html">binary-append</a></span>, but 
 we'll ignore the distinction here) decomposes its first argument by successive 
 <span class="tt"><a href="COMMON-LISP____CDR.html">cdr</a></span>s as long as it is a cons, the induction scheme suggested by 
 <span class="v">(<a href="COMMON-LISP____APPEND.html">append</a> x y)</span> has a base case supposing <span class="v">x</span> to be an atom (i.e., not a 
 cons) and then has an induction step in which the induction hypothesis is 
 obtained by replacing <span class="v">x</span> by <span class="v">(<a href="COMMON-LISP____CDR.html">cdr</a> x)</span>.  This substitution decreases the 
 same measure used to justify the definition of <span class="tt"><a href="COMMON-LISP____APPEND.html">append</a></span>.  Observe that 
 an induction scheme is suggested by a recursive function application only if 
 the controlling actuals are distinct variables, a condition that is sufficient 
 to ensure that the ``substitution'' used to create the induction hypothesis is 
 indeed a substitution and that it drives down a certain measure.  In 
 particular, <span class="v">(<a href="COMMON-LISP____APPEND.html">append</a> (foo x) y)</span> does not suggest an induction unwinding 
 <span class="tt"><a href="COMMON-LISP____APPEND.html">append</a></span> because the induction scheme suggested by <span class="v">(<a href="COMMON-LISP____APPEND.html">append</a> x y)</span> 
 requires that we substitute <span class="v">(<a href="COMMON-LISP____CDR.html">cdr</a> x)</span> for <span class="v">x</span> and we cannot do that if 
 <span class="v">x</span> is not a variable symbol.</p> 
 
 <p>Once ACL2 has collected together all the suggested induction schemes it 
 massages them in various ways, combining some to simultaneously unwind certain 
 cliques of functions and vetoing others because they ``flaw'' others.  We do 
 not further discuss the induction heuristics here; the interested reader 
 should see <a href="ACL2____INDUCTION-HEURISTICS.html">induction-heuristics</a>.</p> 
 
 <p>However, unlike Nqthm, ACL2 provides a means by which the user can 
 elaborate the rules under which function applications suggest induction 
 schemes.  Such rules are called <span class="v">:induction</span> rules.  The definitional 
 principle automatically creates an <span class="v">:induction</span> rule, named <span class="v">(:induction
 fn)</span>, for each admitted recursive function, <span class="v">fn</span>.  It is this rule that 
 links applications of <span class="v">fn</span> to the induction scheme it suggests.  Disabling 
 <span class="v">(:induction fn)</span> will prevent <span class="v">fn</span> from suggesting the induction scheme 
 derived from its recursive definition (with an exception for induction schemes 
 by way of user-defined induction rules, as discussed at the end below).  It is 
 possible for the user to create additional <span class="v">:induction</span> rules by using the 
 <span class="v">:induction</span> rule class in <span class="tt"><a href="ACL2____DEFTHM.html">defthm</a></span>.</p> 
 
 <p>Technically we are ``overloading'' <span class="tt"><a href="ACL2____DEFTHM.html">defthm</a></span> by using it in the 
 creation of <span class="v">:induction</span> rules because no theorem need be proved to set up 
 the heuristic link represented by an <span class="v">:induction</span> rule.  However, since 
 <span class="tt"><a href="ACL2____DEFTHM.html">defthm</a></span> is generally used to create rules and rule-class objects are 
 generally used to specify the exact form of each rule, we maintain that 
 convention and introduce the notion of an <span class="v">:induction</span> rule.  An 
 <span class="v">:induction</span> rule can be created from any lemma whatsoever.</p> 
 
 <pre class="code">General Form of an :induction Lemma or Corollary:
T

General Form of an :induction rule-class:
(:induction :pattern pat-term
            :condition cond-term
            :scheme scheme-term)</pre> 
 
 <p>where <span class="v">pat-term</span>, <span class="v">cond-term</span>, and <span class="v">scheme-term</span> are all terms, 
 <span class="v">pat-term</span> is the application of a function symbol, <span class="v">fn</span>, 
 <span class="v">scheme-term</span> is the application of a function symbol, <span class="v">rec-fn</span>, that 
 suggests an induction, and, finally, every free variable of <span class="v">cond-term</span> and 
 <span class="v">scheme-term</span> is a free variable of <span class="v">pat-term</span>.  We actually check that 
 <span class="v">rec-fn</span> is either recursively defined — so that it suggests the 
 induction that is intrinsic to its recursion — or else that another 
 <span class="v">:induction</span> rule has been proved linking a call of <span class="v">rec-fn</span> as the 
 <span class="v">:pattern</span> to some scheme.</p> 
 
 <p>The induction rule created is used as follows.  When an instance of the 
 <span class="v">:pattern</span> term occurs in a conjecture to be proved by induction and the 
 corresponding instance of the <span class="v">:condition</span> term is known to be non-<span class="v">nil</span> 
 (by type reasoning alone), the corresponding instance of the <span class="v">:scheme</span> term 
 is created and the rule ``suggests'' the induction, if any, suggested by that 
 term.  (Analysis of that term may further involve induction rules, though the 
 applied rule is removed from consideration during that further analysis, in 
 order to avoid looping.)  If <span class="v">rec-fn</span> has a recursive definition, then the 
 the definition's dual induction scheme is suggested (i.e., unwinding the 
 function).</p> 
 
 <p>(Remark.  Unlike <span class="v">:induct</span> <a href="ACL2____HINTS.html">hints</a>, the <span class="v">:scheme</span> of an 
 <span class="v">:induction</span> rule only introduces induction schemes based on the top-level 
 function symbol of the indicated term, not of any of its subterms.  End of 
 Remark.)</p> 
 
 <p>Consider, for example, the example given above,</p> 
 
 <pre class="code">(:induction :pattern (<a href="COMMON-LISP_____A2.html">*</a> 1/2 i)
            :condition (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> i) (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> i 0))
            :scheme (recursion-by-sub2 i)).</pre> 
 
 <p>In this example, we imagine that <span class="v">recursion-by-sub2</span> is the 
 function:</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> recursion-by-sub2 (i)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> i)
           (<a href="COMMON-LISP_____C3.html">&lt;</a> 1 i))
      (recursion-by-sub2 (<a href="COMMON-LISP____-.html">-</a> i 2))
      t))</pre> 
 
 <p>Observe that this function recursively decomposes its natural number 
 argument by subtracting <span class="v">2</span> from it repeatedly and stops when the argument 
 is <span class="v">1</span> or less.  The value of the function is irrelevant; it is its 
 induction scheme that concerns us.  The induction scheme suggested by 
 <span class="v">(recursion-by-sub2 i)</span> is</p> 
 
 <pre class="code">(<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> i) (<a href="COMMON-LISP_____C3.html">&lt;</a> 1 i)))   ; base case
              (:p i))
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> i) (<a href="COMMON-LISP_____C3.html">&lt;</a> 1 i))    ; induction step
                   (:p (<a href="COMMON-LISP____-.html">-</a> i 2)))
              (:p i)))</pre> 
 
 <p>We can think of the base case as covering two situations.  The first is 
 when <span class="v">i</span> is not an integer.  The second is when the integer <span class="v">i</span> is less 
 than or equal to <span class="v">1</span>.  In the base case we must prove <span class="v">(:p i)</span> without 
 further help.  The induction step deals with those natural numbers <span class="v">i</span> 
 greater than <span class="v">1</span>, and inductively assumes the conjecture for <span class="v">i-2</span> while 
 proving it for <span class="v">i</span>.  Let us call this scheme ``induction on <span class="v">i</span> by 
 twos.''</p> 
 
 <p>Suppose the above <span class="v">:induction</span> rule has been added.  Then an occurrence 
 of, say, <span class="v">(<a href="COMMON-LISP_____A2.html">*</a> 1/2 k)</span> in a conjecture to be proved by induction would 
 suggest, via this rule, an induction on <span class="v">k</span> by twos, provided <span class="v">k</span> was 
 known to be a nonnegative integer.  This is because the induction rule's 
 <span class="v">:pattern</span> is matched in the conjecture, its <span class="v">:condition</span> is satisfied, 
 and the <span class="v">:scheme</span> suggested by the rule is that derived from 
 <span class="v">(recursion-by-sub2 k)</span>, which is induction on <span class="v">k</span> by twos.  Similarly, 
 the term <span class="v">(<a href="COMMON-LISP_____A2.html">*</a> 1/2 (<a href="COMMON-LISP____LENGTH.html">length</a> l))</span> would suggest no induction via this rule, 
 even though the rule ``fires'' because it creates the <span class="v">:scheme</span> 
 <span class="v">(recursion-by-sub2 (<a href="COMMON-LISP____LENGTH.html">length</a> l))</span> which suggests no inductions unwinding 
 <span class="v">recursion-by-sub2</span> (since the controlling argument of 
 <span class="v">recursion-by-sub2</span> in this <span class="v">:scheme</span> is not a variable symbol).</p> 
 
 <p>Continuing this example one step further illustrates the utility of 
 <span class="v">:induction</span> rules.  We could define the function <span class="v">recursion-by-cddr</span> 
 that suggests the induction scheme decomposing its <span class="tt"><a href="COMMON-LISP____CONSP.html">consp</a></span> argument two 
 <span class="tt"><a href="COMMON-LISP____CDR.html">cdr</a></span>s at a time.  We could then add the <span class="v">:induction</span> rule linking 
 <span class="v">(<a href="COMMON-LISP_____A2.html">*</a> 1/2 (<a href="COMMON-LISP____LENGTH.html">length</a> x))</span> to <span class="v">(recursion-by-cddr x)</span> and arrange for <span class="v">(<a href="COMMON-LISP_____A2.html">*</a>
 1/2 (<a href="COMMON-LISP____LENGTH.html">length</a> l))</span> to suggest induction on <span class="v">l</span> by <span class="tt"><a href="COMMON-LISP____CDDR.html">cddr</a></span>.</p> 
 
 <p>Observe that <span class="v">:induction</span> rules require no proofs to be done.  Such a 
 rule is merely a heuristic link between the <span class="v">:pattern</span> term, which may 
 occur in conjectures to be proved by induction, and the <span class="v">:scheme</span> term, 
 from which an induction scheme may be derived.  Hence, when an <span class="v">:induction</span> 
 rule-class is specified in a <span class="tt"><a href="ACL2____DEFTHM.html">defthm</a></span> event, the theorem proved is 
 irrelevant.  The easiest theorem to prove is, of course, <span class="v">t</span>.  Thus, we 
 suggest that when an <span class="v">:induction</span> rule is to be created, the following form 
 be used:</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> name T
  :rule-classes ((:induction :pattern pat-term
                             :condition cond-term
                             :scheme scheme-term)))</pre> 
 
 <p>The name of the rule created is <span class="v">(:induction name)</span>.  When that <a href="ACL2____RUNE.html">rune</a> is <a href="ACL2____DISABLE.html">disable</a>d the heuristic link between <span class="v">pat-term</span> and 
 <span class="v">scheme-term</span> is broken.</p> 
 
 <p>Note that if <span class="v">fn</span> is defined recursively and <span class="v">(:induction fn)</span> is 
 <a href="ACL2____DISABLE.html">disable</a>d, then normally the induction scheme for <span class="v">fn</span> will not be 
 available during a proof.  However, the induction scheme for <span class="v">fn</span> is 
 available, even if it is disabled, when it is indicated by application of a 
 user-defined <span class="v">:induction</span> rule.  So for the <span class="v">:induction</span> rule above, 
 <span class="v">recursion-by-sub2-induction-rule</span>: even if <span class="v">(:induction
 recursion-by-sub2)</span> is disabled, nevertheless the induction scheme for 
 <span class="v">recursion-by-sub2</span> will be available to apply to the instantiated 
 <span class="v">:scheme-term</span>.</p>
</body>
</html>
