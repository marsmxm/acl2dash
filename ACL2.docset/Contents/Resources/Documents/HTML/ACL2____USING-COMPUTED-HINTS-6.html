<html>
<head>
<meta charset="UTF-8">
<title>Using-computed-hints-6</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____USING-COMPUTED-HINTS-6">Click for Using-computed-hints-6 in the Full Manual</a></h3>

<p>Using the computed-hint-replacement feature</p><p>So far none of our computed hints have used the 
 <span class="v">:COMPUTED-HINT-REPLACEMENT</span> feature.  We now illustrate that.</p> 
 
 <p>The <span class="v">:computed-hint-replacement</span> feature can easily lead to loops.  So 
 as you experiment with the examples in this section and your own hints using 
 this feature, be ready to interrupt the theorem prover and abort!</p> 
 
 <p>A non-looping use of the <span class="v">:computed-hint-replacement</span> feature would be a 
 hint like this:</p> 
 
 <pre class="code">(<a href="COMMON-LISP____IF.html">if</a> (certain-terms-present clause)
    '(:computed-hint-replacement t
      :in-theory (<a href="ACL2____ENABLE.html">enable</a> lemma25))
    '(:computed-hint-replacement t
      :in-theory (<a href="ACL2____DISABLE.html">disable</a> lemma25)))</pre> 
 
 <p>In this hint, if certain terms are present in <span class="v">clause</span>, as determined by 
 the function with the obvious name (here undefined), then this hint enables 
 <span class="v">lemma25</span> and otherwise disables it.  <span class="v">Lemma25</span> might be a very 
 expensive lemma, e.g., one that matches frequently and has an expensive and 
 rarely established hypothesis.  One might wish it enabled only under certain 
 conditions.  Recall that theories are inherited by children.  So once 
 <span class="v">lemma25</span> is enabled it ``stays'' enabled for the children, until disabled; 
 and vice versa.  If the <span class="v">:computed-hint-replacement</span> feature were not 
 present and computed hints were always deleted after they had been used, then 
 <span class="v">lemma25</span> would be left enabled (or disabled) for all the children produced 
 by the first firing of the hint.  But with the arrangement here, every subgoal 
 gets a theory deemed suitable by the hint, and the hint persists.</p> 
 
 <p>Now we will set up a toy to allow us to play with computed hints to 
 understand them more deeply.  To follow the discussion it is best to execute 
 the following events.</p> 
 
 <pre class="code">(<a href="ACL2____DEFSTUB.html">defstub</a> wrapper (x) t)
(<a href="ACL2____DEFAXIOM.html">defaxiom</a> wrapper-axiom (wrapper x) :rule-classes nil)</pre> 
 
 <p>Now submit the following event and watch what happens.</p> 
 
 <pre class="code">(<a href="ACL2____THM.html">thm</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> u v)
  :hints (`(:use (:instance wrapper-axiom (x a)))))</pre> 
 
 <p>The theorem prover adds <span class="v">(wrapper a)</span> to the goal and then abandons the 
 proof attempt because it cannot prove the subgoal.  Since the computed hint is 
 deleted upon use, the hint is not applied to the subgoal (i.e., the child of 
 the goal).</p> 
 
 <p>What happens if we do the following?</p> 
 
 <pre class="code">(<a href="ACL2____THM.html">thm</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> u v)
  :hints (`(:computed-hint-replacement t
            :use (:instance wrapper-axiom (x a)))))</pre> 
 
 <p>As one might expect, this loops forever: The hint is applied to the child 
 and adds the hypothesis again.  When the hint fires, nothing is actually 
 changed, since <span class="v">(wrapper a)</span> is already in the subgoal.</p> 
 
 <p>So let's change the experiment a little.  Let's make the hint add the 
 hypothesis <span class="v">(wrapper p)</span> where <span class="v">p</span> is the first literal of the clause. 
 This is silly but it allows us to explore the behavior of computed hints a 
 little more.</p> 
 
 <pre class="code">(<a href="ACL2____THM.html">thm</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> u v)
  :hints (`(:use (:instance wrapper-axiom (x ,(<a href="COMMON-LISP____CAR.html">car</a> clause))))))</pre> 
 
 <p>So in this case, the theorem prover changes the goal to</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">IMPLIES</a> (WRAPPER (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> U V)) (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> U V))</pre> 
 
 <p>which then simplifies to</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">IMPLIES</a> (WRAPPER NIL) (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> U V))</pre> 
 
 <p>because the concluding equality can be assumed false in the hypothesis 
 (e.g., think of the contrapositive version).  Nothing else happens because the 
 hint has been removed and so is not applicable to the child.</p> 
 
 <p>Now consider the following — and be ready to interrupt it and 
 abort!</p> 
 
 <pre class="code">(<a href="ACL2____THM.html">thm</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> u v)
  :hints (`(:computed-hint-replacement t
            :use (:instance wrapper-axiom (x ,(<a href="COMMON-LISP____CAR.html">car</a> clause))))))</pre> 
 
 <p>This time the hint is not removed and so is applied to the child.  So from 
 <span class="v">Goal</span> we get</p> 
 
 <pre class="code">Goal'
(<a href="ACL2____IMPLIES.html">IMPLIES</a> (WRAPPER (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> U V))
         (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> U V))</pre> 
 
 <p>and then</p> 
 
 <pre class="code">Goal''
(<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____AND.html">AND</a> (WRAPPER (<a href="COMMON-LISP____NOT.html">NOT</a> (WRAPPER (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> U V))))
              (WRAPPER (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> U V)))
         (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> U V))</pre> 
 
 <p>etc.</p> 
 
 <p>First, note that the hint is repeatedly applied to its children.  That is 
 because we wrote <span class="v">:computed-hint-replacement t</span>.  But second, note that 
 <span class="v">Goal'</span> is not even being simplified before <span class="v">Goal''</span> is produced from 
 it.  If it were being simplified, the <span class="v">(<a href="COMMON-LISP____EQUAL.html">equal</a> u v)</span>'s in the hypotheses 
 would be replaced by <span class="v">nil</span>.  This is a feature.  It means after a computed 
 hint has fired, other hints are given a chance at the result, even the hint 
 itself unless it is removed from the list of hints.</p> 
 
 <p>As an exercise, let's arrange for the hint to stay around and be applied 
 indefinitely but with a simplification between each use of the the hint.  To 
 do this we need to pass information from one application of the hint to the 
 next, essentially to say ``stay around but don't fire.''</p> 
 
 <p>First, we will define a function to use in the hint.  This is more than a 
 mere convenience; it allows the hint to ``reproduce itself'' in the 
 replacement.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> wrapper-challenge (clause parity)
  (<a href="COMMON-LISP____IF.html">if</a> parity
      `(:computed-hint-replacement ((wrapper-challenge clause nil))
        :use (:instance wrapper-axiom (x ,(<a href="COMMON-LISP____CAR.html">car</a> clause))))
      `(:computed-hint-replacement ((wrapper-challenge clause t)))))</pre> 
 
 <p>Note that this function is not recursive, even though it uses its own name. 
 That is because the occurrence of its name is in a quoted constant.</p> 
 
 <p>Now consider the following.  What will it do?</p> 
 
 <pre class="code">(<a href="ACL2____THM.html">thm</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> u v)
  :hints ((wrapper-challenge clause t)))</pre> 
 
 <p>First, observe that this is a legal hint because it is a term that mentions 
 only the free variable <span class="v">CLAUSE</span>.  When defining hint functions you may 
 sometimes think their only arguments are the four variables <span class="v">id</span>, 
 <span class="v">clause</span>, <span class="v">world</span>, and <span class="v">stable-under-simplificationp</span>.  That is not 
 so.  But in your hints you must call those functions so that those are the 
 only free variables.  Note also that the occurrence of <span class="v">clause</span> inside the 
 <span class="v">:computed-hint-replacement</span> is not an occurrence of the variable clause 
 but just a constant.  Just store this note away for a moment.  We'll return to 
 it momentarily.</p> 
 
 <p>Second, the basic cleverness of this hint is that every time it fires it 
 reproduces itself with the opposite parity.  When the parity is <span class="v">t</span> it 
 actually changes the goal by adding a hypothesis.  When the parity is <span class="v">nil</span> 
 it doesn't change the goal and so allows simplification to proceed — but 
 it swaps the parity back to <span class="v">t</span>.  What you can see with this simple toy is 
 that we can use the computed hints to pass information from parent to 
 child.</p> 
 
 <p>Ok, so what happens when the event above is executed?  Try it.  You will 
 see that ACL2 applied the hint the first time.  It doesn't get around to 
 printing the output because an error is caused before it can print.  But here 
 is a blow-by-blow description of what happens.  The hint is evaluated on 
 <span class="v">Goal</span> with the <span class="v">clause</span> <span class="v">((<a href="COMMON-LISP____EQUAL.html">equal</a> u v))</span>.  It produces a hint exactly 
 as though we had typed:</p> 
 
 <pre class="code">("Goal" :use (:instance wrapper-axiom (x (<a href="COMMON-LISP____EQUAL.html">equal</a> u v))))</pre> 
 
 <p>which is applied to this goal. In addition, it produces the new hints 
 argument</p> 
 
 <pre class="code">:hints ((wrapper-challenge clause nil)).</pre> 
 
 <p>By applying the <span class="v">"Goal"</span> hint we get the new subgoal</p> 
 
 <pre class="code">Goal'
(<a href="ACL2____IMPLIES.html">implies</a> (wrapper (<a href="COMMON-LISP____EQUAL.html">equal</a> u v))
         (<a href="COMMON-LISP____EQUAL.html">equal</a> u v))</pre> 
 
 <p>but this is not printed because, before printing it, the theorem prover 
 looks for hints to apply to it and finds</p> 
 
 <pre class="code">(wrapper-challenge clause nil)</pre> 
 
 <p>That is evaluated and produces a hint exactly as though we had typed:</p> 
 
 <pre class="code">("Goal'" )</pre> 
 
 <p>and the new hints argument:</p> 
 
 <pre class="code">:hints ((wrapper-challenge clause nil)).</pre> 
 
 <p>But if you supply the hint <span class="v">("Goal'" )</span>, ACL2 will signal an error 
 because it does not allow you to specify an empty hint!</p> 
 
 <p>So the definition of <span class="v">wrapper-challenge</span> above is almost correct but 
 fatally flawed.  We need a non-empty ``no-op'' hint.  One such hint is to tell 
 the system to expand a term that will always be expanded anyway.  So undo 
 <span class="v">wrapper-challenge</span>, redefine it, and try the proof again.  Now remember 
 the observation about <span class="v">clause</span> that we asked you to ``store'' above.  The 
 new definition of <span class="v">wrapper-challenge</span> illustrates what we meant.  Note that 
 the first formal parameter of <span class="v">wrapper-challenge</span>, below, is no longer 
 named <span class="v">clause</span> but is called <span class="v">cl</span> instead.  But the ``call'' of 
 <span class="v">wrapper-challenge</span> in the replacements is on <span class="v">clause</span>.  This may seem 
 to violate the rule that a function definition cannot use variables other than 
 the formals.  But the occurrences of <span class="v">clause</span> below are not variables but 
 constants in an object that will eventually be treated as hint term.</p> 
 
 <pre class="code">:ubt wrapper-challenge

(<a href="COMMON-LISP____DEFUN.html">defun</a> wrapper-challenge (cl parity)
  (<a href="COMMON-LISP____IF.html">if</a> parity
      `(:computed-hint-replacement ((wrapper-challenge clause nil))
        :use (:instance wrapper-axiom (x ,(<a href="COMMON-LISP____CAR.html">car</a> cl))))
      `(:computed-hint-replacement ((wrapper-challenge clause t))
        :expand ((<a href="COMMON-LISP____ATOM.html">atom</a> zzz)))))

(<a href="ACL2____THM.html">thm</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> u v)
  :hints ((wrapper-challenge clause t)))</pre> 
 
 <p>This time, things go as you might have expected!  <span class="v">Goal'</span> is produced 
 and simplified, to</p> 
 
 <pre class="code">Goal''
(<a href="ACL2____IMPLIES.html">implies</a> (wrapper nil)
         (<a href="COMMON-LISP____EQUAL.html">equal</a> u v)).</pre> 
 
 <p>Simplification gets a chance because when the new hint 
 <span class="v">(wrapper-challenge clause nil)</span> is fired it does not change the goal.  But 
 it does change the parity in the hints argument so that before <span class="v">Goal''</span> is 
 simplified again, the hint fires and adds the hypothesis:</p> 
 
 <pre class="code">Goal'''
(<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____AND.html">AND</a> (WRAPPER (<a href="COMMON-LISP____NOT.html">NOT</a> (WRAPPER NIL)))
              (WRAPPER NIL))
         (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> U V)).</pre> 
 
 <p>This simplifies, replacing the first <span class="v">(<a href="COMMON-LISP____NOT.html">NOT</a> (WRAPPER NIL))</span> by <span class="v">NIL</span>, 
 since <span class="v">(WRAPPER NIL)</span> is known to be true here.  Thus the goal simplifies 
 to</p> 
 
 <pre class="code">Goal'4'
(<a href="ACL2____IMPLIES.html">IMPLIES</a> (WRAPPER NIL) (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> U V)).</pre> 
 
 <p>The process repeats indefinitely.</p> 
 
 <p>So we succeeded in getting a hint to fire indefinitely but allow a full 
 simplification between rounds.</p>
</body>
</html>
