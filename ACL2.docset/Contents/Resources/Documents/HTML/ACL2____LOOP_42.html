<html>
<head>
<meta charset="UTF-8">
<title>Loop$</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____LOOP_42">Click for Loop$ in the Full Manual</a></h3>

<p>Iteration with an analogue of the Common Lisp <span class="v">loop</span> macro</p><p><span class="v">Loop$</span> is the ACL2 analogue of the Common Lisp's iteration 
 primitive, <span class="v">loop</span>.  This topic introduces the two classes of ACL2 
 $('loop$') expressions, <span class="v">FOR</span> <span class="v">loop$</span>s and <span class="v">DO</span> <span class="v">loop$</span>s; see 
 <a href="ACL2____FOR-LOOP_42.html">for-loop$</a> and <a href="ACL2____DO-LOOP_42.html">do-loop$</a> (respectively) for their full 
 documentation.</p> 
 
 <p>The Introduction below is followed by a discussion of types and guards. 
 But before we get started we emphasize a few key points.</p> 
 
 <ul> 
 
 <li>
<b>Many examples</b> of <span class="tt"><a href="ACL2____LOOP_42.html">loop$</a></span> expressions may be found in <a href="ACL2____COMMUNITY-BOOK.html">community-book</a> <span class="v">projects/apply/loop-tests.lisp</span>.</li> 
 
 <li>The semantics of <span class="v">loop$</span> involve <span class="v">apply$</span>.  Therefore, before using 
 <span class="v">loop$</span>, it is <b>strongly recommended</b> that you include the same book 
 as is typically included when using <span class="tt"><a href="ACL2____APPLY_42.html">apply$</a></span>, as follows. 
 
 <pre class="code">(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "projects/apply/top" :dir :system)</pre>
</li> 
 
 <li>ACL2 <span class="v">loop$</span> statements are executed as Common Lisp <span class="v">loop</span> 
 statements after the relevant <a href="ACL2____GUARD.html">guard</a> conjectures are proved.  Common 
 Lisp <span class="v">loop</span> statements generally execute much faster than 
 equivalent (tail-recursive) functions.</li> 
 
 <li>
<b>Warning:</b> <span class="v">Loop$</span> implements only a modest part of the 
 functionality of Common Lisp's <span class="v">loop</span>.  Aside from the simple fact that 
 <span class="v">loop$</span> allows only a limited subset of the syntax of <span class="v">loop</span>, the main 
 restriction is that the subexpressions of the <span class="v">loop$</span> expression that are 
 evaluated repeatedly must be <a href="ACL2____TAME.html">tame</a>!  These expressions include not only 
 the loop body but, if present, the <span class="v">UNTIL</span> test, the <span class="v">WHEN</span> test, and 
 the <span class="v">FINALLY</span> clause (all discussed below).  Thus, all the function 
 symbols used in these expressions must be <a href="ACL2____BADGE.html">badge</a>d (see <span class="tt"><a href="ACL2____DEFBADGE.html">defbadge</a></span> 
 and <span class="tt"><a href="ACL2____DEFWARRANT.html">defwarrant</a></span>).  Further restrictions are enforced for <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span>'d functions in which recursive calls appear in <span class="v">loop$</span> bodies, but 
 we say little about that in this documentation topic; see <a href="ACL2____LOOP_42-RECURSION.html">loop$-recursion</a>.  We recommend that users unfamiliar with <span class="v">loop$</span> 
 acquaint themselves with the material below and in <a href="ACL2____FOR-LOOP_42.html">for-loop$</a> before 
 wading into <span class="v">loop$-recursion</span>!</li> 
 
 </ul> 
 
 <h3>Introduction to <span class="v">loop$</span>
</h3> 
 
 <p>As noted above, there are two classes of <span class="v">loop$</span> expressions.  These are 
 identified as follows.</p> 
 
 <ul> 
 
 <li>
<span class="v">FOR</span> loop$ expressions: 
 
 <pre class="code">(<a href="ACL2____LOOP_42.html">loop$</a> FOR ...)</pre> 
 
 </li> 
 
 <li>
<span class="v">DO</span> loop$ expressions: 
 
 <pre class="code">(<a href="ACL2____LOOP_42.html">loop$</a> WITH ... DO ...)</pre> 
 
 </li> 
 
 </ul> 
 
 <p>Below we introduce these two classes of <span class="v">loop$</span> expressions.  For full 
 documentation see the topic for each class: see <a href="ACL2____FOR-LOOP_42.html">for-loop$</a> for <span class="v">FOR</span> 
 <span class="v">loop$</span>s and <a href="ACL2____DO-LOOP_42.html">do-loop$</a> for <span class="v">DO</span> <span class="v">loop$</span>s.  In particular 
 various restrictions are discussed in those topics, but for now we mention 
 just the following.  While <span class="v">FOR</span> <span class="v">loop$</span> expressions are often more 
 convenient to use than <span class="v">DO</span> <span class="v">loop$</span> expressions, their <span class="v">UNTIL</span>, 
 <span class="v">WHEN</span>, and body expressions are not permitted to reference <span class="tt"><a href="ACL2____STATE.html">state</a></span> 
 or <a href="ACL2____STOBJ.html">stobj</a>s, and they always return a single value.  <span class="v">DO</span> <span class="v">loop$</span> 
 expressions do not have these restrictions, but they may not use the idioms of 
 <span class="v">FOR</span> <span class="v">loop$</span>s, like ``<span class="v">FOR x IN ...</span>'' or ``<span class="v">UNTIL p</span>''.</p> 
 
 <p>ACL2's <span class="v">loop$</span> is considerably more restrictive than Common Lisp's 
 <span class="v">loop</span>, but when an ACL2 <span class="v">loop$</span> expression is translated without error 
 it has the same meaning as the corresponding Common Lisp <span class="v">loop</span>. 
 <span class="v">Loop$</span> supports <span class="v">:</span><span class="tt"><a href="ACL2____GUARD.html">guard</a></span> expressions (discussed below) in 
 certain places and these are ignored by Common Lisp.</p> 
 
 <p>Next we present some <span class="v">FOR</span> <span class="v">loop$</span> examples.  They illustrate the 
 three supported forms of <span class="v">FOR</span> <span class="v">loop$</span> iteration: the use of <span class="v">IN</span>, to 
 iterate over elements of a list; the use of <span class="v">ON</span>, to iterate over the 
 non-empty tails of a list; and the use of <span class="v">FROM .. TO</span>, to iterate over a 
 range of integers (optionally with <span class="v">BY</span> to specify the increment at each 
 step).  These examples also illustrate the use of <span class="v">WHEN</span> to restrict which 
 iterations are considered and the use of <span class="v">UNTIL</span> to terminate early. 
 Additional keywords illustrated are <span class="v">OF-TYPE</span> to specify types and <span class="v">AS</span> 
 to specify additional iteration variables.  They also illustrate some of the 
 operations permitted at each iteration, such as <span class="v">SUM</span> and <span class="v">COLLECT</span>.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="ACL2____LOOP_42.html">loop$</a> for x in '(1 2 3) sum (<a href="COMMON-LISP_____A2.html">*</a> x x))
14
ACL2 !&gt;(<a href="ACL2____LOOP_42.html">loop$</a> for x in '(1 2 3) collect (<a href="COMMON-LISP_____A2.html">*</a> x x))
(1 4 9)
ACL2 !&gt;(<a href="ACL2____LOOP_42.html">loop$</a> for x on '(1 2 3) collect x)
((1 2 3) (2 3) (3))
ACL2 !&gt;(<a href="ACL2____LOOP_42.html">loop$</a> for x of-type integer from -10 to 10 by 2 collect x)
(-10 -8 -6 -4 -2 0 2 4 6 8 10)
ACL2 !&gt;(<a href="ACL2____LOOP_42.html">loop$</a> for i from 1 to 10
              as  x in '(a b c d e f g)
              collect (<a href="COMMON-LISP____CONS.html">cons</a> i x))
((1 . A)
 (2 . B)
 (3 . C)
 (4 . D)
 (5 . E)
 (6 . F)
 (7 . G))
ACL2 !&gt;(<a href="ACL2____LOOP_42.html">loop$</a> for i from 1 to 10
              as  x in '(a b c d e f g)
              until (<a href="COMMON-LISP_____E3.html">&gt;</a> i 6)
              collect (<a href="COMMON-LISP____CONS.html">cons</a> i x))
((1 . A)
 (2 . B)
 (3 . C)
 (4 . D)
 (5 . E)
 (6 . F))
ACL2 !&gt;(<a href="ACL2____LOOP_42.html">loop$</a> for i from 1 to 10
              as  x in '(a b c d e f g)
              until (<a href="COMMON-LISP_____E3.html">&gt;</a> i 6)
              when (<a href="COMMON-LISP____EVENP.html">evenp</a> i)
              collect (<a href="COMMON-LISP____CONS.html">cons</a> i x))
((2 . B) (4 . D) (6 . F))</pre> 
 
 <p>Finally we present two <span class="v">DO</span> <span class="v">loop$</span> examples.  We explore them 
 further in the documentation specific to <span class="v">DO</span> <span class="v">loop$</span> expressions; see 
 <a href="ACL2____DO-LOOP_42.html">do-loop$</a>.</p> 
 
 <p>Our first <span class="v">DO</span> <span class="v">loop$</span> example shows iteration with the indicated 
 initial values for local variables <span class="v">x</span> and <span class="v">y</span>.  They are modified at 
 each iteration through the loop until <span class="v">x</span> is empty, at which point the 
 value of <span class="v">y</span> is returned.  (See <a href="ACL2____DO-LOOP_42.html">do-loop$</a> for more thorough 
 explanations.)</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="ACL2____LOOP_42.html">loop$</a> with x = '(a b c)
              with y = nil
              do (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____CONSP.html">consp</a> x)
                        (<a href="COMMON-LISP____PROGN.html">progn</a> (setq y (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> x) y))
                               (setq x (<a href="COMMON-LISP____CDR.html">cdr</a> x))))
                       (t (return y))))
(C B A)
ACL2 !&gt;</pre> 
 
 <p>Our second example of a <span class="v">DO</span> <span class="v">loop$</span> expression illustrates more 
 features than the first.  Also, it illustrates the use of a <span class="v">loop$</span> 
 expression inside a definition, which is allowed for both <span class="v">FOR</span> <span class="v">loop$</span>s 
 and <span class="v">DO</span> <span class="v">loop$</span>s.  We see here that <a href="ACL2____STOBJ.html">stobj</a>s and <a href="ACL2____MULTIPLE-VALUE.html">multiple-value</a> returns are allowed for <span class="v">DO</span> <span class="v">loop$</span>s, where the 
 <span class="v">:VALUES</span> keyword specifies the shape of the return.  We also see here the 
 use of the optional <span class="v">:GUARD</span> keyword of a <span class="v">loop$</span> expression (legal for 
 both classes of <span class="v">loop$</span>s, as discussed further below) and the optional 
 <span class="v">:MEASURE</span> keyword of a <span class="v">DO</span> <span class="v">loop$</span> expression.</p> 
 
 <p>But notice the <span class="tt"><a href="ACL2____DEFWARRANT.html">defwarrant</a></span> events below!  They are required because 
 the functions <span class="v">fld</span> and <span class="v">update-fld</span> are not system primitives.  They 
 are introduced by the user's <span class="tt"><a href="ACL2____DEFSTOBJ.html">defstobj</a></span> event below.  This is in 
 contrast to the <span class="v">DO</span> <span class="v">loop$</span> in our first example above where no 
 warrants are required because all the functions in that example are 
 primitive.</p> 
 
 <p>The semantics of <span class="v">loop$</span> involve <span class="v">apply$</span> and thus <span class="v">loop$</span>s 
 inherit the restrictions imposed on <span class="v">apply$</span> and its <a href="ACL2____SCION.html">scion</a>s.  Among 
 those restrictions are that (a) unwarranted <span class="v">:logic</span> mode functions cannot 
 be <span class="v">apply$</span>'d in the top-level read-eval-print loop and (b) proofs about 
 the applications of unwarranted functions are impossible.  Restriction (a) 
 means you cannot even execute a <span class="v">:logic</span> mode <span class="v">loop$</span> containing 
 unwarranted functions.  Restriction (b) means you can't verify the <a href="ACL2____GUARD.html">guard</a>s of such <span class="v">loop$</span>.  This last point obviates the main reason for 
 using <span class="v">loop$</span>: its fast execution as a Common Lisp loop once guards are 
 verified.</p> 
 
 <p>Now here is our second example.</p> 
 
 <pre class="code">(<a href="ACL2____DEFSTOBJ.html">defstobj</a> st fld)
(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "projects/apply/top" :dir :system) ; needed for defwarrant
(<a href="ACL2____DEFWARRANT.html">defwarrant</a> fld)
(<a href="ACL2____DEFWARRANT.html">defwarrant</a> update-fld)

(<a href="COMMON-LISP____DEFUN.html">defun</a> test-loop$ (i0 max st)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> i0) (<a href="ACL2____NATP.html">natp</a> max))
                  :stobjs st))
  (<a href="ACL2____LOOP_42.html">loop$</a> with i of-type (satisfies natp) = i0
         with cnt of-type integer = 0
         do
         :measure (<a href="ACL2____NFIX.html">nfix</a> (<a href="COMMON-LISP____-.html">-</a> max i))
         :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> max)
                     (<a href="ACL2____NATP.html">natp</a> cnt)
                     (<a href="ACL2____STP.html">stp</a> st))
         :values (nil st) ; shape of return; can be omitted when it's (nil)
         (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> i max)
             (loop-finish)
           (<a href="COMMON-LISP____PROGN.html">progn</a> (setq st (update-fld i st))
                  (mv-setq (cnt i)
                           (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP_____B2.html">+</a> 1 cnt) (<a href="COMMON-LISP_____B2.html">+</a> 1 i)))))
         finally
         :guard (<a href="ACL2____STP.html">stp</a> st)
         (return
          (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____LIST.html">list</a> 'from i0 'to max 'is cnt 'steps 'and 'fld '= (fld st))
              st))))

ACL2 !&gt;(test-loop$ 3 8 st)
((FROM 3 TO 8 IS 5 STEPS AND FLD = 7)
 &lt;st&gt;)
ACL2 !&gt;</pre> 
 
 <p>Both classes of <span class="v">loop$</span> expressions (<span class="v">FOR</span> and <span class="v">DO</span> <span class="v">loop$</span>s) 
 rely heavily on the ACL2 built-in function, <span class="tt"><a href="ACL2____APPLY_42.html">apply$</a></span>: in each iteration 
 through the loop, a <a href="COMMON-LISP____LAMBDA.html">lambda</a> object based on the body of the <span class="v">loop$</span> 
 is given as the function argument of <span class="v">apply$</span>.  Similarly, the <span class="v">UNTIL</span> 
 and <span class="v">WHEN</span> clauses of <span class="v">FOR</span> <span class="v">loop$</span>s and the <span class="v">:measure</span> and 
 <span class="v">FINALLY</span> clauses of <span class="v">DO</span> <span class="v">loop$</span>s are translated into <span class="v">lambda</span> 
 objects.  The functions in all those <span class="v">lambda</span> objects must be warranted to 
 evaluate the <span class="v">loop$</span> and/or prove its properties (including its guards) 
 because logically the application of an unwarranted function is 
 undefined.  (However, recall from <a href="ACL2____GUARANTEES-OF-THE-TOP-LEVEL-LOOP.html">guarantees-of-the-top-level-loop</a> that 
 <span class="v">:program</span> mode functions do not need warrants, just badges, for execution 
 in the evaluation theory.)</p> 
 
 <p>The documentation for <span class="tt"><a href="ACL2____APPLY_42.html">apply$</a></span> illustrates a simple <span class="v">defun</span> that 
 is inadmissible because the measure theorem cannot be proved without a warrant 
 and warrants cannot be assumed during the proofs of the measure conjectures. 
 The same issue arises when one of the functions critically involved in a 
 measure conjecture is defined using a <span class="v">loop$</span> whose body involves a 
 user-defined function.  For a simple example of this issue and how to work 
 around it, see <a href="ACL2____COMMUNITY-BOOK.html">community-book</a> 
 <span class="v">books/demos/measure-and-warrant.lisp</span>.</p> 
 
 <h3>Types and guards in <span class="v">loop$</span> expressions</h3> 
 
 <p>In this section we document basic aspects of the <span class="v">OF-TYPE</span> and 
 <span class="v">:GUARD</span> keywords in <span class="tt"><a href="ACL2____LOOP_42.html">loop$</a></span> expressions.  See <a href="ACL2____FOR-LOOP_42.html">for-loop$</a> and 
 <a href="ACL2____DO-LOOP_42.html">do-loop$</a> for detailed documentation on guards for <span class="v">FOR</span> and <span class="v">DO</span> 
 <span class="v">loop$</span> expressions, respectively.</p> 
 
 <p><span class="v">Loop$</span> expressions execute fastest when they are <a href="ACL2____GUARD.html">guard</a> 
 verified.  But the <span class="v">loop$</span> body raises interesting guard verification 
 problems, as do the <span class="v">UNTIL</span> and <span class="v">WHEN</span> tests of a <span class="v">FOR</span> <span class="v">loop$</span>, 
 because they are executed for many different values of the iteration 
 variables.  The <span class="v">FINALLY</span> clause of a <span class="v">DO</span> <span class="v">loop$</span> raises a similar 
 concern, since the values of its variables may be modified repeatedly by 
 execution of the <span class="v">loop$</span> body.  It may be necessary to provide type 
 information or even stronger invariants to verify guards for <span class="v">loop$</span>s.  We 
 now provide a few examples illustrating the handling of guards in 
 <span class="v">loop$</span>.</p> 
 
 <p>The first example below is an acceptable <span class="v">loop$</span> expression but cannot 
 be guard verified, as would be necessary if it appeared in a <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> 
 that was to be guard verified.  The problem is that <span class="v">(<a href="COMMON-LISP_____B2.html">+</a> 1 x)</span> requires 
 <span class="v">x</span> to be numeric and, in general, we don't know anything about the value 
 of <span class="v">x</span> here.  (Actually, because the target range is just a constant 
 below, ACL2 could deduce information about each value <span class="v">x</span> takes on, but it 
 doesn't.)  The second example can be guard verified and has the advantage of 
 being standard Common Lisp so compilers might optimize the handing of <span class="v">(<a href="COMMON-LISP_____B2.html">+</a> 1
 x)</span>.  The third example can also be guard verified but since the <span class="v">:GUARD</span> 
 directive used here is ignored by Common Lisp it does not inform the 
 compiler, so this example might execute more slowly than the previous one. 
 The last example shows the syntax and use of the ACL2-specific addition to 
 <span class="v">loop$</span>: the <span class="v">:GUARD</span> directive protecting, in this case, the 
 <span class="v">loop$</span> body.  <span class="v">:GUARD</span> is useful when you wish to add more guard 
 information than can be expressed with the Common Lisp <span class="v">of-type</span> 
 directive.  The <span class="v">of-type</span> and <span class="v">:GUARD</span> directives are conjoined to form 
 the actual guard protecting the <span class="v">loop$</span> body.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="ACL2____LOOP_42.html">loop$</a> for x in '(1 2 3) collect (<a href="COMMON-LISP_____B2.html">+</a> 1 x))
(2 3 4)
ACL2 !&gt;(<a href="ACL2____LOOP_42.html">loop$</a> for x of-type integer in '(1 2 3) collect (<a href="COMMON-LISP_____B2.html">+</a> 1 x))
(2 3 4)
ACL2 !&gt;(<a href="ACL2____LOOP_42.html">loop$</a> for x in '(1 2 3) collect :guard (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x) (<a href="COMMON-LISP_____B2.html">+</a> 1 x))
(2 3 4)
ACL2 !&gt;(<a href="COMMON-LISP____LET.html">let</a> ((<a href="COMMON-LISP____MAX.html">max</a> 10))
        (<a href="ACL2____LOOP_42.html">loop$</a> for x of-type integer in '(1 2 3)
               collect
               :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> max) (<a href="COMMON-LISP_____C3.html">&lt;</a> x max))
               (<a href="COMMON-LISP____-.html">-</a> max x)))
(9 8 7)</pre> 
 
 <p>The guard on the <span class="v">(<a href="COMMON-LISP____-.html">-</a> max x)</span> above is <span class="v">(<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x) (<a href="COMMON-LISP____INTEGERP.html">integerp</a>
 max) (<a href="COMMON-LISP_____C3.html">&lt;</a> x max))</span> and the compiler is informed that <span class="v">x</span> is an integer by 
 the <span class="v">of-type</span>.</p> 
 
 <p>The examples just above are of <span class="v">FOR</span> <span class="v">loop$</span>s.  Here is a <span class="v">DO</span> 
 <span class="v">loop$</span> example that illustrates types and guards.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="ACL2____LOOP_42.html">loop$</a> with i of-type integer = 7
              with ans = nil
              do
              :guard (<a href="ACL2____TRUE-LISTP.html">true-listp</a> ans)
              (<a href="COMMON-LISP____PROGN.html">progn</a> (setq ans (<a href="COMMON-LISP____CONS.html">cons</a> i ans))
                     (setq i (<a href="COMMON-LISP____-.html">-</a> i 2))
                     (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> i 0) (loop-finish) t))
              finally
              :guard (<a href="ACL2____TRUE-LISTP.html">true-listp</a> ans)
              (return (<a href="COMMON-LISP____REVERSE.html">reverse</a> ans)))
(7 5 3 1)
ACL2 !&gt;</pre> 
 
 <p>Neither <span class="v">:GUARD</span> is necessary in order for this execution to complete. 
 However, if this <span class="v">loop$</span> is put into a definition — <span class="v">(<a href="COMMON-LISP____DEFUN.html">defun</a> foo ()
 (<a href="ACL2____LOOP_42.html">loop$</a> ...))</span> — then both <span class="v">:GUARD</span> expressions are necessary in 
 order for the definition to be <a href="ACL2____GUARD.html">guard</a>-verified.</p> 
 
 <p>As suggested above, when a <span class="v">loop$</span> expression occurs in the body of a 
 <a href="ACL2____GUARD.html">guard</a>-verified function, it will be executed as a Common Lisp 
 <span class="v">loop</span> expression, which can be much more efficient than executing without 
 such guard verification.  This efficiency can also be gained in top-level 
 <span class="v">loop$</span> expressions if the <a href="ACL2____TAU-SYSTEM.html">tau-system</a> completes (silently) the 
 necessary guard verification.  See <a href="ACL2____PRINT-CL-CACHE.html">print-cl-cache</a>.</p>
</body>
</html>
