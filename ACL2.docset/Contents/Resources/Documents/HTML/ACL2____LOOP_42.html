<html>
<head>
<meta charset="UTF-8">
<title>Loop$</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____LOOP_42">Click for Loop$ in the Full Manual</a></h3>

<p>Iteration with an analogue of the Common Lisp <span class="v">loop</span> macro</p><p><span class="v">Loop$</span> is the ACL2 analogue of the Common Lisp's iteration 
  primitive, <span class="v">loop</span>.  This documentation assumes the reader has at least a 
  passing familiarity with <span class="v">loop</span>.</p> 
 
  <p><b>Note:</b> Before using <span class="v">loop$</span>, it is a good idea to include the 
  same book as is typically included when using <span class="tt"><a href="ACL2____APPLY_42.html">apply$</a></span>, as follows.</p> 
 
  <pre class="code">(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "projects/apply/top" :dir :system)</pre> 
 
  <p><b>Warning:</b> <span class="v">Loop$</span> implements only a small part of the 
  functionality of <span class="v">loop</span>.  Aside from the simple fact that <span class="v">loop$</span> 
  allows a small subset of the syntax of <span class="v">loop</span>, the main restriction is 
  that the subexpressions of the <span class="v">loop$</span> statement that are evaluated 
  repeatedly must be <a href="ACL2____TAME.html">tame</a>!  These expressions include the <span class="v">until</span> 
  test, the <span class="v">when</span> test, and the <span class="v">loop$</span> body.  Thus, all the function 
  symbols used in these expressions must be badged (see <span class="tt"><a href="ACL2____DEFBADGE.html">defbadge</a></span> and 
  <span class="tt"><a href="ACL2____DEFWARRANT.html">defwarrant</a></span>).  Since functions involving <span class="tt"><a href="ACL2____STATE.html">state</a></span> or <a href="ACL2____STOBJ.html">stobj</a>s cannot be badged, you cannot use them in the <span class="v">until</span>, <span class="v">when</span>, 
  or body expressions of <span class="v">loop$</span>s.  Further restrictions are enforced for 
  <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span>'d functions in which recursive calls appear in <span class="v">loop$</span> 
  bodies.  We mention that only in passing in this documentation topic.  It is 
  discussed more fully in <a href="ACL2____LOOP_42-RECURSION.html">loop$-recursion</a>.  We recommend that users 
  unfamiliar with <span class="v">loop$</span> acquaint themselves with the material below, 
  before wading into <span class="v">loop$-recursion</span>!</p> 
 
  <p><b>Warning:</b> <span class="v">Do</span> <span class="v">Loop$</span>s have recently been added but are so 
  far undocumented!  The definition below can be admitted as a guard-verified 
  logic mode function (after evaluating the events that precede it).</p> 
 
  <pre class="code">(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "projects/apply/top" :dir :system)

(<a href="ACL2____DEFSTOBJ.html">defstobj</a> st fld)
(<a href="ACL2____DEFWARRANT.html">defwarrant</a> fld)
(<a href="ACL2____DEFWARRANT.html">defwarrant</a> update-fld)

(<a href="COMMON-LISP____DEFUN.html">defun</a> test-loop$ (i0 max st)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> i0) (<a href="ACL2____NATP.html">natp</a> max))
                  :stobjs st))
  (<a href="ACL2____LOOP_42.html">loop$</a> with i of-type (satisfies natp) = i0
         with cnt of-type integer = 0
         do
         :measure (<a href="ACL2____NFIX.html">nfix</a> (<a href="COMMON-LISP____-.html">-</a> max i))
         :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> max)
                     (<a href="ACL2____NATP.html">natp</a> cnt)
                     (<a href="ACL2____STP.html">stp</a> st))
         :values (nil st) ; shape of return; can be omitted when it's (nil)
         (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> i max)
             (loop-finish)
           (<a href="COMMON-LISP____PROGN.html">progn</a> (setq st (update-fld i st))
                  (mv-setq (cnt i)
                           (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP_____B2.html">+</a> 1 cnt) (<a href="COMMON-LISP_____B2.html">+</a> 1 i)))))
         finally
         :guard (<a href="ACL2____STP.html">stp</a> st)
         (return
          (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____LIST.html">list</a> 'from i0 'to max 'is cnt 'steps 'and 'fld '= (fld st))
              st))))

ACL2 !&gt;(test 3 8 st)
((FROM 3 TO 8 IS 5 STEPS AND FLD = 7)
 &lt;st&gt;)
ACL2 !&gt;</pre> 
 
  <p>The example <span class="v">do loop$</span> above illustrates most of the features 
  supported.  There are many restrictions, the most annoying of which are 
  probably as follows.</p> 
 
  <ul> 
 
  <li>You can't mix the idioms of <span class="v">for</span> <span class="v">loop$</span>s, like ``<span class="v">for x in
  ...</span>'' or ``<span class="v">until p</span>'', with <span class="v">do</span>, or <i>vice versa</i>.</li> 
 
  <li>Common Lisp's ``implicit <span class="v">progn</span>s'' are not recognized.  You have to 
  write explicit <span class="v">progn</span>s.</li> 
 
  <li>You can't put <span class="v">progn</span>, <span class="v">setq</span>, <span class="v">mv-setq</span>, <span class="v">return</span>, and 
  <span class="v">loop-finish</span> just anywhere.  For example, you can't write <span class="v">(setq a (<a href="COMMON-LISP_____B2.html">+</a>
  b (return 23) c))</span>.</li> 
 
  <li>
<a href="ACL2____LOOP_42-RECURSION.html">Loop$-recursion</a> under <span class="v">do</span> <span class="v">loop$</span>s is not yet 
  supported.</li> 
 
  </ul> 
 
  <p>The best current guide to <span class="v">do</span> <span class="v">loop$</span>s is a comment in the ACL2 
  source file <span class="v">translate.lisp</span>.  Search for the comment</p> 
 
  <pre class="code">; Section 11: Do Loop$s</pre> 
 
  <p>and continue on to Section 12 as well if you want to use stobjs or return 
  multiple values in your <span class="v">do loop$</span>s.</p> 
 
  <p>Many examples of <span class="v">do loop$</span>s may be found in <a href="ACL2____COMMUNITY-BOOK.html">community-book</a> 
  <span class="v">books/projects/apply/loop-tests.lisp</span>, starting with the comment, ``Now I 
  experiment with do loop$s.''  Examples involving stobjs and multiple-value 
  return are later in the book, under the comment, ``Start tests of DO loop$s 
  that return multiple values and/or stobjs.''</p> 
 
  <p>Also be aware that some documentation topics about <span class="v">loop$</span> may now be 
  misleading because they may claim or suggest that they pertain to all ACL2 
  <span class="v">loop$</span> statements when in fact they may be inaccurate for <span class="v">do</span> 
  <span class="v">loop$</span>s.  The basic problem is that when the documentation was written 
  <i>all</i> <span class="v">loop$</span>s were what we now call ``<span class="v">for</span> <span class="v">loop$</span>s'' and 
  <span class="v">for</span> <span class="v">loop$</span>s are handled differently than <span class="v">do</span> <span class="v">loop$</span>s. 
  Documentation about <span class="v">loop$</span> is still thought to be accurate, but only for 
  <span class="v">for</span> <span class="v">loop$</span>s.  Documentation for the <span class="v">DO</span> keyword is 
  forthcoming.</p> 
 
  <h3>Informal Introduction</h3> 
 
  <p>ACL2's <span class="v">loop$</span> is considerably more restricted than Common Lisp's 
  <span class="v">loop</span> but when an ACL2 <span class="v">loop$</span> statement is translated without error 
  it has the same meaning as the corresponding Common Lisp <span class="v">loop</span>.  (Note: 
  <span class="v">loop$</span> allows <span class="v">:guard</span> declarations in certain places and these are 
  ignored by Common Lisp.)</p> 
 
  <p>We give some examples of legal <span class="v">loop$</span> statements below.  We deal with 
  guards and guard verification later in this topic.</p> 
 
  <pre class="code">ACL2 !&gt;(<a href="ACL2____LOOP_42.html">loop$</a> for x in '(1 2 3) sum (<a href="COMMON-LISP_____A2.html">*</a> x x))
14
ACL2 !&gt;(<a href="ACL2____LOOP_42.html">loop$</a> for x in '(1 2 3) collect (<a href="COMMON-LISP_____A2.html">*</a> x x))
(1 4 9)
ACL2 !&gt;(<a href="ACL2____LOOP_42.html">loop$</a> for x on '(1 2 3) collect x)
((1 2 3) (2 3) (3))
ACL2 !&gt;(<a href="ACL2____LOOP_42.html">loop$</a> for x from -10 to 10 by 2 collect x)
(-10 -8 -6 -4 -2 0 2 4 6 8 10)
ACL2 !&gt;(<a href="ACL2____LOOP_42.html">loop$</a> for i from 1 to 10
              as  x in '(a b c d e f g)
              collect (<a href="COMMON-LISP____CONS.html">cons</a> i x))
((1 . A)
 (2 . B)
 (3 . C)
 (4 . D)
 (5 . E)
 (6 . F)
 (7 . G))
ACL2 !&gt;(<a href="ACL2____LOOP_42.html">loop$</a> for i from 1 to 10
              as  x in '(a b c d e f g)
              until (<a href="COMMON-LISP_____E3.html">&gt;</a> i 6)
              collect (<a href="COMMON-LISP____CONS.html">cons</a> i x))
((1 . A)
 (2 . B)
 (3 . C)
 (4 . D)
 (5 . E)
 (6 . F))
ACL2 !&gt;(<a href="ACL2____LOOP_42.html">loop$</a> for i from 1 to 10
              as  x in '(a b c d e f g)
              until (<a href="COMMON-LISP_____E3.html">&gt;</a> i 6)
              when (<a href="COMMON-LISP____EVENP.html">evenp</a> i)
              collect (<a href="COMMON-LISP____CONS.html">cons</a> i x))
((2 . B) (4 . D) (6 . F))</pre> 
 
  <p><span class="v">Loop$</span> statements execute fastest when they are guard verified.  But 
  the <span class="v">until</span>, <span class="v">when</span>, and <span class="v">loop$</span> body raise interesting guard 
  verification problems because they are executed for many different values of 
  the iteration variables.  It may be necessary to provide type information or 
  even stronger invariants to verify their guards.  We now provide a few 
  examples illustrating the handling of guards in <span class="v">loop$</span>.</p> 
 
  <p>The first example below is an acceptable <span class="v">loop$</span> statement but cannot 
  be guard verified, as would be necessary if it appeared in a <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> 
  that was to be guard verified.  The problem is that <span class="v">(<a href="COMMON-LISP_____B2.html">+</a> 1 x)</span> requires 
  <span class="v">x</span> to be numeric and, in general, we don't know anything about the value 
  of <span class="v">x</span> here.  (Actually, because the target range is just a constant 
  below, we could deduce information about each value <span class="v">x</span> takes on, but we 
  don't.)  The second example can be guard verified and has the advantage of 
  being standard Common Lisp so compilers might optimize the handing of <span class="v">(<a href="COMMON-LISP_____B2.html">+</a> 1
  x)</span>.  The third example can also be guard verified but since the <span class="v">:guard</span> 
  directive used here is ignored by Common Lisp it does not inform the 
  compiler, so this example might execute more slowly than the previous one. 
  The last example shows the syntax and use of the ACL2-specific addition to 
  <span class="v">loop$</span>: the <span class="v">:guard</span> directive protecting, in this case, the 
  <span class="v">loop$</span> body.  <span class="v">:Guard</span> is useful when you wish to add more guard 
  information than can be expressed with the Common Lisp <span class="v">of-type</span> 
  directive.  The <span class="v">of-type</span> and <span class="v">:guard</span> directives are conjoined to form 
  the actual guard protecting the <span class="v">loop$</span> body.</p> 
 
  <pre class="code">ACL2 !&gt;(<a href="ACL2____LOOP_42.html">loop$</a> for x in '(1 2 3) collect (<a href="COMMON-LISP_____B2.html">+</a> 1 x))
(2 3 4)
ACL2 !&gt;(<a href="ACL2____LOOP_42.html">loop$</a> for x of-type integer in '(1 2 3) collect (<a href="COMMON-LISP_____B2.html">+</a> 1 x))
(2 3 4)
ACL2 !&gt;(<a href="ACL2____LOOP_42.html">loop$</a> for x in '(1 2 3) collect :guard (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x) (<a href="COMMON-LISP_____B2.html">+</a> 1 x))
(2 3 4)
ACL2 !&gt;(<a href="COMMON-LISP____LET.html">let</a> ((<a href="COMMON-LISP____MAX.html">max</a> 10))
        (<a href="ACL2____LOOP_42.html">loop$</a> for x of-type integer in '(1 2 3)
               collect :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> max) (<a href="COMMON-LISP_____C3.html">&lt;</a> x max)) (<a href="COMMON-LISP____-.html">-</a> max x)))
(9 8 7)</pre> 
 
  <p>The guard on the <span class="v">(<a href="COMMON-LISP____-.html">-</a> max x)</span> above is <span class="v">(<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x) (<a href="COMMON-LISP____INTEGERP.html">integerp</a>
  max) (<a href="COMMON-LISP_____C3.html">&lt;</a> x max))</span> and the compiler is informed that <span class="v">x</span> is an integer by 
  the <span class="v">of-type</span>.</p> 
 
  <p>As of ACL2 Version 8.2, the only allowed iteration clauses are <span class="v">in</span>, 
  where the variable ranges over the elements of the given true list, <span class="v">on</span>, 
  where the variable ranges over the tails of the given true-list, and 
  <span class="v">from/to/by</span> where the variable ranges over the integers between two 
  bounds, stepping by a positive integer increment (or by 1 if no <span class="v">by</span> 
  clause is provided.)</p> 
 
  <p>You may have as many iteration clauses as you wish, connected with 
  <span class="v">as</span>.  Each must introduce a unique iteration variable and that variable 
  may be optionally followed by an <span class="v">of-type</span> <span class="tt"><a href="ACL2____TYPE-SPEC.html">type-spec</a></span> 
  specification.  <span class="v">Of-type</span> is a Common Lisp feature that allows the 
  compiler to optimize operations on the variable in question.  An 
  example is</p> 
 
  <pre class="code">(<a href="ACL2____LOOP_42.html">loop$</a> for v of-type (<a href="COMMON-LISP____AND.html">and</a> integer (<a href="COMMON-LISP____NOT.html">not</a> (satisfies zerop)))
             from 1 to 100
       sum (<a href="COMMON-LISP_____F2.html">/</a> 1 v))</pre> 
 
  <p>After all of the iteration clauses, you may have a termination test, 
  signaled by <span class="v">until</span>, and/or a conditional test signaled by <span class="v">when</span>.  If 
  both are provided, the <span class="v">until</span> test must come first.  Iteration stops when 
  the <span class="v">until</span> test is satisfied.  The conditional test determines whether 
  the loop body is executed for the current value of the iteration 
  variables.</p> 
 
  <p>Between the <span class="v">until</span> symbol and the expression to be tested, and between 
  the <span class="v">when</span> symbol and its expression, you may include a <span class="v">:guard</span> 
  clause.  This is useful if guard verification requires an invariant relating 
  multiple iteration variables.  And example of a guarded <span class="v">until</span> clause is</p> 
 
  <pre class="code">(<a href="ACL2____LOOP_42.html">loop$</a> for u in lst1 as v in lst2
       until :guard (invariantp u v) (test u v)
       collect (<a href="ACL2____BODY.html">body</a> u v))</pre> 
 
  <p>ACL2 Version 8.2 supports only five operators, <span class="v">sum</span>, <span class="v">collect</span>, 
  <span class="v">always</span>, <span class="v">thereis</span> and <span class="v">append</span>.  We anticipate adding other Common 
  Lisp operators eventually.</p> 
 
  <p>The special symbols noted above, sometimes called ``<span class="v">loop$</span> keywords'', 
  may be in any package.  These are <span class="v">FOR</span>, <span class="v">IN</span>, <span class="v">ON</span>, <span class="v">FROM</span>, 
  <span class="v">TO</span>, <span class="v">BY</span>, <span class="v">OF-TYPE</span>, <span class="v">WHEN</span>, <span class="v">UNTIL</span>, <span class="v">SUM</span>, 
  <span class="v">COLLECT</span>, <span class="v">ALWAYS</span>, <span class="v">THEREIS</span>, and <span class="v">APPEND</span>.</p> 
 
  <p>Between the operator, e.g., <span class="v">sum</span> or <span class="v">collect</span>, and the 
  <span class="v">loop$</span> body you may include a <span class="v">:guard</span> clause as in</p> 
 
  <pre class="code">(<a href="ACL2____LOOP_42.html">loop$</a> for u in lst1 as v in lst2
       collect :guard (invariantp u v) (<a href="ACL2____BODY.html">body</a> u v))</pre> 
 
  <p>This is sometimes necessary in the verification of the guards for the 
  <span class="v">loop$</span> body because Common Lisp's <span class="v">of-type</span> clauses do not permit you 
  to relate one variable to another.</p> 
 
  <p><b>Important Reminder:</b> Recall that <span class="v">apply$</span> and thus <span class="v">loop$</span> are 
  unspecified in the absence of warrants for the relevant user-defined function 
  symbols.  In the documentation for <span class="tt"><a href="ACL2____APPLY_42.html">apply$</a></span>, we illustrated how a 
  simple <span class="v">defun</span> was inadmissible because the measure theorem cannot be 
  proved without a warrant and warrants cannot be assumed during the proofs of 
  the measure conjectures.  The same issue arises if <span class="v">loop$</span> involving 
  user-defined functions are involved critically in measure conjectures.  We 
  hope to address this issue in the future.</p> 
 
  <h3>General Form</h3> 
 
  <p>The syntax of Common Lisp <span class="v">loop</span> statements is extremely complicated. 
  Rather than try to write the abstract syntax of ACL2's <span class="v">loop$</span> statements 
  in the same formal style, we take a different approach, which is workable 
  because <span class="v">loop$</span> allows fewer options.</p> 
 
  <p>First we introduce the syntax of a ``target clause,'' a ``type-spec,'' and 
  the ``operators.''  Then we describe the most elaborate form of a <span class="v">loop$</span> 
  statement in terms of these elements and ordinary ACL2 terms.  Every legal 
  <span class="v">loop$</span> statement can be produced by omitting certain optional elements 
  from the most elaborate <span class="v">loop$</span> form.  So we conclude the syntactic 
  description of <span class="v">loop$</span> by listing the elements that can be omitted.</p> 
 
  <p>A <i>target clause</i> has one of four forms</p> 
 
  <ul> 
  <li>
<span class="v">IN</span> <i>list-expr</i>
</li> 
 
  <li>
<span class="v">ON</span> <i>list-expr</i>
</li> 
 
  <li>
<span class="v">FROM</span> <i>lo-expr</i> <span class="v">TO</span> <i>hi-expr</i>
</li> 
 
  <li>
<span class="v">FROM</span> <i>lo-expr</i> <span class="v">TO</span> <i>hi-expr</i> <span class="v">BY</span> <i>step-expr</i>
</li> 
 
  </ul> 
 
  <p>where <i>list-expr</i> is a term (which is expected to evaluate to a true 
  list), <i>lo-expr</i> and <i>hi-expr</i> are terms (which are expected to 
  evaluate to integers), and <i>step-expr</i> is a term (which is expected to 
  evaluate to a positive integer).</p> 
 
  <p>The legal <i>type-specs</i> are listed in <span class="tt"><a href="ACL2____TYPE-SPEC.html">type-spec</a></span>.</p> 
 
  <p>The legal <i>operators</i> are <span class="v">SUM</span>, <span class="v">COLLECT</span>, <span class="v">ALWAYS</span>, 
  <span class="v">THEREIS</span>, and <span class="v">APPEND</span>.</p> 
 
  <p>The most elaborate <span class="v">loop$</span> statement is of the form</p> 
 
  <p>        <span class="v">(<a href="ACL2____LOOP_42.html">LOOP$</a> FOR </span><i>v1</i><span class="v"> OF-TYPE </span><i>spec1 
  target1</i><br>                 
          <span class="v">AS </span>   <i>v2</i><span class="v"> OF-TYPE </span><i>spec2 
  target2</i><br>                 
          ...<br>           
                <span class="v">AS </span>   <i>vn</i><span class="v">
  OF-TYPE </span><i>specn targetn</i><br>             
              <span class="v">UNTIL :GUARD </span><i>guard1 
  until-expr</i><br>                 
          <span class="v">WHEN </span>   <span class="v">:GUARD </span><i>guard2 
  when-expr</i><br>             
              ; Note the <span class="v">ALWAYS</span>/<span class="v">THEREIS</span> Exceptions 
  below!<br>                   
        <i>op</i><span class="v"> :GUARD </span><i>guard3 
  body-expr</i><span class="v">)</span><br></p> 
 
  <p>where each <i>vi</i>   is a legal variable symbol and they are all 
  distinct, each <i>type-speci</i>   is a <span class="tt"><a href="ACL2____TYPE-SPEC.html">type-spec</a></span>, each 
  <i>targeti</i>   is a target clause, each <i>guardi</i>, 
  <i>until-expr</i>, and <i>when-expr</i>   is a term, <i>op</i>   is 
  an operator, and <i>body-expr</i>   is a term.  Furthermore, 
  <i>until-expr</i>, <i>when-expr</i>, and <i>body-expr</i>   must be 
  <a href="ACL2____TAME.html">tame</a>!</p> 
 
  <p><i>The <span class="v">ALWAYS</span>/<span class="v">THEREIS</span> Exception:</i> Common Lisp prohibits loops 
  with both a <span class="v">WHEN</span> clause and either an <span class="v">ALWAYS</span> or a <span class="v">THEREIS</span> 
  operator.  For example, if you are tempted to use <span class="v">WHEN</span> <i>p</i> with 
  <span class="v">ALWAYS</span> <i>q</i> we recommend you write <span class="v">ALWAYS</span> <span class="v">(<a href="ACL2____IMPLIES.html">implies</a> </span><i>p 
  q</i><span class="v">)</span>.</p> 
 
  <p>The following elements may be omitted.</p> 
 
  <ul> 
  <li>any line beginning with <span class="v">AS</span>, <span class="v">UNTIL</span> or <span class="v">WHEN</span>,</li> 
 
  <li>any <span class="v">OF-TYPE</span> <i>speci</i>, and</li> 
 
  <li>any <span class="v">:GUARD</span> <i>guardi</i>.</li> 
 
  </ul> 
 
  <p>As noted above, the <span class="v">loop$</span> keywords (as used above) may be in any 
  package.  These are <span class="v">FOR</span>, <span class="v">IN</span>, <span class="v">ON</span>, <span class="v">FROM</span>, <span class="v">TO</span>, <span class="v">BY</span>, 
  <span class="v">OF-TYPE</span>, <span class="v">WHEN</span>, <span class="v">UNTIL</span>, <span class="v">SUM</span>, <span class="v">COLLECT</span>, <span class="v">ALWAYS</span>, 
  <span class="v">THEREIS</span>, and <span class="v">APPEND</span>.</p> 
 
  <p>We give names to certain classes of the syntactic entities above.  The 
  <i>v1</i>, ..., <i>vn</i> are called the <i>iteration variables</i>.  The 
  <i>spec1</i>, ..., <i>specn</i> are called <i>type specs</i>, each corresponds to 
  a certain iteration variable, and each gives rise to a <i>type term</i> about 
  its variable in the sense that ``<span class="v">X OF-TYPE (SATISFIES NATP)</span>'' gives rise 
  to the type term <span class="v">(<a href="ACL2____NATP.html">NATP</a> X)</span> and ``<span class="v">I OF-TYPE INTEGER</span>'' gives rise to 
  the type term <span class="v">(<a href="COMMON-LISP____INTEGERP.html">INTEGERP</a> I)</span>.  The terms involved in the target 
  expressions, e.g., the <i>list-expr</i> in ``<span class="v">IN</span> <i>list-expr</i>'' and 
  ``<span class="v">ON</span> <i>list-expr</i>'' and the <i>lo-expr</i>, <i>hi-expr</i> and 
  optional <i>step-expr</i> in the ``<span class="v">FROM</span> <i>lo-expr</i> <span class="v">TO</span> 
  <i>hi-expr</i> <span class="v">BY</span> <i>step-expr</i>'' targets are called <i>target 
  terms</i>.  Finally, the <i>until-expr</i>, <i>when-expr</i>, and 
  <i>body-expr</i> are called <i>iterative forms</i>.</p> 
 
  <p>We distinguish the target terms from the iterative forms because they are 
  handled very differently at evaluation time.  When a <span class="v">loop$</span> is evaluated, 
  the target terms are evaluated just once.  But the iterative forms are 
  evaluated multiple times as the iteration variables range over the values of 
  the targets.</p> 
 
  <p>A <span class="v">loop$</span> statement with just one iteration variable and in which the 
  iterative forms mention no free variable other than the iteration variable 
  is called a <i>simple <span class="v">loop$</span></i>.  An example of a simple loop is</p> 
 
  <pre class="code">(<a href="ACL2____LOOP_42.html">loop$</a> for x in lst when (<a href="COMMON-LISP____EVENP.html">evenp</a> x) collect (<a href="COMMON-LISP_____B2.html">+</a> 1 (sq x)))</pre> 
 
  <p>A <span class="v">loop$</span> statement called a <i>fancy <span class="v">loop$</span></i> if it is not 
  simple.  Both of the following <span class="v">loop$</span>s are fancy.</p> 
 
  <pre class="code">(<a href="ACL2____LOOP_42.html">loop$</a> for x in xlst as y on ylst collect (expr x y))

(<a href="ACL2____LOOP_42.html">loop$</a> for x in xlst collect (expr x z))</pre> 
 
  <p>The first is fancy because it has two iteration variables.  The second is 
  fancy because the body freely uses the variable <span class="v">z</span> which is not the 
  iteration variable.</p> 
 
  <h3>Semantics</h3> 
 
  <p><span class="v">Loop$</span> expressions are translated into calls of <a href="ACL2____SCION.html">scion</a>s, with 
  the <span class="v">until</span> and <span class="v">when</span> clauses translated into preprocessors of the 
  targets.  But which scions are used depend on whether the loop is simple or 
  fancy.  Recall that a fancy loop is one that has either or both of the 
  following characteristics: (a) there is one or more <span class="v">as</span> clauses, 
  and/or (b) one of the iterative forms (the <span class="v">until</span>, <span class="v">when</span> or loop body 
  expression) refers to variables other than an iteration variable.  If the 
  <span class="v">loop$</span> statement is simple, the simple scions are used; otherwise the 
  fancy scions are used.</p> 
 
  <pre class="code">loop$
syntax              simple          fancy
symbol              scion           scion
______________________________________________
sum                 sum$            sum$+
collect             collect$        collect$+
always              always$         always$+
thereis             thereis$        thereis$+
append              append$         append$+
until               until$          until$+
when                when$           when$+</pre> 
 
  <p>We deal with simple <span class="v">loop$</span>s first.</p> 
 
  <h4>Semantics of Simple Loop$s</h4> 
 
  <p>For example, the simple <span class="v">loop$</span></p> 
  <pre class="code">(<a href="ACL2____LOOP_42.html">loop$</a> for x in lst collect (<a href="COMMON-LISP_____B2.html">+</a> 1 (sq x)))</pre> 
  <p>translates to (a term equivalent to)</p> 
 
  <pre class="code">(<a href="ACL2____COLLECT_42.html">collect$</a> (<a href="ACL2____LAMBDA_42.html">lambda$</a> (x)
                   (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> x))
                   (<a href="COMMON-LISP_____B2.html">+</a> 1 (sq x)))
          lst).</pre> 
 
  <p><b>Note:</b> The actual translation is tagged with various markers that 
  play a role in evaluation but which are logically irrelevant and which are 
  removed during proof.  In this discussion we will not display the marked-up 
  translations but logically equivalent terms instead.  You can see the actual 
  translations for yourself with <span class="tt"><a href="ACL2____TRANS.html">trans</a></span>.</p> 
 
  <p>In the translation the target term, <span class="v">lst</span>, appears as an ordinary 
  subterm of the translation.  But the iterative form, <span class="v">(<a href="COMMON-LISP_____B2.html">+</a> 1 (sq x))</span>, 
  becomes the body of a <span class="tt"><a href="ACL2____LAMBDA_42.html">lambda$</a></span> expression, which means its translation 
  becomes a component of a quoted <span class="v">LAMBDA</span> object.  When the <span class="v">collect$</span> 
  is evaluated, the target term is evaluated once but the iterative form is 
  evaluated once for each element of the value of the target.</p> 
 
  <p><span class="v">Until</span> and <span class="v">when</span> clauses are handled by preprocessing the target. 
  E.g.,</p> 
 
  <pre class="code">(<a href="ACL2____LOOP_42.html">loop$</a> for x in lst
       until (<a href="COMMON-LISP_____E3.html">&gt;</a> x 100)
       when (<a href="COMMON-LISP____EVENP.html">evenp</a> x)
       collect (<a href="COMMON-LISP_____B2.html">+</a> 1 (sq x)))</pre> 
 
  <p>becomes</p> 
 
  <pre class="code">(<a href="ACL2____COLLECT_42.html">collect$</a> (<a href="ACL2____LAMBDA_42.html">lambda$</a> (x)
                   (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> x))
                   (<a href="COMMON-LISP_____B2.html">+</a> 1 (sq x)))
          (<a href="ACL2____WHEN_42.html">when$</a> (<a href="ACL2____LAMBDA_42.html">lambda$</a> (x)
                          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> x))
                          (<a href="COMMON-LISP____EVENP.html">evenp</a> x))
                 (<a href="ACL2____UNTIL_42.html">until$</a> (<a href="ACL2____LAMBDA_42.html">lambda$</a> (x)
                                  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> x))
                                  (<a href="COMMON-LISP_____E3.html">&gt;</a> x 100))
                         lst)))</pre> 
 
  <p>So from a logical perspective, the presence of an <span class="v">until</span> and/or 
  <span class="v">when</span> clause in a <span class="v">collect</span> iteration over <span class="v">lst</span> ``copies'' the 
  target value.  The <span class="v">until$</span> copies <span class="v">lst</span> until encountering the first 
  element on which its functional argument is true.  The <span class="v">when$</span> then copies 
  that (shortened?) target, keeping only the elements that satisfy its 
  functional argument.  Finally, the <span class="v">collect$</span> then applies its functional 
  argument and collects all the values.</p> 
 
  <p><span class="v">ON</span> and <span class="v">FROM/TO/BY</span> targets are handled by listing all the 
  elements in the given target.  For example,</p> 
 
  <pre class="code">(<a href="ACL2____LOOP_42.html">loop$</a> for x on lst collect (expr x))</pre> 
 
  <p>which maps <span class="v">x</span> over successive tails of <span class="v">lst</span> and collects the value 
  of <span class="v">expr</span> has the logical meaning</p> 
 
  <pre class="code">(<a href="ACL2____COLLECT_42.html">collect$</a> (<a href="ACL2____LAMBDA_42.html">lambda$</a> (x) (expr x))
          (tails lst))</pre> 
 
  <p>where, for example, <span class="v">(tails '(1 2 3))</span> is <span class="v">((1 2 3) (2 3) (3))</span>.</p> 
 
  <p>Spiritually similarly,</p> 
  <pre class="code">(<a href="ACL2____LOOP_42.html">loop$</a> for i from 1 to max by step collect (expr x))</pre> 
 
  <p>becomes</p> 
 
  <pre class="code">(<a href="ACL2____COLLECT_42.html">collect$</a> (<a href="ACL2____LAMBDA_42.html">lambda$</a> (x) (expr x))
          (from-to-by 1 max step))</pre> 
 
  <p>where, for example, <span class="v">(from-to-by 1 10 2)</span> is <span class="v">(1 3 5 7 9)</span>.</p> 
 
  <p>Similar translations are done for the other operators, e.g., <span class="v">sum</span> and 
  <span class="v">always</span>.  The advantage of this translation style is that it allows 
  compositional reasoning.  We discuss this further below.</p> 
 
  <p>The following example illustrates basic <a href="ACL2____GUARD.html">guard</a> proof obligations, in 
  particular showing that <span class="v">when</span> clauses do not help with verifying guards 
  for the loop bodies.  (Similarly, <span class="v">until</span> clauses do not help either.) 
  The basic problem is that ACL2 requires that <span class="tt"><a href="COMMON-LISP____LAMBDA.html">lambda</a></span> objects be guard 
  veriable in isolation, not confined to the context in which a particular 
  <span class="v">lambda</span> object appears.  Consider the following.</p> 
 
  <pre class="code">(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "projects/apply/top" :dir :system)
(<a href="ACL2____DEFUN_42.html">defun$</a> sq (n)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____NATP.html">natp</a> n)))
  (<a href="COMMON-LISP_____A2.html">*</a> n n))
(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (lst)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____NAT-LISTP.html">nat-listp</a> lst)))
  (<a href="ACL2____LOOP_42.html">loop$</a> for x of-type (satisfies nat-listp) on lst
         when (<a href="COMMON-LISP____CONSP.html">consp</a> x)
         sum (sq (<a href="COMMON-LISP____CAR.html">car</a> x))))</pre> 
 
  <p>Guard verification fails for <span class="v">foo</span>.  The summary says that a goal of 
  <span class="v">NIL</span> was generated.  Using <span class="v">:</span><span class="tt"><a href="ACL2____PSO.html">pso</a></span> we can see that the <span class="v">NIL</span> 
  goal came from:</p> 
 
  <pre class="code">Subgoal 1
(<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="ACL2____NAT-LISTP.html">NAT-LISTP</a> X) (<a href="ACL2____NATP.html">NATP</a> (<a href="COMMON-LISP____CAR.html">CAR</a> X))).</pre> 
 
  <p>Let's see what is going on by looking at the following abbreviated 
  translation of the <span class="v">loop$</span> expression.</p> 
 
  <pre class="code">(<a href="ACL2____SUM_42.html">sum$</a> '(<a href="COMMON-LISP____LAMBDA.html">lambda</a> (x)
         (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (satisfies nat-listp) x)
                  (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____NAT-LISTP.html">nat-listp</a> x)
                         :split-types t)
                  (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> x))
         (sq (<a href="COMMON-LISP____CAR.html">car</a> x)))
      (<a href="ACL2____WHEN_42.html">when$</a> '(<a href="COMMON-LISP____LAMBDA.html">lambda</a> ...) (tails lst)))</pre> 
 
  <p>Notice that the <span class="v">lambda</span> object supplied to <span class="v">sum$</span> cannot be guard 
  verified in isolation: <span class="v">nil</span> satisfies the <span class="v">:guard</span> and <span class="v">(<a href="COMMON-LISP____CAR.html">car</a> nil)</span> 
  violates the guard of <span class="v">sq</span>.  The following modification, which adds a 
  <span class="v">:guard</span> directive after the <span class="v">sum</span> op keyword, solves the problem.</p> 
 
  <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (lst)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____NAT-LISTP.html">nat-listp</a> lst)))
  (<a href="ACL2____LOOP_42.html">loop$</a> for x of-type (satisfies nat-listp) on lst
         when (<a href="COMMON-LISP____CONSP.html">consp</a> x)
         sum :guard (<a href="COMMON-LISP____CONSP.html">consp</a> x)  ; note new :guard
         (sq (<a href="COMMON-LISP____CAR.html">car</a> x))))</pre> 
 
  <p>This new <span class="v">:guard</span> may feel redundant, coming as it does after the 
  <span class="v">when (<a href="COMMON-LISP____CONSP.html">consp</a> x)</span> clause.  But it is necessary given the compositional 
  semantics.</p> 
 
  <p>The abbreviated translation of the <span class="v">defun</span> above shows that the 
  application <span class="v">(sq (<a href="COMMON-LISP____CAR.html">car</a> x))</span> is protected by a suitable guard in the 
  <span class="v">lambda</span> object.</p> 
 
  <pre class="code">(<a href="ACL2____SUM_42.html">sum$</a> '(<a href="COMMON-LISP____LAMBDA.html">lambda</a> (x)
         (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (satisfies nat-listp) x)
                  (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____NAT-LISTP.html">nat-listp</a> x) (<a href="COMMON-LISP____CONSP.html">consp</a> x) 'nil)
                         :split-types t)
                  (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> x))
         (sq (<a href="COMMON-LISP____CAR.html">car</a> x)))
      (<a href="ACL2____WHEN_42.html">when$</a> '(<a href="COMMON-LISP____LAMBDA.html">lambda</a> ...) (tails lst)))</pre> 
 
  <p>Naively we might have expected that the guard proof obligation for the 
  <span class="v">loop$</span> body <span class="v">(sq (<a href="COMMON-LISP____CAR.html">car</a> x))</span> could assume the <span class="v">when</span> clause, but that 
  expectation would be wrong because of the compositional semantics we use and 
  the fact that <span class="tt"><a href="COMMON-LISP____LAMBDA.html">lambda</a></span> object must be guard-verifiable on their own. 
  The reason for the latter requirement is that our implementation caches 
  guard-verified <span class="v">lambda</span> objects for evaluation in raw Lisp, which may take 
  place in other contexts different from that in which the <span class="v">lambda</span> first 
  appeared.</p> 
 
  <h4>Semantics of Fancy Loop$s</h4> 
 
  <p>An example of a fancy <span class="v">loop$</span> is</p> 
 
  <pre class="code">(<a href="ACL2____LOOP_42.html">loop$</a> for x in xlst as y in ylst collect (expr x y z))</pre> 
 
  <p>This loop exhibits both characteristics (a) and (b): it has an <span class="v">as</span> 
  clause and the variable <span class="v">z</span> appears in the loop body.  Either 
  characteristic is sufficient to classify the loop as fancy.  So fancy scions 
  are used.  Its semantic counterpart, i.e., its translation, is</p> 
 
  <pre class="code">(<a href="ACL2____COLLECT_42_B2.html">collect$+</a>
 (<a href="ACL2____LAMBDA_42.html">lambda$</a> (loop$-gvars loop$-ivars)
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> loop$-gvars)
                                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> loop$-gvars) 1)
                                      (<a href="ACL2____TRUE-LISTP.html">true-listp</a> loop$-ivars)
                                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> loop$-ivars) 2))))
          (<a href="COMMON-LISP____LET.html">let</a> ((z (<a href="COMMON-LISP____CAR.html">car</a> loop$-gvars))
                (x (<a href="COMMON-LISP____CAR.html">car</a> loop$-ivars))
                (y (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CDR.html">cdr</a> loop$-ivars))))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> x y))
            (expr x y z)))
 (<a href="COMMON-LISP____LIST.html">list</a> z)
 (loop$-as (<a href="COMMON-LISP____LIST.html">list</a> xlst ylst)))</pre> 
 
  <p>Before we show the definition of <span class="v">collect$+</span> note that the arguments 
  above to <span class="v">collect$+</span> are (i) a <span class="v">lambda$</span> expression that handles the 
  evaluation of the iterative form, in this case <span class="v">(expr x y z)</span>, where 
  <span class="v">x</span> and <span class="v">y</span> are iteration variables and <span class="v">z</span> is a ``global'' variable 
  not among the iteration variables; (ii) the list of values of the ``global'' 
  variables, in this case the list containing <span class="v">z</span>; and (iii) a target list 
  constructed by <span class="v">loop$-as</span> from the various targets provided in the 
  <span class="v">loop$</span>, in this case <span class="v">xlst</span> and <span class="v">ylst</span>, supplying values for 
  iteration variables <span class="v">x</span> and <span class="v">y</span> respectively.  For example, 
  <span class="v">(loop$-as (<a href="COMMON-LISP____LIST.html">list</a> '(a b c d e) '(1 2 3)))</span> is <span class="v">((a 1) (b 2) (c 3))</span>. 
  These tuples contain successive corresponding values of <span class="v">x</span> and 
  <span class="v">y</span>.</p> 
 
  <p>The definition of <span class="v">collect$+</span> is essentially</p> 
  <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> collect$+ (fn loop$-gvars lst)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ENDP.html">endp</a> lst)
      nil
      (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="ACL2____APPLY_42.html">apply$</a> fn (<a href="COMMON-LISP____LIST.html">list</a> loop$-gvars (<a href="COMMON-LISP____CAR.html">car</a> lst)))
            (<a href="ACL2____COLLECT_42_B2.html">collect$+</a> fn loop$-gvars (<a href="COMMON-LISP____CDR.html">cdr</a> lst)))))</pre> 
 
  <p>We have omitted the guard and an <span class="v">MBE</span> form that makes it run more 
  efficiently.  All the fancy <span class="v">loop$</span> scions are defined analogously.</p> 
 
  <p>Inspection of the <span class="v">lambda$</span> expression above reveals that it takes a 
  list of global variable values and a list of iteration variable values, 
  unpacks them with a <span class="v">let</span> that binds the global variables, here just 
  <span class="v">z</span>, to their values and binds the iteration variables, here <span class="v">x</span> and 
  <span class="v">y</span>, to the corresponding pair of values from the target, and then 
  evaluates the <span class="v">loop$</span> body, <span class="v">(expr x y z)</span>.</p> 
 
  <p>The names of the formals for the <span class="v">lambda$</span> expressions generated by 
  <span class="v">loop$</span> statements are always <span class="v">loop$-gvars</span> and <span class="v">loop$-ivars</span>, for 
  ``<span class="v">loop$</span> global variables'' and ``<span class="v">loop$</span> iteration variables.''</p> 
 
  <p><span class="v">Until</span> and <span class="v">when</span> clauses in a fancy <span class="v">loop$</span> are handled exactly 
  as they are in simple <span class="v">loop$</span>s, except that the fancy scions are used 
  since the target list is a list of tuples of iteration variable values and 
  the <span class="v">until</span> and <span class="v">when</span> forms may refer to global variables.</p> 
 
  <h4>Special Guard Conjectures for LOOP$</h4> 
 
  <p>Since every <span class="v">loop$</span> expands to a call of a <span class="v">loop$</span> scion on a lambda 
  object and a target, one would expect that guard verification would generate 
  the guard conjectures for that scion and target.  Indeed, it does.  In 
  particular, the lambda object must have the correct number of formals (which 
  is guaranteed by translation) and the target must be a true-listp.</p> 
 
  <p>But in addition to the expected guard conjectures, we generate some 
  special ones for the terms produced by translating <span class="v">loop$</span> statements.  We 
  discuss the reasons in the next section, but here we just state what the 
  special conjectures are.  We limit ourselves to a simple <span class="v">loop$</span>.  Fancy 
  <span class="v">loop$</span> generalize in the obvious way.  The three classes of ``special 
  guard conjectures'' for <span class="v">loop$</span> statements are:</p> 
 
  <p>First, every element (or tail, in the case of <span class="v">ON</span> <span class="v">loop$</span>s) 
  satisfies the type-spec, if any.  Note that in the case of <span class="v">ON</span> 
  <span class="v">loop$</span>s <i>every</i> tail, including the empty one, must satisfy the 
  type-spec.</p> 
 
  <p>Second, the type-spec, if any, implies the guards of the <span class="v">loop$</span> 
  body.</p> 
 
  <p>Third, the <span class="v">loop$</span> body produces a value acceptable to the <span class="v">loop$</span> 
  operator, e.g., the body of <span class="v">SUM</span> <span class="v">loop$</span> produces a number and 
  the body of an <span class="v">APPEND</span> <span class="v">loop$</span> produces a true list.</p> 
 
  <h4>Discussion of Why LOOP$s Have Special Guards</h4> 
 
  <p>All of the simple <span class="v">loop$</span> scions have the same guard, namely</p> 
 
  <pre class="code">(<a href="COMMON-LISP____AND.html">AND</a> (<a href="ACL2____APPLY_42-GUARD.html">APPLY$-GUARD</a> FN '(NIL))
     (<a href="ACL2____TRUE-LISTP.html">TRUE-LISTP</a> LST)),</pre> 
 
  <p>and all the fancy <span class="v">loop$</span> scions have the same guard, namely</p> 
 
  <pre class="code">(<a href="COMMON-LISP____AND.html">AND</a> (<a href="ACL2____APPLY_42-GUARD.html">APPLY$-GUARD</a> FN '(NIL NIL))
     (<a href="ACL2____TRUE-LISTP.html">TRUE-LISTP</a> LOOP$-GVARS)
     (<a href="ACL2____TRUE-LIST-LISTP.html">TRUE-LIST-LISTP</a> LST)).</pre> 
 
  <p>In addition to the normal guard conjectures that would be generated by 
  calls of these scions, ACL2 generates some special guard conjectures because 
  the normal guard conjectures are insufficient to guarantee the error-free 
  execution of the corresponding Common Lisp <span class="v">loop</span> statements.</p> 
 
  <p>For example, the logical meaning of</p> 
 
  <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (lst)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (foo-guardp lst)))
  (<a href="ACL2____LOOP_42.html">loop$</a> for x of-type (satisfies spec) on lst sum (expr x)))</pre> 
 
  <p>is</p> 
 
  <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (lst)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (foo-guardp lst)))
  (<a href="ACL2____SUM_42.html">sum$</a> (<a href="ACL2____LAMBDA_42.html">lambda$</a> (x)
                 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (satisfies spec) x))
                 (expr x))
        (tails lst))).</pre> 
 
  <p>Prior to the provision for special guards, the normal guard conjectures 
  generated for <span class="v">foo</span> would be</p> 
 
  <pre class="code">(<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____IMPLIES.html">implies</a> (foo-guardp lst)                                 ; [1]
              (<a href="ACL2____APPLY_42-GUARD.html">apply$-guard</a>
               (<a href="ACL2____LAMBDA_42.html">lambda$</a> (x)
                 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (satisfies spec) x))
                 (expr x))
               '(nil)))
     (<a href="ACL2____IMPLIES.html">implies</a> (foo-guardp lst)                                 ; [2]
              (<a href="ACL2____TRUE-LISTP.html">true-listp</a> (tails lst)))
     (<a href="ACL2____IMPLIES.html">implies</a> (foo-guardp lst)                                 ; [3]
              (<a href="ACL2____TRUE-LISTP.html">true-listp</a> lst))
     (<a href="ACL2____IMPLIES.html">implies</a> (spec x) (expr-guardp x)))                       ; [4]</pre> 
 
  <p>Conjectures [1] and [2] stem from the guard for <span class="v">sum$</span> and establish 
  that the guard for <span class="v">foo</span> implies that <span class="v">sum$</span> is passed a function 
  object of one argument and a true-list.  Conjecture [3] establishes the guard 
  of <span class="v">tails</span>.  And conjecture [4] establishes that the guard on the 
  <span class="v">lambda$</span> implies the guard of its body.</p> 
 
  <p>But consider the raw Lisp <span class="v">loop</span> generated by the <span class="v">loop$</span> in the raw 
  Lisp definition of <span class="v">foo</span>,</p> 
 
  <pre class="code">(loop for x of-type (satisfies spec) on lst sum (expr x)).</pre> 
 
  <p>For this <span class="v">loop</span> to execute without error we need to know that [5] every 
  non-empty tail of <span class="v">lst</span> satisfies <span class="v">spec</span>, [6] that for every tail, 
  <span class="v">x</span>, of <span class="v">lst</span>, <span class="v">(expr x)</span> returns a number, and [7] that <span class="v">nil</span> 
  satisfies <span class="v">spec</span>.  The last is somewhat surprising but inspection of 
  Common Lisp reveals that even though <span class="v">(expr x)</span> is never called on the 
  empty tail of <span class="v">lst</span>, implementations running with high safety settings 
  check that the empty list satisfies <span class="v">spec</span>.</p> 
 
  <p>So when ACL2's guard verification process encounters a <span class="v">sum$</span> like that 
  in the logical <span class="v">defun</span> of <span class="v">foo</span>, it generates three additional guard 
  conjectures</p> 
 
  <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____WARRANT.html">warrant</a> ...) ; see below                   ; [5]
              (foo-guardp lst)
              (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> newv (tails lst)))
         (spec newv))

(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____WARRANT.html">warrant</a> ...) ; see below                   ; [6]
              (foo-guardp lst)
              (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> newv (tails lst)))
         (<a href="ACL2____ACL2-NUMBERP.html">acl2-numberp</a>
          (<a href="ACL2____APPLY_42.html">apply$</a> (<a href="ACL2____LAMBDA_42.html">lambda$</a> (x)
                    (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (satisfies spec) x))
                    (expr x))
                  (<a href="COMMON-LISP____LIST.html">list</a> newv))))

(<a href="ACL2____IMPLIES.html">implies</a> (foo-guardp lst)                                 ; [7]
         (spec nil))</pre> 
 
  <p>Notice the addition of hypotheses above of the form <span class="v">(<a href="ACL2____WARRANT.html">warrant</a> ...)</span>. 
  ACL2 adds such <i><a href="ACL2____WARRANT.html">warrant</a> hypotheses</i> for function symbols that 
  might be <span class="tt"><a href="ACL2____APPLY_42.html">apply$</a></span>ed during evaluation of a scion call (in this case, 
  <span class="v">sum$</span>).</p> 
 
  <p>In general, you may notice that ACL2 generates such ``special'' guard 
  conjectures for all calls of <span class="v">loop$</span> scions, whether or not they stemmed 
  from uses of <span class="v">loop$</span>.  <span class="v">FROM/TO/BY</span> targets require that the bounds and 
  step all satisfy the <span class="v">of-type</span> specification, and the <span class="v">append</span> operator 
  requires that the loop body generate a <span class="tt"><a href="ACL2____TRUE-LISTP.html">true-listp</a></span> (instead of an 
  <span class="tt"><a href="ACL2____ACL2-NUMBERP.html">ACL2-numberp</a></span> as required by the <span class="v">sum</span> operator).</p> 
 
  <h4>The Compromise Between Reasoning and Efficiency</h4> 
 
  <p>The translation of <span class="v">loop$</span> statements into formal terms reflects a 
  compromise between facilitating compositional reasoning and efficient 
  execution.</p> 
 
  <p>One sign of that compromise is our use of scions to handle <span class="v">until</span> and <span class="v">when</span> 
  clauses.  As noted above, by translating</p> 
 
  <pre class="code">(<a href="ACL2____LOOP_42.html">loop$</a> for x in lst until ... when ... collect ...)</pre> 
 
  <p>into</p> 
 
  <pre class="code">(<a href="ACL2____COLLECT_42.html">collect$</a> ... (<a href="ACL2____WHEN_42.html">when$</a> ... (<a href="ACL2____UNTIL_42.html">until$</a> ... lst)))</pre> 
 
  <p>we're forcing the evaluation of the formal semantics to copy the target 
  twice before collecting.  But it gives us the ability to reason 
  compositionally about <span class="v">collect$</span>, <span class="v">when$</span>, and <span class="v">until$</span>.  We could 
  have defined a version of <span class="v">collect$</span> that took three <span class="v">lambda$</span> 
  expressions, one to terminate the collection, one to filter for the elements 
  we're interested in, and one to transform those elements into the values we 
  wish to collect.  This would avoid copying upon evaluation but make it more 
  difficult to reason.</p> 
 
  <p>Another example of compositionality is to consider a simple <span class="v">loop$</span> 
  over the <span class="v">in</span> target <span class="v">(<a href="COMMON-LISP____APPEND.html">append</a> a b)</span>.  There are 8 different ways you 
  can do a simple <span class="v">collect</span> over an <span class="v">(<a href="COMMON-LISP____APPEND.html">append</a> a b)</span> target,</p> 
 
  <pre class="code">(<a href="ACL2____LOOP_42.html">loop$</a> for x in (<a href="COMMON-LISP____APPEND.html">append</a> a b) collect (expr x))
(<a href="ACL2____LOOP_42.html">loop$</a> for x on (<a href="COMMON-LISP____APPEND.html">append</a> a b) collect (expr x))
(<a href="ACL2____LOOP_42.html">loop$</a> for x in (<a href="COMMON-LISP____APPEND.html">append</a> a b) until (stop x) collect (expr x))
(<a href="ACL2____LOOP_42.html">loop$</a> for x on (<a href="COMMON-LISP____APPEND.html">append</a> a b) until (stop x) collect (expr x))
(<a href="ACL2____LOOP_42.html">loop$</a> for x in (<a href="COMMON-LISP____APPEND.html">append</a> a b) when (test x) collect (expr x))
(<a href="ACL2____LOOP_42.html">loop$</a> for x on (<a href="COMMON-LISP____APPEND.html">append</a> a b) when (test x) collect (expr x))
(<a href="ACL2____LOOP_42.html">loop$</a> for x in (<a href="COMMON-LISP____APPEND.html">append</a> a b) until (stop x) when (test x)
       collect (expr x))
(<a href="ACL2____LOOP_42.html">loop$</a> for x on (<a href="COMMON-LISP____APPEND.html">append</a> a b) until (stop x) when (test x)
       collect (expr x))</pre> 
 
  <p>Similarly, there are 8 ways to <span class="v">sum</span> over an <span class="v">(<a href="COMMON-LISP____APPEND.html">append</a> a b)</span> target, 
  8 ways to <span class="v">append</span> over an <span class="v">(<a href="COMMON-LISP____APPEND.html">append</a> a b)</span>, and 4 ways each to 
  <span class="v">always</span> or <span class="v">thereis</span> over an <span class="v">(<a href="COMMON-LISP____APPEND.html">append</a> a b)</span> target.  Thus, there 
  are 32 different simple <span class="v">loop$</span>s over <span class="v">(<a href="COMMON-LISP____APPEND.html">append</a> a b)</span>.  And you can 
  arrange to distribute the <span class="v">loop$</span> over the <span class="v">(<a href="COMMON-LISP____APPEND.html">append</a> a b)</span> with just 
  seven rewrite rules.</p> 
 
  <pre class="code">(<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____COLLECT_42.html">collect$</a> fn (<a href="COMMON-LISP____APPEND.html">append</a> a b))
       (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="ACL2____COLLECT_42.html">collect$</a> fn a)
               (<a href="ACL2____COLLECT_42.html">collect$</a> fn b)))

(<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____SUM_42.html">sum$</a> fn (<a href="COMMON-LISP____APPEND.html">append</a> a b))
       (<a href="COMMON-LISP_____B2.html">+</a> (<a href="ACL2____SUM_42.html">sum$</a> fn a)
          (<a href="ACL2____SUM_42.html">sum$</a> fn b)))

(<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____ALWAYS_42.html">always$</a> fn (<a href="COMMON-LISP____APPEND.html">append</a> a b))
       (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____ALWAYS_42.html">always$</a> fn a)
            (<a href="ACL2____ALWAYS_42.html">always$</a> fn b)))

(<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____THEREIS_42.html">thereis$</a> fn (<a href="COMMON-LISP____APPEND.html">append</a> a b))
       (<a href="COMMON-LISP____OR.html">or</a> (<a href="ACL2____THEREIS_42.html">thereis$</a> fn a)
           (<a href="ACL2____THEREIS_42.html">thereis$</a> fn b)))

(<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____APPEND_42.html">append$</a> fn (<a href="COMMON-LISP____APPEND.html">append</a> a b))
       (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="ACL2____APPEND_42.html">append$</a> fn a)
               (<a href="ACL2____APPEND_42.html">append$</a> fn b)))

(<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____UNTIL_42.html">until$</a> fn (<a href="COMMON-LISP____APPEND.html">append</a> a b))
       (<a href="COMMON-LISP____IF.html">if</a> (exists$ fn a)
           (<a href="ACL2____UNTIL_42.html">until$</a> fn a)
           (<a href="COMMON-LISP____APPEND.html">append</a> a (<a href="ACL2____UNTIL_42.html">until$</a> fn b))))

(<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____WHEN_42.html">when$</a> fn (<a href="COMMON-LISP____APPEND.html">append</a> a b))
       (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="ACL2____WHEN_42.html">when$</a> fn a)
               (<a href="ACL2____WHEN_42.html">when$</a> fn b)))</pre> 
 
  <p>Thus, you can reason about <span class="v">when</span> and <span class="v">until</span> clauses without having 
  to consider how they are used in the superior <span class="v">loop$</span> statement.</p> 
 
  <p>To deal with fancy <span class="v">loop$</span> you need seven more rewrite rules, one for 
  each fancy <span class="v">loop$</span> scion.  But since every simple <span class="v">loop$</span> can be 
  expressed by an appropriate use of fancy scions, we could have translated 
  every <span class="v">loop$</span> to fancy scions.  We chose to break compositionality here 
  because we think simple <span class="v">loop$</span>s are most common and wanted to keep their 
  semantics simple.  I.e., we compromised.</p> 
 
  <p>By the way, if you want the prover to convert every simple scion to its 
  fancy counterpart you could prove rewrite rules like that below.</p> 
 
  <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> convert-collect$-to-collect$+
  (<a href="ACL2____IMPLIES.html">implies</a> (ok-fnp fn)
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____COLLECT_42.html">collect$</a> fn lst)
                  (<a href="ACL2____COLLECT_42_B2.html">collect$+</a> `(<a href="COMMON-LISP____LAMBDA.html">lambda</a> (loop$-gvars loop$-ivars)
                                (,fn (<a href="COMMON-LISP____CAR.html">car</a> loop$-ivars)))
                             nil
                             (loop$-as (<a href="COMMON-LISP____LIST.html">list</a> lst)))))
  :hints (("[1]Goal"
           :expand ((<a href="ACL2____TAMEP.html">tamep</a> (<a href="COMMON-LISP____CONS.html">cons</a> fn '(x)))
                    (<a href="ACL2____TAMEP.html">tamep</a> (<a href="COMMON-LISP____CONS.html">cons</a> fn '((<a href="COMMON-LISP____CAR.html">car</a> loop$-ivars))))))))</pre>
</body>
</html>
