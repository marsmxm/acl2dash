<html>
<head>
<meta charset="UTF-8">
<title>Atc-integer-formats</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=C____ATC-INTEGER-FORMATS">Click for Atc-integer-formats in the Full Manual</a></h3>

<p>A model of C integer formats for ATC.</p><p>[C] provides constraints on the formats of the integer types [C:6.2.5], 
     but not a complete definition of the formats (unlike Java). 
     A general formalization of C should be parameterized over these formats. 
     Here, for the current purposes of ATC, 
     we define the formats, but we do so in a way that 
     should make it easy to change and swap some aspects of the definitions.</p><p>[C:6.2.6.2/2] allows padding bits, which we disallow here. 
     [C:6.2.6.2/2] allows signed integers to be 
     two's complement, one's complement, or sign and magnitude; 
     we just assume two's complement here.</p><p>The exact number of bits in a byte is also implementation-dependent 
     [C:5.2.4.2.1/1] [C:6.2.6.1/3], 
     so we introduce a nullary function for the number of bits in a byte, 
     i.e. in a <span class="v">char</span> (unsigned, signed, or plain). 
     We define it to be 8, because that ought to be the most frequent case.</p><p>We also introduce nullary functions for the number of bits that form 
     (signed and unsigned) 
     <span class="v">short</span>s, <span class="v">int</span>s, <span class="v">long</span>, and <span class="v">long long</span>s. 
     Given the above choice of no padding bits, 
     these numbers of bits have to be multiples of the number of bits in a byte, 
     because those integers have to take a whole number of bytes. 
     Recall that each unsigned/signed integer type 
     takes the same storage as the corresponding signed/unsigned type 
     [C:6.2.5/6].</p><p>We prove some theorems about the nullary functions. 
     We disable the definitions of the nullary functions, 
     including executable counterparts. 
     This way, we minimize the dependencies from the exact definitions, 
     and we define the integer values, conversions, and operations 
     as independently from the exact sizes as possible. 
     Thus, it may not be difficult to replace this file 
     with another one with different definitions.</p><p>The definitions that we pick here are consistent with <span class="v">gcc</span> 
     on (at least some versions of) macOS and Linux, namely: 
     <span class="v">char</span> is 8 bits, 
     <span class="v">short</span> is 16 bits (2 bytes), 
     <span class="v">int</span> is 32 bits (4 bytes), 
     <span class="v">long</span> is 64 bits (8 bytes), and 
     <span class="v">long long</span> is also 64 bits (8 bytes). 
     These are all consistent with the ranges in [C:5.2.4.2.1]: 
     <span class="v">char</span> is at least 8 bits, 
     <span class="v">short</span> is at least 16 bits, 
     <span class="v">int</span> is at least 16 bits, 
     <span class="v">long</span> is at least 32 bits, and 
     <span class="v">long long</span> is at least 64 bits. 
     Furthermore, the ranges are increasing [C:6.2.5/8].</p><p>For now we only define formats for 
     the standard signed and unsigned integer types except <span class="v">_Bool</span>. 
     Note that the plain <span class="v">char</span> type is not covered yet; 
     it is an integer type, 
     but not a standard integer type in C's terminology.</p>
</body>
</html>
