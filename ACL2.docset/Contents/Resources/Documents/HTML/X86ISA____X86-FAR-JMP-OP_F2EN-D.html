<html>
<head>
<meta charset="UTF-8">
<title>X86-far-jmp-op/en-d</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=X86ISA____X86-FAR-JMP-OP_F2EN-D">Click for X86-far-jmp-op/en-d in the Full Manual</a></h3>

<p>Absolute Indirect Jump: Far</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(x86-far-jmp-op/en-d proc-mode start-rip temp-rip 
                     prefixes rex-byte opcode modr/m sib x86) 
 
  → 
x86</pre></dt>
<dt>Returns</dt>
<dd>
<span class="tt">x86</span> — <font color="#606060">Type <span class="v">(x86p x86)</span>, given <span class="v">(x86p x86)</span>.</font>
</dd> 
 
</dl></div> 
<p>Op/En: D</p> 
<p><span class="tt">FF/5: JMP m16:16 or m16:32 or m16:64</span></p> 
 
<p>Source: Intel Manuals (Vol. 2A) Instruction Set Reference: the 
text below has been edited to contain information only about the 
64-bit mode.</p> 
 
<p><i>The JMP instruction cannot be used to perform 
inter-privilege-level far jumps.</i> The processor always uses the 
segment selector part of the far address to access the corresponding 
descriptor in the GDT or LDT. The descriptor type and access rights 
determine the type of jump to be performed.</p> 
 
<p><b>Far Jump to a Conforming or Non-Conforming Code Segment:</b> If 
the selected descriptor is for a code segment, a far jump to a code 
segment at the same privilege level is performed. If the selected code 
segment is at a different privilege level and the code segment is 
non-conforming, a general-protection exception is generated.  The 
target operand specifies an absolute far address indirectly with a 
memory location (m16:16 or m16:32 or m16:64). The operand-size 
attribute and the REX.w bit determine the size of the offset (16 or 
32 or 64 bits) in the far address. The new code segment selector and 
its descriptor are loaded into CS register, and the offset from the 
instruction is loaded into the RIP register.</p> 
 
<p><b>Far Jump through a Call Gate:</b> When executing a far jump 
through a call gate, the segment selector specified by the target 
operand identifies the call gate. The offset part of the target 
operand is ignored. The processor then jumps to the code segment 
specified in the call gate descriptor and begins executing the 
instruction at the offset specified in the call gate. No stack switch 
occurs. The target operand specifies the far address of the call gate 
indirectly with a memory location (m16:16 or m16:32 or m16:64).</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>x86-far-jmp-op/en-d</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 x86-far-jmp-op/en-d
 (proc-mode start-rip temp-rip
            prefixes rex-byte opcode modr/m sib x86)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (x86)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (integer 0 4) proc-mode)
          (<a href="COMMON-LISP____TYPE.html">type</a> (signed-byte 48) start-rip)
          (<a href="COMMON-LISP____TYPE.html">type</a> (signed-byte 48) temp-rip)
          (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 52) prefixes)
          (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 8) rex-byte)
          (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 8) opcode)
          (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 8) modr/m)
          (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 8) sib))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> proc-mode start-rip temp-rip
                     prefixes rex-byte opcode modr/m sib))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="X86ISA____PREFIXES-P.html">prefixes-p</a> prefixes)
                             (<a href="X86ISA____MODR_F2M-P.html">modr/m-p</a> modr/m)
                             (<a href="X86ISA____SIB-P.html">sib-p</a> sib)
                             (<a href="X86ISA____RIP-GUARD-OKP.html">rip-guard-okp</a> proc-mode temp-rip))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((__function__ 'x86-far-jmp-op/en-d))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
  (<a href="ACL2____B_A2.html">b*</a>
   ((?ctx 'x86-far-jmp-op/en-d)
    (?r/m (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 3)
               (<a href="X86ISA____MODR_F2M-_E3R_F2M.html">modr/m-&gt;r/m</a> modr/m)))
    (?mod (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 2)
               (<a href="X86ISA____MODR_F2M-_E3MOD.html">modr/m-&gt;mod</a> modr/m)))
    (?reg (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 3)
               (<a href="X86ISA____MODR_F2M-_E3REG.html">modr/m-&gt;reg</a> modr/m))))
   (<a href="ACL2____B_A2.html">b*</a>
    (((when (<a href="COMMON-LISP____EQUAL.html">equal</a> mod 3))
      (!!ms-fresh :source-operand-not-memory-location mod))
     (p2 (<a href="X86ISA____PREFIXES-_E3SEG.html">prefixes-&gt;seg</a> prefixes))
     (p4? (<a href="COMMON-LISP____EQUAL.html">equal</a> 103 (<a href="X86ISA____PREFIXES-_E3ADR.html">prefixes-&gt;adr</a> prefixes)))
     ((<a href="COMMON-LISP____THE.html">the</a> (integer 2 8) offset-size)
      (<a href="X86ISA____SELECT-OPERAND-SIZE.html">select-operand-size</a> proc-mode nil
                           rex-byte nil prefixes nil nil nil x86))
     (seg-reg
         (<a href="X86ISA____SELECT-SEGMENT-REGISTER.html">select-segment-register</a> proc-mode p2 p4? mod r/m sib x86))
     (inst-ac? t)
     ((<a href="ACL2____MV.html">mv</a> flg mem
          (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 3) increment-rip-by)
          (<a href="COMMON-LISP____THE.html">the</a> (signed-byte 64) ?addr)
          x86)
      (<a href="X86ISA____X86-OPERAND-FROM-MODR_F2M-AND-SIB-BYTES.html">x86-operand-from-modr/m-and-sib-bytes</a>
           proc-mode
           0 (<a href="COMMON-LISP____THE.html">the</a> (integer 2 10) (<a href="COMMON-LISP_____B2.html">+</a> 2 offset-size))
           inst-ac? t seg-reg p4?
           temp-rip rex-byte r/m mod sib 0 x86))
     ((when flg)
      (!!ms-fresh :x86-operand-from-modr/m-and-sib-bytes-error flg))
     (badlength? (<a href="X86ISA____CHECK-INSTRUCTION-LENGTH.html">check-instruction-length</a>
                      start-rip temp-rip increment-rip-by))
     ((when badlength?)
      (!!fault-fresh :gp 0
                     :instruction-length badlength?))
     (selector (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 16) (<a href="X86ISA____N16.html">n16</a> mem)))
     (offset (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____PART-SELECT.html">part-select</a> mem
                                      :low 16
                                      :width (<a href="COMMON-LISP____ASH.html">ash</a> offset-size 3))
                  :exec (<a href="COMMON-LISP____ASH.html">ash</a> mem -16)))
     ((<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 13) sel-index)
      (<a href="X86ISA____SEGMENT-SELECTORBITS-_E3INDEX.html">segment-selectorbits-&gt;index</a> selector))
     ((<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 1) sel-ti)
      (<a href="X86ISA____SEGMENT-SELECTORBITS-_E3TI.html">segment-selectorbits-&gt;ti</a> selector))
     ((<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 2) sel-rpl)
      (<a href="X86ISA____SEGMENT-SELECTORBITS-_E3RPL.html">segment-selectorbits-&gt;rpl</a> selector))
     ((when (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> sel-ti 0)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> sel-index 0)))
      (!!fault-fresh :gp 0
                     :gp-nullselector 0))
     ((<a href="ACL2____MV.html">mv</a> dt-base-addr dt-limit)
      (<a href="COMMON-LISP____IF.html">if</a>
         (<a href="COMMON-LISP____EQUAL.html">equal</a> sel-ti 0)
         (<a href="ACL2____B_A2.html">b*</a> ((gdtr (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 80) (stri 0 x86)))
              (gdtr-base (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQL.html">eql</a> proc-mode 0)
                             (<a href="X86ISA____GDTR_F2IDTRBITS-_E3BASE-ADDR.html">gdtr/idtrbits-&gt;base-addr</a> gdtr)
                             (<a href="X86ISA____N32.html">n32</a> (<a href="X86ISA____GDTR_F2IDTRBITS-_E3BASE-ADDR.html">gdtr/idtrbits-&gt;base-addr</a> gdtr))))
              (gdtr-limit (<a href="X86ISA____GDTR_F2IDTRBITS-_E3LIMIT.html">gdtr/idtrbits-&gt;limit</a> gdtr)))
             (<a href="ACL2____MV.html">mv</a> gdtr-base gdtr-limit))
         (<a href="ACL2____B_A2.html">b*</a> ((ldtr-base (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 64)
                              (ssr-hidden-basei 0 x86)))
              (ldtr-base (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQL.html">eql</a> proc-mode 0)
                             ldtr-base (<a href="X86ISA____N32.html">n32</a> ldtr-base)))
              (ldtr-limit (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 32)
                               (ssr-hidden-limiti 0 x86))))
             (<a href="ACL2____MV.html">mv</a> ldtr-base ldtr-limit))))
     (largest-address (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP____ASH.html">ash</a> sel-index 3) 7))
     ((when (<a href="COMMON-LISP_____C3.html">&lt;</a> dt-limit largest-address))
      (!!fault-fresh :gp sel-index
                     :gp-selector-limit-check-failed
                     (<a href="COMMON-LISP____LIST.html">list</a> selector dt-base-addr dt-limit)))
     (descriptor-addr (<a href="COMMON-LISP_____B2.html">+</a> dt-base-addr
                         (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 16)
                              (<a href="COMMON-LISP____ASH.html">ash</a> sel-index 3))))
     ((when (<a href="COMMON-LISP____NOT.html">not</a> (<a href="X86ISA____CANONICAL-ADDRESS-P.html">canonical-address-p</a> descriptor-addr)))
      (!!ms-fresh
           :descriptor-addr-virtual-memory-error descriptor-addr))
     ((<a href="ACL2____MV.html">mv</a> flg (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 64) descriptor)
          x86)
      (<a href="X86ISA____RML-SIZE.html">rml-size</a> 8 descriptor-addr :x x86))
     ((when flg)
      (!!ms-fresh :rml-size-error flg))
     (s (<a href="X86ISA____CODE-SEGMENT-DESCRIPTORBITS-_E3S.html">code-segment-descriptorbits-&gt;s</a> descriptor))
     ((when (<a href="COMMON-LISP_____D3.html">=</a> s 1))
      (<a href="ACL2____B_A2.html">b*</a>
       ((msb-of-type
             (<a href="X86ISA____CODE-SEGMENT-DESCRIPTORBITS-_E3MSB-OF-TYPE.html">code-segment-descriptorbits-&gt;msb-of-type</a> descriptor))
        ((unless (<a href="COMMON-LISP_____D3.html">=</a> msb-of-type 1))
         (!!fault-fresh :gp sel-index
                        :jmp-far-data-segment sel-index))
        (d (<a href="X86ISA____CODE-SEGMENT-DESCRIPTORBITS-_E3D.html">code-segment-descriptorbits-&gt;d</a> descriptor))
        ((when (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____EQL.html">eql</a> proc-mode 0) (<a href="COMMON-LISP_____D3.html">=</a> d 1)))
         (!!fault-fresh :gp sel-index
                        :cs.d=1-in-64-bit-mode sel-index))
        (cpl (cpl x86))
        (dpl (<a href="X86ISA____CODE-SEGMENT-DESCRIPTORBITS-_E3DPL.html">code-segment-descriptorbits-&gt;dpl</a> descriptor))
        (c (<a href="X86ISA____CODE-SEGMENT-DESCRIPTORBITS-_E3C.html">code-segment-descriptorbits-&gt;c</a> descriptor))
        (allowed (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____D3.html">=</a> c 1)
                     (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> dpl cpl)
                     (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> sel-rpl cpl) (<a href="COMMON-LISP____EQUAL.html">equal</a> cpl dpl))))
        ((when (<a href="COMMON-LISP____NOT.html">not</a> allowed))
         (!!fault-fresh
              :gp sel-index
              :privilege-check-fail
              (<a href="COMMON-LISP____ACONS.html">acons</a> :dpl dpl
                     (<a href="COMMON-LISP____ACONS.html">acons</a> :cpl cpl (<a href="COMMON-LISP____ACONS.html">acons</a> :rpl sel-rpl nil)))))
        (p (<a href="X86ISA____CODE-SEGMENT-DESCRIPTORBITS-_E3P.html">code-segment-descriptorbits-&gt;p</a> descriptor))
        ((unless (<a href="COMMON-LISP_____D3.html">=</a> p 1))
         (!!fault-fresh :np sel-index
                        :code-segment-not-present sel-index))
        (jmp-addr (<a href="COMMON-LISP____CASE.html">case</a> offset-size (2 (<a href="X86ISA____N16.html">n16</a> offset))
                        (4 (<a href="X86ISA____N32.html">n32</a> offset))
                        (t (<a href="X86ISA____I64.html">i64</a> offset))))
        (jmp-addr-ok
         (<a href="COMMON-LISP____IF.html">if</a>
          (<a href="COMMON-LISP____EQL.html">eql</a> proc-mode 0)
          (<a href="X86ISA____CANONICAL-ADDRESS-P.html">canonical-address-p</a> jmp-addr)
          (<a href="ACL2____B_A2.html">b*</a>
           ((limit15-0
                (<a href="X86ISA____CODE-SEGMENT-DESCRIPTORBITS-_E3LIMIT15-0.html">code-segment-descriptorbits-&gt;limit15-0</a> descriptor))
            (limit19-16
               (<a href="X86ISA____CODE-SEGMENT-DESCRIPTORBITS-_E3LIMIT19-16.html">code-segment-descriptorbits-&gt;limit19-16</a> descriptor))
            (limit (<a href="ACL2____PART-INSTALL.html">part-install</a> limit15-0 (<a href="COMMON-LISP____ASH.html">ash</a> limit19-16 16)
                                 :low 0
                                 :width 16))
            (g (<a href="X86ISA____CODE-SEGMENT-DESCRIPTORBITS-_E3G.html">code-segment-descriptorbits-&gt;g</a> descriptor))
            (max-offset (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____D3.html">=</a> g 1) (<a href="COMMON-LISP____1-.html">1-</a> (<a href="COMMON-LISP____ASH.html">ash</a> limit 12)) limit)))
           (<a href="COMMON-LISP_____C3.html">&lt;</a> jmp-addr max-offset))))
        ((unless jmp-addr-ok)
         (!!fault-fresh
              :gp 0
              :noncanonical-or-outside-segment-limit jmp-addr))
        (new-cs-visible (<a href="X86ISA_____12SEGMENT-SELECTORBITS-_E3RPL.html">!segment-selectorbits-&gt;rpl</a> cpl selector))
        (x86 (!seg-visiblei 1 new-cs-visible x86))
        (x86 (!seg-hidden-basei 1 dt-base-addr x86))
        (x86 (!seg-hidden-limiti 1 dt-limit x86))
        (x86 (!seg-hidden-attri
                  1
                  (<a href="X86ISA____MAKE-CODE-SEGMENT-ATTR-FIELD.html">make-code-segment-attr-field</a> descriptor)
                  x86))
        (x86 (<a href="X86ISA____WRITE-_A2IP.html">write-*ip</a> proc-mode jmp-addr x86)))
       x86))
     ((when (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> proc-mode 0)))
      (!!ms-fresh :far-jmp-system-unimplemented-in-32-bit-mode))
     (largest-address (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP____ASH.html">ash</a> sel-index 3) 15))
     ((when (<a href="COMMON-LISP_____C3.html">&lt;</a> dt-limit largest-address))
      (!!fault-fresh :gp sel-index
                     :gp-selector-limit-check-failed
                     (<a href="COMMON-LISP____LIST.html">list</a> selector dt-base-addr dt-limit)))
     ((<a href="ACL2____MV.html">mv</a> flg (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 128) descriptor)
          x86)
      (<a href="X86ISA____RML-SIZE.html">rml-size</a> 16 descriptor-addr :x x86))
     ((when flg)
      (!!ms-fresh :rml-size-error flg))
     ((<a href="ACL2____MV.html">mv</a> call-gate-desc? reason2)
      (<a href="X86ISA____IA32E-VALID-CALL-GATE-SEGMENT-DESCRIPTOR-P.html">ia32e-valid-call-gate-segment-descriptor-p</a> descriptor))
     ((when call-gate-desc?)
      (<a href="ACL2____B_A2.html">b*</a>
       ((cpl (cpl x86))
        (dpl (<a href="X86ISA____CALL-GATE-DESCRIPTORBITS-_E3DPL.html">call-gate-descriptorbits-&gt;dpl</a> descriptor))
        ((when (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> cpl dpl) (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> sel-rpl dpl))))
         (!!fault-fresh
              :gp sel-index
              :privilege-check-fail
              (<a href="COMMON-LISP____ACONS.html">acons</a> :dpl dpl
                     (<a href="COMMON-LISP____ACONS.html">acons</a> :cpl cpl (<a href="COMMON-LISP____ACONS.html">acons</a> :rpl sel-rpl nil)))))
        (cs-selector
             (<a href="X86ISA____CALL-GATE-DESCRIPTORBITS-_E3SELECTOR.html">call-gate-descriptorbits-&gt;selector</a> descriptor))
        ((<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 13) cs-sel-index)
         (<a href="X86ISA____SEGMENT-SELECTORBITS-_E3INDEX.html">segment-selectorbits-&gt;index</a> cs-selector))
        ((<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 1) cs-sel-ti)
         (<a href="X86ISA____SEGMENT-SELECTORBITS-_E3TI.html">segment-selectorbits-&gt;ti</a> cs-selector))
        ((<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 2) cs-sel-rpl)
         (<a href="X86ISA____SEGMENT-SELECTORBITS-_E3RPL.html">segment-selectorbits-&gt;rpl</a> cs-selector))
        ((when (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> cs-sel-ti 0)
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> cs-sel-index 0)))
         (!!fault-fresh :gp 0
                        :call-gate-code-segment-nullselector 0))
        ((<a href="ACL2____MV.html">mv</a> cs-dt-base-addr cs-dt-limit)
         (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> sel-ti 0)
             (<a href="ACL2____B_A2.html">b*</a> ((gdtr (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 80) (stri 0 x86)))
                  (gdtr-base (<a href="X86ISA____GDTR_F2IDTRBITS-_E3BASE-ADDR.html">gdtr/idtrbits-&gt;base-addr</a> gdtr))
                  (gdtr-base (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQL.html">eql</a> proc-mode *64-bit-mode*)
                                 gdtr-base (<a href="X86ISA____N32.html">n32</a> gdtr-base)))
                  (gdtr-limit (<a href="X86ISA____GDTR_F2IDTRBITS-_E3LIMIT.html">gdtr/idtrbits-&gt;limit</a> gdtr)))
                 (<a href="ACL2____MV.html">mv</a> gdtr-base gdtr-limit))
             (<a href="ACL2____B_A2.html">b*</a> ((ldtr-base (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 64)
                                  (ssr-hidden-basei 0 x86)))
                  (ldtr-base (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQL.html">eql</a> proc-mode 0)
                                 ldtr-base (<a href="X86ISA____N32.html">n32</a> ldtr-base)))
                  (ldtr-limit (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 32)
                                   (ssr-hidden-limiti 0 x86))))
                 (<a href="ACL2____MV.html">mv</a> ldtr-base ldtr-limit))))
        (largest-address (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP____ASH.html">ash</a> cs-sel-index 3) 7))
        ((when (<a href="COMMON-LISP_____C3.html">&lt;</a> cs-dt-limit largest-address))
         (!!fault-fresh :gp cs-sel-index
                        :gp-selector-limit-check-failed
                        (<a href="COMMON-LISP____LIST.html">list</a> cs-selector
                              cs-dt-base-addr cs-dt-limit)))
        (cs-descriptor-addr (<a href="COMMON-LISP_____B2.html">+</a> cs-dt-base-addr
                               (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 16)
                                    (<a href="COMMON-LISP____ASH.html">ash</a> cs-sel-index 3))))
        ((when (<a href="COMMON-LISP____NOT.html">not</a> (<a href="X86ISA____CANONICAL-ADDRESS-P.html">canonical-address-p</a> cs-descriptor-addr)))
         (!!ms-fresh :cs-descriptor-addr-virtual-memory-error
                     cs-descriptor-addr))
        ((<a href="ACL2____MV.html">mv</a> flg
             (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 64) cs-descriptor)
             x86)
         (<a href="X86ISA____RML-SIZE.html">rml-size</a> 8 cs-descriptor-addr :x x86))
        ((when flg)
         (!!ms-fresh :rml-size-error flg))
        ((<a href="ACL2____MV.html">mv</a> valid? reason)
         (<a href="X86ISA____IA32E-VALID-CODE-SEGMENT-DESCRIPTOR-P.html">ia32e-valid-code-segment-descriptor-p</a> cs-descriptor))
        ((when (<a href="COMMON-LISP____NOT.html">not</a> valid?))
         (!!fault-fresh :gp cs-sel-index
                        :call-gate-code-segment-descriptor-invalid
                        (<a href="COMMON-LISP____CONS.html">cons</a> reason cs-descriptor)))
        (cs-dpl (<a href="X86ISA____CODE-SEGMENT-DESCRIPTORBITS-_E3DPL.html">code-segment-descriptorbits-&gt;dpl</a> cs-descriptor))
        (c-bit (<a href="X86ISA____CODE-SEGMENT-DESCRIPTORBITS-_E3C.html">code-segment-descriptorbits-&gt;c</a> cs-descriptor))
        ((when (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> c-bit 1)
                        (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> cs-dpl cpl)))
                   (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> c-bit 0)
                        (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQL.html">eql</a> cs-dpl cpl)))))
         (!!fault-fresh
              :gp cs-sel-index
              :privilege-check-fail
              (<a href="COMMON-LISP____ACONS.html">acons</a> :c-bit c-bit
                     (<a href="COMMON-LISP____ACONS.html">acons</a> :cpl cpl (<a href="COMMON-LISP____ACONS.html">acons</a> :cs-dpl cs-dpl nil)))))
        (call-gate-offset15-0
             (<a href="X86ISA____CALL-GATE-DESCRIPTORBITS-_E3OFFSET15-0.html">call-gate-descriptorbits-&gt;offset15-0</a> descriptor))
        (call-gate-offset31-16
             (<a href="X86ISA____CALL-GATE-DESCRIPTORBITS-_E3OFFSET31-16.html">call-gate-descriptorbits-&gt;offset31-16</a> descriptor))
        (call-gate-offset63-32
             (<a href="X86ISA____CALL-GATE-DESCRIPTORBITS-_E3OFFSET63-32.html">call-gate-descriptorbits-&gt;offset63-32</a> descriptor))
        (call-gate-offset31-0
          (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____PART-INSTALL.html">part-install</a> call-gate-offset15-0
                                    (<a href="COMMON-LISP____ASH.html">ash</a> call-gate-offset31-16 16)
                                    :low 0
                                    :width 16)
               :exec
               (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 32)
                    (<a href="COMMON-LISP____LOGIOR.html">logior</a> (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 16)
                                 call-gate-offset15-0)
                            (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 32)
                                 (<a href="COMMON-LISP____ASH.html">ash</a> call-gate-offset31-16 16))))))
        (call-gate-offset
          (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____PART-INSTALL.html">part-install</a> call-gate-offset31-0
                                    (<a href="COMMON-LISP____ASH.html">ash</a> call-gate-offset63-32 32)
                                    :low 0
                                    :width 32)
               :exec
               (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 64)
                    (<a href="COMMON-LISP____LOGIOR.html">logior</a> (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 32)
                                 call-gate-offset31-0)
                            (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 64)
                                 (<a href="COMMON-LISP____ASH.html">ash</a> call-gate-offset63-32 32))))))
        (jmp-addr (<a href="COMMON-LISP____CASE.html">case</a> offset-size (2 (<a href="X86ISA____N16.html">n16</a> call-gate-offset))
                        (4 (<a href="X86ISA____N32.html">n32</a> call-gate-offset))
                        (t call-gate-offset)))
        ((when (<a href="COMMON-LISP____NOT.html">not</a> (<a href="X86ISA____CANONICAL-ADDRESS-P.html">canonical-address-p</a> jmp-addr)))
         (!!ms-fresh :target-offset-virtual-memory-error jmp-addr))
        (new-cs-visible
             (<a href="X86ISA_____12SEGMENT-SELECTORBITS-_E3RPL.html">!segment-selectorbits-&gt;rpl</a> cpl cs-selector))
        (x86 (!seg-visiblei 1 new-cs-visible x86))
        (x86 (!seg-hidden-basei 1 cs-dt-base-addr x86))
        (x86 (!seg-hidden-limiti 1 cs-dt-limit x86))
        (x86 (!seg-hidden-attri
                  1
                  (<a href="X86ISA____MAKE-CODE-SEGMENT-ATTR-FIELD.html">make-code-segment-attr-field</a> cs-descriptor)
                  x86))
        (x86 (<a href="X86ISA____WRITE-_A2IP.html">write-*ip</a> proc-mode jmp-addr x86)))
       x86)))
    (!!fault-fresh
     :gp sel-index
     :either-both-code-segment-or-call-gate-are-absent-or-some-other-descriptor-is-present
     (<a href="COMMON-LISP____CONS.html">cons</a> reason2 descriptor))))))</pre> 
<p><b>Theorem: </b>x86p-of-x86-far-jmp-op/en-d</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 x86p-of-x86-far-jmp-op/en-d
 (<a href="ACL2____IMPLIES.html">implies</a>
  (x86p x86)
  (<a href="ACL2____B_A2.html">b*</a>
    ((x86 (<a href="X86ISA____X86-FAR-JMP-OP_F2EN-D.html">x86-far-jmp-op/en-d</a> proc-mode start-rip temp-rip prefixes
                               rex-byte opcode modr/m sib x86)))
    (x86p x86)))
 :rule-classes :rewrite)</pre> 

</body>
</html>
