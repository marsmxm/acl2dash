<html>
<head>
<meta charset="UTF-8">
<title>Performance-problems</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=GL____PERFORMANCE-PROBLEMS">Click for Performance-problems in the Full Manual</a></h3>

<p></p> 
 
<p>Any bit-blasting tool has capacity limitations.  However, you may also run into 
cases where GL is performing poorly due to preventable issues.  When GL seems 
to be running forever, it can be helpful to trace the symbolic interpreter to 
see which functions are causing the problem.  To trace the symbolic 
interpreter, run</p> 
 
<pre class="code">(gl::trace-gl-interp :show-values t)</pre> 
 
<p>Here, at each call of the symbolic interpreter, the term being interpreted 
and the variable bindings are shown, but since symbolic objects may be too 
large to print, any bindings that are not concrete are hidden.  You can also 
get a trace with no variable bindings using <span class="v">:show-values nil</span>.  It may also 
be helpful to simply interrupt the computation and look at the Lisp backtrace, 
after executing</p> 
 
<pre class="code">(<a href="ACL2____SET-DEBUGGER-ENABLE.html">set-debugger-enable</a> t)</pre> 
 
<p>In many cases, performance problems are due to BDDs growing too large.  This 
is likely the case if the interpreter appears to get stuck (not printing any 
more trace output) and the backtrace contains a lot of functions with names 
beginning in <span class="v">q-</span>, which is the convention for BDD operators.  In some 
cases, these performance problems may be solved by choosing a more efficient 
BDD order.  But note that certain operations like multiplication are 
exponentially hard.  If you run into these limits, you may need to refactor or 
decompose your problem into simpler sub-problems, e.g., with <a href="ACL2____DEF-GL-PARAM-THM.html">def-gl-param-thm</a>.</p> 
 
<p>There is one kind of BDD performance problem with a special solution. 
Suppose GL is asked to prove <span class="v">(<a href="COMMON-LISP____EQUAL.html">equal</a> spec impl)</span> when this does not actually 
hold.  Sometimes the symbolic objects for <span class="v">spec</span> and <span class="v">impl</span> can be 
created, but the BDD representing their equality is too large to fit in memory. 
The goal may then be restated with <a href="ACL2____ALWAYS-EQUAL.html">ACL2::always-equal</a> instead of 
<span class="v">equal</span> as the final comparison.  Logically, <span class="v">always-equal</span> is just 
<span class="v">equal</span>.  But <span class="v">always-equal</span> has a custom symbolic counterpart that 
returns <span class="v">t</span> when its arguments are equivalent, or else produces a symbolic 
object that captures just one counterexample and is indeterminate in all other 
cases.</p> 
 
<p>Another possible problem is that the symbolic interpreter never gets stuck, 
but keeps opening up more and more functions.  These problems might be due to 
<a href="GL____REDUNDANT-RECURSION.html">redundant-recursion</a>, which may be avoided by providing a more efficient 
<a href="GL____PREFERRED-DEFINITIONS.html">preferred-definitions</a>.</p>
</body>
</html>
