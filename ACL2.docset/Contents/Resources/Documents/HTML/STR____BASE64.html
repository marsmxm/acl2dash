<html>
<head>
<meta charset="UTF-8">
<title>Base64</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=STR____BASE64">Click for Base64 in the Full Manual</a></h3>

<p>Routines for Base 64 string encoding/decoding.</p><p>We implement ACL2 functions for Base 64 encoding and decoding as 
described in <a href="http://www.ietf.org/rfc/rfc4648.txt" target="_blank"><nobr>RFC 4648<img src="../Icon_External_Link.png" title="External link to http://www.ietf.org/rfc/rfc4648.txt"></nobr></a>.</p> 
 
<p>Our functions are quite efficient, given the constraints of ACL2 string 
processing.  We prove the following inversion theorem, which shows that if 
encode some text and then try to decode it, then (1) decoding succeeds and (2) 
we get the original text back.</p> 
 
<p><b>Theorem: </b>base64-decode-of-base64-encode</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> base64-decode-of-base64-encode
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="STR____BASE64-DECODE.html">base64-decode</a> (<a href="STR____BASE64-ENCODE.html">base64-encode</a> x))
               (<a href="ACL2____MV.html">mv</a> t (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____STRINGP.html">stringp</a> x) x ""))))</pre> 
 
<p>Of course, this theorem does not say anything about whether we have encoded 
or decoded the text "correctly" as described in RFC 4648.  After all, if we 
simply used the identity function as our encoder and decoder, the above theorem 
would still hold.</p> 
 
<p>However, to the degree possible, our encoder/decoder are intended to 
implement Base64 encoding as described by RFC 4648.  We do not implement 
variants of base64 encoding such as "base64 URL encoding" and "base64 MIME 
encoding." Some particular details of our implementation:</p> 
 
<ul> 
 
<li>Per Section 3.1, our encoder does not add line breaks.</li> 
 
<li>Per Section 3.2, our encoder adds appropriate padding characters.</li> 
 
<li>Per Section 3.3, our decoder rejects data with non-alphabet 
characters.</li> 
 
<li>Per Section 3.5, our encoder sets the pad bits to zero.</li> 
 
<li>We use the Base64 alphabet described in Table 1.  We do not use the "URL 
and Filename safe" Base64 alphabet.</li> 
 
</ul> 
 
<p>We have not attempted to prove the "other" inversion property, i.e., if we 
start with some encoded text, decode it, and re-encode the result, then we 
should get back our initial, encoded text.  This is probably not currently 
true.  To prove it, we would need to change the decoder to reject inputs where 
the pad bits are nonzero.  Implementations "may" choose to implement this 
check according to Section 3.5, and in principle it would be a nice 
enhancement.</p> 
 

</body>
</html>
