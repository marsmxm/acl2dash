<html>
<head>
<meta charset="UTF-8">
<title>Atj-pre-translation-array-analysis</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=JAVA____ATJ-PRE-TRANSLATION-ARRAY-ANALYSIS">Click for Atj-pre-translation-array-analysis in the Full Manual</a></h3>

<p>Pre-translation step performed by ATJ: 
          single-threadedness analysis of Java primitive arrays.</p><p>In order to generate Java code 
     that correctly destructively updates (primitive) arrays, 
     we perform a <a href="ACL2____STOBJ.html">stobj</a>-like analysis 
     to establish that arrays are treated single-threadedly 
     in the ACL2 functions that are translated to Java.</p><p>Unlike the other pre-translation steps, 
     this analysis does not modify the ACL2 function bodies. 
     However, this analysis is best carried out 
     between the type annotation pre-translation step 
     and the variable reuse pre-translation step. 
     The reason why this analysis should be carried out 
     after the type annotation step 
     is that we need the type annotations to determine where the arrays are, 
     and subject them to the analysis. 
     The reason why this analysis should be carried before 
     the variable reuse step 
     is that this step may mark and differentiate array variables 
     that the analysis needs to ensure that they denote the same array 
     and that the array is treated single-threadedly.</p><p>This array analysis is similar to ACL2's stobj analysis 
     in the sense that it imposes the same draconian constraints 
     on the use of arrays, 
     namely that the same name is consistently used for each array, 
     that functions with array inputs are passed those names, 
     that every array possibly modified by a function 
     is bound to the same name and is also returned by the surrounding function, 
     and so on.</p><p>However, this array analysis also differs from the stobj analysis, 
     because stobjs are global variables 
     whose names must be consistently used by all the functions 
     that manipulate them. 
     In contrast, (representations of) Java arrays in ACL2 functions 
     do not have global names, but their names are local to the functions. 
     Consider a function <span class="v">f</span> that takes two arrays as inputs 
     and returns them (possibly modified) as outputs, 
     and a function <span class="v">g</span> that takes two array inputs <span class="v">a</span> and <span class="v">b</span> 
     and calls <span class="v">g</span> with them: 
     we need to know how the two array outputs of <span class="v">g</span> 
     correspond to the array inputs of <span class="v">g</span>, 
     so that we can check that <span class="v">f</span> properly binds 
     the possibly modified array <span class="v">a</span> to the variable <span class="v">a</span> 
     and the possibly modified array <span class="v">b</span> to the variable <span class="v">b</span>. 
     In ACL2's stobj analysis, <span class="v">g</span> will have the <span class="v">stobjs-out</span> property 
     that says which results are which stobjs, using their global names 
     (except the case in which <span class="v">g</span> is 
     the same as or mutually recursive with <span class="v">f</span>, 
     in which case ACL2 presumably uses the non-recursive branches of the clique 
     to determine the output stobjs of the functions). 
     In our array analysis, we need something like the <span class="v">stobjs-out</span> property: 
     we do that beforehand (i.e. before the array analysis) via 
     <span class="tt"><a href="JAVA____ATJ-MAIN-FUNCTION-TYPE.html">atj-main-function-type</a></span> and <span class="tt"><a href="JAVA____ATJ-OTHER-FUNCTION-TYPE.html">atj-other-function-type</a></span>, 
     which allow the specification of output array names. 
     But since array names are not global as pointed out above, 
     output array names in the ATJ function type tables alone do not suffice. 
     We need to take into account the ``mapping'' between input array names 
     (which are the formal parameters of a function) 
     and the output array names. 
     For the example <span class="v">f</span> above, 
     perhaps its two array formal arguments are <span class="v">x</span> and <span class="v">y</span>: 
     based on which output array has name <span class="v">x</span> vs. <span class="v">y</span>, 
     we can determine the mapping. 
     Thus, when we analyze <span class="v">g</span>, which passes <span class="v">a</span> and <span class="v">b</span> to <span class="v">f</span>, 
     we match <span class="v">a</span> and <span class="v">b</span> to <span class="v">x</span> and <span class="v">y</span>, 
     and we determine which results of <span class="v">f</span> 
     must be bound to <span class="v">a</span> and <span class="v">b</span> in <span class="v">g</span>. 
     Note that this approach works also if <span class="v">g</span> 
     is mutually recursive with or the same as <span class="v">f</span> 
     (in the latter case the variables <span class="v">a</span> and <span class="v">b</span> 
     would be the same as <span class="v">x</span> and <span class="v">y</span> then), 
     because all functions must have type and array name information 
     before the array analysis takes place. 
     If the type and array name information is incorrect/inconsistent, 
     the array analysis will reveal that.</p><p>Another complication of this array analysis, 
     which does not happen with stobjs, 
     is that some functions may create new arrays (directly or indirectly). 
     These are arrays not passed as inputs, but returned as outputs afresh. 
     As such, they do not correspond to any inputs, 
     so there is no name mapping. 
     This is why 
     <span class="tt"><a href="JAVA____ATJ-MAIN-FUNCTION-TYPE.html">atj-main-function-type</a></span> and <span class="tt"><a href="JAVA____ATJ-OTHER-FUNCTION-TYPE.html">atj-other-function-type</a></span> 
     allow unnamed array outputs, 
     whose meaning is that they must be newly created arrays; 
     the array analysis checks that. 
     If <span class="v">f</span> returns new arrays, 
     and <span class="v">g</span> calls <span class="v">f</span>, 
     then the array analysis must ensure that these new arrays 
     are bound to variables distinct from each other 
     and from the ones of the input arrays. 
     In contrast, stobjs are not really created by functions; 
     they are declared, essentially as global variables, 
     and created beforehand.</p>
</body>
</html>
