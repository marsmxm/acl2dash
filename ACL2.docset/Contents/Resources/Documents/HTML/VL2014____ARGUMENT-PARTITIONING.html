<html>
<head>
<meta charset="UTF-8">
<title>Argument-partitioning</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=VL2014____ARGUMENT-PARTITIONING">Click for Argument-partitioning in the Full Manual</a></h3>

<p>How arguments to instance arrays are split up and given to the 
individual instances.</p><p>Recall that in the <a href="VL2014____REPLICATE-INSTS.html">replicate-insts</a> transform we are 
basically rewriting instance arrays like this:</p> 
 
<pre class="code">type instname [N:0] (arg1, arg2, ..., argM) ;</pre> 
 
<p>Into things like this:</p> 
 
<pre class="code">type instname_0 (arg1-0, arg2-0, ..., argM-0);
type instname_1 (arg1-1, arg2-1, ..., argM-1);
...
type instname_N (arg1-N, arg2-N, ..., argM-N);</pre> 
 
<p>Let us consider a particular, non-blank argument, <span class="v">ArgI</span>, whose width is 
<span class="v">ArgI-W</span>.  Suppose this argument is connected to a non-blank port with width 
<span class="v">P-W</span>.</p> 
 
<p>Let's be clear on what we mean by <span class="v">P-W</span>.  If we are talking about module 
instances then this is quite straightforward: the module has a list of ports, 
and we can see how wide these ports are supposed to be by looking at the widths 
of their port expressions; see <a href="VL2014____VL-PORT-P.html">vl-port-p</a>.  The argument <span class="v">ArgI</span> 
corresponds to some particular port, and so the width of that port is what 
<span class="v">P-W</span> is going to be.  If we are talking about gates, then P-W is always 
1.</p> 
 
<p>According to the semantics laid forth in 7.1.6, there are only two valid 
cases.</p> 
 
<p><b>Case 1.</b> <span class="v">ArgI-W = P-W.</span> In this case, the argument is simply to be 
replicated, verbatim, across all of the new instances.</p> 
 
<p><b>Case 2.</b> <span class="v">ArgI-W = P-W * K</span>, where <span class="v">K</span> is the number of 
instances specified by this array.  That is, if our instance array declaration 
is:</p> 
 
<pre class="code">type instname [N:0] (arg1, arg2, ...);</pre> 
 
<p>then <span class="v">K</span> is <span class="v">N+1</span>.  In this case, we are going to slice up <span class="v">ArgI</span> 
into <span class="v">K</span> segments of <span class="v">P-W</span> bits each, and send them off to the instances. 
For example, in the code:</p> 
 
<pre class="code">wire w[3:0];
not g [3:0] (<a href="ACL2____W.html">w</a>, 4'b0011);</pre> 
 
<p>The <span class="v">ArgI-W</span> of both <span class="v">w</span> and <span class="v">4'b0011</span> is four, while the <span class="v">P-W</span> 
is 1.  In this case, we create four one-bit slices of <span class="v">w</span>, and four one-bit 
slices of <span class="v">4'b0011</span>, and connect them with four separate not-gates.</p> 
 
<p>When we are dealing with gates, <span class="v">P-W</span> is always 1.  But when we talk 
about modules, <span class="v">P-W</span> might be larger.  For example, consider the module:</p> 
 
<pre class="code">module two_bit_and (o, a, b) ;
   output [1:0] o;
   input [1:0] a;
   input [1:0] b;
   assign o = a &amp; b;
endmodule</pre> 
 
<p>And here we have an array of these two_bit_and modules:</p> 
 
<pre class="code">wire [7:0] j;
two_bit_and myarray [3:0] (j, 8'b 11_00_10_01, 2'b 01);</pre> 
 
<p>This array is equivalent to:</p> 
 
<pre class="code">two_bit_and myarray_0 (j[7:6], 2'b 11, 2'b 01) ;
two_bit_and myarray_1 (j[5:4], 2'b 00, 2'b 01) ;
two_bit_and myarray_2 (j[3:2], 2'b 10, 2'b 01) ;
two_bit_and myarray_3 (j[1:0], 2'b 01, 2'b 01) ;</pre> 
 
<p>And so the value of <span class="v">j</span> will be <span class="v">8'b 0100_0001</span>.</p> 
 
<p>That is, since all of the ports of two_bit_and are 2 bits, and we are 
creating four instances, each of the array arguments can only be 2 or 8 bits 
long.  Any 8-bit arguments are split into 2-bit slices, and any 2-bit arguments 
are replicated.</p>
</body>
</html>
