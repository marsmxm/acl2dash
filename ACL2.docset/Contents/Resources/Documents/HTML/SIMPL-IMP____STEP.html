<html>
<head>
<meta charset="UTF-8">
<title>Step</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=SIMPL-IMP____STEP">Click for Step in the Full Manual</a></h3>

<p>Semantics of Imp commands.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(step cfg) → new-cfg</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">cfg</span> — <font color="#606060">Guard <span class="v">(<a href="SIMPL-IMP____CONFIGP.html">configp</a> cfg)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">new-cfg</span> — <font color="#606060">Type <span class="v">(<a href="SIMPL-IMP____CONFIGP.html">configp</a> new-cfg)</span>.</font>
</dd> 
 
</dl></div> 
<p>According to the guard, this is defined 
     only if there are commands in the configuration, 
     i.e. there is something to do. 
     Otherwise, execution is in a terminated state.</p><p>A step consists in 
     taking the first command in the configuration 
     and executing it. 
     This may modify the environment, 
     and the list of the commands in the configuration.</p><p>An assignment is executed by evaluating the expression 
     and writing the obtained value into the variable. 
     The assignment command is removed from the configuration, 
     because it is completely executed.</p><p>A conditional is executed by evaluating the condition first. 
     Based on the obtained value, 
     the conditional is replaced by one of its branches. 
     This means that conditionals are non-strict in Imp: 
     the other branch is eliminated, not executed.</p><p>A loop is executed by evaluating the condition first. 
     If it is false, the loop command is removed from the configuration: 
     the loop is completely executed in this case. 
     If the condition is true instead, 
     the loop body is added in front of the command list in the configuration, 
     without removing the loop command itself: 
     since the loop condition is true, 
     we need to execute the body at least one more time, 
     and then we need to execute the loop as a whole again, 
     i.e. re-evaluate the condition (generally in a different environment).</p><p>This step function is executable.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>step</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
  step (cfg)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SIMPL-IMP____CONFIGP.html">configp</a> cfg)))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SIMPL-IMP____CONFIG-_E3COMMS.html">config-&gt;comms</a> cfg))))
  (<a href="ACL2____B_A2.html">b*</a> ((comms (<a href="SIMPL-IMP____CONFIG-_E3COMMS.html">config-&gt;comms</a> cfg))
       (<a href="SIMPL-IMP____ENV.html">env</a> (<a href="SIMPL-IMP____CONFIG-_E3ENV.html">config-&gt;env</a> cfg))
       ((unless (<a href="ACL2____MBT.html">mbt</a> (<a href="COMMON-LISP____CONSP.html">consp</a> comms)))
        (<a href="SIMPL-IMP____CONFIG-FIX.html">config-fix</a> cfg))
       (<a href="SIMPL-IMP____COMM.html">comm</a> (<a href="COMMON-LISP____CAR.html">car</a> comms)))
      (<a href="SIMPL-IMP____COMM-CASE.html">comm-case</a>
           comm
           :asg (<a href="ACL2____B_A2.html">b*</a> ((var comm.var)
                     (val (<a href="SIMPL-IMP____AEVAL.html">aeval</a> comm.exp env))
                     (new-env (<a href="SIMPL-IMP____WRITE-VAR.html">write-var</a> var val env))
                     (new-comms (<a href="COMMON-LISP____CDR.html">cdr</a> comms)))
                    (<a href="SIMPL-IMP____MAKE-CONFIG.html">make-config</a> :comms new-comms
                                 :env new-env))
           :if (<a href="ACL2____B_A2.html">b*</a> ((<a href="COMMON-LISP____COND.html">cond</a> (<a href="SIMPL-IMP____BEVAL.html">beval</a> comm.cond env))
                    (new-comms (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="COMMON-LISP____IF.html">if</a> cond comm.then comm.else)
                                       (<a href="COMMON-LISP____CDR.html">cdr</a> comms))))
                   (<a href="SIMPL-IMP____MAKE-CONFIG.html">make-config</a> :comms new-comms :env env))
           :while (<a href="ACL2____B_A2.html">b*</a> ((<a href="COMMON-LISP____COND.html">cond</a> (<a href="SIMPL-IMP____BEVAL.html">beval</a> comm.cond env))
                       (new-comms (<a href="COMMON-LISP____IF.html">if</a> cond (<a href="COMMON-LISP____APPEND.html">append</a> comm.body comms)
                                      (<a href="COMMON-LISP____CDR.html">cdr</a> comms))))
                      (<a href="SIMPL-IMP____MAKE-CONFIG.html">make-config</a> :comms new-comms
                                   :env env)))))</pre> 
<p><b>Theorem: </b>configp-of-step</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> configp-of-step
        (<a href="ACL2____B_A2.html">b*</a> ((new-cfg (<a href="SIMPL-IMP____STEP.html">step</a> cfg)))
            (<a href="SIMPL-IMP____CONFIGP.html">configp</a> new-cfg))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>step-of-config-fix-cfg</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> step-of-config-fix-cfg
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SIMPL-IMP____STEP.html">step</a> (<a href="SIMPL-IMP____CONFIG-FIX.html">config-fix</a> cfg))
               (<a href="SIMPL-IMP____STEP.html">step</a> cfg)))</pre> 
<p><b>Theorem: </b>step-config-equiv-congruence-on-cfg</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> step-config-equiv-congruence-on-cfg
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SIMPL-IMP____CONFIG-EQUIV.html">config-equiv</a> cfg cfg-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SIMPL-IMP____STEP.html">step</a> cfg) (<a href="SIMPL-IMP____STEP.html">step</a> cfg-equiv)))
        :rule-classes :congruence)</pre> 

</body>
</html>
