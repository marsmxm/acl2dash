<html>
<head>
<meta charset="UTF-8">
<title>Seq-equiv</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=AIGNET____SEQ-EQUIV">Click for Seq-equiv in the Full Manual</a></h3>

<p>Sequential equivalence of aignets</p><p>We consider two aignets to be sequentially equivalent if: 
<ul> 
<li>they have the same number of primary outputs</li> 
<li>corresponding outputs sequentially evaluate to the same value under the 
same series of primary input assignments and the all-0 initial register assignment. 
</li>
</ul> 
</p> 
 
<p>This is a weaker condition than combinational equivalence: combinational 
equivalence implies sequential equivalence, but not vice versa.</p> 
 
<p>This particular formulation of sequential equivalence assumes that 
evaluations of both networks start in the all-0 state.  Why?  Sequential 
equivalence should allow differences in the the state encoding of the two 
circuits, so we can't just universally quantify the initial register 
assignment.  We could take the initial register assignments as two additional 
inputs, but then this wouldn't truly be an equivalence relation.  We could 
existentially quantify over the initial register assignments, i.e. 
 
<blockquote> there exist initial states for aignets A and B such that for all 
input sequences, the outputs of A and B have the same values on each 
frame</blockquote> 
 
but this isn't really what we want either.  It might instead be something like: 
 
<blockquote> for each initial state of aignet A, there exists an initial state 
for aignet B such that for all input sequences, the outputs of A and B have the 
same values on each frame</blockquote> 
 
but this isn't even an equivalence relation!  Instead we're going to fix an 
initial state for each aignet, choosing the all-0 state as a simple 
convention.  One can fix an FSM with a different initial state to one 
with the all-0 initial state using <a href="AIGNET____AIGNET-COPY-INIT.html">aignet-copy-init</a>.</p> 
 
 
<h3>Definitions and Theorems</h3><p><b>Theorem: </b>seq-equiv-necc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  seq-equiv-necc
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="AIGNET____SEQ-EQUIV.html">seq-equiv</a> aignet aignet2)
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (output-eval-seq k n inframes nil aignet)
                         (output-eval-seq k n inframes nil aignet2))
                  t)))</pre> 
<p><b>Theorem: </b>seq-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> seq-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="AIGNET____SEQ-EQUIV.html">seq-equiv</a> x y))
             (<a href="AIGNET____SEQ-EQUIV.html">seq-equiv</a> x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="AIGNET____SEQ-EQUIV.html">seq-equiv</a> x y)
                      (<a href="AIGNET____SEQ-EQUIV.html">seq-equiv</a> y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="AIGNET____SEQ-EQUIV.html">seq-equiv</a> x y) (<a href="AIGNET____SEQ-EQUIV.html">seq-equiv</a> y z))
                      (<a href="AIGNET____SEQ-EQUIV.html">seq-equiv</a> x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>seq-equiv-implies-equal-output-eval-seq-5</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     seq-equiv-implies-equal-output-eval-seq-5
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="AIGNET____SEQ-EQUIV.html">seq-equiv</a> aignet aignet-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (output-eval-seq k n frames nil aignet)
                     (output-eval-seq k n frames nil aignet-equiv)))
     :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>comb-equiv-implies-same-frame-regvals</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 comb-equiv-implies-same-frame-regvals
 (<a href="ACL2____IMPLIES.html">implies</a>
      (<a href="COMMON-LISP____AND.html">and</a> (<a href="AIGNET____COMB-EQUIV.html">comb-equiv</a> aignet aignet2)
           (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="AIGNET____NUM-REGS.html">num-regs</a> aignet)
               (<a href="AIGNET____NUM-REGS.html">num-regs</a> aignet2)))
      (<a href="ACL2____BITS-EQUIV.html">bits-equiv</a> (frame-regvals k frames initsts aignet)
                  (<a href="ACL2____TAKE.html">take</a> (<a href="AIGNET____NUM-REGS.html">num-regs</a> aignet)
                        (frame-regvals k frames initsts aignet2)))))</pre> 
<p><b>Theorem: </b>comb-equiv-implies-seq-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> comb-equiv-implies-seq-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="AIGNET____COMB-EQUIV.html">comb-equiv</a> aignet aignet2)
                 (<a href="AIGNET____SEQ-EQUIV.html">seq-equiv</a> aignet aignet2)))</pre> 

</body>
</html>
