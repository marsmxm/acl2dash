<html>
<head>
<meta charset="UTF-8">
<title>Aig-and</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____AIG-AND">Click for Aig-and in the Full Manual</a></h3>

<p><span class="v">(<a href="ACL2____AIG-AND.html">aig-and</a> x1 x2 ...)</span> constructs an AIG representing <span class="v">(<a href="COMMON-LISP____AND.html">and</a> x1 x2
...)</span>.</p><p>The main function is <a href="ACL2____AIG-BINARY-AND.html">aig-binary-and</a>.  It implements 
something like the algorithm described in:</p> 
 
<ul> 
 
<li>Robert Brummayer and Armin Biere.  <a href="http://fmv.jku.at/papers/BrummayerBiere-MEMICS06.pdf" target="_blank"><nobr>Local Two-Level And 
Inverter Graph Minimization Without Blowup<img src="../Icon_External_Link.png" title="External link to http://fmv.jku.at/papers/BrummayerBiere-MEMICS06.pdf"></nobr></a>.  Mathematical and Engineering 
Methods in Computer Science (MEMICS).  2006.</li> 
 
</ul> 
 
<p>In particular, see Table 2 in that paper, which describes optimization rules 
that are ``locally size decreasing without affecting global sharing 
negatively.''</p> 
 
<p>We try to implement these rules in <a href="ACL2____AIG-AND-MAIN.html">aig-and-main</a>, which returns:</p> 
 
<pre class="code">(<a href="ACL2____MV.html">mv</a> status arg1 arg2)</pre> 
 
<p>The status is either:</p> 
 
<ul> 
<li>
<span class="v">:fail</span> if no rule applies, in which case <span class="v">arg1</span> and <span class="v">arg2</span> are 
just copies of <span class="v">x</span> and <span class="v">y</span> and we need to construct a new AND node that 
joins them together;</li> 
 
<li>
<span class="v">:subterm</span> if a rewrite rule applies that reduces the AND of <span class="v">x</span> and 
<span class="v">y</span> to either a constant or to a subterm of <span class="v">x</span> or <span class="v">y</span>.  This subterm 
is returned as both <span class="v">arg1</span> and <span class="v">arg2</span>.  In this case, we assume there is 
no more rewriting to be done and just return the reduced subterm.</li> 
 
<li>
<span class="v">:reduced</span> if a rewrite rule applies that reduces the AND in some 
interesting way, where it is no longer a proper subterm of <span class="v">x</span> or <span class="v">y</span>. 
In this case, it may be possible to further reduce <span class="v">arg1</span> and <span class="v">arg2</span>, 
so we want to recursively rewrite them.</li> 
 
</ul> 
 
<p><span class="v">aig-and</span> itself is a macro which extends <span class="v">aig-binary-and</span> across many 
arguments.  As one last special optimization, when there is more than one 
argument we try to "short-circuit" the computation and avoid evaluating some 
arguments.</p> 
 
<p>See also <a href="ACL2____AIG-AND-DUMB.html">aig-and-dumb</a>, which is much less sophisticated but may be 
easier to reason about in certain cases where you really care about the 
structure of the resulting AIGs.</p> 
 
<p>A June 2015 experiment suggests that, for a particular 80-bit floating point 
addition problem, this fancier algorithm improves the size of AIGs produced by 
<a href="ACL2____SV.html">sv</a> by about 3% when measured either by unique AND nodes or by unique 
conses.</p> 
 
<p><b>Macro: </b>aig-and</p><pre class="code">(<a href="COMMON-LISP____DEFMACRO.html">defmacro</a>
     aig-and (<a href="COMMON-LISP_____62REST.html">&amp;rest</a> args)
     (<a href="COMMON-LISP____CONS.html">cons</a> 'mbe
           (<a href="COMMON-LISP____CONS.html">cons</a> ':logic
                 (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="ACL2____AIG-AND-MACRO-LOGIC-PART.html">aig-and-macro-logic-part</a> args)
                       (<a href="COMMON-LISP____CONS.html">cons</a> ':exec
                             (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="ACL2____AIG-AND-MACRO-EXEC-PART.html">aig-and-macro-exec-part</a> args)
                                   'nil))))))</pre> 
 

</body>
</html>
