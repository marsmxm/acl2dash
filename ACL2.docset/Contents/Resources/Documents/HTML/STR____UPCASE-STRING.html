<html>
<head>
<meta charset="UTF-8">
<title>Upcase-string</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=STR____UPCASE-STRING">Click for Upcase-string in the Full Manual</a></h3>

<p>Convert a string to upper case.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(upcase-string x) â†’ *</pre></dt> 
</dl></div> 
<p><span class="tt">(upcase-string x)</span> converts a string to upper case, effectively 
by transforming each of its characters with <a href="STR____UPCASE-CHAR.html">upcase-char</a>.</p> 
 
<p>ACL2 has a built-in alternative to this function, <a href="COMMON-LISP____STRING-UPCASE.html">common-lisp::string-upcase</a>, but it is irritating to use because it has <a href="COMMON-LISP____STANDARD-CHAR-P.html">standard-char-p</a> guards.  In contrast, <span class="v">upcase-string</span> works on strings with 
arbitrary characters.</p> 
 
<p>We try to make this fast.  For better performance, we avoid consing and 
simply return <span class="v">x</span> unchanged when it has no characters that need to be 
converted.  Of course, deciding whether some conversion is necessary will 
marginally slow this function down when some conversion is necessary, but we 
think the gain of not consing outweighs this.  At any rate, this optimization 
does not affect the logical definition.</p> 
 
<p>Despite trying to make this fast, the builtin <span class="v">string-upcase</span> can really 
outperform us since it doesn't have to build the intermediate list, etc.  It's 
really a shame that <span class="v">string-upcase</span> has such a terrible guard.  Well, at 
least we're better when no work needs to be done:</p> 
 
<pre class="code">(time (loop for i fixnum from 1 to 1000000 do
        (<a href="STR____UPCASE-STRING.html">str::upcase-string</a> "Hello, World!")))  ;; 1.2 seconds, 336 MB
(time (loop for i fixnum from 1 to 1000000 do
        (string-upcase "Hello, World!")))       ;; .26 seconds, 64 MB

(time (loop for i fixnum from 1 to 1000000 do
        (<a href="STR____UPCASE-STRING.html">str::upcase-string</a> "HELLO, WORLD!")))  ;; .15 seconds, 0 MB
(time (loop for i fixnum from 1 to 1000000 do
        (string-upcase "HELLO, WORLD!")))       ;; .23 seconds, 64 MB</pre> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>upcase-string</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 upcase-string (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> string x))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'upcase-string))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____MBE.html">mbe</a>
     :logic (<a href="ACL2____IMPLODE.html">implode</a> (<a href="STR____UPCASE-CHARLIST.html">upcase-charlist</a> (<a href="ACL2____EXPLODE.html">explode</a> x)))
     :exec
     (<a href="COMMON-LISP____LET.html">let</a> ((xl (<a href="COMMON-LISP____LENGTH.html">length</a> x)))
          (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="STR____STRING-HAS-SOME-DOWN-ALPHA-P.html">string-has-some-down-alpha-p</a> x 0 xl))
              x
              (<a href="STR____RCHARS-TO-STRING.html">rchars-to-string</a> (<a href="STR____UPCASE-STRING-AUX.html">upcase-string-aux</a> x 0 xl nil)))))))</pre> 
<p><b>Theorem: </b>istreqv-implies-equal-upcase-string-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> istreqv-implies-equal-upcase-string-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="STR____ISTREQV.html">istreqv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="STR____UPCASE-STRING.html">upcase-string</a> x)
                        (<a href="STR____UPCASE-STRING.html">upcase-string</a> x-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>len-of-upcase-string</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> len-of-upcase-string
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> (<a href="ACL2____EXPLODE.html">explode</a> (<a href="STR____UPCASE-STRING.html">upcase-string</a> x)))
               (<a href="ACL2____LEN.html">len</a> (<a href="ACL2____EXPLODE.html">explode</a> x))))</pre> 
<p><b>Theorem: </b>length-of-upcase-string</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> length-of-upcase-string
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____LENGTH.html">length</a> (<a href="STR____UPCASE-STRING.html">upcase-string</a> x))
               (<a href="ACL2____LEN.html">len</a> (<a href="ACL2____EXPLODE.html">explode</a> x))))</pre> 
<p><b>Theorem: </b>equal-of-empty-string-with-upcase-string</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-empty-string-with-upcase-string
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> "" (<a href="STR____UPCASE-STRING.html">upcase-string</a> x))
               (<a href="COMMON-LISP____ATOM.html">atom</a> (<a href="ACL2____EXPLODE.html">explode</a> x))))</pre> 
<p><b>Theorem: </b>string-upcase-is-upcase-string</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> string-upcase-is-upcase-string
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____STRING-UPCASE.html">common-lisp::string-upcase</a> x)
               (<a href="STR____UPCASE-STRING.html">upcase-string</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> x))))</pre> 

</body>
</html>
