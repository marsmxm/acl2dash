<html>
<head>
<meta charset="UTF-8">
<title>Type-set</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____TYPE-SET">Click for Type-set in the Full Manual</a></h3>

<p>How type information is encoded in ACL2</p><p>To help you experiment with type-sets we briefly note the following 
 utility functions.</p> 
 
 <p><span class="v">(type-set-quote x)</span> will return the type-set of the object <span class="v">x</span>.  For 
 example, <span class="v">(type-set-quote "test")</span> is <span class="v">2048</span> and <span class="v">(type-set-quote
 '(a b c))</span> is <span class="v">512</span>.</p> 
 
 <p><span class="v">(<a href="ACL2____TYPE-SET.html">type-set</a> 'term nil nil nil (ens state) (<a href="ACL2____W.html">w</a> state) nil nil nil)</span> will 
 return the type-set of <span class="v">term</span> with respect to the current world and the 
 top-level enabled structure.  For example,</p> 
 
 <pre class="code">(<a href="ACL2____TYPE-SET.html">type-set</a> '(<a href="COMMON-LISP____INTEGERP.html">integerp</a> x) nil nil nil (ens state) (<a href="ACL2____W.html">w</a> state) nil nil nil)</pre> 
 
 <p>will return (mv 192 nil).  192, otherwise known as <span class="v">*ts-boolean*</span>, is 
 the type-set containing <span class="v">t</span> and <span class="v">nil</span>.  The second result may be ignored 
 in these experiments.  <span class="v">Term</span> must be in the <span class="v">translated</span>, internal form 
 shown by <span class="v">:</span><span class="tt"><a href="ACL2____TRANS.html">trans</a></span>.  See <a href="ACL2____TRANS.html">trans</a> and see <a href="ACL2____TERM.html">term</a>.</p> 
 
 <p><span class="v">(type-set-implied-by-term 'x nil 'term (ens state)(<a href="ACL2____W.html">w</a> state) nil)</span> will 
 return the type-set deduced for the variable symbol <span class="v">x</span> assuming the 
 <span class="v">translated</span> term, <span class="v">term</span>, true.  The second result may be ignored in 
 these experiments.  For example,</p> 
 
 <pre class="code">(type-set-implied-by-term 'v nil '(<a href="COMMON-LISP____INTEGERP.html">integerp</a> v)
                          (ens state) (<a href="ACL2____W.html">w</a> state) nil)</pre> 
 
 <p>returns <span class="v">11</span>.</p> 
 
 <p><span class="v">(convert-type-set-to-term 'x ts (ens state) (<a href="ACL2____W.html">w</a> state) nil)</span> will return 
 a term whose truth is equivalent to the assertion that the term <span class="v">x</span> has 
 type-set <span class="v">ts</span>.  The second result may be ignored in these experiments.  For 
 example</p> 
 
 <pre class="code">(convert-type-set-to-term 'v 523 (ens state) (<a href="ACL2____W.html">w</a> state) nil)</pre> 
 
 <p>returns a term expressing the claim that <span class="v">v</span> is either an integer or a 
 non-<span class="v">nil</span> true-list.  <span class="v">523</span> is the <span class="v">logical-or</span> of <span class="v">11</span> (which 
 denotes the integers) with <span class="v">512</span> (which denotes the non-<span class="v">nil</span> 
 true-lists).</p> 
 
 <p>The ``actual primitive types'' of ACL2 are listed in 
 <span class="v">*actual-primitive-types*</span>, whose elements are shown below.  Each actual 
 primitive type denotes a set — sometimes finite and sometimes not 
 — of ACL2 objects and these sets are pairwise disjoint.  For example, 
 <span class="v">*ts-zero*</span> denotes the set containing 0 while <span class="v">*ts-negative-integer*</span> 
 denotes the set containing all of the negative integers.</p> 
 
 <pre class="code">*TS-ZERO*                  ;;; {0}
*TS-ONE*                   ;;; {1}
*TS-INTEGER&gt;1*             ;;; integers greater than 1
*TS-POSITIVE-RATIO*        ;;; positive non-integer rationals
*TS-NEGATIVE-INTEGER*      ;;; negative integers
*TS-NEGATIVE-RATIO*        ;;; negative non-integer rationals
*TS-COMPLEX-RATIONAL*      ;;; complex rationals
*TS-NIL*                   ;;; {nil}
*TS-T*                     ;;; {t}
*TS-NON-T-NON-NIL-SYMBOL*  ;;; symbols other than nil, t
*TS-PROPER-CONS*           ;;; nil-terminated non-empty lists
*TS-IMPROPER-CONS*         ;;; conses that are not proper
*TS-STRING*                ;;; strings
*TS-CHARACTER*             ;;; characters</pre> 
 
 <p>The actual primitive types were chosen by us to make theorem proving 
 convenient.  Thus, for example, the actual primitive type <span class="v">*ts-nil*</span> 
 contains just <span class="v">nil</span> so that we can encode the hypothesis ``<span class="v">x</span> is 
 <span class="v">nil</span>'' by saying ``<span class="v">x</span> has type <span class="v">*ts-nil*</span>'' and the hypothesis 
 ``<span class="v">x</span> is non-<span class="v">nil</span>'' by saying ``<span class="v">x</span> has type complement of 
 <span class="v">*ts-nil*</span>.''  We similarly devote a primitive type to <span class="v">t</span>, <span class="v">*ts-t*</span>, 
 and to a third type, <span class="v">*ts-non-t-non-nil-symbol*</span>, to contain all the other 
 ACL2 symbols.</p> 
 
 <p>Let <span class="v">*ts-other*</span> denote the set of all Common Lisp objects other than 
 those in the actual primitive types.  Thus, <span class="v">*ts-other*</span> includes such 
 things as floating point numbers and CLTL array objects.  The actual primitive 
 types together with <span class="v">*ts-other*</span> constitute what we call <span class="v">*universe*</span>. 
 Note that <span class="v">*universe*</span> is a finite set containing one more object than 
 there are actual primitive types; that is, here we are using <span class="v">*universe*</span> 
 to mean the finite set of primitive types, not the infinite set of all objects 
 in all of those primitive types.  <span class="v">*Universe*</span> is a partitioning of the set 
 of all Common Lisp objects: every object belongs to exactly one of the sets in 
 <span class="v">*universe*</span>.</p> 
 
 <p>Abstractly, a ``type-set'' is a subset of <span class="v">*universe*</span>.  To say that a 
 term, <span class="v">x</span>, ``has type-set <span class="v">ts</span>'' means that under all possible 
 assignments to the variables in <span class="v">x</span>, the value of <span class="v">x</span> is a member of 
 some member of <span class="v">ts</span>.  Thus, <span class="v">(<a href="COMMON-LISP____CONS.html">cons</a> x y)</span> has type-set 
 <span class="v">{*ts-proper-cons* *ts-improper-cons*}</span>.  A term can have more than one 
 type-set.  For example, <span class="v">(<a href="COMMON-LISP____CONS.html">cons</a> x y)</span> also has the type-set 
 <span class="v">{*ts-proper-cons* *ts-improper-cons* *ts-nil*}</span>.  Extraneous types can be 
 added to a type-set without invalidating the claim that a term ``has'' that 
 type-set.  Generally we are interested in the smallest type-set a term has, 
 but because the entire theorem-proving problem for ACL2 can be encoded as a 
 type-set question, namely, ``Does <span class="v">p</span> have type-set complement of 
 <span class="v">*ts-nil*</span>?,'' finding the smallest type-set for a term is an undecidable 
 problem.  When we speak informally of ``the'' type-set we generally mean ``the 
 type-set found by our heuristics'' or ``the type-set assumed in the current 
 context.''</p> 
 
 <p>Note that if a type-set, <span class="v">ts</span>, does not contain <span class="v">*ts-other*</span> as an 
 element then it is just a subset of the actual primitive types.  If it does 
 contain <span class="v">*ts-other*</span> it can be obtained by subtracting from <span class="v">*universe*</span> 
 the complement of <span class="v">ts</span>.  Thus, every type-set can be written as a (possibly 
 complemented) subset of the actual primitive types.</p> 
 
 <p>By assigning a unique bit position to each actual primitive type we can 
 encode every subset, <span class="v">s</span>, of the actual primitive types by the nonnegative 
 integer whose ith bit is on precisely if <span class="v">s</span> contains the ith actual 
 primitive type.  The type-sets written as the complement of <span class="v">s</span> are encoded 
 as the two's-complement bitwise <span class="v">`not'</span> of the encoding of <span class="v">s</span>.  Those 
 type-sets are thus negative integers.  The bit positions assigned to the 
 actual primitive types are enumerated from <span class="v">0</span> in the same order as the 
 types are listed in <span class="v">*actual-primitive-types*</span>.  At the concrete level, a 
 type-set is an integer between <span class="v">*min-type-set*</span> and <span class="v">*max-type-set*</span>, 
 inclusive.</p> 
 
 <p>For example, <span class="v">*ts-nil*</span> has bit position <span class="v">7</span>.  The type-set 
 containing just <span class="v">*ts-nil*</span> is thus represented by <span class="v">128</span>.  If a term has 
 type-set <span class="v">128</span> then the term is always equal to <span class="v">nil</span>.  The type-set 
 containing everything but <span class="v">*ts-nil*</span> is the bitwise <span class="v">`not'</span> of <span class="v">128</span>, 
 which is <span class="v">-129</span>.  If a term has type-set <span class="v">-129</span>, it is never equal to 
 <span class="v">nil</span>.  By ``always'' and ``never'' we mean under all, or under no, 
 assignments to the variables, respectively.</p> 
 
 <p>Here is a more complicated example.  Let <span class="v">s</span> be the type-set containing 
 all of the symbols and the natural numbers.  The relevant actual primitive 
 types, their bit positions and their encodings are:</p> 
 
 <pre class="code">actual primitive type       bit    value

*ts-zero*                    0       1
*ts-one*                     1       2
*ts-integer&gt;1*               2       4
*ts-nil*                     7     128
*ts-t*                       8     256
*ts-non-t-non-nil-symbol*    9     512</pre> 
 
 <p>Thus, the type-set <span class="v">s</span> is represented by <span class="v">(<a href="COMMON-LISP_____B2.html">+</a> 1 2 4 128 256 512)</span> = 
 <span class="v">903</span>.  The complement of <span class="v">s</span>, i.e., the set of all objects other than 
 the natural numbers and the symbols, is <span class="v">-904</span>.  We can get ACL2 to provide 
 such information as follows.</p> 
 
 <pre class="code">ACL2 !&gt;(decode-type-set 903)
(TS-UNION *TS-SYMBOL* *TS-NON-NEGATIVE-INTEGER*)
ACL2 !&gt;(decode-type-set -904)
(TS-COMPLEMENT (TS-UNION *TS-SYMBOL* *TS-NON-NEGATIVE-INTEGER*))
ACL2 !&gt;</pre>
</body>
</html>
