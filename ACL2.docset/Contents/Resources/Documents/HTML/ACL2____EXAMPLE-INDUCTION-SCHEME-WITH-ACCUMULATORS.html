<html>
<head>
<meta charset="UTF-8">
<title>Example-induction-scheme-with-accumulators</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____EXAMPLE-INDUCTION-SCHEME-WITH-ACCUMULATORS">Click for Example-induction-scheme-with-accumulators in the Full Manual</a></h3>

<p>Induction scheme with accumulators</p><p>See <a href="ACL2____LOGIC-KNOWLEDGE-TAKEN-FOR-GRANTED-INDUCTIVE-PROOF.html">logic-knowledge-taken-for-granted-inductive-proof</a> for an 
 explanation of what we mean by the induction <i>suggested</i> by a recursive 
 function or a term.</p> 
 
 <p>To prove <span class="v">(p x a)</span> for all <span class="v">x</span> and all <span class="v">a</span>, prove each of the 
 following:</p> 
 
 <pre class="code"><i>Base Case</i>: 
(implies (endp x) 
         (p x a)) 
</pre> 
 
 <pre class="code"><i>Induction Step</i>: 
(implies (and (not (endp x)) 
              (p (cdr x) (cons (car x) a))) 
         (p x a)) 
</pre> 
 
 <p>Note that in the induction hypothesis we assume <span class="v">p</span> for a smaller <span class="v">x</span> 
 but a larger <span class="v">a</span>.  In fact, we could include as many induction hypotheses 
 as we want and use any terms we want in the <span class="v">a</span> position as long as the 
 <span class="v">x</span> position is occupied by a smaller term.</p> 
 
 <p>A function that suggests this particular induction is shown below.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> rev1 (x a)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ENDP.html">endp</a> x)
      a
      (rev1 (<a href="COMMON-LISP____CDR.html">cdr</a> x) (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> x) a)))).</pre> 
 
 <p>A function that suggests a similar induction in which three induction 
 hypotheses are provided, one in which the <span class="v">a</span> position is occupied by 
 <span class="v">(<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> x) a)</span>, another in which the <span class="v">a</span> position is occupied by 
 some arbitrary term <span class="v">b</span>, and a third in which the <span class="v">a</span> position is 
 occupied by <span class="v">a</span>, is suggested by the term <span class="v">(rev1-modified x a b)</span> 
 where</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> rev1-modified (x a b)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ENDP.html">endp</a> x)
      (<a href="COMMON-LISP____LIST.html">list</a> x a b)
      (<a href="COMMON-LISP____LIST.html">list</a> (rev1-modified (<a href="COMMON-LISP____CDR.html">cdr</a> x) (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> x) a) b)
            (rev1-modified (<a href="COMMON-LISP____CDR.html">cdr</a> x) b b)
            (rev1-modified (<a href="COMMON-LISP____CDR.html">cdr</a> x) a b))))</pre> 
 
 <p>Remember that the value of this term or function is irrelevant to the 
 induction suggested.  Because ACL2's definitional principle insists that all 
 the formal parameters play a role in the computation (at least syntactically), 
 it is common practice when defining functions for their induction schemes to 
 return the <span class="v">list</span> of all the formals (to ensure all variables are involved) 
 and to combine recursive calls on a given branch with <span class="v">list</span> (to avoid 
 introducing additional case analysis as would happen if <span class="v">and</span> or <span class="v">or</span> or 
 other propositional functions are used).</p> 
 
 <p>If you tried to prove <span class="v">(p x a)</span> and suggested the induct hint 
 <span class="v">(rev1-modified x a (fact k))</span>, as by</p> 
 
 <pre class="code">(<a href="ACL2____THM.html">thm</a> (p x a)
     :hints (("Goal" :induct (rev1-modified x a (fact k)))))</pre> 
 
 <p>the inductive argument would be:</p> 
 
 <pre class="code"><i>Base Case</i>: 
(implies (endp x) 
         (p x a)) 
</pre> 
 
 <pre class="code"><i>Inductive Step</i>: 
(implies (and (not (endp x)) 
              (p (cdr x) (cons (car x) a)) 
              (p (cdr x) (fact k)) 
              (p (cdr x) a)) 
         (p x a)) 
</pre>
</body>
</html>
