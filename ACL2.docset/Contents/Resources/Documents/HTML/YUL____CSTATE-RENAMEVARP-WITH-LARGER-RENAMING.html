<html>
<head>
<meta charset="UTF-8">
<title>Cstate-renamevarp-with-larger-renaming</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=YUL____CSTATE-RENAMEVARP-WITH-LARGER-RENAMING">Click for Cstate-renamevarp-with-larger-renaming in the Full Manual</a></h3>

<p>Theorems about computation states and variable renamings, 
          not involving dynamic semantic operations.</p><p>If two computation states are related by variable renaming, 
     they are also related by a larger variable renaming. 
     This is proved by first proving a similar theorem for local states.</p><p>The motivation for this theorem is that, 
     when a list of statements (in a block) is executed, 
     execution may not reach the end of the statemnts. 
     However, statically, when we consider that list of statements, 
     we extend the variable renaming 
     according to the whole list of statements. 
     Since we want to show that execution preserves 
     the variable renaming relation between computation states, 
     we need to able to relate the final states 
     with the final variable renamings, 
     which may be larger due to execution ending before the end. 
     So this theorem enables us to bridge this gap.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Theorem: </b>lstate-match-renamevarp-of-larger</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     lstate-match-renamevarp-of-larger
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="YUL____LSTATEP.html">lstatep</a> old-lstate)
                   (<a href="YUL____LSTATEP.html">lstatep</a> new-lstate)
                   (<a href="YUL____LSTATE-RENAMEVARP.html">lstate-renamevarp</a> old-lstate new-lstate ren)
                   (<a href="ACL2____SUBSETP-EQUAL.html">subsetp-equal</a> (<a href="YUL____RENAMING-_E3LIST.html">renaming-&gt;list</a> ren)
                                  (<a href="YUL____RENAMING-_E3LIST.html">renaming-&gt;list</a> ren1)))
              (<a href="YUL____LSTATE-MATCH-RENAMEVARP.html">lstate-match-renamevarp</a> old-lstate new-lstate ren1)))</pre> 
<p><b>Theorem: </b>lstate-renamevarp-of-larger</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lstate-renamevarp-of-larger
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="YUL____LSTATEP.html">lstatep</a> old-lstate)
                      (<a href="YUL____LSTATEP.html">lstatep</a> new-lstate)
                      (<a href="YUL____LSTATE-RENAMEVARP.html">lstate-renamevarp</a> old-lstate new-lstate ren)
                      (<a href="ACL2____SUBSETP-EQUAL.html">subsetp-equal</a> (<a href="YUL____RENAMING-_E3LIST.html">renaming-&gt;list</a> ren)
                                     (<a href="YUL____RENAMING-_E3LIST.html">renaming-&gt;list</a> ren1)))
                 (<a href="YUL____LSTATE-RENAMEVARP.html">lstate-renamevarp</a> old-lstate new-lstate ren1)))</pre> 
<p><b>Theorem: </b>cstate-renamevarp-of-larger</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> cstate-renamevarp-of-larger
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="YUL____CSTATE-RENAMEVARP.html">cstate-renamevarp</a> old-cstate new-cstate ren)
                      (<a href="ACL2____SUBSETP-EQUAL.html">subsetp-equal</a> (<a href="YUL____RENAMING-_E3LIST.html">renaming-&gt;list</a> ren)
                                     (<a href="YUL____RENAMING-_E3LIST.html">renaming-&gt;list</a> ren1)))
                 (<a href="YUL____CSTATE-RENAMEVARP.html">cstate-renamevarp</a> old-cstate new-cstate ren1)))</pre> 

</body>
</html>
