<html>
<head>
<meta charset="UTF-8">
<title>Subtypep</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=SYNTHETO____SUBTYPEP">Click for Subtypep in the Full Manual</a></h3>

<p>Check if a type is a subtype of another type.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(subtypep sub sup tops) → yes/no</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">sub</span> — <font color="#606060">Guard <span class="v">(<a href="SYNTHETO____TYPEP.html">typep</a> sub)</span>.</font>
</dd> 
  <dd>
<span class="tt">sup</span> — <font color="#606060">Guard <span class="v">(<a href="SYNTHETO____TYPEP.html">typep</a> sup)</span>.</font>
</dd> 
  <dd>
<span class="tt">tops</span> — <font color="#606060">Guard <span class="v">(<a href="SYNTHETO____TOPLEVEL-LISTP.html">toplevel-listp</a> tops)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">yes/no</span> — <font color="#606060">Type <span class="v">(<a href="ACL2____BOOLEANP.html">booleanp</a> yes/no)</span>.</font>
</dd> 
 
</dl></div> 
<p>The subtype definitions in a list of Syntheto top-level constructs 
     induce a subtype relation over types. 
     In Syntheto, subtype means true inclusion of values, 
     not an embedding as in other languages; 
     thus, certain values belong to multiple types, 
     e.g. the integer 4 belongs to the type of integers, 
     but also to a possible subtype of natural numbers, 
     and to a possible subtype of even numbers.</p><p>A primitive, collection, or options type 
     is only (reflexively) a subtype of itself. 
     Currently Syntheto's subtypes do not lift 
     from element types to collection types. 
     A defined type is only a subtype of itself 
     if it is a sum or product type; 
     otherwise, it is a subtype not only of itself, 
     but also of its direct supertype 
     (i.e. the one referenced in its subtype definition), 
     and of all the direct supertype's supertypes.</p><p>Thus, to check whether <span class="v">sub</span> is a subtype of <span class="v">sup</span>, 
     we first check if they are the same type. 
     Otherwise, the subtype relation cannot hold 
     unless <span class="v">sub</span> has a direct supertype. 
     If the latter is the same as <span class="v">sup</span>, the subtype relation holds. 
     Otherwise, we recursively check whether 
     the direct supertype is a subtype of <span class="v">sup</span>.</p><p>In well-formed Syntheto there are no subtype circularities 
     and so the recursion terminates. 
     However, this ACL2 function has 
     no assumption of well-formedness. 
     The latter notion needs the notion of maximal supertype to be expressed: 
     it may be possible to set up a large mutual recursion 
     to define all these concepts, 
     but that may increase the complexity of the static semantics. 
     Thus, we prefer to totalize this function here 
     to work on non-well-formed lists of Syntheto top-level constructs. 
     We extract the list of all defined type names 
     from the list of top-level constructs, 
     and use that list to look up the type definitions, 
     removing each used up definition from the list. 
     This way, circularities are detected when attempting to look up 
     the same definition twice, which will not be in the list the second time; 
     we return <span class="v">nil</span> (i.e. no subtype relation) if we detect a circularity. 
     The length of the list is the measure for termination.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>subtypep-aux</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 subtypep-aux
 (sub sup defined-names tops)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SYNTHETO____TYPEP.html">typep</a> sub)
                             (<a href="SYNTHETO____TYPEP.html">typep</a> sup)
                             (<a href="SYNTHETO____IDENTIFIER-LISTP.html">identifier-listp</a> defined-names)
                             (<a href="SYNTHETO____TOPLEVEL-LISTP.html">toplevel-listp</a> tops))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((__function__ 'subtypep-aux))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
  (<a href="ACL2____B_A2.html">b*</a>
   ((defined-names (<a href="SYNTHETO____IDENTIFIER-LIST-FIX.html">identifier-list-fix</a> defined-names)))
   (<a href="COMMON-LISP____OR.html">or</a>
    (<a href="SYNTHETO____TYPE-EQUIV.html">type-equiv</a> sub sup)
    (<a href="ACL2____B_A2.html">b*</a>
     ((direct (<a href="SYNTHETO____DIRECT-SUPERTYPE.html">direct-supertype</a> sub tops)))
     (<a href="COMMON-LISP____AND.html">and</a>
       direct
       (<a href="ACL2____B_A2.html">b*</a> ((name (<a href="SYNTHETO____TYPE-DEFINED-_E3NAME.html">type-defined-&gt;name</a> sub)))
           (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> name defined-names)
                (subtypep-aux direct
                              sup (<a href="ACL2____REMOVE1-EQUAL.html">remove1-equal</a> name defined-names)
                              tops)))))))))</pre> 
<p><b>Theorem: </b>booleanp-of-subtypep-aux</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> booleanp-of-subtypep-aux
        (<a href="ACL2____B_A2.html">b*</a> ((yes/no (subtypep-aux sub sup defined-names tops)))
            (<a href="ACL2____BOOLEANP.html">booleanp</a> yes/no))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>subtypep-aux-of-type-fix-sub</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> subtypep-aux-of-type-fix-sub
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (subtypep-aux (<a href="SYNTHETO____TYPE-FIX.html">type-fix</a> sub)
                             sup defined-names tops)
               (subtypep-aux sub sup defined-names tops)))</pre> 
<p><b>Theorem: </b>subtypep-aux-type-equiv-congruence-on-sub</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   subtypep-aux-type-equiv-congruence-on-sub
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SYNTHETO____TYPE-EQUIV.html">type-equiv</a> sub sub-equiv)
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (subtypep-aux sub sup defined-names tops)
                   (subtypep-aux sub-equiv sup defined-names tops)))
   :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>subtypep-aux-of-type-fix-sup</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> subtypep-aux-of-type-fix-sup
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (subtypep-aux sub (<a href="SYNTHETO____TYPE-FIX.html">type-fix</a> sup)
                             defined-names tops)
               (subtypep-aux sub sup defined-names tops)))</pre> 
<p><b>Theorem: </b>subtypep-aux-type-equiv-congruence-on-sup</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   subtypep-aux-type-equiv-congruence-on-sup
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SYNTHETO____TYPE-EQUIV.html">type-equiv</a> sup sup-equiv)
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (subtypep-aux sub sup defined-names tops)
                   (subtypep-aux sub sup-equiv defined-names tops)))
   :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>subtypep-aux-of-identifier-list-fix-defined-names</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> subtypep-aux-of-identifier-list-fix-defined-names
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (subtypep-aux sub
                             sup (<a href="SYNTHETO____IDENTIFIER-LIST-FIX.html">identifier-list-fix</a> defined-names)
                             tops)
               (subtypep-aux sub sup defined-names tops)))</pre> 
<p><b>Theorem: </b>subtypep-aux-identifier-list-equiv-congruence-on-defined-names</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  subtypep-aux-identifier-list-equiv-congruence-on-defined-names
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SYNTHETO____IDENTIFIER-LIST-EQUIV.html">identifier-list-equiv</a> defined-names defined-names-equiv)
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (subtypep-aux sub sup defined-names tops)
                  (subtypep-aux sub sup defined-names-equiv tops)))
  :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>subtypep-aux-of-toplevel-list-fix-tops</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> subtypep-aux-of-toplevel-list-fix-tops
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (subtypep-aux sub sup
                             defined-names (<a href="SYNTHETO____TOPLEVEL-LIST-FIX.html">toplevel-list-fix</a> tops))
               (subtypep-aux sub sup defined-names tops)))</pre> 
<p><b>Theorem: </b>subtypep-aux-toplevel-list-equiv-congruence-on-tops</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   subtypep-aux-toplevel-list-equiv-congruence-on-tops
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SYNTHETO____TOPLEVEL-LIST-EQUIV.html">toplevel-list-equiv</a> tops tops-equiv)
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (subtypep-aux sub sup defined-names tops)
                   (subtypep-aux sub sup defined-names tops-equiv)))
   :rule-classes :congruence)</pre> 
<p><b>Function: </b>subtypep</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> subtypep (sub sup tops)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SYNTHETO____TYPEP.html">typep</a> sub)
                                   (<a href="SYNTHETO____TYPEP.html">typep</a> sup)
                                   (<a href="SYNTHETO____TOPLEVEL-LISTP.html">toplevel-listp</a> tops))))
       (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'subtypep))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
            (subtypep-aux sub sup (<a href="SYNTHETO____GET-DEFINED-TYPE-NAMES.html">get-defined-type-names</a> tops)
                          tops)))</pre> 
<p><b>Theorem: </b>booleanp-of-subtypep</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> booleanp-of-subtypep
        (<a href="ACL2____B_A2.html">b*</a> ((yes/no (<a href="SYNTHETO____SUBTYPEP.html">subtypep</a> sub sup tops)))
            (<a href="ACL2____BOOLEANP.html">booleanp</a> yes/no))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>subtypep-of-type-fix-sub</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> subtypep-of-type-fix-sub
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBTYPEP.html">subtypep</a> (<a href="SYNTHETO____TYPE-FIX.html">type-fix</a> sub) sup tops)
               (<a href="SYNTHETO____SUBTYPEP.html">subtypep</a> sub sup tops)))</pre> 
<p><b>Theorem: </b>subtypep-type-equiv-congruence-on-sub</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> subtypep-type-equiv-congruence-on-sub
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SYNTHETO____TYPE-EQUIV.html">type-equiv</a> sub sub-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBTYPEP.html">subtypep</a> sub sup tops)
                        (<a href="SYNTHETO____SUBTYPEP.html">subtypep</a> sub-equiv sup tops)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>subtypep-of-type-fix-sup</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> subtypep-of-type-fix-sup
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBTYPEP.html">subtypep</a> sub (<a href="SYNTHETO____TYPE-FIX.html">type-fix</a> sup) tops)
               (<a href="SYNTHETO____SUBTYPEP.html">subtypep</a> sub sup tops)))</pre> 
<p><b>Theorem: </b>subtypep-type-equiv-congruence-on-sup</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> subtypep-type-equiv-congruence-on-sup
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SYNTHETO____TYPE-EQUIV.html">type-equiv</a> sup sup-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBTYPEP.html">subtypep</a> sub sup tops)
                        (<a href="SYNTHETO____SUBTYPEP.html">subtypep</a> sub sup-equiv tops)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>subtypep-of-toplevel-list-fix-tops</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> subtypep-of-toplevel-list-fix-tops
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBTYPEP.html">subtypep</a> sub sup (<a href="SYNTHETO____TOPLEVEL-LIST-FIX.html">toplevel-list-fix</a> tops))
               (<a href="SYNTHETO____SUBTYPEP.html">subtypep</a> sub sup tops)))</pre> 
<p><b>Theorem: </b>subtypep-toplevel-list-equiv-congruence-on-tops</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> subtypep-toplevel-list-equiv-congruence-on-tops
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SYNTHETO____TOPLEVEL-LIST-EQUIV.html">toplevel-list-equiv</a> tops tops-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBTYPEP.html">subtypep</a> sub sup tops)
                        (<a href="SYNTHETO____SUBTYPEP.html">subtypep</a> sub sup tops-equiv)))
        :rule-classes :congruence)</pre> 

</body>
</html>
