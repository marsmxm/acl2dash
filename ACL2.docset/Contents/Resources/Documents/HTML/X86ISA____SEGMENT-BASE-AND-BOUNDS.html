<html>
<head>
<meta charset="UTF-8">
<title>Segment-base-and-bounds</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=X86ISA____SEGMENT-BASE-AND-BOUNDS">Click for Segment-base-and-bounds in the Full Manual</a></h3>

<p>Return a segment's base linear address, lower bound, and upper bound.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(segment-base-and-bounds proc-mode seg-reg x86) 
  → 
(mv base lower-bound upper-bound)</pre></dt>
<dt>Returns</dt>
<dd>
<span class="tt">base</span> — <font color="#606060">Type <span class="v">(<a href="X86ISA____N64P.html">n64p</a> base)</span>, given <span class="v">(x86p x86)</span>.</font>
</dd> 
<dd>
<span class="tt">lower-bound</span> — <font color="#606060">Type <span class="v">(<a href="X86ISA____N33P.html">n33p</a> lower-bound)</span>.</font>
</dd> 
<dd>
<span class="tt">upper-bound</span> — <font color="#606060">Type <span class="v">(<a href="X86ISA____N32P.html">n32p</a> upper-bound)</span>.</font>
</dd> 
 
</dl></div> 
<p> 
   The segment is the one in the given segment register. 
   </p> 
   <p> 
   Base addresses coming from segment descriptors are always 32 bits: 
   see Intel manual, Mar'17, Vol. 3A, Sec. 3.4.5 
   and AMD manual, Apr'16, Vol. 2, Sec. 4.7 and 4.8. 
   However, in 64-bit mode, segment bases for FS and GS are 64 bits: 
   see Intel manual, Mar'17, Vol. 3A, Sec. 3.4.4 
   and AMD manual, Apr'16, Vol. 2, Sec 4.5.3. 
   As an optimization, in 64-bit mode, 
   since segment bases for CS, DS, SS, and ES are ignored, 
   this function just returns 0 as the base result under these conditions. 
   In 64-bit mode, when the segment register is FS or GS, 
   we read the base address from the MSRs 
   mentioned in Intel manual, Mar'17, Vol. 3A, Sec. 3.4.4 
   and AMD manual, Apr'16, Vol. 2, Sec 4.5.3; 
   these are physically mapped to the relevant hidden portions of FS and GS, 
   so it should be a state invariant that they are equal to 
   the relevant hidden portions of FS and GS. 
   In 32-bit mode, since the high 32 bits are ignored 
   (see Intel manual, Mar'17, Vol. 3A, Sec. 3.4.4 
   and AMD manual, Apr'16, Vol. 2, Sec 4.5.3), 
   we only return the low 32 bits of the base address 
   read from the hidden portion of the segment register. 
   </p> 
   <p> 
   <span class="v">*hidden-segment-register-layout*</span> uses 32 bits 
   for the segment limit, 
   which is consistent with the 20 bits in segment descriptors 
   when the G (granularity) bit is 1: 
   see Intel manual, Mar'17, Vol. 3A, Sec. 3.4.5 
   and AMD manual, Apr'16, Vol. 2, Sec. 4-7 and 4-8. 
   Thus, the limit is an unsigned 32-bit integer. 
   </p> 
   <p> 
   The lower bound is 0 for code segments, i.e. for the CS register. 
   For data (including stack) segments, 
   i.e. for the SS, DS, ES, FS, and GS registers, 
   the lower bound depends on the E bit: 
   if E is 0, the lower bound is 0; 
   if E is 1, the segment is an expand-down data segment 
   and the lower bound is one plus the segment limit. 
   See Intel manual, Mar'17, Vol. 3A, Sec. 3.4.5 
   and AMD manual, Apr'16, Vol. 2, Sec. 4.7 and 4-8. 
   Since the limit is an unsigned 32-bit (see above), 
   adding 1 may produce an unsigned 33-bit result. 
   Even though this should not actually happen with well-formed segments, 
   this function returns an unsigned 33-bit integer as the lower bound result. 
   As an optimization, in 64-bit mode, 
   since segment limits and bounds are ignored, 
   this function returns 0 as the lower bound; 
   the caller must ignore this result in 64-bit mode. 
   </p> 
   <p> 
   The upper bound is the segment limit for code segments, 
   i.e. for the CS register. 
   For data (including stack) segments, 
   i.e. for the SS, DS, ES, FS, and GS registers, 
   the upper bound depends on the E and D/B bits: 
   if E is 0, the upper bound is the segment limit; 
   if E is 1, the segment is an expand-down data segment 
   and the upper bound is 2^32-1 if D/B is 1, 2^16-1 if D/B is 0. 
   See Intel manual, Mar'17, Vol. 3A, Sec. 3.4.5 
   and AMD manual, Apr'16, Vol. 2, Sec. 4.7 and 4-8. 
   Since  the limit is an unsigned 32-bit (see above), 
   this function returns an unsigned 32-bit integer as the upper bound result. 
   As an optimization, in 64-bit mode, 
   since segment limits and bounds are ignored, 
   this function returns 0 as the upper bound; 
   the caller must ignore this result in 64-bit mode. 
   </p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>segment-base-and-bounds$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 segment-base-and-bounds$inline
 (proc-mode seg-reg x86)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (x86)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (integer 0 4) proc-mode)
          (<a href="COMMON-LISP____TYPE.html">type</a> (integer 0 5) seg-reg))
 (<a href="COMMON-LISP____CASE.html">case</a>
  proc-mode
  (0 (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____EQL.html">eql</a> seg-reg 4) (<a href="ACL2____MV.html">mv</a> (msri 1 x86) 0 0))
           ((<a href="COMMON-LISP____EQL.html">eql</a> seg-reg 5) (<a href="ACL2____MV.html">mv</a> (msri 2 x86) 0 0))
           (t (<a href="ACL2____MV.html">mv</a> 0 0 0))))
  (1
   (<a href="ACL2____MBE.html">mbe</a>
    :logic
    (<a href="ACL2____B_A2.html">b*</a>
      ((base (<a href="ACL2____LOGHEAD.html">loghead</a> 64 (seg-hidden-basei seg-reg x86)))
       (limit (<a href="ACL2____LOGHEAD.html">loghead</a> 32 (seg-hidden-limiti seg-reg x86)))
       (attr (<a href="ACL2____LOGHEAD.html">loghead</a> 16 (seg-hidden-attri seg-reg x86)))
       (d/b (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____D3.html">=</a> seg-reg 1)
                (<a href="X86ISA____CODE-SEGMENT-DESCRIPTOR-ATTRIBUTESBITS-_E3D.html">code-segment-descriptor-attributesbits-&gt;d</a> attr)
                (<a href="X86ISA____DATA-SEGMENT-DESCRIPTOR-ATTRIBUTESBITS-_E3D_F2B.html">data-segment-descriptor-attributesbits-&gt;d/b</a> attr)))
       (e (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____D3.html">=</a> seg-reg 1)
              0
              (<a href="X86ISA____DATA-SEGMENT-DESCRIPTOR-ATTRIBUTESBITS-_E3E.html">data-segment-descriptor-attributesbits-&gt;e</a> attr)))
       (lower (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____D3.html">=</a> e 1) (<a href="COMMON-LISP____1_B2.html">1+</a> limit) 0))
       (upper (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____D3.html">=</a> e 1)
                  (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____D3.html">=</a> d/b 1) 4294967295 65535)
                  limit)))
      (<a href="ACL2____MV.html">mv</a> (<a href="X86ISA____N32.html">n32</a> base) lower upper))
    :exec
    (<a href="ACL2____B_A2.html">b*</a>
      (((<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 64) base)
        (seg-hidden-basei seg-reg x86))
       ((<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 32) base)
        (<a href="BITSETS____BIGNUM-EXTRACT.html">bitsets::bignum-extract</a> base 0))
       ((<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 32) limit)
        (seg-hidden-limiti seg-reg x86))
       ((<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 16) attr)
        (seg-hidden-attri seg-reg x86))
       (d/b (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____D3.html">=</a> seg-reg 1)
                (<a href="X86ISA____CODE-SEGMENT-DESCRIPTOR-ATTRIBUTESBITS-_E3D.html">code-segment-descriptor-attributesbits-&gt;d</a> attr)
                (<a href="X86ISA____DATA-SEGMENT-DESCRIPTOR-ATTRIBUTESBITS-_E3D_F2B.html">data-segment-descriptor-attributesbits-&gt;d/b</a> attr)))
       (e (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____D3.html">=</a> seg-reg 1)
              0
              (<a href="X86ISA____DATA-SEGMENT-DESCRIPTOR-ATTRIBUTESBITS-_E3E.html">data-segment-descriptor-attributesbits-&gt;e</a> attr)))
       (lower (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____D3.html">=</a> e 1) (<a href="COMMON-LISP____1_B2.html">1+</a> limit) 0))
       (upper (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____D3.html">=</a> e 1)
                  (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____D3.html">=</a> d/b 1) 4294967295 65535)
                  limit)))
      (<a href="ACL2____MV.html">mv</a> base lower upper))))
  (otherwise (<a href="ACL2____MV.html">mv</a> 0 0 0))))</pre> 
<p><b>Theorem: </b>n64p-of-segment-base-and-bounds.base</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 n64p-of-segment-base-and-bounds.base
 (<a href="ACL2____IMPLIES.html">implies</a>
      (x86p x86)
      (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?base ?lower-bound ?upper-bound)
            (segment-base-and-bounds$inline proc-mode seg-reg x86)))
          (<a href="X86ISA____N64P.html">n64p</a> base)))
 :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>n33p-of-segment-base-and-bounds.lower-bound</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     n33p-of-segment-base-and-bounds.lower-bound
     (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?base ?lower-bound ?upper-bound)
           (segment-base-and-bounds$inline proc-mode seg-reg x86)))
         (<a href="X86ISA____N33P.html">n33p</a> lower-bound))
     :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>n32p-of-segment-base-and-bounds.upper-bound</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     n32p-of-segment-base-and-bounds.upper-bound
     (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?base ?lower-bound ?upper-bound)
           (segment-base-and-bounds$inline proc-mode seg-reg x86)))
         (<a href="X86ISA____N32P.html">n32p</a> upper-bound))
     :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>segment-base-is-n64p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 segment-base-is-n64p
 (<a href="ACL2____IMPLIES.html">implies</a>
     (x86p x86)
     (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a>
          64
          (<a href="ACL2____MV-NTH.html">mv-nth</a> 0
                  (<a href="X86ISA____SEGMENT-BASE-AND-BOUNDS.html">segment-base-and-bounds</a> proc-mode seg-reg x86))))
 :rule-classes
 (:rewrite
  (:type-prescription
   :corollary
   (<a href="ACL2____IMPLIES.html">implies</a>
    (x86p x86)
    (<a href="ACL2____NATP.html">natp</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> 0
                  (<a href="X86ISA____SEGMENT-BASE-AND-BOUNDS.html">segment-base-and-bounds</a> proc-mode seg-reg x86))))
   :hints
   (("Goal" :in-theory '(<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> integer-range-p natp))))
  (:linear
   :corollary
   (<a href="ACL2____IMPLIES.html">implies</a>
    (x86p x86)
    (<a href="COMMON-LISP____AND.html">and</a>
       (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 0
           (<a href="ACL2____MV-NTH.html">mv-nth</a> 0
                   (<a href="X86ISA____SEGMENT-BASE-AND-BOUNDS.html">segment-base-and-bounds</a> proc-mode seg-reg x86)))
       (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> 0
                  (<a href="X86ISA____SEGMENT-BASE-AND-BOUNDS.html">segment-base-and-bounds</a> proc-mode seg-reg x86))
          18446744073709551616)))
   :hints
   (("Goal"
        :in-theory '(<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> integer-range-p (:e expt)))))))</pre> 
<p><b>Theorem: </b>segment-lower-bound-is-n33p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 segment-lower-bound-is-n33p
 (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a>
      33
      (<a href="ACL2____MV-NTH.html">mv-nth</a> 1
              (<a href="X86ISA____SEGMENT-BASE-AND-BOUNDS.html">segment-base-and-bounds</a> proc-mode seg-reg x86)))
 :rule-classes
 (:rewrite
  (:type-prescription
     :corollary
     (<a href="ACL2____NATP.html">natp</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> 1
                   (<a href="X86ISA____SEGMENT-BASE-AND-BOUNDS.html">segment-base-and-bounds</a> proc-mode seg-reg x86)))
     :hints
     (("Goal" :in-theory '(<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> integer-range-p natp))))
  (:linear
   :corollary
   (<a href="COMMON-LISP____AND.html">and</a>
       (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 0
           (<a href="ACL2____MV-NTH.html">mv-nth</a> 1
                   (<a href="X86ISA____SEGMENT-BASE-AND-BOUNDS.html">segment-base-and-bounds</a> proc-mode seg-reg x86)))
       (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> 1
                  (<a href="X86ISA____SEGMENT-BASE-AND-BOUNDS.html">segment-base-and-bounds</a> proc-mode seg-reg x86))
          8589934592))
   :hints
   (("Goal"
        :in-theory '(<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> integer-range-p (:e expt)))))))</pre> 
<p><b>Theorem: </b>segment-upper-bound-is-n32p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 segment-upper-bound-is-n32p
 (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a>
      32
      (<a href="ACL2____MV-NTH.html">mv-nth</a> 2
              (<a href="X86ISA____SEGMENT-BASE-AND-BOUNDS.html">segment-base-and-bounds</a> proc-mode seg-reg x86)))
 :rule-classes
 (:rewrite
  (:type-prescription
     :corollary
     (<a href="ACL2____NATP.html">natp</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> 2
                   (<a href="X86ISA____SEGMENT-BASE-AND-BOUNDS.html">segment-base-and-bounds</a> proc-mode seg-reg x86)))
     :hints
     (("Goal" :in-theory '(<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> integer-range-p natp))))
  (:linear
   :corollary
   (<a href="COMMON-LISP____AND.html">and</a>
       (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 0
           (<a href="ACL2____MV-NTH.html">mv-nth</a> 2
                   (<a href="X86ISA____SEGMENT-BASE-AND-BOUNDS.html">segment-base-and-bounds</a> proc-mode seg-reg x86)))
       (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> 2
                  (<a href="X86ISA____SEGMENT-BASE-AND-BOUNDS.html">segment-base-and-bounds</a> proc-mode seg-reg x86))
          4294967296))
   :hints
   (("Goal"
        :in-theory '(<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> integer-range-p (:e expt)))))))</pre> 
<p><b>Theorem: </b>segment-base-and-bound-of-xw</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 segment-base-and-bound-of-xw
 (<a href="ACL2____IMPLIES.html">implies</a>
   (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> fld :msr))
        (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> fld :seg-hidden-base))
        (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> fld :seg-hidden-limit))
        (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> fld :seg-hidden-attr)))
   (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="X86ISA____SEGMENT-BASE-AND-BOUNDS.html">segment-base-and-bounds</a> proc-mode
                                   seg-reg (xw fld index value x86))
          (<a href="X86ISA____SEGMENT-BASE-AND-BOUNDS.html">segment-base-and-bounds</a> proc-mode seg-reg x86))))</pre> 

</body>
</html>
