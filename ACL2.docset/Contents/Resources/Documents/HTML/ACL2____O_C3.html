<html>
<head>
<meta charset="UTF-8">
<title>O&lt;</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____O_C3">Click for O&lt; in the Full Manual</a></h3>

<p>The well-founded less-than relation on ordinals up to <span class="v">epsilon-0</span></p><p>If <span class="v">x</span> and <span class="v">y</span> are both <span class="v">o-p</span>s (see <a href="ACL2____O-P.html">o-p</a>) then 
 <span class="v">(<a href="ACL2____O_C3.html">o&lt;</a> x y)</span> is true iff <span class="v">x</span> is strictly less than <span class="v">y</span>.  <span class="v">o&lt;</span> is 
 well-founded on the <span class="tt"><a href="ACL2____O-P.html">o-p</a></span>s.  When <span class="v">x</span> and <span class="v">y</span> are both nonnegative 
 integers, <span class="v">o&lt;</span> is just the familiar ``less than'' relation (<span class="tt"><a href="COMMON-LISP_____C3.html">&lt;</a></span>).</p> 
 
 <p><span class="v">o&lt;</span> plays a key role in the formal underpinnings of the ACL2 logic.  In 
 order for a recursive definition to be admissible it must be proved to 
 ``terminate.''  By terminate we mean that the arguments to the function ``get 
 smaller'' as the function recurs and this sense of size comparison must be 
 such that there is no ``infinitely descending'' sequence of ever smaller 
 arguments.  That is, the relation used to compare successive arguments must be 
 well-founded on the domain being measured.</p> 
 
 <p>The most basic way ACL2 provides to prove termination requires the user to 
 supply (perhaps implicitly) a mapping of the argument tuples into the ordinals 
 with some ``measure'' expression in such a way that the measures of the 
 successive argument tuples produced by recursion decrease according to the 
 relation <span class="v">o&lt;</span>.  The validity of this method rests on the well-foundedness 
 of <span class="v">o&lt;</span> on the <span class="tt"><a href="ACL2____O-P.html">o-p</a></span>s.</p> 
 
 <p>Without loss of generality, suppose the definition in question introduces 
 the function <span class="v">f</span>, with one formal parameter <span class="v">x</span> (which might be a list 
 of objects).  Then we require that there exist a measure expression, <span class="v">(m
 x)</span>, that always produces an <span class="tt"><a href="ACL2____O-P.html">o-p</a></span>.  Furthermore, consider any 
 recursive call, <span class="v">(f (d x))</span>, in the body of the definition.  Let <span class="v">hyps</span> 
 be the conjunction of terms, each of which is either the test of an <span class="tt"><a href="COMMON-LISP____IF.html">if</a></span> 
 in the body or else the negation of such a test, describing the path through 
 the body to the recursive call in question.  Then it must be a theorem 
 that</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">IMPLIES</a> hyps (<a href="ACL2____O_C3.html">O&lt;</a> (m (d x)) (m x))).</pre> 
 
 <p>When we say <span class="v">o&lt;</span> is ``well-founded'' on the <span class="tt"><a href="ACL2____O-P.html">o-p</a></span>s we mean that 
 there is no infinite sequence of <span class="tt"><a href="ACL2____O-P.html">o-p</a></span>s such that each is smaller than 
 its predecessor in the sequence.  Thus, the theorems that must be proved about 
 <span class="v">f</span> when it is introduced establish that it cannot recur forever because 
 each time a recursive call is taken <span class="v">(m x)</span> gets smaller.  From this, and 
 the syntactic restrictions on definitions, it can be shown (as on page 44 in 
 ``A Computational Logic'', Boyer and Moore, Academic Press, 1979) that there 
 exists a function satisfying the definition; intuitively, the value assigned 
 to any given <span class="v">x</span> by the alleged function is that computed by a sufficiently 
 large machine.  Hence, the logic is consistent if the axiom defining <span class="v">f</span> is 
 added.</p> 
 
 <p>See <a href="ACL2____O-P.html">o-p</a> for a discussion of the ordinals and how to compare two 
 ordinals.</p> 
 
 <p>The definitional principle permits the use of relations other than <span class="v">o&lt;</span> 
 but they must first be proved to be well-founded on some domain.  See <a href="ACL2____WELL-FOUNDED-RELATION-RULE.html">well-founded-relation-rule</a>.  Roughly put, alternative relations are shown 
 well-founded by providing an order-preserving mapping from their domain into 
 the ordinals.  See <a href="COMMON-LISP____DEFUN.html">defun</a> for details on how to specify which 
 well-founded relation is to be used.</p> 
 
 <p><b>Function: </b>o&lt;</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> o&lt; (x y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (o&lt;g x) (o&lt;g y))))
       (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="ACL2____O-FINP.html">o-finp</a> x) (<a href="COMMON-LISP____OR.html">or</a> (<a href="ACL2____O-INFP.html">o-infp</a> y) (<a href="COMMON-LISP_____C3.html">&lt;</a> x y)))
             ((<a href="ACL2____O-FINP.html">o-finp</a> y) nil)
             ((<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____O-FIRST-EXPT.html">o-first-expt</a> x)
                          (<a href="ACL2____O-FIRST-EXPT.html">o-first-expt</a> y)))
              (<a href="ACL2____O_C3.html">o&lt;</a> (<a href="ACL2____O-FIRST-EXPT.html">o-first-expt</a> x) (<a href="ACL2____O-FIRST-EXPT.html">o-first-expt</a> y)))
             ((<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP_____D3.html">=</a> (<a href="ACL2____O-FIRST-COEFF.html">o-first-coeff</a> x) (<a href="ACL2____O-FIRST-COEFF.html">o-first-coeff</a> y)))
              (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____O-FIRST-COEFF.html">o-first-coeff</a> x) (<a href="ACL2____O-FIRST-COEFF.html">o-first-coeff</a> y)))
             (t (<a href="ACL2____O_C3.html">o&lt;</a> (<a href="ACL2____O-RST.html">o-rst</a> x) (<a href="ACL2____O-RST.html">o-rst</a> y)))))</pre>
</body>
</html>
