<html>
<head>
<meta charset="UTF-8">
<title>Defalist</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=FTY____DEFALIST">Click for Defalist in the Full Manual</a></h3>

<p>Define an alist type with a fixing function, supported by <a href="FTY____DEFTYPES.html">deftypes</a>.</p><p><span class="v">Defalist</span> provides a recognizer predicate, fixing function, and 
a few theorems defining an alist with keys of some type mapping to values of some type.</p> 
 
<p><span class="v">Defalist</span> is compatible with <a href="FTY____DEFTYPES.html">deftypes</a>, and can be 
mutually-recursive with other <span class="v">deftypes</span> compatible type generators.  As 
with all <a href="FTY____DEFTYPES.html">deftypes</a>-compatible type generators, its key and value types 
must either be one produced by a compatible type generator or else have an 
associated fixing function given by <a href="FTY____DEFFIXTYPE.html">deffixtype</a>.  (They may also be 
untyped.)  See <a href="FTY____BASETYPES.html">basetypes</a> for some base types with fixing 
functions.</p> 
 
<p>The syntax of defalist is:</p> 
<pre class="code">(<a href="FTY____DEFALIST.html">defalist</a> fooalist
  :key-type symbol
  :val-type foo
  :parents (...)     ;; xdoc
  :short "..."       ;; xdoc
  :long "..."        ;; xdoc
  :measure (<a href="COMMON-LISP_____B2.html">+</a> 1 (<a href="COMMON-LISP_____A2.html">*</a> 2 (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> x)))
                     ;; default: (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> x)
  :xvar x            ;; default: x, or find x symbol in measure
  :prepwork          ;; admit these events before starting
  :pred fooalistp     ;; default: fooalist-p
  :fix fooalistfix    ;; default: fooalist-fix
  :equiv fooalist-=   ;; default: fooalist-equiv
  :count fooalistcnt  ;; default: fooalist-count
                     ;; (may be nil; skipped unless mutually recursive)
  :no-count t        ;; default: nil, same as :count nil
  :true-listp t      ;; default: nil, require nil final cdr
  :strategy :drop-keys ;; default: :fix-keys
)</pre> 
 
<p>The keyword arguments are all optional, although it doesn't make much sense 
to define an alist with neither a key-type nor value-type.</p> 
 
<p>The <span class="v">:strategy</span> keyword changes the way the fixing function works; by 
default, every pair in the alist is kept but its key and value are fixed.  With 
<span class="v">:strategy :drop-keys</span>, pairs with malformed keys are dropped, but malformed 
values are still fixed. <a href="FTY____DEFMAP.html">Defmap</a> is an abbreviation for <span class="v">defalist</span> with 
<span class="v">:strategy :drop-keys</span>.</p> 
 
<p>As part of the event, deflist calls <a href="STD____DEFLIST.html">std::deflist</a> to produce several 
useful theorems about the introduced predicate.</p> 
 
<p>Defalist (by itself, not when part of mutually-recursive deftypes form) also 
allows previously defined alist predicates.  For example, the following form 
produces a fixing function for ACL2's built-in <span class="v">timer-alistp</span> predicate:</p> 
 
<pre class="code">(<a href="FTY____DEFALIST.html">defalist</a> timer-alist :pred timer-alistp
                      :key-type symbolp
                      :val-type rational-listp)</pre> 
 
<p>Similarly to <span class="tt"><a href="FTY____DEFLIST.html">deflist</a></span>, the theorems generated by <span class="v">defalist</span> depend 
on the currently included books, and calling <span class="v">defalist</span> again with the same 
argument after including more books may generate additional theorem.  See 
<span class="tt"><a href="FTY____DEFLIST.html">deflist</a></span> for more details.</p>
</body>
</html>
