<html>
<head>
<meta charset="UTF-8">
<title>Evaluation</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____EVALUATION">Click for Evaluation in the Full Manual</a></h3>

<p>Evaluating ACL2 expressions</p><p>This topic uses examples to expose how ACL2 uses Common Lisp to 
 evaluate expressions.  Links are provided to topics that elaborate on 
 aspects of evaluation in ACL2.</p> 
 
 <p>At a high level, we can say that ACL2 evaluation takes place using the 
 underlying host Common Lisp.  But consider the form <span class="v">(<a href="COMMON-LISP____CAR.html">car</a> 3)</span>.  In Common 
 Lisp this is an error; typically you will be thrown into the Lisp debugger. 
 In the ACL2 read-eval-print loop, however, you may see the following.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="COMMON-LISP____CAR.html">car</a> 3)


ACL2 Error in TOP-LEVEL:  The guard for the function call (<a href="COMMON-LISP____CAR.html">CAR</a> X),
which is (<a href="COMMON-LISP____OR.html">OR</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> X) (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> X NIL)), is violated by the arguments
in the call (<a href="COMMON-LISP____CAR.html">CAR</a> 3).
See :DOC set-guard-checking for information about suppressing this
check with (<a href="ACL2____SET-GUARD-CHECKING.html">set-guard-checking</a> :none), as recommended for new users.
To debug see :DOC print-gv, see :DOC trace, and see :DOC wet.

ACL2 !&gt;</pre> 
 
 <p>The message suggests that the function <span class="v">car</span> has a <a href="ACL2____GUARD.html">guard</a>, or 
 precondition, that is violated by the proposed argument, <span class="v">3</span>.  So clearly 
 something more is going on here than just evaluation of the form <span class="v">(<a href="COMMON-LISP____CAR.html">car</a> 3)</span> 
 in Common Lisp.</p> 
 
 <p>In fact, every ACL2 function symbol is associated with the following two 
 Common Lisp definitions, as explained below:</p> 
 
 <ul> 
 
 <li>the ``executable-counterpart'' definition, sometimes called the ``*1*'' 
 function (pronounced ``star one star''); and</li> 
 
 <li>the ``submitted'' definition (sometimes called the ``raw Lisp'' 
 function).</li> 
 
 </ul> 
 
 <p>We may also speak of the ``executable-counterpart'' and ``submitted'' 
 functions, which are the two functions defined by the 
 ``executable-counterpart'' and ``submitted'' definitions, respectively.</p> 
 
 <p>Let us explore these two functions in the case of <span class="v">car</span>.  When <span class="v">(<a href="COMMON-LISP____CAR.html">car</a>
 3)</span> is evaluated in the ACL2 loop, the executable-counterpart of <span class="v">car</span> is 
 applied to the argument <span class="v">3</span>.  That executable-counterpart (which was 
 hand-coded) first checks the guard of <span class="v">car</span>, which fails for <span class="v">3</span>, 
 leading to the error displayed above.  If instead the form to be evaluated by 
 ACL2 is <span class="v">(<a href="COMMON-LISP____CAR.html">car</a> '(4 5 6))</span>, the executable-counterpart of <span class="v">car</span> will first 
 check that the guard of <span class="v">car</span> holds for the list argument <span class="v">(4 5 6)</span>; 
 then seeing that this is the case, it will apply the Common Lisp function 
 <span class="v">car</span> — which we consider to be the ``submitted'' function for 
 <span class="v">car</span> — to that list argument, returning <span class="v">4</span>.</p> 
 
 <p>The example above does not really explain why the submitted function is 
 called ``submitted'', so let us consider the more common case of a defined 
 function, as opposed to a <a href="ACL2____PRIMITIVE.html">primitive</a> like <span class="v">car</span>.  Suppose we define 
 the following functions <span class="v">f</span> and <span class="v">g</span>, each of which has an implicit <a href="ACL2____GUARD.html">guard</a> (precondition) of <span class="v">t</span>, i.e., the precondition always holds.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> f (x)
  (<a href="COMMON-LISP____CAR.html">car</a> x))
(<a href="COMMON-LISP____DEFUN.html">defun</a> g (x)
  (f x))</pre> 
 
 <p>ACL2 defines two functions named <span class="v">"F"</span>: the executable-counterpart of 
 <span class="v">f</span>, sometimes called ``<span class="v">*1*f</span>'', and the submitted function for <span class="v">f</span>. 
 It also defines two such functions for <span class="v">g</span>.  The executable-counterpart is 
 generated by ACL2 to include not only code to check guards, but also code to 
 invoke the executable-counterparts of its callees.  (Such invocation can be 
 avoided by a process known as verifying guards, as we explain further below.) 
 We can see what is going on by tracing calls of <span class="v">f</span> (see <a href="COMMON-LISP____TRACE.html">trace</a> for 
 more about tracing); some analysis follows below this display.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="ACL2____TRACE_42.html">trace$</a> f g)
 ((F) (<a href="ACL2____G.html">G</a>))
ACL2 !&gt;(<a href="ACL2____G.html">g</a> '(4 5 6))
1&gt; (ACL2_*1*_ACL2::G (4 5 6))
  2&gt; (ACL2_*1*_ACL2::F (4 5 6))
  &lt;2 (ACL2_*1*_ACL2::F 4)
&lt;1 (ACL2_*1*_ACL2::G 4)
4
ACL2 !&gt;</pre> 
 
 <p>It is now perhaps evident why sometimes we call the executable-counterpart 
 functions the ``*1* functions'': the executable-counterpart is actually 
 defined in a special ``*1*'' package that corresponds to the package of the 
 submitted function.  The trace above shows that the executable-counterpart of 
 <span class="v">g</span> calls the executable-counterpart of <span class="v">f</span>, rather than calling any 
 submitted function.</p> 
 
 <p>Such a trace can show us an error caused by applying <span class="v">car</span> to 
 <span class="v">3</span>.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="ACL2____G.html">g</a> 3)
1&gt; (ACL2_*1*_ACL2::G 3)
  2&gt; (ACL2_*1*_ACL2::F 3)


ACL2 Error in TOP-LEVEL:  The guard for the function call (<a href="COMMON-LISP____CAR.html">CAR</a> X),
which is (<a href="COMMON-LISP____OR.html">OR</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> X) (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> X NIL)), is violated by the arguments
in the call (<a href="COMMON-LISP____CAR.html">CAR</a> 3).
See :DOC set-guard-checking for information about suppressing this
check with (<a href="ACL2____SET-GUARD-CHECKING.html">set-guard-checking</a> :none), as recommended for new users.
To debug see :DOC print-gv, see :DOC trace, and see :DOC wet.

ACL2 !&gt;</pre> 
 
 <p>It is generally more efficient to invoke a submitted functions — 
 which has as its Common Lisp definition exactly the <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> form 
 submitted to ACL2 — than it is to invoke an executable-counterpart, 
 which is generated by ACL2 to do auxiliary calculations including 
 guard-checking.  So we next modify the example above to show that by 
 performing a process called ``guard verification'', we can avoid *1* function 
 calls, so that submitted functions are invoked instead.  This time we supply 
 reasonable guards for <span class="v">f</span> and <span class="v">g</span>, in a fresh ACL2 session.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> f (x)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x) (<a href="COMMON-LISP____NULL.html">null</a> x))))
  (<a href="COMMON-LISP____CAR.html">car</a> x))
(<a href="COMMON-LISP____DEFUN.html">defun</a> g (x)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____CONSP.html">consp</a> x)))
  (f x))</pre> 
 
 <p>This time, we see that the executable-counterpart of <span class="v">g</span> directly calls 
 the submitted function for <span class="v">g</span>, because <span class="v">g</span> was guard-verified when 
 <span class="v">g</span> was admitted and the value <span class="v">'(4 5 6)</span> for the formal <span class="v">x</span> of 
 <span class="v">g</span> satisfies the guard <span class="v">(<a href="COMMON-LISP____CONSP.html">consp</a> x)</span> of <span class="v">g</span>.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="ACL2____TRACE_42.html">trace$</a> f g)
 ((F) (<a href="ACL2____G.html">G</a>))
ACL2 !&gt;(<a href="ACL2____G.html">g</a> '(4 5 6))
1&gt; (ACL2_*1*_ACL2::G (4 5 6))
  2&gt; (<a href="ACL2____G.html">G</a> (4 5 6))
    3&gt; (F (4 5 6))
    &lt;3 (F 4)
  &lt;2 (<a href="ACL2____G.html">G</a> 4)
&lt;1 (ACL2_*1*_ACL2::G 4)
4
ACL2 !&gt;</pre> 
 
 <p>We can also see that because <span class="v">3</span> fails to satisfy the guard of <span class="v">g</span>, a 
 guard violation is signaled by the executable-counterpart of <span class="v">g</span>, rather 
 than (as before) by the executable-counterpart of <span class="v">car</span>.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="ACL2____G.html">g</a> 3)
1&gt; (ACL2_*1*_ACL2::G 3)


ACL2 Error in TOP-LEVEL:  The guard for the function call (<a href="ACL2____G.html">G</a> X), which
is (<a href="COMMON-LISP____CONSP.html">CONSP</a> X), is violated by the arguments in the call (<a href="ACL2____G.html">G</a> 3).
See :DOC set-guard-checking for information about suppressing this
check with (<a href="ACL2____SET-GUARD-CHECKING.html">set-guard-checking</a> :none), as recommended for new users.
To debug see :DOC print-gv, see :DOC trace, and see :DOC wet.

ACL2 !&gt;</pre> 
 
 <p>See if you can predict the corresponding traces if instead, <span class="v">f</span> has a 
 suitable guard and is guard-verified, but <span class="v">g</span> is as in the first 
 example (with an implicit guard of <span class="v">t</span>, and not guard-verified):</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> f (x)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x) (<a href="COMMON-LISP____NULL.html">null</a> x))))
  (<a href="COMMON-LISP____CAR.html">car</a> x))
(<a href="COMMON-LISP____DEFUN.html">defun</a> g (x)
  (f x))</pre> 
 
 <p>The corresponding trace is as follows; discussion follows.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="ACL2____G.html">g</a> '(4 5 6))
1&gt; (ACL2_*1*_ACL2::G (4 5 6))
  2&gt; (ACL2_*1*_ACL2::F (4 5 6))
    3&gt; (F (4 5 6))
    &lt;3 (F 4)
  &lt;2 (ACL2_*1*_ACL2::F 4)
&lt;1 (ACL2_*1*_ACL2::G 4)
4
ACL2 !&gt;(<a href="ACL2____G.html">g</a> 3)
1&gt; (ACL2_*1*_ACL2::G 3)
  2&gt; (ACL2_*1*_ACL2::F 3)


ACL2 Error in TOP-LEVEL:  The guard for the function call (F X), which
is (<a href="COMMON-LISP____OR.html">OR</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> X) (<a href="COMMON-LISP____NULL.html">NULL</a> X)), is violated by the arguments in the call
(F 3).
See :DOC set-guard-checking for information about suppressing this
check with (<a href="ACL2____SET-GUARD-CHECKING.html">set-guard-checking</a> :none), as recommended for new users.
To debug see :DOC print-gv, see :DOC trace, and see :DOC wet.

ACL2 !&gt;</pre> 
 
 <p>The traces above show that first, the executable-counterpart of <span class="v">g</span> 
 calls the executable-counterpart of <span class="v">f</span>.  This is because <span class="v">g</span> is not 
 guard-verified, so its executable-counterpart can only invoke other 
 executable-counterparts.  However, since <span class="v">f</span> is guard-verified, its 
 executable-counterpart invokes its submitted function when the guard is 
 satisfied, for example to generate the call <span class="v">(F (4 5 6))</span>.  If the guard 
 for <span class="v">f</span> fails to hold, however, the executable-counterpart for <span class="v">f</span> 
 causes a guard violation error, as shown above for the executable-counterpart 
 call <span class="v">(ACL2_*1*_ACL2::F 3)</span>.</p> 
 
 <p>See also <a href="ACL2____GUARD.html">guard</a> and its subtopics, especially, <a href="ACL2____GUARDS-AND-EVALUATION.html">guards-and-evaluation</a>, for a discussion of guards and their connection to 
 evaluation.  Advanced system hackers who want to see the 
 executable-counterpart definition for <span class="v">f</span> may invoke <span class="v">(<a href="ACL2____TRACE_12.html">trace!</a>
 (oneify-cltl-code :native t))</span> before defining <span class="v">f</span> in ACL2.</p>
</body>
</html>
