<html>
<head>
<meta charset="UTF-8">
<title>Defobject</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=C____DEFOBJECT">Click for Defobject in the Full Manual</a></h3>

<p>Define a shallowly embedded external object.</p><h3>Introduction</h3><p>A more colloquial term for this is `global variable', 
      i.e. a variable declared at the top level of a file, 
      as opposed to a local variable, which is declared in a block. 
      In more technical terms, 
      a C translation unit consists of 
      a sequence of external declarations [C:6.9], 
      where an external declaration is 
      either a function definition [C:6.9.1] 
      or a declaration [C:6.7], 
      where the latter may define an object [C:6.9.2]. 
      Thus, a global variable is introduced as 
      an external object definition.</p><p>This macro defines an external C object shallowly embedded in ACL2. 
      The macro specifies the name, type, and initializer. 
      The macro stores this information in a table, 
      and generates a recognizer for the possible values of the object. 
      A shallowly embedded C function that accesses the object 
      is represented by an ACL2 function with a parameter 
      that has the same name as the object 
      and whose guard says that the parameter 
      satisfies the generated recognizer. 
      While the parameter has to be explicit in purely functional ACL2, 
      the C function has no corresponding parameter, 
      and instead accesses the object directly by name, 
      since the object is in scope. 
      The macro also generates a nullary function 
      that returns the initial value of the object.</p><p>Currently this macro only supports objects of integer array types, 
      but we plan to extend support to more types.</p><h3>General Form</h3><pre class="code">(<a href="C____DEFOBJECT.html">defobject</a> name
           :type ...
           :init ...
  )</pre><h3>Inputs</h3><p><span class="v">name</span></p><blockquote>
<p>Name of the externally defined object.</p>
<p>It must be a symbol whose <span class="tt"><a href="COMMON-LISP____SYMBOL-NAME.html">symbol-name</a></span> is 
       a portable ASCII identifier as defined in <span class="tt"><a href="C____ATC.html">atc</a></span>, 
       that is distinct from the <span class="tt"><a href="COMMON-LISP____SYMBOL-NAME.html">symbol-name</a></span>s of objects 
       introduced by previous successful calls of <span class="v">defobject</span>.</p>
</blockquote><p><span class="v">:type</span> — no default</p><blockquote>
<p>Type of the externally defined object.</p>
<p>It must be one of</p>
<ul>
<li><span class="v">(<a href="C____SCHAR.html">schar</a> &lt;pos&gt;)</span></li>
<li><span class="v">(<a href="C____UCHAR.html">uchar</a> &lt;pos&gt;)</span></li>
<li><span class="v">(<a href="C____SSHORT.html">sshort</a> &lt;pos&gt;)</span></li>
<li><span class="v">(<a href="C____USHORT.html">ushort</a> &lt;pos&gt;)</span></li>
<li><span class="v">(<a href="C____SINT.html">sint</a> &lt;pos&gt;)</span></li>
<li><span class="v">(<a href="C____UINT.html">uint</a> &lt;pos&gt;)</span></li>
<li><span class="v">(<a href="C____SLONG.html">slong</a> &lt;pos&gt;)</span></li>
<li><span class="v">(<a href="C____ULONG.html">ulong</a> &lt;pos&gt;)</span></li>
<li><span class="v">(<a href="C____SLLONG.html">sllong</a> &lt;pos&gt;)</span></li>
<li><span class="v">(<a href="C____ULLONG.html">ullong</a> &lt;pos&gt;)</span></li>
</ul>
<p>where <span class="v">&lt;pos&gt;</span> is a positive integer not exceeding <span class="tt"><a href="C____ULLONG-MAX.html">ullong-max</a></span>. 
       Each of these represents an integer array type with the specified size, 
       where the limit on the size is so that 
       it can be represented by a C integer constant.</p>
</blockquote><p><span class="v">:init</span> — no default</p><blockquote>
<p>Initializer of the externally defined object.</p>
<p>It must be a list of length <span class="v">&lt;pos&gt;</span> 
       of constant expression terms returning <span class="v">T</span>, 
       where <span class="v">T</span> is the integer type specified in the <span class="v">:type</span> input 
       (i.e. the element type of the array), 
       and where the notion of constant expression term returning <span class="v">T</span> 
       is defined below. 
       This list represents an array initializer [C:6.7.9].</p>
<p>The terms must be guard-verifiable. 
       This requirement is checked implicitly 
       by generating the <span class="v">object-&lt;name&gt;-init</span> function 
       (see the `Generated Events' section below) 
       via an event that requires its guard verification.</p>
</blockquote><h3>Constant Expression Terms</h3><p>This is a restricted version of the notion of 
      pure expression terms defined in <span class="tt"><a href="C____ATC.html">atc</a></span>. 
      A pure expression term is an ACL2 term that represent 
      a C pure expression that may involve variables. 
      A constant expression term is an ACL2 term that represents 
      a C constant expressions [C:6.6], 
      which does not involve variables. 
      Since there are no variables involved, 
      the notion of constant expression term is defined 
      without reference to any ACL2 function <span class="v">fn</span>, 
      unlike the notion of pure expression term in <span class="tt"><a href="C____ATC.html">atc</a></span>.</p><p>A <i>constant expression term returning</i> <span class="v">T</span>, 
      where <span class="v">T</span> is a non-<span class="v">void</span> C type, 
      is inductively defined as one of the following:</p><ul>
<li>A call of a function <span class="v">&lt;type&gt;-&lt;base&gt;-const</span> on a quoted integer, 
       when <span class="v">&lt;type&gt;</span> is among<ul>
<li><span class="v">sint</span></li>
<li><span class="v">uint</span></li>
<li><span class="v">slong</span></li>
<li><span class="v">ulong</span></li>
<li><span class="v">sllong</span></li>
<li><span class="v">ullong</span></li>
</ul>
<span class="v">&lt;base&gt;</span> is among<ul>
<li><span class="v">dec</span></li>
<li><span class="v">oct</span></li>
<li><span class="v">hex</span></li>
</ul>
<span class="v">T</span> is the C type corresponding to <span class="v">&lt;type&gt;</span> 
       and the quoted integer is non-negative and in the range of <span class="v">T</span>. 
       This represents a C integer constant 
       of the C type indicated by the name of the function, 
       expressed in decimal, octal, or hexadecimal base.</li>
<li>A call of a function <span class="v">&lt;op&gt;-&lt;type&gt;</span> on 
       a constant expression term returning <span class="v">U</span>, 
       when <span class="v">&lt;op&gt;</span> is among<ul>
<li><span class="v">plus</span></li>
<li><span class="v">minus</span></li>
<li><span class="v">bitnot</span></li>
<li><span class="v">lognot</span></li>
</ul>
<span class="v">&lt;type&gt;</span> is among<ul>
<li><span class="v">schar</span></li>
<li><span class="v">uchar</span></li>
<li><span class="v">sshort</span></li>
<li><span class="v">ushort</span></li>
<li><span class="v">sint</span></li>
<li><span class="v">uint</span></li>
<li><span class="v">slong</span></li>
<li><span class="v">ulong</span></li>
<li><span class="v">sllong</span></li>
<li><span class="v">ullong</span></li>
</ul>
<span class="v">T</span> is the C type corresponding to 
       the return type of <span class="v">&lt;op&gt;-&lt;type&gt;</span> 
       and <span class="v">U</span> is the C type corresponding to <span class="v">&lt;type&gt;</span>. 
       This represents the C operator indicated by the name of the function 
       applied to a value of the type indicated by the name of the function. 
       The guard verification requirement ensures that 
       the operator yields a well-defined result. 
       These functions covers all the C unary operators 
       (using the nomenclature in [C]).</li>
<li>A call of a function <span class="v">&lt;op&gt;-&lt;type1&gt;-&lt;type2&gt;</span> 
       on constant expression terms returning <span class="v">U</span> and <span class="v">V</span>, 
       when <span class="v">&lt;op&gt;</span> is among<ul>
<li><span class="v">add</span></li>
<li><span class="v">sub</span></li>
<li><span class="v">mul</span></li>
<li><span class="v">div</span></li>
<li><span class="v">rem</span></li>
<li><span class="v">shl</span></li>
<li><span class="v">shr</span></li>
<li><span class="v">lt</span></li>
<li><span class="v">gt</span></li>
<li><span class="v">le</span></li>
<li><span class="v">ge</span></li>
<li><span class="v">eq</span></li>
<li><span class="v">ne</span></li>
<li><span class="v">bitand</span></li>
<li><span class="v">bitxor</span></li>
<li><span class="v">bitior</span></li>
</ul>
<span class="v">&lt;type1&gt;</span> and <span class="v">&lt;type2&gt;</span> are among<ul>
<li><span class="v">schar</span></li>
<li><span class="v">uchar</span></li>
<li><span class="v">sshort</span></li>
<li><span class="v">ushort</span></li>
<li><span class="v">sint</span></li>
<li><span class="v">uint</span></li>
<li><span class="v">slong</span></li>
<li><span class="v">ulong</span></li>
<li><span class="v">sllong</span></li>
<li><span class="v">ullong</span></li>
</ul>
<span class="v">T</span> is the C type corresponding to 
       the return type of <span class="v">&lt;op&gt;-&lt;type1&gt;-&lt;type2&gt;</span>, 
       <span class="v">U</span> is the C type corresponding to <span class="v">&lt;type1&gt;</span>, and 
       <span class="v">V</span> is the C type corresponding to <span class="v">&lt;type2&gt;</span>. 
       This represents the C operator indicated by the name of the function 
       applied to values of the types indicated by the name of the function. 
       The guard verification requirement ensures that 
       the operator yields a well-defined result. 
       These functions covers all the C strict pure binary operators; 
       the non-strict operators <span class="v">&amp;&amp;</span> and <span class="v">||</span>, 
       and the non-pure operators <span class="v">=</span>, <span class="v">+=</span>, etc., 
       are represented differently.</li>
<li>A call of a function <span class="v">&lt;type1&gt;-from-&lt;type2&gt;</span> 
       on a constant expression term returning <span class="v">U</span>, 
       when <span class="v">&lt;type1&gt;</span> and <span class="v">&lt;type2&gt;</span> are among<ul>
<li><span class="v">schar</span></li>
<li><span class="v">uchar</span></li>
<li><span class="v">sshort</span></li>
<li><span class="v">ushort</span></li>
<li><span class="v">sint</span></li>
<li><span class="v">uint</span></li>
<li><span class="v">slong</span></li>
<li><span class="v">ulong</span></li>
<li><span class="v">sllong</span></li>
<li><span class="v">ullong</span></li>
</ul>and also differ from each other, 
       <span class="v">T</span> is the C type corresponding to <span class="v">&lt;type1&gt;</span> 
       and <span class="v">U</span> is the C type corresponding to <span class="v">&lt;type2&gt;</span>. 
       This represents 
       a cast to the type indicated by the first part of the function name. 
       The guard verification requirement ensures that 
       the conversion yields a well-defined result. 
       Even though conversions 
       happen automatically in certain circumstances in C, 
       these functions always represent explicit casts; 
       implict conversions are represented implicitly, 
       e.g. via the function for a unary operator 
       that promotes the operand.</li>
</ul><h3>Generated Events</h3><p><span class="v">object-&lt;name&gt;-p</span></p><blockquote>
<p>Recognizer of the possible values of the externally defined object.</p>
<p>This is defined as</p>
<pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> object-&lt;name&gt;-p (x)
  (<a href="COMMON-LISP____AND.html">and</a> (&lt;type&gt;-arrayp x)
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (&lt;type&gt;-array-length x) &lt;pos&gt;)))</pre>
<p>where <span class="v">&lt;name&gt;</span> is the name of the object 
       specified in the <span class="v">name</span> input 
       and <span class="v">&lt;type&gt;</span> is the integer fixtype name 
       specified in the <span class="v">:type</span> input. 
       The recognizer <span class="v">object-&lt;name&gt;-p</span> is 
       in the same package as the <span class="v">name</span> input. 
       The function is in logic mode and guard-verified; 
       its guard verification is always expected to succeed.</p>
</blockquote><p><span class="v">object-&lt;name&gt;-init</span></p><blockquote>
<p>Nullary function that returns the initializing value 
       of the externally defined object.</p>
<p>This is defined as</p>
<pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> object-&lt;name&gt;-init ()
  (&lt;type&gt;-array-of (<a href="COMMON-LISP____LIST.html">list</a> &lt;term1&gt; &lt;term2&gt; ...)))</pre>
<p>where <span class="v">&lt;name&gt;</span> is the name of the object 
       specified in the <span class="v">name</span> input, 
       <span class="v">&lt;type&gt;</span> is the integer fixtype name 
       specified in the <span class="v">:type</span> input, 
       and <span class="v">&lt;term1&gt;</span>, <span class="v">&lt;term2&gt;</span>, etc. 
       are the terms in the list in the <span class="v">:init</span> input. 
       The nullary function <span class="v">object-&lt;name&gt;-init</span> is 
       in the same package as the <span class="v">name</span> input. 
       The function is in logic mode and guard-verified: 
       its guard verification checks some of the requirements 
       on the <span class="v">:init</span> input mentioned in the `Inputs' section above.</p>
</blockquote>
</body>
</html>
