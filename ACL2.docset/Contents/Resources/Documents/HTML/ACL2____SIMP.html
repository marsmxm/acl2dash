<html>
<head>
<meta charset="UTF-8">
<title>Simp</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____SIMP">Click for Simp in the Full Manual</a></h3>

<p><span class="tt">Simp</span> returns a list of simplified versions of its input 
 term, each paired with a hypothesis list under which the input and output 
 terms are provably equal.</p> 
 
 <p>This tool is implemented on top of another tool, <span class="tt"><a href="ACL2____BASH-TERM-TO-DNF.html">bash-term-to-dnf</a></span>. 
 However, <span class="v">bash-term-to-dnf</span> treats its input term as a propositional 
 assertion, so it is unsuitable if you want to simpify a non-Boolean term to 
 produce a provably equal output term.  The <span class="v">simp</span> tool is well-suited to 
 that task.</p> 
 
 <p>However, a case split may occur under simplification.  Moroever, <span class="v">simp</span> 
 takes a second argument, which is a list of hypotheses, which are simplified 
 too and hence might also generate case splits.  Thus, <span class="v">simp</span> actually 
 returns a list of term/hypothesises pairs each of the form 
 <span class="v">(&lt;simplified-term&gt; &lt;simplified-hypothesis-1&gt;
 ... &lt;simplified-hypothesis-k&gt;)</span>, where for each such pair the following may 
 be expected to be a theorem:</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> &lt;simplified-hypothesis-1&gt;
              ...
              &lt;simplified-hypothesis-k&gt;)
         &lt;simplified-term&gt;)</pre> 
 
 <p>Example:</p> 
 
 <p>Suppose we have submitted the following two definitions.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> p (x) (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____STRINGP.html">stringp</a> x) (<a href="ACL2____ACL2-NUMBERP.html">acl2-numberp</a> x)))
(<a href="COMMON-LISP____DEFUN.html">defun</a> f (x) (<a href="COMMON-LISP____IF.html">if</a> (p x) (<a href="COMMON-LISP____CONS.html">cons</a> x x) 17))</pre> 
 
 <p>Then:</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="ACL2____SIMP.html">simp</a> (f x) nil)
 (((<a href="COMMON-LISP____CONS.html">CONS</a> X X) (<a href="ACL2____ACL2-NUMBERP.html">ACL2-NUMBERP</a> X))
  (17 (<a href="COMMON-LISP____NOT.html">NOT</a> (<a href="COMMON-LISP____STRINGP.html">STRINGP</a> X))
      (<a href="COMMON-LISP____NOT.html">NOT</a> (<a href="ACL2____ACL2-NUMBERP.html">ACL2-NUMBERP</a> X)))
  ((<a href="COMMON-LISP____CONS.html">CONS</a> X X) (<a href="COMMON-LISP____STRINGP.html">STRINGP</a> X)))
ACL2 !&gt;(<a href="ACL2____SIMP.html">simp</a> (f x) nil :hints (("Goal" :in-theory (<a href="ACL2____DISABLE.html">disable</a> p))))
 ((17 (<a href="COMMON-LISP____NOT.html">NOT</a> (P X))) ((<a href="COMMON-LISP____CONS.html">CONS</a> X X) (P X)))
ACL2 !&gt;</pre> 
 
 <p>Notice the space in front of the results.  This indicates that what is 
 actually returned is an <a href="ACL2____ERROR-TRIPLE.html">error 
 triple</a>, for example as follows in the final case above.</p> 
 
 <pre class="code">(<a href="ACL2____MV.html">mv</a> ((17 (<a href="COMMON-LISP____NOT.html">NOT</a> (P X))) ((<a href="COMMON-LISP____CONS.html">CONS</a> X X) (P X))) &lt;state&gt;)</pre> 
 
 <p>General Form:</p> 
 
 <pre class="code">(<a href="ACL2____SIMP.html">simp</a> term hypothesis-list :hints hints :verbose verbose)</pre> 
 
 <p>where <span class="v">term</span> and each member of the list <span class="v">hypothesis-list</span> are terms 
 in user-level syntax, <span class="v">hints</span> (which is optional) is a list of <a href="ACL2____HINTS.html">hints</a> 
 such as might be given to <span class="tt"><a href="ACL2____DEFTHM.html">defthm</a></span>, and a <span class="v">verbose</span> (which is 
 optional, <span class="v">nil</span> by default) allows output from the prover if non-<span class="v">nil</span>. 
 The result is an <a href="ACL2____ERROR-TRIPLE.html">error triple</a>, 
 <span class="tt">(mv nil val state)</span>, where <span class="tt">val</span> is a list, each member of 
 which is of the form <span class="v">(&lt;simplified-term&gt; &lt;simplified-hypothesis-1&gt;
 ... &lt;simplified-hypothesis-k&gt;)</span>, where <span class="v">&lt;simplified-term&gt;</span> and each 
 <span class="v">&lt;simplified-hypothesis-i&gt;</span> are untranslated (user-level) forms, as 
 described earlier in this topic.</p>
</body>
</html>
