<html>
<head>
<meta charset="UTF-8">
<title>Trace$</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____TRACE_42">Click for Trace$ in the Full Manual</a></h3>

<p>Trace function evaluations</p><pre class="code">Examples:
(<a href="ACL2____TRACE_42.html">trace$</a> foo bar)     ; trace foo and bar
(<a href="ACL2____TRACE_42.html">trace$</a>)             ; return current trace info (no new tracing specified)
(<a href="ACL2____TRACE_42.html">trace$</a> (foo :entry  ; trace foo, printing first actual parameter upon entry
             (<a href="COMMON-LISP____CAR.html">car</a> arglist)))
(<a href="ACL2____TRACE_42.html">trace$</a> (foo :exit   ; trace foo, using fmt to print upon exit
             (:fmt (<a href="ACL2____MSG.html">msg</a> "Exiting FOO with ~x0"
                        value))))
(<a href="ACL2____TRACE_42.html">trace$</a> (foo :native t))

General Forms:
(<a href="ACL2____TRACE_42.html">trace$</a> spec1 spec2 ... specn) ; n &gt;= 1
(<a href="ACL2____TRACE_42.html">trace$</a>)</pre> 
 
 <p>where the <span class="v">speci</span> are trace specs, as described below.</p> 
 
 <p><span class="v">Trace$</span> installs alternate code for the indicated functions that prints 
 information upon entry to, and exit from, calls of the functions.  For an 
 alternate tracing utility used for educational purposes in <a href="http://acl2s.ccs.neu.edu/acl2s/doc/" target="_blank"><nobr>ACL2s<img src="../Icon_External_Link.png" title="External link to http://acl2s.ccs.neu.edu/acl2s/doc/"></nobr></a>, see community book 
 <span class="v">books/misc/trace-star.lisp</span>.</p> 
 
 <p>From a logical perspective all trace printing is a fiction.  (But see <a href="ACL2____TRACE_12.html">trace!</a>  for a way to get around this and modify <a href="ACL2____STATE.html">state</a>.)  For a related 
 fiction, see <a href="ACL2____CW.html">cw</a>.  <span class="v">(<a href="ACL2____TRACE_42.html">Trace$</a>)</span> returns the list of currently-active 
 trace specs, while the application of <span class="v">trace$</span> to at least one argument 
 returns the list of its arguments that are successfully acted on.</p> 
 
 <p>Output from <span class="tt"><a href="ACL2____TRACE_42.html">trace$</a></span> normally goes to the screen, i.e., to <span class="tt"><a href="ACL2____STANDARD-CO.html">standard-co</a></span>.  But it can be redirected to a file; see <a href="ACL2____OPEN-TRACE-FILE.html">open-trace-file</a>.</p> 
 
 <p>See <a href="ACL2____UNTRACE_42.html">untrace$</a> for how to undo the effect of <span class="tt"><a href="ACL2____TRACE_42.html">trace$</a></span>.  Also see 
 <a href="COMMON-LISP____TRACE.html">trace</a> for mention of modifications made to raw Lisp trace, which is 
 accessible (as described below) using the <span class="v">:native</span> keyword.</p> 
 
 <p>Note that when <span class="v">trace$</span> is applied to a function without option 
 <span class="v">:native</span>, that function's declarations and documentation are 
 discarded.</p> 
 
 <p>Next, we introduce tracing with some examples.  After that, we provide 
 reference documentation for individual trace options allowed in a trace spec. 
 Note that although our example focuses on user-defined functions, <span class="v">trace$</span> 
 can also be applied to built-in functions, though perhaps only system hackers 
 should take advantage of this observation.</p> 
 
 <p>We begin by illustrating the simplest sort of trace spec: a function 
 symbol.  For example, the form <span class="v">(<a href="ACL2____TRACE_42.html">trace$</a> foo bar)</span> directs the tracing of 
 functions <span class="v">foo</span> and <span class="v">bar</span> by virtue of the two trace specs <span class="v">foo</span> and 
 <span class="v">bar</span>.  We can see tracing in action by first defining:</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> f (x)
  (<a href="COMMON-LISP____CONS.html">cons</a> x x))

(<a href="COMMON-LISP____DEFUN.html">defun</a> g (x)
  (<a href="COMMON-LISP____LIST.html">list</a> (f x) 3))</pre> 
 
 <p>The following log then illustrates tracing of these two functions.  Notice 
 that before <a href="ACL2____GUARD.html">guard</a>s have been verified, the ``executable-counterpart 
 functions'' are called but the corresponding submitted functions are 
 not (see <a href="ACL2____EVALUATION.html">evaluation</a> for relevant background); but after guard 
 verification of <span class="v">f</span>, the submitted function for <span class="v">f</span> is indeed called. 
 (See <a href="ACL2____GUARD.html">guard</a> and see <a href="ACL2____GUARD-EVALUATION-EXAMPLES-LOG.html">guard-evaluation-examples-log</a>.)</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="ACL2____TRACE_42.html">trace$</a> f g)
 ((F) (<a href="ACL2____G.html">G</a>))
ACL2 !&gt;(<a href="ACL2____G.html">g</a> 7)
1&gt; (ACL2_*1*_ACL2::G 7)
  2&gt; (ACL2_*1*_ACL2::F 7)
  &lt;2 (ACL2_*1*_ACL2::F (7 . 7))
&lt;1 (ACL2_*1*_ACL2::G ((7 . 7) 3))
((7 . 7) 3)
ACL2 !&gt;(<a href="ACL2____VERIFY-GUARDS.html">verify-guards</a> f)

Computing the guard conjecture for F....

The guard conjecture for F is trivial to prove.  F is compliant with
Common Lisp.

Summary
Form:  ( VERIFY-GUARDS F)
Rules: NIL
Warnings:  None
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 F
ACL2 !&gt;(<a href="ACL2____G.html">g</a> 7)
1&gt; (ACL2_*1*_ACL2::G 7)
  2&gt; (ACL2_*1*_ACL2::F 7)
    3&gt; (F 7)
    &lt;3 (F (7 . 7))
  &lt;2 (ACL2_*1*_ACL2::F (7 . 7))
&lt;1 (ACL2_*1*_ACL2::G ((7 . 7) 3))
((7 . 7) 3)
ACL2 !&gt;</pre> 
 
 <p>The following example introduces trace specs other than function symbols. 
 Consider the following definition.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> fact (n)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____NATP.html">natp</a> n)))
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> n)
      1
    (<a href="COMMON-LISP_____A2.html">*</a> n (fact (<a href="COMMON-LISP____1-.html">1-</a> n)))))</pre> 
 
 <p>The following log illustrates the use of trace options <span class="v">:cond</span> 
 (condition for entering trace), <span class="v">:entry</span> (what to print on entry), and 
 <span class="v">:exit</span> (what to print on exit).  The reason for two calls on argument 4 is 
 that we are seeing such calls for the executable-counterpart of <span class="v">fact</span> and 
 also its raw Lisp function.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="ACL2____TRACE_42.html">trace$</a> (fact :cond (<a href="COMMON-LISP____EVENP.html">evenp</a> (<a href="COMMON-LISP____CAR.html">car</a> arglist))
                     :entry (<a href="COMMON-LISP____CONS.html">cons</a> 'factorial-call arglist)
                     :exit (<a href="COMMON-LISP____CAR.html">car</a> values)))
 ((FACT :COND (<a href="COMMON-LISP____EVENP.html">EVENP</a> (<a href="COMMON-LISP____CAR.html">CAR</a> ARGLIST))
        :ENTRY (<a href="COMMON-LISP____CONS.html">CONS</a> 'FACTORIAL-CALL ARGLIST)
        :EXIT (<a href="COMMON-LISP____CAR.html">CAR</a> VALUES)))
ACL2 !&gt;(fact 4)
1&gt; (FACTORIAL-CALL 4)
  2&gt; (FACTORIAL-CALL 4)
    3&gt; (FACTORIAL-CALL 2)
      4&gt; (FACTORIAL-CALL 0)
      &lt;4 1
    &lt;3 2
  &lt;2 24
&lt;1 24
24
ACL2 !&gt;</pre> 
 
 <p>Notice that <span class="v">VALUES</span> above is the list of all values returned, which is 
 a one-element list unless <span class="tt"><a href="ACL2____MV.html">mv</a></span> return is used, as illustrated in the 
 following example, after defining: <span class="v">(<a href="COMMON-LISP____DEFUN.html">defun</a> two-vals (x) (<a href="ACL2____MV.html">mv</a> x 7))</span>.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="ACL2____TRACE_42.html">trace$</a> two-vals)
 ((TWO-VALS))
ACL2 !&gt;(two-vals 3)
1&gt; (ACL2_*1*_ACL2::TWO-VALS 3)
&lt;1 (ACL2_*1*_ACL2::TWO-VALS 3 7)
(3 7)
ACL2 !&gt;(<a href="ACL2____VERIFY-GUARDS.html">verify-guards</a> two-vals)

Computing the guard conjecture for TWO-VALS....

The guard conjecture for TWO-VALS is trivial to prove, given the :executable-
counterpart of CONS.  TWO-VALS is compliant with Common Lisp.

Summary
Form:  ( VERIFY-GUARDS TWO-VALS)
Rules: ((:EXECUTABLE-COUNTERPART CONS))
Warnings:  None
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 TWO-VALS
ACL2 !&gt;(two-vals 3)
1&gt; (ACL2_*1*_ACL2::TWO-VALS 3)
  2&gt; (TWO-VALS 3)
  &lt;2 (TWO-VALS 3 7)
&lt;1 (ACL2_*1*_ACL2::TWO-VALS 3 7)
(3 7)
ACL2 !&gt;</pre> 
 
 <p>We now document all of the options that may appear in a trace spec.  A 
 trace spec with options is of the form</p> 
 
 <pre class="code">(fn :kwd1 val1 :kwd2 val2 ... :kwdn valn)</pre> 
 
 <p>and here we document each legal keyword <span class="v">:kwdi</span> and corresponding 
 expected value <span class="v">vali</span>.  Note that <span class="v">trace$</span> is intended primarily for 
 functions defined in the ACL2 command loop (see <a href="ACL2____LP.html">lp</a>).  If you want to 
 trace a function that is defined in raw Lisp, then you can use option 
 <span class="v">:native</span> (see below), but then many other <span class="v">trace$</span> options will not be 
 available to you: all of them except <span class="v">:multiplicity</span> and <span class="v">:native</span> 
 itself will be passed directly to the <span class="v">trace</span> utility of the underlying 
 Common Lisp.</p> 
 
 <p><span class="v">:COND</span>, <span class="v">:ENTRY</span>, and <span class="v">:EXIT</span></p> 
 
 <h3>Introduction</h3> 
 
 <p>For each of these three options, the value is a 
 (user-level) term, except that for <span class="v">:entry</span> and <span class="v">:exit</span> the value can be 
 of the form <span class="v">(:fmt u)</span> or <span class="v">(:fmt! u)</span>, where <span class="v">u</span> is a user-level 
 term.  We skip these two latter cases for now and return to them later.  Then 
 the indicated term is evaluated as indicated in the next paragraph, and if the 
 <span class="v">:cond</span> term is omitted or evaluates to non-<span class="v">nil</span>, then the value of the 
 <span class="v">:entry</span> term is printed on entry and the value of the <span class="v">:exit</span> term is 
 printed on exit.  By default, where <span class="v">:entry</span> is omitted or is specified as 
 <span class="v">nil</span>, the value printed for <span class="v">:entry</span> is the list obtained by consing 
 the calling function symbol onto the list of actual parameters: in the 
 notation described below, this is <span class="v">(<a href="COMMON-LISP____CONS.html">cons</a> TRACED-FN ARGLIST)</span>.  Similarly, 
 the default for printing at the exit of the function call, i.e. where 
 <span class="v">:exit</span> is omitted or is specified as <span class="v">nil</span>, is <span class="v">(<a href="COMMON-LISP____CONS.html">cons</a> TRACED-FN
 VALUES)</span> where <span class="v">VALUES</span> is the list of values returned as described 
 below.</p> 
 
 <h3>Available Variables</h3> 
 
 <blockquote>NOTE.  The symbols mentioned below, for example <span class="v">ARGLIST</span>, are 
 all in the <span class="v">"ACL2"</span> package.  If you are in another package you may need 
 an <span class="v">"ACL2::"</span> package prefix, e.g., <span class="v">ACL2::ARGLIST</span>.</blockquote> 
 
 <p>In the evaluations of the term described below upon a call of <span class="v">fn</span>, each 
 formal parameter of the definition of <span class="v">fn</span> will be bound to the 
 corresponding actual of the call, the variable <span class="v">ARGLIST</span> will be bound to 
 the list of actuals, and the variable <span class="v">TRACED-FN</span> will be bound to the 
 function being called (either <span class="v">fn</span> or its executable-counterpart function; 
 see above).  Additionally in the case of <span class="v">:exit</span>, the variable <span class="v">VALUES</span> 
 will be bound to the multiple values returned (thus, a one-element list if 
 <span class="tt"><a href="ACL2____MV.html">mv</a></span> is not used in the return).  Also for <span class="v">:exit</span>, we bind 
 <span class="v">VALUE</span> to the logical value returned, i.e., to the suitable list of values 
 returned in the <span class="tt"><a href="ACL2____MV.html">mv</a></span> case and otherwise to the single value returned. 
 So in the <span class="v">mv</span> case, <span class="v">VALUE</span> is the same as <span class="v">VALUES</span>, and otherwise 
 <span class="v">VALUE</span> is <span class="v">(<a href="COMMON-LISP____CAR.html">car</a> VALUES)</span>.  Finally, the variable <span class="v">TRACE-LEVEL</span> will 
 be bound to the level, or depth, of tracing; that is, the number printed at 
 entry and exit (e.g., 3 in <span class="v">`3&gt;'</span> and <span class="v">`&lt;3'</span>).  Other than these 
 variables and <span class="tt"><a href="ACL2____STATE.html">state</a></span>, no other variable may occur in the term, whose 
 value must be a single non-<span class="tt"><a href="ACL2____STOBJ.html">stobj</a></span> value, unless there is an active 
 trust tag (see <a href="ACL2____DEFTTAG.html">defttag</a>).</p> 
 
 <h3>Basic Options</h3> 
 
 <p>Now suppose <span class="v">fn</span> is called.  First: If <span class="v">:cond</span> is supplied and the 
 result of evaluating the <span class="v">:cond</span> term is <span class="v">nil</span>, then no tracing is done. 
 Otherwise tracing proceeds as follows.  First the <span class="v">:entry</span> form is 
 evaluated, and the result is printed.  Then the call of <span class="v">fn</span> is evaluated. 
 Finally the <span class="v">:exit</span> term is evaluated and the result is printed.  As 
 indicated above, the default for the <span class="v">:entry</span> term if omitted or explicitly 
 <span class="v">nil</span> is <span class="v">(<a href="COMMON-LISP____CONS.html">cons</a> TRACED-FN ARGLIST)</span>, and the default for the <span class="v">:exit</span> 
 term if omitted or explicitly <span class="v">nil</span> is <span class="v">(<a href="COMMON-LISP____CONS.html">cons</a> TRACED-FN VALUES)</span>.</p> 
 
 <p>Note that if the function has a formal named <span class="v">ARGLIST</span>, then 
 <span class="v">ARGLIST</span> will nevertheless refer to the entire list of formals, not the 
 single formal named <span class="v">ARGLIST</span>; similarly for <span class="v">TRACED-FN</span>, and 
 additionally for <span class="v">VALUE</span> and <span class="v">VALUES</span> in the case of <span class="v">:exit</span>.</p> 
 
 <p>As mentioned above, for each of <span class="v">:entry</span> and <span class="v">:exit</span>, a value of 
 <span class="v">nil</span> specifies the default behavior.  If you really want a value of 
 <span class="v">nil</span>, use a non-<span class="v">nil</span> form that evaluates to <span class="v">nil</span>, for example 
 <span class="v">(<a href="COMMON-LISP____CAR.html">car</a> nil)</span> or <span class="v">'nil</span>.  However, for <span class="v">:cond</span> a value of <span class="v">nil</span> 
 means what it says: do not evaluate the <span class="v">:entry</span> or <span class="v">:exit</span> forms.</p> 
 
 <p>Finally we discuss the case that the <span class="v">:entry</span> or <span class="v">:exit</span> term is of 
 the form <span class="v">(:fmt u)</span> or <span class="v">(:fmt! u)</span>.  In these cases, the term <span class="v">u</span> is 
 evaluated as described above to produce a value, say <span class="v">msg</span>, but instead of 
 printing <span class="v">msg</span> directly, ACL2 calls <span class="v">fmt1</span> using the string <span class="v">"~@0"</span> 
 and the alist that binds just character <span class="v">#\0</span> to <span class="v">msg</span>.  The following 
 example illustrates this point, where <span class="v">fact</span> is defined as above.  Also see 
 <a href="ACL2____FMT.html">fmt</a>.  Note that <span class="v">(<a href="ACL2____MSG.html">msg</a> string . vals)</span> produces a value suitable for 
 a <span class="v">"~@"</span> directive to the <span class="v">fmt</span> family of print functions.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="ACL2____TRACE_42.html">trace$</a>
        (fact
         :entry (:fmt (<a href="ACL2____MSG.html">msg</a> "Tracing ~x0 on ~x1" traced-fn arglist))
         :exit (<a href="COMMON-LISP____CAR.html">car</a> values)))
 ((FACT :ENTRY (:FMT (<a href="ACL2____MSG.html">MSG</a> "Tracing ~x0 on ~x1" TRACED-FN ARGLIST))
        :EXIT (<a href="COMMON-LISP____CAR.html">CAR</a> VALUES)))
ACL2 !&gt;(fact 3)
1&gt; Tracing ACL2_*1*_ACL2::FACT on (3)
  2&gt; Tracing FACT on (3)
    3&gt; Tracing FACT on (2)
      4&gt; Tracing FACT on (1)
        5&gt; Tracing FACT on (0)
        &lt;5 1
      &lt;4 1
    &lt;3 2
  &lt;2 6
&lt;1 6
6
ACL2 !&gt;</pre> 
 
 <p>If <span class="v">:fmt!</span> is used instead of <span class="v">:fmt</span>, then indentation as is the 
 prefix string, <span class="v">"n&gt; "</span> or <span class="v">"&lt;n "</span>.  The following example 
 illustrates the use of <span class="v">:fmt!</span>.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="ACL2____TRACE_42.html">trace$</a>
        (fact
         :entry (:fmt! (<a href="ACL2____MSG.html">msg</a> "Tracing ~x0 on ~x1" traced-fn arglist))
         :exit (:fmt! (<a href="ACL2____MSG.html">msg</a> "From input ~x0: ~x1"
                           (<a href="COMMON-LISP____CAR.html">car</a> arglist) (<a href="COMMON-LISP____CAR.html">car</a> values)))))
 ((FACT :ENTRY (:FMT! (<a href="ACL2____MSG.html">MSG</a> "Tracing ~x0 on ~x1" TRACED-FN ARGLIST))
        :EXIT (:FMT! (<a href="ACL2____MSG.html">MSG</a> "From input ~x0: ~x1" (<a href="COMMON-LISP____CAR.html">CAR</a> ARGLIST)
                          (<a href="COMMON-LISP____CAR.html">CAR</a> VALUES)))))
ACL2 !&gt;(fact 3)
Tracing ACL2_*1*_ACL2::FACT on (3)
Tracing FACT on (3)
Tracing FACT on (2)
Tracing FACT on (1)
Tracing FACT on (0)
From input 0: 1
From input 1: 1
From input 2: 2
From input 3: 6
From input 3: 6
6
ACL2 !&gt;</pre> 
 
 <p>Here is the same example, with user-managed indentation.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="ACL2____TRACE_42.html">trace$</a>
        (fact
         :entry (:fmt! (<a href="ACL2____MSG.html">msg</a> "~t0Tracing ~x1 on ~x2"
                            (<a href="COMMON-LISP_____B2.html">+</a> 3 (<a href="COMMON-LISP_____A2.html">*</a> 2 trace-level))
                            traced-fn arglist))
         :exit (:fmt! (<a href="ACL2____MSG.html">msg</a> "~t0From input ~x1: ~x2"
                           (<a href="COMMON-LISP____1_B2.html">1+</a> (<a href="COMMON-LISP_____A2.html">*</a> 2 trace-level))
                           (<a href="COMMON-LISP____CAR.html">car</a> arglist) (<a href="COMMON-LISP____CAR.html">car</a> values)))))
 ((FACT :ENTRY (:FMT! (<a href="ACL2____MSG.html">MSG</a> "~t0Tracing ~x1 on ~x2"
                           (<a href="COMMON-LISP_____B2.html">+</a> 3 (<a href="COMMON-LISP_____A2.html">*</a> 2 TRACE-LEVEL))
                           TRACED-FN ARGLIST))
        :EXIT (:FMT! (<a href="ACL2____MSG.html">MSG</a> "~t0From input ~x1: ~x2"
                          (<a href="COMMON-LISP____1_B2.html">1+</a> (<a href="COMMON-LISP_____A2.html">*</a> 2 TRACE-LEVEL))
                          (<a href="COMMON-LISP____CAR.html">CAR</a> ARGLIST)
                          (<a href="COMMON-LISP____CAR.html">CAR</a> VALUES)))))
ACL2 !&gt;(fact 3)
   Tracing ACL2_*1*_ACL2::FACT on (3)
     Tracing FACT on (3)
       Tracing FACT on (2)
         Tracing FACT on (1)
           Tracing FACT on (0)
           From input 0: 1
         From input 1: 1
       From input 2: 2
     From input 3: 6
   From input 3: 6
6
ACL2 !&gt;</pre> 
 
 <h3>Advanced Options (alphabetical list)</h3> 
 
 <p><span class="v">:COMPILE</span></p> 
 
 <p>The tracing of <span class="v">fn</span> installs a substitute definition of <span class="v">fn</span> that 
 prints trace information.  If the <span class="v">:compile</span> option is omitted or has value 
 <span class="v">:same</span>, then the new definition will be compiled if and only if the 
 existing definition is already compiled.  Otherwise, the new definition will 
 be compiled exactly when the value of <span class="v">:compile</span> is not <span class="v">nil</span>.</p> 
 
 <p><span class="v">:DEF</span>, <span class="v">:MULTIPLICITY</span></p> 
 
 <p>ACL2's <span class="v">trace$</span> mechanism often needs to know the number of outputs of a 
 traced function, in the sense of <span class="tt"><a href="ACL2____MV.html">mv</a></span>.  If you trace a function that was 
 not defined inside the ACL2 loop (hence you are using the <span class="v">:native</span> 
 option), or if you provide an alternative definition using option <span class="v">:def</span> 
 (see below) and the new definition changes the number of values returned, then 
 a natural number value for <span class="v">:multiplicity</span> informs the trace utility of the 
 number of expected outputs of the function being traced.  In the case that 
 <span class="v">:native</span> is supplied, the effect of a non-<span class="v">nil</span> <span class="v">:multiplicity</span> 
 value depends on the host Lisp.  In the case of Lisps for which ACL2 uses the 
 built-in Lisp mechanism for returning multiple values (see <a href="ACL2____MV.html">mv</a>), which 
 are CCL and threaded SBCL as of June, 2010, <span class="v">:multiplicity</span> is not needed 
 and is ignored with <span class="v">:native t</span>.  For GCL and Allegro CL, 
 <span class="v">:multiplicity</span> is used to generate a suitable <span class="v">:exit</span> form if the 
 <span class="v">:exit</span> keyword was not already supplied.  For the other Lisps, the 
 <span class="v">:multiplicity</span> value is treated essentially as 1 whether it is supplied or 
 not, because we do not know how to pass suitable information based on this 
 value to the host Lisp's built-in tracing mechanism.</p> 
 
 <p>Note that even supplying a <span class="v">:multiplicity</span> option does not change the 
 meaning of the variable <span class="v">values</span>.  See the discussion of <span class="v">:native</span> 
 below.</p> 
 
 <p>A useful option can be to supply a definition as the value of <span class="v">:def</span>. 
 (Again, note that if <span class="v">:native</span> is used, then all options other than 
 <span class="v">:multiplicity</span> are passed directly to the underlying Lisp; in particular, 
 <span class="v">:def</span> will have no effect with <span class="v">:native</span> except in the unlikely case 
 that the raw Lisp provides some sort of support for <span class="v">:def</span>.)  Note that 
 this definition should be like a <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> form, but without the leading 
 <span class="v">defun</span> symbol; and it should define the function symbol being traced, with 
 the same formal parameter list.  However, tracing of the 
 ``executable-counterpart'' of a function (see <a href="ACL2____EVALUATION.html">evaluation</a> is not 
 sensitive to the <span class="v">:def</span> option; rather, if a function has an 
 executable-counterpart then that executable-counterpart is traced.</p> 
 
 <p><span class="v">:EVISC-TUPLE</span></p> 
 
 <p>The printing described above is, by default, done using the current default 
 trace evisc-tuple, which can be set using <span class="tt"><a href="ACL2____SET-TRACE-EVISC-TUPLE.html">set-trace-evisc-tuple</a></span> (for 
 the shape of this tuple, see <a href="ACL2____EVISC-TUPLE.html">evisc-tuple</a>); see <a href="ACL2____SET-TRACE-EVISC-TUPLE.html">set-trace-evisc-tuple</a>.  This tuple is based by default on the raw Lisp 
 variables <span class="v">*print-level*</span> and <span class="v">*print-length*</span>, and will hide the ACL2 
 <a href="ACL2____WORLD.html">world</a> and handle <a href="ACL2____STOBJ.html">stobj</a>s appropriately.  You may override this 
 default by supplying an evisc tuple with the <span class="v">:evisc-tuple</span> argument in 
 your trace spec.  Be careful to supply a valid evisc-tuple, or you may get a 
 raw Lisp error!</p> 
 
 <p>A special value, <span class="v">:print</span>, is useful if you are doing system hacking 
 that can produce objects that are not valid ACL2 objects, such as raw Lisp 
 arrays or objects in supporting packages not visible in the ACL2 
 read-eval-print loop.  If you supply <span class="v">:evisc-tuple :print</span>, then the 
 printing described above will be done with raw Lisp printing rather than ACL2 
 printing: specifically, with <span class="v">(format *trace-output* "s%" x)</span>, where 
 <span class="v">x</span> is the value to be printed.</p> 
 
 <p>A second special value for <span class="v">:evisc-tuple</span>, <span class="v">:no-print</span>, avoids 
 printing the values of the <span class="v">:entry</span> and <span class="v">:exit</span> forms (or their 
 defaults, if not specified).  This option is of use for side effects; for an 
 example see community book <span class="v">books/misc/wet.lisp</span>.</p> 
 
 <p>Note that if <span class="v">:evisc-tuple X</span> is supplied, then the form <span class="v">X</span> will be 
 evaluated before the function body is entered.  You can thus pull some tricks 
 to print extra information before the <span class="v">:entry</span> form is evaluated, for 
 example as follows for a factorial function, <span class="v">fact</span>.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="ACL2____TRACE_42.html">trace$</a> (fact :evisc-tuple
                     (<a href="ACL2____PROG2_42.html">prog2$</a> (<a href="ACL2____CW.html">cw</a> "~|**** HERE IS CW ****~|")
                             nil)))
 ((FACT :EVISC-TUPLE (<a href="ACL2____PROG2_42.html">PROG2$</a> (<a href="ACL2____CW.html">CW</a> "~|**** HERE IS CW ****~|")
                             NIL)))
ACL2 !&gt;(fact 3)
**** HERE IS CW ****
1&gt; (ACL2_*1*_ACL2::FACT 3)
**** HERE IS CW ****
  2&gt; (ACL2_*1*_ACL2::FACT 2)
**** HERE IS CW ****
    3&gt; (ACL2_*1*_ACL2::FACT 1)
**** HERE IS CW ****
      4&gt; (ACL2_*1*_ACL2::FACT 0)
      &lt;4 (ACL2_*1*_ACL2::FACT 1)
    &lt;3 (ACL2_*1*_ACL2::FACT 1)
  &lt;2 (ACL2_*1*_ACL2::FACT 2)
&lt;1 (ACL2_*1*_ACL2::FACT 6)
6
ACL2 !&gt;</pre> 
 
 <p><span class="v">:FORMALS</span></p> 
 
 <p>Normally ACL2 can figure out the formals for a given function.  This is 
 always the case for functions defined in the ACL2 command loop and when option 
 <span class="v">:def</span> is supplied.  If neither of these cases applies then you can still 
 trace a function (even without using the <span class="v">:native</span> option) by supplying 
 option <span class="v">:notinline :fncall</span>, but you will still need to supply the list of 
 formal parameters.  The value of the <span class="v">:formals</span> option should be the list 
 of formals in this case.</p> 
 
 <p><span class="v">:HIDE</span></p> 
 
 <p>The default value for this advanced option is <span class="v">t</span>, which causes <a href="ACL2____STOBJ.html">stobj</a>s and the logical <a href="ACL2____WORLD.html">world</a> to be printed as single symbols, along 
 with certain large structures of interest to developers (rewrite constants, 
 enabled structures, and event and command index structures).  If however the 
 value <span class="v">nil</span> is supplied, then this default behavior is defeated.  In that 
 case, you can still arrange to print the logical world as a symbol and to 
 print <a href="ACL2____STOBJ.html">stobj</a>s without breaking the trace printing: see <a href="ACL2____SET-TRACE-EVISC-TUPLE.html">set-trace-evisc-tuple</a> for how to do this globally, or similarly use the 
 <span class="v">:evisc-tuple</span> option to <span class="v">trace$</span> to do this with a single trace spec. 
 Note however that with value <span class="v">nil</span> specified for <span class="v">:hide</span>, such use of an 
 evisc-tuple will not deal properly with local stobjs (see <a href="ACL2____WITH-LOCAL-STOBJ.html">with-local-stobj</a>) or stobjs bound by <span class="tt"><a href="ACL2____STOBJ-LET.html">stobj-let</a></span>, or with the 
 aforementioned large structures other than the logical <a href="ACL2____WORLD.html">world</a>.</p> 
 
 <p><span class="v">:NATIVE</span></p> 
 
 <p>If <span class="v">:native</span> is supplied with a non-<span class="v">nil</span> value, then the trace spec 
 is passed to the native Lisp trace (after removing the <span class="v">:native</span> option). 
 A trust tag (see <a href="ACL2____DEFTTAG.html">defttag</a>) is required in order to use this option, 
 because no syntactic check is made on the <span class="v">:cond</span>, <span class="v">:entry</span>, or 
 <span class="v">:exit</span> forms  arbitrary raw Lisp may occur in them!</p> 
 
 <p>Note that by ``native Lisp trace'' we mean the currently installed 
 <span class="v">trace</span>.  As discussed briefly elsewhere (see <a href="COMMON-LISP____TRACE.html">trace</a>), ACL2 has 
 modified that trace to be more useful if the underlying host Lisp is GCL, 
 Allegro CL, or CCL (OpenMCL).  If you need the original trace utility supplied 
 for those Lisps, quit the ACL2 loop with <span class="v">:q</span> and call <span class="v">old-trace</span> and 
 <span class="v">old-untrace</span> in raw Lisp where you would otherwise call <span class="v">trace</span> and 
 <span class="v">untrace</span>.  Note that the original trace utility supplied with a given Lisp 
 will not hide the ACL2 logical <a href="ACL2____WORLD.html">world</a> or give special treatment to <a href="ACL2____STOBJ.html">stobj</a>s.</p> 
 
 <p>It is important to understand that if <span class="v">:native t</span> is specified, then all 
 other options are interpreted by the native Lisp trace.  For example, that 
 trace probably has no understanding of the use of <span class="v">:fmt</span> described above 
 for <span class="v">:entry</span> or <span class="v">:exit</span>.  Indeed, the native trace may not even accept 
 any of <span class="v">:cond</span>, <span class="v">:entry</span> or <span class="v">:exit</span>, let alone any of the advanced 
 options!  Moreover, if <span class="v">:native t</span> is specified, then even a 
 <span class="v">:multiplicity</span> option does not provide the meaning of the variable 
 <span class="v">values</span> that one might desire.  In GCL for example, in the case of an 
 <span class="tt"><a href="ACL2____MV.html">mv</a></span> return of a function defined only in raw Lisp (not in ACL2), this 
 variable will be bound to a list containing only the first result.</p> 
 
 <p><span class="v">:NOTINLINE</span></p> 
 
 <p>By default, a new definition installed by <span class="v">trace$</span> will include a 
 <span class="v">notinline</span> declaration so that recursive calls will always be traced. 
 (But see Remark (0) below for an exception involving <a href="ACL2____INVARIANT-RISK.html">invariant-risk</a>.) 
 To avoid this declaration, supply value <span class="v">nil</span>.</p> 
 
 <p>A special value for <span class="v">:notinline</span>, <span class="v">:fncall</span>, will cause the traced 
 function to call its original definition.  Without this special value, the new 
 installed definition for the traced function will include the body of the 
 original definition.  This <span class="v">:fncall</span> behavior is the default only in the 
 following cases:</p> 
 
 <ul> 
 
 <li>for functions whose definitions are built into ACL2;</li> 
 
 <li>for functions that have been added (using a trust tag, an advanced 
 feature, so most users can probably ignore this case) to either of the <span class="tt"><a href="ACL2____STATE.html">state</a></span> global variables <span class="v">program-fns-with-raw-code</span> or 
 <span class="v">logic-fns-with-raw-code</span>;</li> 
 
 <li>for <span class="tt"><a href="ACL2____MEMOIZE.html">memoize</a></span>d functions.</li> 
 
 </ul> 
 
 <p>The legal values for <span class="v">:notinline</span> are <span class="v">t</span> (the default for other than 
 the cases displayed above), <span class="v">nil</span>, and <span class="v">:fncall</span>.</p> 
 
 <h3>Remarks</h3> 
 
 <p>(0) For a <span class="v">:</span><span class="tt"><a href="ACL2____PROGRAM.html">program</a></span> mode function with <a href="ACL2____INVARIANT-RISK.html">invariant-risk</a>, 
 recursive calls are never traced.  To see these recursive calls, use one of 
 the two methods to defeat invariant-risk checking; see <a href="ACL2____INVARIANT-RISK.html">invariant-risk</a>. (Implementation note: This behavior on recursive calls is a 
 consequence of how ACL2 defines the executable-counterpart  also known 
 as the ``*1* function'' (see <a href="ACL2____EVALUATION.html">evaluation</a>)  to call a local 
 function to do the computation.)</p> 
 
 <p>(1) If some of the given trace specs have errors, then <span class="v">trace$</span> will 
 generally print error messages for those but will still process those that do 
 not have errors.  The value returned will indicate the trace specs that were 
 processed successfully.</p> 
 
 <p>(2) If you certify or include a book that redundantly defines a function 
 that is currently traced, then tracing behavior may disappear if a compiled 
 definition is installed for the submitted function or its 
 executable-counterpart (see <a href="ACL2____EVALUATION.html">evaluation</a> for relevant background).</p> 
 
 <p>(3) Some predefined functions are called during tracing.  In order to avoid 
 infinite loops, such calls of traced predefined functions will be made using 
 the original predefined functions, not using their code installed by 
 <span class="v">trace$</span>.</p> 
 
 <p>(4) For a <a href="ACL2____WORMHOLE.html">wormhole</a> such as the <a href="ACL2____BREAK-REWRITE.html">break-rewrite</a> loop, all calls 
 of <span class="v">trace$</span> and <span class="tt"><a href="ACL2____UNTRACE_42.html">untrace$</a></span> inside that wormhole are undone upon exit 
 from the wormhole.  In particular, if you trace or untrace a function during a 
 <span class="tt"><a href="ACL2____BRR.html">brr</a></span> break, then effects of that trace or untrace will disappear when 
 you proceed using a keyword such as <span class="v">:eval</span> or <span class="v">:go</span>.</p>
</body>
</html>
