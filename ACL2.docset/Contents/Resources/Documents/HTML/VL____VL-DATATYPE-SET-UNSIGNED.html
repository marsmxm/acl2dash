<html>
<head>
<meta charset="UTF-8">
<title>Vl-datatype-set-unsigned</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=VL____VL-DATATYPE-SET-UNSIGNED">Click for Vl-datatype-set-unsigned in the Full Manual</a></h3>

<p>Removes any explicit signed indicator from a datatype.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(vl-datatype-set-unsigned x) → new-x</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">x</span> — <font color="#606060">Guard <span class="v">(<a href="VL____VL-DATATYPE-P.html">vl-datatype-p</a> x)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">new-x</span> — <font color="#606060">Type <span class="v">(<a href="VL____VL-DATATYPE-P.html">vl-datatype-p</a> new-x)</span>.</font>
</dd> 
 
</dl></div> 
<p>This is rather specific in purpose and generally shouldn't be used. 
The case where it is useful is when we are indexing into an (explicitly signed) 
packed array; this means that the whole array is signed, but not the selected 
parts.  So we strip the signed qualifier off of the type when we index into 
packed dimensions.  (This doesn't apply to usertypes that are defined as signed 
types!  If we index down to such a type, it IS signed, but any packed array of 
such a type is not.  So we don't need to descend into usertypes or somehow mark 
them as unsigned.  We just have to know that a usertype with one or more packed 
dimensions counts as unsigned.)</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>vl-datatype-set-unsigned</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 vl-datatype-set-unsigned (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="VL____VL-DATATYPE-P.html">vl-datatype-p</a> x)))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((__function__ 'vl-datatype-set-unsigned))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
  (<a href="VL____VL-DATATYPE-CASE.html">vl-datatype-case</a>
     x
     :vl-coretype (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="VL____CHANGE-VL-CORETYPE.html">change-vl-coretype</a> x :signedp nil)
                       :exec (<a href="COMMON-LISP____IF.html">if</a> x.signedp
                                 (<a href="VL____CHANGE-VL-CORETYPE.html">change-vl-coretype</a> x :signedp nil)
                                 x))
     :vl-struct (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="VL____CHANGE-VL-STRUCT.html">change-vl-struct</a> x :signedp nil)
                     :exec (<a href="COMMON-LISP____IF.html">if</a> x.signedp
                               (<a href="VL____CHANGE-VL-STRUCT.html">change-vl-struct</a> x :signedp nil)
                               x))
     :vl-union (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="VL____CHANGE-VL-UNION.html">change-vl-union</a> x :signedp nil)
                    :exec (<a href="COMMON-LISP____IF.html">if</a> x.signedp
                              (<a href="VL____CHANGE-VL-UNION.html">change-vl-union</a> x :signedp nil)
                              x))
     :otherwise (<a href="VL____VL-DATATYPE-FIX.html">vl-datatype-fix</a> x))))</pre> 
<p><b>Theorem: </b>vl-datatype-p-of-vl-datatype-set-unsigned</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> vl-datatype-p-of-vl-datatype-set-unsigned
        (<a href="ACL2____B_A2.html">b*</a> ((new-x (<a href="VL____VL-DATATYPE-SET-UNSIGNED.html">vl-datatype-set-unsigned</a> x)))
            (<a href="VL____VL-DATATYPE-P.html">vl-datatype-p</a> new-x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>vl-datatype-resolved-p-of-set-unsigned</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> vl-datatype-resolved-p-of-set-unsigned
        (<a href="ACL2____B_A2.html">b*</a> ((?new-x (<a href="VL____VL-DATATYPE-SET-UNSIGNED.html">vl-datatype-set-unsigned</a> x)))
            (<a href="ACL2____IMPLIES.html">implies</a> (vl-datatype-resolved-p x)
                     (vl-datatype-resolved-p new-x))))</pre> 
<p><b>Theorem: </b>vl-datatype-set-unsigned-of-vl-datatype-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> vl-datatype-set-unsigned-of-vl-datatype-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="VL____VL-DATATYPE-SET-UNSIGNED.html">vl-datatype-set-unsigned</a> (<a href="VL____VL-DATATYPE-FIX.html">vl-datatype-fix</a> x))
               (<a href="VL____VL-DATATYPE-SET-UNSIGNED.html">vl-datatype-set-unsigned</a> x)))</pre> 
<p><b>Theorem: </b>vl-datatype-set-unsigned-vl-datatype-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> vl-datatype-set-unsigned-vl-datatype-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="VL____VL-DATATYPE-EQUIV.html">vl-datatype-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="VL____VL-DATATYPE-SET-UNSIGNED.html">vl-datatype-set-unsigned</a> x)
                        (<a href="VL____VL-DATATYPE-SET-UNSIGNED.html">vl-datatype-set-unsigned</a> x-equiv)))
        :rule-classes :congruence)</pre> 

</body>
</html>
