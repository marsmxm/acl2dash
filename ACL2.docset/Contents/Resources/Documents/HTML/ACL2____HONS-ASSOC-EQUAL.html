<html>
<head>
<meta charset="UTF-8">
<title>Hons-assoc-equal</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____HONS-ASSOC-EQUAL">Click for Hons-assoc-equal in the Full Manual</a></h3>

<p><span class="v">(<a href="ACL2____HONS-ASSOC-EQUAL.html">hons-assoc-equal</a> key alist)</span> is <b>not fast</b>; it serves as 
the logical definition for <span class="tt"><a href="ACL2____HONS-GET.html">hons-get</a></span>.</p><p>The definition of <span class="v">hons-assoc-equal</span> is similar to that of 
 <span class="tt"><a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a></span>, except that (1) it does not require <span class="tt"><a href="ACL2____ALISTP.html">alistp</a></span> as a 
 guard, and (2) it "skips over" any non-conses when its alist argument is 
 malformed.</p> 
 
 <p>We typically leave <span class="v">hons-get</span> enabled and reason about 
 <span class="v">hons-assoc-equal</span> instead.  One benefit of this approach is that it avoids 
 certain "false" discipline warnings that might arise from execution during 
 theorem proving.</p> 
 
 <p><b>Function: </b>hons-assoc-equal</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> hons-assoc-equal (key alist)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____ATOM.html">atom</a> alist) nil)
             ((<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CAR.html">car</a> alist))
                   (<a href="ACL2____HONS-EQUAL.html">hons-equal</a> key (<a href="COMMON-LISP____CAAR.html">caar</a> alist)))
              (<a href="COMMON-LISP____CAR.html">car</a> alist))
             (t (<a href="ACL2____HONS-ASSOC-EQUAL.html">hons-assoc-equal</a> key (<a href="COMMON-LISP____CDR.html">cdr</a> alist)))))</pre>
</body>
</html>
