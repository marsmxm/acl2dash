<html>
<head>
<meta charset="UTF-8">
<title>Future-work-related-to-the-tau-system</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____FUTURE-WORK-RELATED-TO-THE-TAU-SYSTEM">Click for Future-work-related-to-the-tau-system in the Full Manual</a></h3>

<p>Some tau system problems that we hope someone will address</p><p>The tau system is inexpressive compared to modern polymorphic type 
 systems — something that may be unavoidable in an untyped first-order 
 language.  However, we believe its effectiveness could be greatly increased by 
 the development of some additional tools.  We also believe that most of these 
 tools could be provided by ACL2 users creating certified community books that 
 exploit the basic tools already provided.  It is likely the initial attempts 
 to create such books will show the inadequacy of some of the current 
 algorithms and data structures in the tau system and might point the way to 
 improvements.</p> 
 
 <p>As implementors of ACL2 our preference is to support the improvement of the 
 core algorithms and data structures and provide customizable hooks allowing 
 users to exploit them by developing effective and convenient interfaces. 
 However, we want the further elaboration and optimization of the tau system to 
 be based on user experience not just speculation.</p> 
 
 <p>Some tools we <i>think</i> might help are listed below.  We invite 
 volunteers and further suggestions.</p> 
 
 <p><i>A tau-centric signature notation</i> for use in function definitions, 
 exploited by a macro replacing <span class="v">defun</span> so that input-output relationships 
 phrased in tau terms are proved as <span class="v">:tau-system</span> rules immediately after 
 functions are introduced:</p> 
 
 <p>We have, for example, experimented with a book defining a macro that allows 
 the definition of the function <span class="v">ap</span> (append) accompanied by a signature 
 rule.  Subsequent <span class="v">defsig</span> events can add other signatures in the same 
 notation.</p> 
 
 <pre class="code">(defsig ap (<a href="ACL2____TRUE-LISTP.html">true-listp</a> * true-listp ==&gt; true-listp) (x y)
   (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x)
       (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> x) (ap (<a href="COMMON-LISP____CDR.html">cdr</a> x) y))
       y))

(defsig ap (<a href="ACL2____INTEGER-LISTP.html">integer-listp</a> * integer-listp ==&gt; integer-listp))</pre> 
 
 <p>This experimental book provides succinct syntax for all tau signatures. 
 For example, that book parses the signature</p> 
 
 <pre class="code">(<a href="ACL2____NATP.html">NATP</a> (<a href="COMMON-LISP_____F2_D3.html">/=</a> 3 5 7) (<a href="COMMON-LISP_____C3.html">&lt;</a> 16) * TRUE-LISTP ==&gt; BOOLEANP * INTEGER-LISTP * NATP)</pre> 
 
 <p>to be the signature of a function with two inputs and three outputs.  The 
 first input must be a natural number, different from 3, 5, and 7, and less 
 than 16.  The second input must be a true list.  The first output is a 
 boolean, the second a list of integers, and the third a natural.</p> 
 
 <p>To express this signature for function <span class="v">fn</span> as a formula requires 
 significantly more typing by the user:</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____AND.html">AND</a> (<a href="ACL2____NATP.html">NATP</a> X)
              (<a href="COMMON-LISP____NOT.html">NOT</a> (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> X 3))
              (<a href="COMMON-LISP____NOT.html">NOT</a> (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> X 5))
              (<a href="COMMON-LISP____NOT.html">NOT</a> (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> X 7))
              (<a href="COMMON-LISP_____C3.html">&lt;</a> X 16)
              (<a href="ACL2____TRUE-LISTP.html">TRUE-LISTP</a> Y))
         (<a href="COMMON-LISP____AND.html">AND</a> (<a href="ACL2____BOOLEANP.html">BOOLEANP</a> (<a href="ACL2____MV-NTH.html">MV-NTH</a> 0 (FN X Y)))
              (INTEGER-LISP (<a href="ACL2____MV-NTH.html">MV-NTH</a> 1 (FN X Y)))
              (<a href="ACL2____NATP.html">NATP</a> (<a href="ACL2____MV-NTH.html">MV-NTH</a> 2 (FN X Y)))))</pre> 
 
 <p>We suspect that the provision of some succinct tau-centric notation (not 
 necessarily the one above) for signatures at definition-time will mean users 
 get more benefit from the tau system.</p> 
 
 <p><i>Some tau inference mechanisms</i>: This phrase suggests two different 
 improvements.  One is to implement a mechanism that adds or completes 
 signatures for function definitions by exploiting knowledge of commonly used 
 recursive schemas and the signatures of the subroutines in the body.  For 
 example, the definition of <span class="v">ap</span> above rather obviously has the 
 signature</p> 
 
 <pre class="code">(<a href="ACL2____INTEGER-LISTP.html">integer-listp</a> * integer-listp ==&gt; integer-listp)</pre> 
 
 <p>and many others just based on the two recursive schemas that (a) collect 
 certain elements from lists and (b) check that all elements have a certain 
 property.</p> 
 
 <p>The other ``tau inference'' improvement is to implement a mechanism for 
 inferring relations between user-defined Booleans, perhaps by exploiting 
 example generation, testing, and knowledge of recursive schemas.  For example, 
 it is fairly obvious that <span class="tt"><a href="ACL2____SYMBOL-ALISTP.html">symbol-alistp</a></span> implies <span class="tt"><a href="ACL2____ALISTP.html">alistp</a></span>. 
 Making the user state these relations invites omissions that render the tau 
 system very unpredictable.</p> 
 
 <p><i>A tau assistant</i>: It would be useful to have a way to find out what 
 tau rules are missing.  Given a term that the user believes should 
 ``obviously'' have some tau (``type'') what rules might be added to make the 
 tau algorithm compute that expected tau?  For example, if <span class="v">(<a href="ACL2____G.html">g</a> x)</span> is known 
 to satisfy <span class="v">P</span> and <span class="v">(f x)</span> is known to satisfy <span class="v">R</span> when its argument 
 satisfies <span class="v">S</span>:</p> 
 
 <pre class="code">g : T ==&gt; P
f : S ==&gt; R</pre> 
 
 <p>then if the user asserts that <span class="v">(f (<a href="ACL2____G.html">g</a> x))</span> ``ought'' to have tau <span class="v">R</span>, 
 one plausible suggestion is the simple tau rule that <span class="v">(P x)</span> implies <span class="v">(<a href="ACL2____S.html">S</a>
 x)</span>.  Such assistance — while still confronting an undecidable problem 
 — might be easier to implement within the tau framework than more 
 generally in ACL2.  (Many users have wanted such an assistant to suggest 
 lemmas for the rewriter.)</p>
</body>
</html>
