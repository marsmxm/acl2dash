<html>
<head>
<meta charset="UTF-8">
<title>Resulterr-limitp</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=YUL____RESULTERR-LIMITP">Click for Resulterr-limitp in the Full Manual</a></h3>

<p>Recognize limit errors.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(resulterr-limitp x) → yes/no</pre></dt>
<dt>Returns</dt>
<dd>
<span class="tt">yes/no</span> — <font color="#606060">Type <span class="v">(<a href="ACL2____BOOLEANP.html">booleanp</a> yes/no)</span>.</font>
</dd> 
 
</dl></div> 
<p>As explained in the <a href="YUL____DYNAMIC-SEMANTICS.html">dynamic semantics</a>, the ACL2 functions that formalize the execution of Yul code 
     take an artificial limit counter as input, 
     and return an error when that limit is exhausted. 
     This is one of several kinds of errors that may be returned 
     by those ACL2 functions, which formalize a defensive dynamic semantics.</p><p>Here we define a predicate that recognizes limit errors, 
     i.e. values of type <span class="tt"><a href="FTY____RESULTERR.html">resulterr</a></span> 
     whose innermost information starts with the keyword <span class="v">:limit</span>, 
     where `innermost' refers to 
     the stack discussed in <span class="tt"><a href="FTY____ERR.html">err</a></span> and <span class="tt"><a href="FTY____ERR-PUSH.html">fty::err-push</a></span>. 
     The adequacy of this predicate definition depends on 
     the definition of the ACL2 execution functions for Yul, 
     in particular the fact that they return error limits of this form. 
     This predicate must be adapted if that form changes.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>resulterr-limitp-aux</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> resulterr-limitp-aux (stack)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'resulterr-limitp-aux))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
            (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____ATOM.html">atom</a> stack) nil)
                  ((<a href="COMMON-LISP____ATOM.html">atom</a> (<a href="COMMON-LISP____CDR.html">cdr</a> stack))
                   (<a href="ACL2____B_A2.html">b*</a> ((fun-info (<a href="COMMON-LISP____CAR.html">car</a> stack))
                        ((unless (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> fun-info)
                                      (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> fun-info))))
                         nil)
                        (info (<a href="COMMON-LISP____CADR.html">cadr</a> fun-info))
                        ((unless (<a href="COMMON-LISP____CONSP.html">consp</a> info)) nil))
                       (<a href="COMMON-LISP____EQ.html">eq</a> (<a href="COMMON-LISP____CAR.html">car</a> info) :limit)))
                  (t (resulterr-limitp-aux (<a href="COMMON-LISP____CDR.html">cdr</a> stack))))))</pre> 
<p><b>Theorem: </b>booleanp-of-resulterr-limitp-aux</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> booleanp-of-resulterr-limitp-aux
        (<a href="ACL2____B_A2.html">b*</a> ((yes/no (resulterr-limitp-aux stack)))
            (<a href="ACL2____BOOLEANP.html">booleanp</a> yes/no))
        :rule-classes :rewrite)</pre> 
<p><b>Function: </b>resulterr-limitp</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> resulterr-limitp (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'resulterr-limitp))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
            (<a href="COMMON-LISP____AND.html">and</a> (<a href="FTY____RESULTERRP.html">resulterrp</a> x)
                 (<a href="ACL2____B_A2.html">b*</a> ((info (<a href="FTY____RESULTERR-_E3INFO.html">fty::resulterr-&gt;info</a> x)))
                     (resulterr-limitp-aux info)))))</pre> 
<p><b>Theorem: </b>booleanp-of-resulterr-limitp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> booleanp-of-resulterr-limitp
        (<a href="ACL2____B_A2.html">b*</a> ((yes/no (<a href="YUL____RESULTERR-LIMITP.html">resulterr-limitp</a> x)))
            (<a href="ACL2____BOOLEANP.html">booleanp</a> yes/no))
        :rule-classes :rewrite)</pre> 

</body>
</html>
