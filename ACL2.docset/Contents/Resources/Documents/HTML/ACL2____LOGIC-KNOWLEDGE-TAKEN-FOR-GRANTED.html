<html>
<head>
<meta charset="UTF-8">
<title>Logic-knowledge-taken-for-granted</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____LOGIC-KNOWLEDGE-TAKEN-FOR-GRANTED">Click for Logic-knowledge-taken-for-granted in the Full Manual</a></h3>

<p>Background knowledge in ACL2 logic for theorem prover tutorial</p><p>You might think that in order to use the theorem prover you have to 
 know the mathematical logic supported by ACL2.  But you need to know a lot 
 less about it than you might think.</p> 
 
 <p>Technically, a theorem is a formula that can be derived from axioms by 
 using rules of inference.  Thus, to do a proof you have to know (a) the syntax 
 of formulas, (b) the axioms, and (c) the rules of inference.  Traditionally, 
 these things are spelled out in excruciating detail in treatments of 
 mathematical logic â€” and for good reason.</p> 
 
 <p>The whole point of proving theorems is that it is a way to determine that a 
 formula is ``always true'' (under some model of the axioms).  By ``always 
 true'' we actually mean what logicians mean when they say the formula is 
 <i>valid</i>: true in the model, for all possible values of the variables. 
 Here by ``model of the axioms'' we mean an understanding of the meaning of the 
 various function symbols so that the axioms are true for all values of the 
 variables.  If the variables in your conjecture can take on an infinite number 
 of values, proof is often the <b>only</b> way to determine that a conjecture 
 is ``always true.''  So if proof is being used to determine that a 
 questionable formula is always true the proof must be carried out flawlessly. 
 Thus, the (a) syntax, (b) axioms, and (c) rules of inference must be described 
 precisely and followed to the letter.</p> 
 
 <p>But formal mathematical logic was invented to explain how people reason. 
 To the extent that logic mimics human reasoning, proofs can be seen as just 
 extremely carefully crafted arguments.  Given that ACL2 is responsible for 
 following the rules ``to the letter,'' your main job is ``explain'' the big 
 leaps.</p> 
 
 <p>To use the theorem prover you must understand (a) the syntax, because you 
 must be able to write formulas flawlessly.  But you don't have to know (b) the 
 axioms and (c) the rules of inference at nearly the same level of precision, 
 as long as you understand the basic structure and language of proofs.</p> 
 
 <p>Below is part of a proof of a certain theorem.  You ought to be able to 
 understand the following.  Since what we describe is a proof of one case of 
 the formula, we hope that you're <i>convinced</i> that the formula holds for 
 that case.</p> 
 
 <p>Read this and follow the links to confirm that you understand what happens. 
 Be sure to then use your browser's <b>Back Button</b> to return to this page 
 and continue.</p> 
 
 <p><b>An Annotated Proof of</b></p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> z)
         (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____REV.html">rev</a> (<a href="ACL2____REV.html">rev</a> z)) z))</pre> 
 
 <p>``We will prove that reversing the reverse of a <span class="v">true-listp</span> yields the 
 original list.  The formula stating this is above.  We will prove it by <a href="ACL2____LOGIC-KNOWLEDGE-TAKEN-FOR-GRANTED-INDUCTIVE-PROOF.html">induction</a> on the 
 list structure of <span class="v">z</span>.</p> 
 
 <p>The <a href="ACL2____LOGIC-KNOWLEDGE-TAKEN-FOR-GRANTED-BASE-CASE.html">base 
 case</a> of the induction is:</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____ENDP.html">endp</a> z)
         (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> z)
                  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____REV.html">rev</a> (<a href="ACL2____REV.html">rev</a> z)) z))).</pre> 
 
 <p>This formula is equivalent, by <a href="ACL2____LOGIC-KNOWLEDGE-TAKEN-FOR-GRANTED-PROPOSITIONAL-CALCULUS.html">propositional 
 calculus</a>, to</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____ENDP.html">endp</a> z)
              (<a href="ACL2____TRUE-LISTP.html">true-listp</a> z))
         (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____REV.html">rev</a> (<a href="ACL2____REV.html">rev</a> z)) z))</pre> 
 
 <p><a href="ACL2____LOGIC-KNOWLEDGE-TAKEN-FOR-GRANTED-REWRITING.html">Rewriting</a> with the 
 definition of <span class="v">endp</span> produces:</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> z))
              (<a href="ACL2____TRUE-LISTP.html">true-listp</a> z))
         (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____REV.html">rev</a> (<a href="ACL2____REV.html">rev</a> z)) z))</pre> 
 
 <p><a href="ACL2____LOGIC-KNOWLEDGE-TAKEN-FOR-GRANTED-REWRITING-REPEATEDLY.html">Rewriting 
 repeatedly</a> starting with the definition of <span class="v">true-listp</span> produces:</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> z))
              (<a href="COMMON-LISP____EQUAL.html">equal</a> z nil))
         (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____REV.html">rev</a> (<a href="ACL2____REV.html">rev</a> z)) z))</pre> 
 
 <p>Then using the second <i>hypothesis</i>, just <a href="ACL2____LOGIC-KNOWLEDGE-TAKEN-FOR-GRANTED-EQUALS-FOR-EQUALS.html">substituting equals for 
 equals</a>, we get</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> z))
              (<a href="COMMON-LISP____EQUAL.html">equal</a> z nil))
         (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____REV.html">rev</a> (<a href="ACL2____REV.html">rev</a> nil)) nil))</pre> 
 
 <p>Since the <i>conclusion</i> involves no variables, we can <a href="ACL2____LOGIC-KNOWLEDGE-TAKEN-FOR-GRANTED-EVALUATION.html">evaluate</a> it, getting</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> z))
              (<a href="COMMON-LISP____EQUAL.html">equal</a> z nil))
         T)</pre> 
 
 <p>But this is an <a href="ACL2____LOGIC-KNOWLEDGE-TAKEN-FOR-GRANTED-INSTANCE.html">instance</a> of the <a href="ACL2____LOGIC-KNOWLEDGE-TAKEN-FOR-GRANTED-PROPOSITIONAL-CALCULUS.html">tautology</a> 
 <span class="v">(<a href="ACL2____IMPLIES.html">implies</a> p T)</span>.  Thus, the base case is proved.''</p> 
 
 <p>Now it is time for a little quiz.  There are just three questions.</p> 
 
 <p><b>Q1</b>: The case above was the Base Case of an inductive proof of</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> z)
         (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____REV.html">rev</a> (<a href="ACL2____REV.html">rev</a> z)) z))</pre> 
 
 <p>in which we did induction on the structure of the linear list <span class="v">z</span>.  What 
 is the Induction Step?  That is, what do you have to prove besides the Base 
 Case to complete this inductive proof?</p> 
 
 <p>Below are four commonly given answers; choose one.  Then look <a href="ACL2____LOGIC-KNOWLEDGE-TAKEN-FOR-GRANTED-Q1-ANSWER.html">here</a> to find 
 out if you're right.</p> 
 
 <pre class="code"><i>Induction Step -- Choice (i)</i>: 
(implies (not (endp z)) 
         (implies (true-listp z) 
                  (equal (rev (rev z)) z))) 
 
<i>Induction Step -- Choice (ii)</i>: 
(implies (true-listp (cdr z)) 
         (equal (rev (rev (cdr z))) (cdr z))) 
 
<i>Induction Step -- Choice (iii)</i>: 
(implies (and (not (endp z)) 
              (equal (rev (rev (cdr x))) (cdr x))) 
         (implies (true-listp z) 
                  (equal (rev (rev z)) z))) 
 
<i>Induction Step -- Choice (iv)</i>: 
(implies (and (not (endp z)) 
              (implies (true-listp (cdr z)) 
                       (equal (rev (rev (cdr z))) (cdr z)))) 
         (implies (true-listp z) 
                  (equal (rev (rev z)) z))) 
</pre> 
 
 <p><b>Q2</b>: To prove the Induction Step we must prove one or more of the 
 goals below.</p> 
 
 <p>Which combinations are sufficient to imply the Induction Step?  Decide what 
 is required and then look <a href="ACL2____LOGIC-KNOWLEDGE-TAKEN-FOR-GRANTED-Q2-ANSWER.html">here</a> to find out if you're 
 right.  To help you, the Induction Step is of the form:</p> 
 
 <pre class="code"><i>Induction Step</i>: 
(implies (and <i>c</i> 
              (implies <i>p'</i> <i>q'</i>)) 
         (implies <i>p</i> <i>q</i>)) 
</pre> 
 
 <p>and beside each candidate subgoal we show its structure in those terms.</p> 
 
 <pre class="code"><i>Subgoal (i)</i>: 
(implies (and (not (endp z))                        ; (implies (and <i>c</i> 
              (true-listp z))                       ;               <i>p</i>) 
         (true-listp (cdr z)))                      ;          <i>p'</i>) 
 
<i>Subgoal (ii)</i>: 
(implies (and (not (endp z))                        ; (implies (and <i>c</i> 
              (true-listp z)                        ;               <i>p</i> 
              (equal (rev (rev (cdr z))) (cdr z)))  ;               <i>q'</i>) 
         (equal (rev (rev z)) z))                   ;          <i>q</i>) 
 
<i>Subgoal (iii)</i>: 
(implies (and (not (endp z))                        ; (implies (and <i>c</i> 
              (equal (rev (rev (cdr z))) (cdr z)))  ;               <i>q'</i>) 
         (equal (rev (rev z)) z))                   ;          <i>q</i>) 
 
<i>Subgoal (iv)</i>: 
(implies (and (not (endp z))                        ; (implies (and <i>c</i> 
              (true-listp (cdr z))                  ;               <i>p'</i> 
              (equal (rev (rev (cdr z))) (cdr z)))  ;               <i>q'</i>) 
         (equal (rev (rev z)) z))                   ;          <i>q</i>) 
</pre> 
 
 <p><b>Q3</b>: Suppose you know the theorem</p> 
 
 <pre class="code"><i>Theorem</i>: 
(implies (p (f x)) 
         (equal (g (h x)) 
                x)) 
</pre> 
 
 <p>and you wish to rewrite the target <span class="v">(<a href="ACL2____G.html">g</a> (h a))</span> to <span class="v">a</span> in</p> 
 
 <pre class="code"><i>Goal Conjecture</i>: 
(implies (and (q (f a)) 
              (r a)) 
         (s (g (h a)))) 
</pre> 
 
 <p>What must you prove to relieve the hypothesis of <i>Theorem</i>?</p> 
 
 <p>After you've thought about it, look <a href="ACL2____LOGIC-KNOWLEDGE-TAKEN-FOR-GRANTED-Q3-ANSWER.html">here</a> for our answer.</p> 
 
 <p><b>End of the Quiz</b></p> 
 
 <p>If this page made sense, you're ready to read the introduction to the 
 theorem prover.</p> 
 
 <p>If you are reading this as part of the tutorial introduction to the theorem 
 prover, use your browser's <b>Back Button</b> now to return to <a href="ACL2____INTRODUCTION-TO-THE-THEOREM-PROVER.html">introduction-to-the-theorem-prover</a>.</p>
</body>
</html>
