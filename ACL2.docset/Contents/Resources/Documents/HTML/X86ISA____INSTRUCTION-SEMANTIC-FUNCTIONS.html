<html>
<head>
<meta charset="UTF-8">
<title>Instruction-semantic-functions</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=X86ISA____INSTRUCTION-SEMANTIC-FUNCTIONS">Click for Instruction-semantic-functions in the Full Manual</a></h3>

<p>Instruction Semantic Functions</p><p>The instruction semantic functions have dual roles:</p> 
 
<ol> 
 <li>They fetch the instruction's operands, as dictated by the decoded 
  components of the instruction (like the prefixes, SIB byte, etc.) 
  provided as input; these decoded components are provided by our x86 
  decoder function <a href="X86ISA____X86-FETCH-DECODE-EXECUTE.html">x86-fetch-decode-execute</a>.</li> 
 
  <li> They contain or act as the functional specification of the 
  instructions.  For example, the functional specification function of 
  the ADD instruction returns two values: the appropriately truncated 
  sum of the operands and the modified flags. We do not deal with the 
  x86 state in these specifications.</li> 
</ol> 
 
<p>Each semantic function takes, among other arguments, the value 
<span class="v">start-rip</span> of the instruction pointer at the beginning of the 
instruction, and the value <span class="v">temp-rip</span> of the instruction pointer 
after the decoding of the prefixes, REX byte, opcode, ModR/M byte, and 
SIB byte (some of these bytes may not be present).  The semantic 
function may further increment the instruction pointer beyond 
<span class="v">temp-rip</span> to read the ending bytes of the instruction, e.g. to 
read a displacement or an immediate.  The semantic function eventually 
writes the final value of the instruction pointer into RIP.</p> 
 

</body>
</html>
