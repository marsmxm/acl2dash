<html>
<head>
<meta charset="UTF-8">
<title>Atc-tutorial-events</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=C____ATC-TUTORIAL-EVENTS">Click for Atc-tutorial-events in the Full Manual</a></h3>

<p>ATC tutorial: ACL2 events generated by ATC.</p><p>(This page may be skipped at first reading.)</p><p>As briefly mentioned in <a href="C____ATC-TUTORIAL-INT-PROGRAMS.html">atc-tutorial-int-programs</a>, 
    ATC generates some events, besides the C file. 
    This page describes these events in more detail.</p><p>These events are generated only if the <span class="v">:proofs</span> option is <span class="v">t</span>, 
    which is the default, i.e. if proofs are generated. 
    The events all pertain to the proofs. 
    When <span class="v">:proofs</span> is <span class="v">nil</span>, ATC only generates the C file.</p><p>These events are generated in an <span class="tt"><a href="ACL2____ENCAPSULATE.html">encapsulate</a></span>, 
    from which they are exported. 
    The <span class="tt"><a href="ACL2____ENCAPSULATE.html">encapsulate</a></span> also includes 
    some locally generated events that support the exported events. 
    The option <span class="v">:print :all</span> can be used to see all the events, 
    including the local ones.</p><h5>Program Constant</h5><p>ATC generates a named constant whose value is 
    the AST of the generated C program. 
    More precisely, it is the AST of the generated translation unit, 
    which is a value of the fixtype <span class="tt"><a href="C____TRANSUNIT.html">transunit</a></span> in <a href="C____ATC-ABSTRACT-SYNTAX.html">ATC's abstract syntax of C</a>. The translation unit is the content of the generated file: 
    the AST is <a href="C____ATC-PRETTY-PRINTER.html">pretty-printed</a> to the <span class="v">.c</span> file. 
    Currently ATC generates C programs that consist of 
    single translation units in single C files.</p><p>The <span class="v">:const-name</span> option directly controls the name of this constant.</p><p>The reason for generating this constant is so that 
    it can be used in the generated theorems described next, 
    making the theorems more readable.</p><h5>Static Correctness Theorem</h5><p>ATC generates a theorem asserting that 
    the generated C program is statically correct, 
    according to <a href="C____ATC-STATIC-SEMANTICS.html">ATC's static semantics of C</a>.</p><p>More precisely, ATC generates a theorem of the form</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> &lt;constant&gt;-well-formed
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____CHECK-TRANSUNIT.html">check-transunit</a> &lt;constant&gt;) :wellformed))</pre><p>This asserts that 
    when <span class="tt"><a href="C____CHECK-TRANSUNIT.html">check-transunit</a></span> is applied 
    to the named constant described above 
    (i.e. the abstract syntax of the generated C program), 
    the result is the value <span class="v">:wellformed</span>. 
    That is, the AST satisfies all the requirements 
    of the static semantics of C: 
    the code can be compiled by a C compiler, 
    which is a prerequisite for executing it.</p><p>Since the program AST is a constant 
    and <span class="tt"><a href="C____CHECK-TRANSUNIT.html">check-transunit</a></span> is executable, 
    the theorem is proved easily by execution.</p><p>The name of the theorem is obtained by appending <span class="v">-well-formed</span> 
    after the name of the constant for the generated program. 
    Currently ATC provides no option 
    to control directly the name of this theorem; 
    it can be controlled only indirectly, 
    via the <span class="v">:const-name</span> option for the constant name (see above).</p><h5>Dynamic Correctness Theorems</h5><p>ATC generates theorems asserting that 
    the generated C program is dynamically correct, 
    according to <a href="C____ATC-DYNAMIC-SEMANTICS.html">ATC's dynamic semantics of C</a>.</p><p>More precisely, for each target function <span class="v">fn</span> 
    (see <a href="C____ATC-TUTORIAL-MULTIPLE-FUNCTIONS.html">atc-tutorial-multiple-functions</a> for details on 
    how multiple ACL2 functions are translated to corresponding C functions), 
    ATC generates a theorem of the form</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> &lt;constant&gt;-&lt;fn&gt;-correct
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> &lt;guard-of-fn&gt;
                (<a href="C____COMPUSTATEP.html">compustatep</a> compst)
                (<a href="COMMON-LISP____INTEGERP.html">integerp</a> limit)
                (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> limit &lt;number&gt;))
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____EXEC-FUN.html">exec-fun</a> (<a href="C____IDENT.html">ident</a> "&lt;fn&gt;")
                            (<a href="COMMON-LISP____LIST.html">list</a> &lt;x1&gt; ... &lt;xn&gt;)
                            compst
                            (<a href="C____INIT-FUN-ENV.html">init-fun-env</a> &lt;constant&gt;)
                            limit)
                  (&lt;fn&gt; &lt;x1&gt; ... &lt;xn&gt;))))</pre><p>This asserts that, under the guard of <span class="v">fn</span>, 
    running the C function corresponding to <span class="v">fn</span> 
    yields the same result as <span class="v">fn</span>. 
    Here, <span class="v">&lt;x1&gt;</span>, ..., <span class="v">&lt;xn&gt;</span> are the formal parameters of <span class="v">fn</span>.</p><p>The variable <span class="v">compst</span> represents the C computation state, 
    described in the <a href="C____ATC-DYNAMIC-SEMANTICS.html">C dynamic semantics</a>: the theorem applies to execution in every possible computation state.</p><p>The term <span class="v">(<a href="C____INIT-FUN-ENV.html">init-fun-env</a> &lt;constant&gt;)</span> constructs the <a href="C____ATC-FUNCTION-ENVIRONMENTS.html">C function environment</a> of the generated translation unit.</p><p>The variable <span class="v">limit</span> and the <span class="v">&lt;number&gt;</span> that provides a lower bound 
    are motivated by the fact that the big-step execution functions 
    take a limit value, as explained in the <a href="C____ATC-DYNAMIC-SEMANTICS.html">C dynamic semantics</a>. The number is calculated by ATC as sufficient to execute the function. 
    The theorem asserts that, for any limit value at or above that limit, 
    execution terminates and yields the same result as <span class="v">fn</span>.</p><p>We remark that the form of the theorem above is accurate 
    when none of the function's arguments are pointers. 
    When they are, the theorem has a slightly more general form, 
    which will be described in upcoming tutorial pages.</p><p>Note that, since <span class="v">fn</span> does not return error values, 
    the theorem implies that the execution of the C code 
    never results in an error, including unsafe operations. 
    This is because the dynamic semantics is defensive, 
    i.e. it checks the validity of every operation before performing it, 
    returning an error if the operation is invalid.</p><p>The guard satisfaction hypothesis is critical. 
    Without it, the C code may return some error, 
    e.g. if the result of an <span class="v">int</span> addition does not fit in an <span class="v">int</span>. 
    Also see the discussion in <a href="C____ATC-TUTORIAL-INT-REPRESENTATION.html">atc-tutorial-int-representation</a> 
    about the guards of the ACL2 functions that represent C operations.</p><p>The dynamic semantics of C is formalized in terms of 
    a deep embedding of C in ACL2: 
    C ASTs are explicitly modeled in ACL2, 
    and (static and dynamic) semantics is defined on the ASTs. 
    In contrast, the ACL2 representation of C programs, 
    e.g. as described in <span class="tt"><a href="C____ATC-TUTORIAL-INT-REPRESENTATION.html">atc-tutorial-int-representation</a></span>, 
    is like a shallow embedding of C in ACL2. 
    Thus, the correctness theorem above provides 
    a bridge between shallow and deep embedding. 
    The two embeddings are in close correspondence by design, 
    but the proofs are still not trivial, 
    because the two embeddings 
    are actually quite different in nature and details.</p><p>The correctness theorem above is proved by 
    expanding <span class="v">fn</span> (for the shallow embedding) 
    and symbolically executing its C counterpart (for the deep embedding). 
    The two converge to the same (non-error) result.</p><p>These correctness proofs for functions are 
    modular with respect to the function call graph: 
    theorems about the correctness of callees 
    are used to prove theorems about the correctness of callers. 
    This is achieved via locally generated theorems 
    that are more general than the exported ones 
    (the latter are not compositional). 
    Future versions of ATC may 
    export these theorems from the <span class="tt"><a href="ACL2____ENCAPSULATE.html">encapsulate</a></span>.</p><p>See <span class="tt"><a href="C____ATC-PROOF-SUPPORT.html">atc-proof-support</a></span> and <span class="tt"><a href="C____ATC-IMPLEMENTATION.html">atc-implementation</a></span> for details 
    on the generated theorems and their proofs.</p><h5>Code Generation after the Events</h5><p>The actual code is generated (i.e. written into the file) 
    after the events above have been successfully processed by ACL2. 
    Thus, if one of the theorems above fails for some reason, 
    no code is generated. 
    The rationale is that, unless the code can be proved correct, 
    it should not be generated. 
    Of course, this is easily defated by setting <span class="v">:proofs</span> to <span class="v">nil</span>. 
    Nonetheless, when <span class="v">:proofs</span> is <span class="v">t</span>, 
    it seems appropriate to generate the code after the proofs.</p><p>This deferral is achieved by having ATC not generate the code directly, 
    but by having ATC generate an event that generates the code. 
    Thus, ATC generates this and the events above, 
    putting the latter before the former, 
    and submits the events, in that order. 
    The effect is as desired.</p><div class="box"></div><p><b>Previous:</b> <a href="C____ATC-TUTORIAL-MULTIPLE-FUNCTIONS.html">ACL2 representation and generation of multiple C functions</a></p><p><b>Next:</b> <a href="C____ATC-TUTORIAL-LOCAL-VARIABLES.html">ACL2 representation of C local variables</a></p>
</body>
</html>
