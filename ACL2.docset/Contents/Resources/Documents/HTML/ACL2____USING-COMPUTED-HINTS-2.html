<html>
<head>
<meta charset="UTF-8">
<title>Using-computed-hints-2</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____USING-COMPUTED-HINTS-2">Click for Using-computed-hints-2 in the Full Manual</a></h3>

<p>One Hint to Every Top-Level Goal in a Forcing Round</p><p>Suppose the main proof completes with a forcing round on three 
 subgoals, "[1]Subgoal 3", "[1]Subgoal 2", and "[1]Subgoal 1".  Suppose 
 you wish to <span class="v">:use lemma42</span> in all top-level goals of the first forcing 
 round.  This can be done supplying the hint</p> 
 
 <pre class="code">(<a href="COMMON-LISP____IF.html">if</a> test '(:use lemma42) nil),</pre> 
 
 <p>where <span class="v">test</span> is an expression that returns <span class="v">t</span> when <span class="v">ID</span> is one of 
 the clause ids in question.</p> 
 
 <pre class="code">    goal-spec     (parse-clause-id goal-spec)

"[1]Subgoal 3"        ((1) (3) . 0)
"[1]Subgoal 2"        ((1) (2) . 0)
"[1]Subgoal 1"        ((1) (1) . 0)</pre> 
 
 <p>Recall (see <a href="ACL2____CLAUSE-IDENTIFIER.html">clause-identifier</a>) that <span class="v">parse-clause-id</span> maps from a 
 goal spec to a clause id, so you can use that function on the goal specs 
 printed in the failed proof attempt to determine the clause ids in 
 question.</p> 
 
 <p>So one acceptable <span class="v">test</span> is</p> 
 
 <pre class="code">(<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> id '(((1) (3) . 0)
                   ((1) (2) . 0)
                   ((1) (1) . 0)))</pre> 
 
 <p>or you could use <span class="v">parse-clause-id</span> in your computed hint if you don't 
 want to see clause ids in your script:</p> 
 
 <pre class="code">(<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> id (parse-clause-id "[1]Subgoal 3"))
    (<a href="COMMON-LISP____EQUAL.html">equal</a> id (parse-clause-id "[1]Subgoal 2"))
    (<a href="COMMON-LISP____EQUAL.html">equal</a> id (parse-clause-id "[1]Subgoal 1")))</pre> 
 
 <p>or you could use the inverse function (see <a href="ACL2____CLAUSE-IDENTIFIER.html">clause-identifier</a>):</p> 
 
 <pre class="code">(<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> (string-for-tilde-@-clause-id-phrase id)
              '("[1]Subgoal 3"
                "[1]Subgoal 2"
                "[1]Subgoal 1"))</pre> 
 
 <p>Recall that what we've shown above are the tests to use in the computed 
 hint.  The hint itself is <span class="v">(<a href="COMMON-LISP____IF.html">if</a> test '(:use lemma42) nil)</span> or something 
 equivalent like <span class="v">(<a href="COMMON-LISP____AND.html">and</a> test '(:use lemma42))</span>.</p> 
 
 <p>The three tests above are all equivalent.  They suffer from the problem of 
 requiring the explicit enumeration of all the goal specs in the first forcing 
 round.  A change in the script might cause more forced subgoals and the ones 
 other than those enumerated would not be given the hint.</p> 
 
 <p>You could write a test that recognizes all first round top-level subgoals 
 no matter how many there are.  Just think of the programming problem: how do I 
 recognize all the clause id's of the form <span class="v">((1) (n) . 0)</span>?  Often you can 
 come to this formulation of the problem by using <span class="v">parse-clause-id</span> on a few 
 of the candidate goal-specs to see the common structure.  A suitable test in 
 this case is:</p> 
 
 <pre class="code">(<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> id) '(1))     ; forcing round 1, top-level (pre-induction)
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> (<a href="COMMON-LISP____CADR.html">cadr</a> id)) 1) ; Subgoal n (<a href="COMMON-LISP____NOT.html">not</a> Subgoal n.i ...)
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CDDR.html">cddr</a> id) 0))      ; no primes</pre> 
 
 <p>The test above is ``overkill'' because it recognizes precisely the clause 
 ids in question.  But recall that once a computed hint is used, it is (by 
 default) removed from the hints available to the children of the clause. 
 Thus, we can widen the set of clause ids recognized to include all the 
 children without worrying that the hint will be applied to those children.</p> 
 
 <p>In particular, the following test supplies the hint to every top-level goal 
 of the first forcing round:</p> 
 
 <pre class="code">(<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> id) '(1))</pre> 
 
 <p>You might worry that it would also supply the hint to the subgoal produced 
 by the hint  the cases we ruled out by the ``overkill'' above.  But 
 that doesn't happen since the hint is unavailable to the children.  You could 
 even write:</p> 
 
 <pre class="code">(<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> id)) 1)</pre> 
 
 <p>which would supply the hint to every goal of the form "[1]Subgoal ..." 
 and again, because we see and fire on the top-level goals first, we will not 
 fire on, say, "[1]Subgoal *1.3/2", i.e., the id '((1 1 3) (2) . 0) even 
 though the test recognizes that id.</p> 
 
 <p>Finally, the following test supplies the hint to every top-level goal of 
 every forcing round (except the 0th, which is the ``gist'' of the proof, not 
 ``really'' a forcing round):</p> 
 
 <pre class="code">(<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> id)) 0))</pre> 
 
 <p>Recall again that in all the examples above we have exhibited the <span class="v">test</span> 
 in a computed hint of the form <span class="v">(<a href="COMMON-LISP____IF.html">if</a> test '(:key1 val1 ...) nil)</span>.</p>
</body>
</html>
