<html>
<head>
<meta charset="UTF-8">
<title>Binary-op-nonstrictp</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=SYNTHETO____BINARY-OP-NONSTRICTP">Click for Binary-op-nonstrictp in the Full Manual</a></h3>

<p>Check if a binary operator is non-strict.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(binary-op-nonstrictp op) → yes/no</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">op</span> — <font color="#606060">Guard <span class="v">(<a href="SYNTHETO____BINARY-OPP.html">binary-opp</a> op)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">yes/no</span> — <font color="#606060">Type <span class="v">(<a href="ACL2____BOOLEANP.html">booleanp</a> yes/no)</span>.</font>
</dd> 
 
</dl></div> 
<p>In Syntheto, some boolean connectives are non-strict, 
     in the sense that one operand can assume 
     the truth or falsehood of the other operand 
     to discharge its type obligations. 
     This is because the value of the result may be determined 
     just by one operand value in some cases. 
     See the static semantics for details.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>binary-op-nonstrictp</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> binary-op-nonstrictp (op)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SYNTHETO____BINARY-OPP.html">binary-opp</a> op)))
       (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'binary-op-nonstrictp))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
            (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____MEMBER-EQ.html">member-eq</a> (<a href="SYNTHETO____BINARY-OP-KIND.html">binary-op-kind</a> op)
                            '(:and :or :implies :implied))
                 t)))</pre> 
<p><b>Theorem: </b>booleanp-of-binary-op-nonstrictp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> booleanp-of-binary-op-nonstrictp
        (<a href="ACL2____B_A2.html">b*</a> ((yes/no (<a href="SYNTHETO____BINARY-OP-NONSTRICTP.html">binary-op-nonstrictp</a> op)))
            (<a href="ACL2____BOOLEANP.html">booleanp</a> yes/no))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>binary-op-nonstrictp-of-binary-op-fix-op</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binary-op-nonstrictp-of-binary-op-fix-op
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____BINARY-OP-NONSTRICTP.html">binary-op-nonstrictp</a> (<a href="SYNTHETO____BINARY-OP-FIX.html">binary-op-fix</a> op))
               (<a href="SYNTHETO____BINARY-OP-NONSTRICTP.html">binary-op-nonstrictp</a> op)))</pre> 
<p><b>Theorem: </b>binary-op-nonstrictp-binary-op-equiv-congruence-on-op</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binary-op-nonstrictp-binary-op-equiv-congruence-on-op
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SYNTHETO____BINARY-OP-EQUIV.html">binary-op-equiv</a> op op-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____BINARY-OP-NONSTRICTP.html">binary-op-nonstrictp</a> op)
                        (<a href="SYNTHETO____BINARY-OP-NONSTRICTP.html">binary-op-nonstrictp</a> op-equiv)))
        :rule-classes :congruence)</pre> 

</body>
</html>
