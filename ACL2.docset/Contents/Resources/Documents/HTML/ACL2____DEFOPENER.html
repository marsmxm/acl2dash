<html>
<head>
<meta charset="UTF-8">
<title>Defopener</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____DEFOPENER">Click for Defopener in the Full Manual</a></h3>

<p>Create a defthm equating a call with its simplification.</p><p>For a related tool, see <a href="ACL2____DEFOPEN.html">defopen</a>.</p> 
 
<p>Example:</p> 
 
<pre class="code">(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "misc/defopener" :dir :system)
(<a href="ACL2____DEFOPENER.html">defopener</a> append-open
  (<a href="COMMON-LISP____APPEND.html">append</a> x y)
  :hyp (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> x) (<a href="ACL2____TRUE-LISTP.html">true-listp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x)))
  :hints (("Goal" :expand ((<a href="COMMON-LISP____APPEND.html">append</a> x y)))))</pre> 
 
<p>The above example creates the following theorem.</p> 
 
<pre class="code">(<a href="ACL2____DEFTHM.html">DEFTHM</a> APPEND-OPEN
  (<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____AND.html">AND</a> (<a href="ACL2____TRUE-LISTP.html">TRUE-LISTP</a> X)
                (<a href="ACL2____TRUE-LISTP.html">TRUE-LISTP</a> (<a href="COMMON-LISP____CDR.html">CDR</a> X)))
           (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="COMMON-LISP____APPEND.html">APPEND</a> X Y)
                  (<a href="COMMON-LISP____IF.html">IF</a> (<a href="COMMON-LISP____NOT.html">NOT</a> X)
                      Y
                      (<a href="COMMON-LISP____CONS.html">CONS</a> (<a href="COMMON-LISP____CAR.html">CAR</a> X) (<a href="COMMON-LISP____APPEND.html">APPEND</a> (<a href="COMMON-LISP____CDR.html">CDR</a> X) Y))))))</pre> 
 
<p>In general, the form</p> 
 
<pre class="code">(<a href="ACL2____DEFOPENER.html">defopener</a> name
  term
  :hyp hyp
  ...)</pre> 
 
<p>attempts to create a theorem of the form</p> 
 
<pre class="code">(<a href="ACL2____DEFTHM.html">DEFTHM</a> NAME
  (<a href="ACL2____IMPLIES.html">IMPLIES</a> HYP
           (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> TERM rhs)))</pre> 
 
<p>where <span class="v">rhs</span> is generated by ACL2's simplification routines.  If <span class="v">:hyp</span> is 
omitted, then of course the resulting form has the expected shape:</p> 
 
<pre class="code">(<a href="ACL2____DEFTHM.html">DEFTHM</a> NAME
  (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> TERM rhs)).</pre> 
 
<p>If an equivalence relation symbol is supplied for <span class="v">:equiv</span>, then 
<span class="v">EQUAL</span> above will be replaced by that symbol.</p> 
 
<p>The output can be rather verbose.  Once <span class="v">rhs</span> as above has been produced, 
ACL2 will print out the theorem to be proved before starting its proof, 
indicated as follows.</p> 
 
<pre class="code">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

&gt;&gt;&gt; STARTING PROOF OF:

(<a href="ACL2____DEFTHM.html">DEFTHM</a> NAME
        ...)

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</pre> 
 
<p>To abbreviate the above message, you can specify an <span class="tt"><a href="ACL2____EVISC-TUPLE.html">evisc-tuple</a></span> using the <span class="v">:evisc-tuple</span> keyword of <span class="v">defopener</span>, 
which is <span class="v">nil</span> by default.</p> 
 
<p>The simplification that takes place uses a prover interface that is also 
used in the distributed book <span class="v">misc/bash</span>, in which the following hint is 
automatically generated for <span class="v">"Goal"</span>, though they can be overridden if 
explicitly supplied in the <span class="v">defopener</span> form for <span class="v">"Goal"</span>:</p> 
 
<pre class="code">:do-not (<a href="ACL2____GENERALIZE.html">generalize</a> eliminate-destructors fertilize eliminate-irrelevance)</pre> 
 
<p>A suitable <span class="v">:do-not-induct</span> hint is also generated, so that induction is 
avoided during the simplification process.  This too can be overridden.</p> 
 
<p>If you only want to see the generated theorem, and not the attempted proof 
of it, use <span class="v">:debug t</span>.  Alternatively, you may want to run without that 
addition and then submit <span class="v">:</span><a href="ACL2____PCB_12.html">pcb!</a> to grab the generated <a href="ACL2____ENCAPSULATE.html">encapsulate</a> form to put into the book that you are developing.  Otherwise, the 
<span class="v">defopener</span> form will call the ACL2 simplifier twice each time you certify 
your book: once to generate the theorem, and once to prove it.</p> 
 
<p>The <span class="v">:flatten</span> keyword is <span class="v">t</span> by default, and causes the result to be 
of the form <span class="v">(<a href="COMMON-LISP____COND.html">cond</a> (c1 v1) (c2 v2) ... (ck vk) (t v))</span>.  That result is 
actually produced from a more primitive tree-based result, of the form <span class="v">(<a href="COMMON-LISP____IF.html">if</a> c
v1 v2)</span>, where <span class="v">v1</span> and <span class="v">v2</span> can themselves be calls of <span class="v">if</span>.  If you 
prefer the more primitive form, use <span class="v">:flatten nil</span>.</p> 
 
<p>None of the arguments of this macro is evaluated.</p> 
 
<p>This tool is heuristic in nature, and failures are possible.  The error 
message might provide debugging clues.  Let us consider an example that 
actually occurred that generated an error message of the following form.</p> 
 
<pre class="code">ACL2 Error in (<a href="ACL2____DEFOPENER.html">DEFOPENER</a> MY-DEFOPENER-RULE ...):  The last literal
of each clause generated is expected to be of the form (equiv lhs rhs)
for the same equiv and lhs. The equiv for the last literal of the first
clause is EQUAL and its lhs is (<a href="ACL2____HIDE.html">HIDE</a> (FOO X Y)) but the last literal of
one clause generated is:

(MY-PREDICATE (<a href="ACL2____HIDE.html">HIDE</a> (FOO X Y)))</pre> 
 
<p>The message suggests that each goal (i.e., clause) after the first should be 
of the form <span class="v">(<a href="ACL2____IMPLIES.html">implies</a> ... (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____HIDE.html">HIDE</a> (FOO X Y)) ...))</span> or simply 
<span class="v">(<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____HIDE.html">HIDE</a> (FOO X Y)) ...)</span>; but in this case, one goal was actually of 
the form <span class="v">(<a href="ACL2____IMPLIES.html">IMPLIES</a> ... (MY-PREDICATE (<a href="ACL2____HIDE.html">HIDE</a> (FOO X Y))))</span>.  After first 
executing <span class="v">(<a href="ACL2____SET-GAG-MODE.html">set-gag-mode</a> nil)</span> and then running <span class="v">defopener</span> again, the 
proof log helped to discover a rewrite rule of the following form.</p> 
 
<pre class="code">(<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (f1 a)
              b)
       (<a href="COMMON-LISP____AND.html">and</a> (my-predicate b)
            ...))</pre> 
 
<p>ACL2 was able to match the term <span class="v">(<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="ACL2____HIDE.html">HIDE</a> (FOO X Y)) (F1 A)</span>) with 
the left-hand side of the above rule, thus rewriting it to a conjunction whose 
first conjunct was <span class="v">(MY-PREDICATE (<a href="ACL2____HIDE.html">HIDE</a> (FOO X Y)))</span>.  The error disappeared 
after that rule was disabled.</p>
</body>
</html>
