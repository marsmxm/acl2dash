<html>
<head>
<meta charset="UTF-8">
<title>Def-svtv-override-fact</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=SV____DEF-SVTV-OVERRIDE-FACT">Click for Def-svtv-override-fact in the Full Manual</a></h3>

<p>Prove a theorem about an SVTV using a specific input env, perhaps 
with overrides, then generalize it to remove overrides and reliance on a 
particular shape of input env.</p> 
<p>Usage:</p> 
<pre class="code">(<a href="SV____DEF-SVTV-OVERRIDE-FACT.html">def-svtv-override-fact</a> theorem-name
  :svtv svtv-name
  :input-vars input-variable-list
  :input-var-bindings input-variable-binding-list
  :override-vars override-variable-list
  :output-vars output-variable-list
  :output-parts output-part-list
  :hyp hypothesis-term
  :concl conclusion-term
  :enable rules-list
  :unsigned-byte-hyps nil
  :no-lemmas nil)</pre> 
 
<p>For each of the keyword arguments, if absent a default will be looked up in 
the <a href="ACL2____TABLE.html">table</a> <span class="v">svtv-override-fact-defaults</span>, which may be (locally) 
modified by users in order to avoid (for example) the need to repeatedly 
specify the same SVTV in every form.</p> 
 
<p>Prerequisites: The SVTV in question must have certain theorems already 
proved about it, in particular those generated by <a href="SV____DEF-SVTV-OVERRIDE-THMS.html">def-svtv-override-thms</a>.  (This event has its own prerequisites as well.)</p> 
 
<p>We briefly describe the arguments of the macro and then we'll describe the 
theorem proved in FGL and the generalized corollary this macro generates.</p> 
 
<h3>Arguments</h3> 
 
<ul> 
<li>
<span class="v">:svtv</span> is the name of the SVTV</li> 
<li>
<span class="v">:input-vars</span> are the names of any input variables of the SVTV that will 
appear in the hypothesis or conclusion, except those that are bound in 
<span class="v">:input-var-bindings</span>
</li> 
<li>
<span class="v">:input-var-bindings</span> is a list of <span class="v">let</span>-like bindings of input 
variables to expressions</li> 
 
<li>
<span class="v">:override-vars</span> is a list of override-value variables of the SVTV to be 
overridden in the FGL theorem.  These should have corresponding override test 
and reference variables (i.e. they should appear in the 
<span class="v">&lt;svtv&gt;-pipeline-override-triples</span> generated by <span class="v">def-svtv-override-thms</span>.</li> 
 
<li>
<span class="v">:output-vars</span> is a list of output variables of the SVTV that are used in the conclusion.</li> 
 
<li>
<span class="v">:output-parts</span> is a list of 4vec expressions -- part selects, zero 
extends, shifts, concatenations -- of the output variables.  The given parts of 
the outputs will be proved to be integerp in order to use a monotonicity 
argument.  Variables that are not mentioned in output-parts will be proved 
integerp as a whole.</li> 
 
<li>
<span class="v">:hyp</span> is a term (default T), which may reference variables 
listed in input-vars and override-vars as well as variables used in the 
expressions of input-bindings</li> 
 
<li>
<span class="v">:concl</span> is a term which may reference the same variables available to 
<span class="v">:hyp</span> as well as the output-vars.</li> 
 
<li>
<span class="v">:enable</span> is a list of rules to be included in the theory for the final 
generalized theorm, mainly useful when specifying <span class="v">:output-parts</span>.</li> 
 
<li>
<span class="v">:lemma-defthm</span> defaults to <span class="v">fgl::def-fgl-thm</span> but can be set 
to (e.g.) <span class="v">defthm</span> or <span class="v">fgl::def-fgl-param-thm</span> to change how the initial 
lemma is proved.</li> 
 
<li>
<span class="v">:lemma-args</span> gives additional arguments to be passed to the form 
proving the initial lemma, which could be hints for a <span class="v">defthm</span> form or FGL 
keyword args for <span class="v">fgl::def-fgl-thm</span> or <span class="v">fgl::def-fgl-param-thm</span>.</li> 
 
<li>
<span class="v">:no-lemmas</span> says to skip the initial override theorem and monotonicity lemma 
and tries to prove the final theorem directly, with the hints given by the user.</li> 
 
<li>
<span class="v">:hints</span> are hints for the final theorem, only used if <span class="v">:no-lemmas</span> is set.</li> 
 
<li>
<span class="v">:unsigned-byte-hyps</span> says to automatically add <span class="v">unsigned-byte-p</span> 
hypotheses for each input and override variable.</li> 
</ul> 
 
<h3>Initial override theorem</h3> 
 
<p>The initial override theorem is typically proved with FGL. It says that 
under the given hypotheses, a run of the SVTV on a particular, explicitly 
constructed environment produces outputs satisfying the conclusion.  In 
addition, it proves that those outputs are integers (whereas they could 
otherwise be arbitrary <a href="SV____4VEC.html">4vec</a>s including X and Z bits).  The environment 
is constructed as follows:</p> 
 
<ul> 
<li>Input variables bound in <span class="v">:input-var-bindings</span> are bound to their respective values</li> 
<li>Input variables listed in <span class="v">:input-vars</span> are bound to variables of the same name</li> 
<li>Override value variables listed in <span class="v">:override-vars</span> are bound to variables of the same name</li> 
<li>Override test variables corresponding to the override value variables 
listed in <span class="v">:override-vars</span> are all bound to -1.</li> 
</ul> 
 
<p>For example, the following form:</p> 
 
<pre class="code">(<a href="SV____DEF-SVTV-OVERRIDE-FACT.html">def-svtv-override-fact</a> partial-prods-to-product
  :svtv multiplier-svtv
  :input-var-bindings ((opcode *mul-opcode*))
  :override-vars (partial-products)
  :output-vars (product)
  :hyp (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> 128 partial-products)
  :concl (<a href="COMMON-LISP____EQUAL.html">equal</a> product (sum-partial-products partial-products)))</pre> 
<p>produces approximately the following initial lemma:</p> 
<pre class="code">(<a href="FGL____DEF-FGL-THM.html">fgl::def-fgl-thm</a> partial-prods-to-product-override-lemma
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> 128 partial-products)
           (<a href="ACL2____B_A2.html">b*</a> ((run (<a href="ACL2____SVTV-RUN.html">svtv-run</a> (multiplier-svtv)
                               `((opcode . ,*mul-opcode*)
                                 (partial-products . ,partial-products)
                                 (override-partial-products . -1))))
                (product (<a href="SV____SVEX-ENV-LOOKUP.html">svex-env-lookup</a> 'product run)))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> product)
                  (<a href="COMMON-LISP____EQUAL.html">equal</a> product (sum-partial-products partial-products))))))</pre> 
 
<h3>Generalized theorem</h3> 
 
<p>The generalized theorem refers to a single free variable <span class="v">env</span> rather 
than a free variable for each input and override value.  It binds <span class="v">run</span> to 
the run of the SVTV on that env.  Input variables -- both those listed in 
<span class="v">:input-vars</span> and the keys of <span class="v">:input-var-bindings</span> -- are bound to their 
lookups in <span class="v">env</span>, outputs are bound (as usual) to their lookups in <span class="v">run</span>, 
and override variables are bound to the lookups of their respective reference 
variables in <span class="v">run</span>.  In addition to the explicit hypothesis, the theorem 
adds hypotheses that each variable bound in <span class="v">:input-var-bindings</span> is bound 
to its respective value in <span class="v">env</span>, and one more hypothesis stating that none 
of the override test variables of the SVTV pipeline-override-triples are bound 
to anything containing 1 bits (effectively, <span class="v">env</span> does not set any 
conditional overrides).</p> 
 
<p>For example, the form above produces approximately the following generalized theorem:</p> 
<pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> partial-prods-to-product
  (<a href="ACL2____B_A2.html">b*</a> ((opcode (<a href="SV____SVEX-ENV-LOOKUP.html">svex-env-lookup</a> 'opcode env))
       (run (<a href="ACL2____SVTV-RUN.html">svtv-run</a> (multiplier-svtv) env))
       (partial-products (<a href="SV____SVEX-ENV-LOOKUP.html">svex-env-lookup</a> 'partial-products run)))
    (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> 128 partial-products)
                  (<a href="COMMON-LISP____EQUAL.html">equal</a> opcode *mul-opcode*)
                  (svex-env-keys-no-1s-p
                   (svar-override-triplelist-&gt;testvars
                    (multiplier-svtv-pipeline-override-triples))
                   env))
             (<a href="ACL2____B_A2.html">b*</a> ((product (<a href="SV____SVEX-ENV-LOOKUP.html">svex-env-lookup</a> 'product run)))
               (<a href="COMMON-LISP____EQUAL.html">equal</a> product (sum-partial-products partial-products))))))</pre> 

</body>
</html>
