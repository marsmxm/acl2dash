<html>
<head>
<meta charset="UTF-8">
<title>Atc-gen-outer-bindings-and-hyps</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=C____ATC-GEN-OUTER-BINDINGS-AND-HYPS">Click for Atc-gen-outer-bindings-and-hyps in the Full Manual</a></h3>

<p>Generate the outer bindings, 
          pointer hypotheses, 
          pointer substitutions, 
          and lemma instantiation, 
          for a correctness theorem.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(atc-gen-outer-bindings-and-hyps 
     typed-formals compst-var fn-recursivep) 
 
  → 
(mv bindings pointer-hyps pointer-subst instantiation)</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">typed-formals</span> — <font color="#606060">Guard <span class="v">(<a href="C____ATC-SYMBOL-TYPE-ALISTP.html">atc-symbol-type-alistp</a> typed-formals)</span>.</font>
</dd> 
  <dd>
<span class="tt">compst-var</span> — <font color="#606060">Guard <span class="v">(<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> compst-var)</span>.</font>
</dd> 
  <dd>
<span class="tt">fn-recursivep</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____BOOLEANP.html">booleanp</a> fn-recursivep)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">bindings</span> — <font color="#606060">Type <span class="v">(<a href="ACL2____DOUBLET-LISTP.html">doublet-listp</a> bindings)</span>.</font>
</dd> 
<dd>
<span class="tt">pointer-hyps</span> — <font color="#606060">Type <span class="v">(<a href="ACL2____TRUE-LISTP.html">true-listp</a> pointer-hyps)</span>.</font>
</dd> 
<dd>
<span class="tt">pointer-subst</span> — <font color="#606060">Type <span class="v">(<a href="ACL2____SYMBOL-SYMBOL-ALISTP.html">symbol-symbol-alistp</a> pointer-subst)</span>, given <span class="v">(<a href="C____ATC-SYMBOL-TYPE-ALISTP.html">atc-symbol-type-alistp</a> typed-formals)</span>.</font>
</dd> 
<dd>
<span class="tt">instantiation</span> — <font color="#606060">Type <span class="v">(<a href="ACL2____DOUBLET-LISTP.html">doublet-listp</a> instantiation)</span>.</font>
</dd> 
 
</dl></div> 
<p>Both C functions and C loops have correctness theorems of the form 
     <span class="v">(<a href="ACL2____B_A2.html">b*</a> (&lt;bindings&gt;) ...)</span>. 
     Here we generate the <span class="v">&lt;bindings&gt;</span>, 
     which we designate as `outer' since they are 
     at the outermost level of the theorem's formula. 
     We also generate some of the hypotheses 
     used in the correctness theorems 
     that relate to the bindings, 
     explained below. 
     We also generate a variable substitution, explained below. 
     We also generate an instantiation 
     for a lemma used in the hints of the generated theorem.</p><p>The (outer) bindings can be determined from 
     the formals of the ACL2 function <span class="v">fn</span> that represents 
     the C function or C loop. 
     The bindings differ between C functions and loops, 
     but there is also commonality, 
     which justifies having this one ACL2 code generation function 
     that handles both cases.</p><p>Consider a non-recursive <span class="v">fn</span>, which represents a C function. 
     Its correctness theorem equates (roughly speaking) 
     a call of <span class="tt"><a href="C____EXEC-FUN.html">exec-fun</a></span> with a call of <span class="v">fn</span>. 
     However, while <span class="v">fn</span> takes arrays as arguments, 
     <span class="tt"><a href="C____EXEC-FUN.html">exec-fun</a></span> takes pointers to those arrays. 
     So we introduce variables for the pointers, 
     named after the formals of <span class="v">fn</span> that are arrays: 
     we add "-PTR" to the formals of <span class="v">fn</span>, 
     which should not cause name conflicts because 
     the names of the formals must be portable C identifiers. 
     For each array formal <span class="v">a</span> of <span class="v">fn</span>, 
     we generate a pointer variable <span class="v">a-ptr</span> as explained, 
     along with a binding <span class="v">(a (<a href="C____READ-ARRAY.html">read-array</a> a-ptr compst))</span>: 
     this binding relates the two variables, 
     and lets us use the guard of <span class="v">fn</span> as hypothesis in the theorem, 
     which uses <span class="v">a</span>, 
     which the binding replaces with the array pointed to by <span class="v">a-ptr</span>. 
     Along with this binding, we also generate hypotheses saying that 
     <span class="v">a-ptr</span> is a non-null pointer of the appropriate type; 
     the type is determined from the type of the formal <span class="v">a</span>. 
     Along with the binding and the hypotheses, 
     we also generate an alist element <span class="v">(a a-ptr)</span>, 
     returned as part of the <span class="v">pointer-subst</span> result, 
     that is used to generate the argument list of <span class="tt"><a href="C____EXEC-FUN.html">exec-fun</a></span>, 
     by applying the substitution <span class="v">pointer-subst</span> to the formals of <span class="v">fn</span>: 
     this way, <span class="v">a</span> gets substituted with <span class="v">a-ptr</span>, 
     which is what we want since <span class="tt"><a href="C____EXEC-FUN.html">exec-fun</a></span> takes pointers, not arrays.</p><p>The non-array formals of a non-recursive <span class="v">fn</span> 
     do not cause any bindings, hypotheses, or substitutions to be generated. 
     They are passed to both <span class="tt"><a href="C____EXEC-FUN.html">exec-fun</a></span> and <span class="v">fn</span> in the theorem, 
     and it is the guard of <span class="v">fn</span> that constrains them 
     in the hypotheses of the theorem.</p><p>The treatment of a recursive <span class="v">fn</span> is a bit more complicated. 
     The correctness theorem for the loop represented by <span class="v">fn</span> 
     equates (roughly speaking) 
     a call of <span class="tt"><a href="C____EXEC-STMT.html">exec-stmt</a></span> with a call of <span class="v">fn</span>. 
     However, <span class="tt"><a href="C____EXEC-STMT.html">exec-stmt</a></span> is called on a computation state, 
     not on anything that corresponds to the formals of <span class="v">fn</span>, 
     as is the case for a non-recursive <span class="v">fn</span> as explained above. 
     There is still a correspondence, of course: 
     the formals of <span class="v">fn</span> correspond to variables in the computation state. 
     We consider the cases of arrays and non-arrays separately.</p><p>If <span class="v">a</span> is a non-array formal of a recursive <span class="v">fn</span>, 
     it corresponds to <span class="v">(<a href="C____READ-VAR.html">read-var</a> &lt;a&gt; compst)</span>, 
     where <span class="v">&lt;a&gt;</span> is the identifier derived from the name of <span class="v">a</span>. 
     Thus, in this case we generate the binding <span class="v">(a (<a href="C____READ-VAR.html">read-var</a> &lt;a&gt; compst))</span>. 
     Since no pointers are involved, in this case we generate 
     no hypotheses and no substitutions.</p><p>If <span class="v">a</span> is an array formal of a recursive <span class="v">fn</span>, 
     we introduce an additional <span class="v">a-ptr</span> variable, 
     similarly to the case of non-recursive <span class="v">fn</span>. 
     We generate two bindings <span class="v">(a-ptr (<a href="C____READ-VAR.html">read-var</a> &lt;a&gt; compst))</span> 
     and <span class="v">(a (<a href="C____READ-ARRAY.html">read-array</a> a-ptr compst))</span>, 
     in that order. 
     The first binding serves to tie <span class="v">a-ptr</span> 
     to the corresponding variable in the computation state, 
     which has the name of <span class="v">a</span>, but it holds a pointer. 
     The second binding is analogous in purpose 
     to the case of a non-recursive <span class="v">fn</span> explained above: 
     it lets us use the guard of <span class="v">fn</span>, which references <span class="v">a</span>, 
     in the hypotheses of the generated theorem 
     without having to make an explicit substitution, 
     because the bindings are in fact doing the substitution. 
     It should be clear why the two bindings have to be in that order; 
     the bindings are put into a <span class="tt"><a href="ACL2____B_A2.html">b*</a></span>, 
     which enforces the order. 
     We generate no substitution map in <span class="v">pointer-subst</span> here, 
     because that only applied to <span class="tt"><a href="C____EXEC-FUN.html">exec-fun</a></span>, 
     which is not used for C loops.</p><p>The reason for generating and using these bindings in the theorems, 
     as opposed to making the substitutions in the theorem's formula, 
     is greater readability. 
     Particularly in the case of loop theorems, 
     if <span class="v">a</span> occurs a few times in the guard, 
     the guard with just <span class="v">a</span> in those occurrences is more readable than 
     if all those occurrences are replaced with <span class="v">(<a href="C____READ-VAR.html">read-var</a> &lt;a&gt; compst)</span>.</p><p>The lemma instantiation is similar to the bindings, 
     but it only concerns the formals of <span class="v">fn</span>, not the <span class="v">a-ptr</span> variables. 
     The instantiation is used on the guard and termination theorems of <span class="v">fn</span>, 
     and therefore it can only concern the formals of <span class="v">fn</span>.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>atc-gen-outer-bindings-and-hyps</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 atc-gen-outer-bindings-and-hyps
 (typed-formals compst-var fn-recursivep)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="C____ATC-SYMBOL-TYPE-ALISTP.html">atc-symbol-type-alistp</a> typed-formals)
                             (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> compst-var)
                             (<a href="ACL2____BOOLEANP.html">booleanp</a> fn-recursivep))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((__function__ 'atc-gen-outer-bindings-and-hyps))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
  (<a href="ACL2____B_A2.html">b*</a>
   (((when (<a href="COMMON-LISP____ENDP.html">endp</a> typed-formals))
     (<a href="ACL2____MV.html">mv</a> nil nil nil nil))
    ((<a href="COMMON-LISP____CONS.html">cons</a> formal type) (<a href="COMMON-LISP____CAR.html">car</a> typed-formals))
    (formal-ptr (<a href="ACL2____ADD-SUFFIX-TO-FN.html">add-suffix-to-fn</a> formal "-PTR"))
    (formal-id (<a href="COMMON-LISP____CONS.html">cons</a> 'ident
                     (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____SYMBOL-NAME.html">symbol-name</a> formal) 'nil)))
    (<a href="C____ARRAYP.html">arrayp</a> (<a href="C____TYPE-CASE.html">type-case</a> type :pointer))
    (bindings
     (<a href="COMMON-LISP____IF.html">if</a>
      fn-recursivep
      (<a href="COMMON-LISP____IF.html">if</a>
       arrayp
       (<a href="COMMON-LISP____LIST.html">list</a>
         (<a href="COMMON-LISP____CONS.html">cons</a> formal-ptr
               (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'read-var
                           (<a href="COMMON-LISP____CONS.html">cons</a> formal-id (<a href="COMMON-LISP____CONS.html">cons</a> compst-var 'nil)))
                     'nil))
         (<a href="COMMON-LISP____CONS.html">cons</a> formal
               (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'read-array
                           (<a href="COMMON-LISP____CONS.html">cons</a> formal-ptr (<a href="COMMON-LISP____CONS.html">cons</a> compst-var 'nil)))
                     'nil)))
       (<a href="COMMON-LISP____LIST.html">list</a>
          (<a href="COMMON-LISP____CONS.html">cons</a> formal
                (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'read-var
                            (<a href="COMMON-LISP____CONS.html">cons</a> formal-id (<a href="COMMON-LISP____CONS.html">cons</a> compst-var 'nil)))
                      'nil))))
      (<a href="COMMON-LISP____IF.html">if</a>
       arrayp
       (<a href="COMMON-LISP____LIST.html">list</a>
         (<a href="COMMON-LISP____CONS.html">cons</a> formal
               (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'read-array
                           (<a href="COMMON-LISP____CONS.html">cons</a> formal-ptr (<a href="COMMON-LISP____CONS.html">cons</a> compst-var 'nil)))
                     'nil)))
       nil)))
    (subst? (<a href="COMMON-LISP____AND.html">and</a> arrayp (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> formal formal-ptr))))
    (hyps
     (<a href="COMMON-LISP____AND.html">and</a>
      arrayp
      (<a href="COMMON-LISP____LIST.html">list</a>
       (<a href="COMMON-LISP____CONS.html">cons</a> 'pointerp (<a href="COMMON-LISP____CONS.html">cons</a> formal-ptr 'nil))
       (<a href="COMMON-LISP____CONS.html">cons</a> 'not
             (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'pointer-nullp
                         (<a href="COMMON-LISP____CONS.html">cons</a> formal-ptr 'nil))
                   'nil))
       (<a href="COMMON-LISP____CONS.html">cons</a> 'equal
             (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'pointer-&gt;reftype
                         (<a href="COMMON-LISP____CONS.html">cons</a> formal-ptr 'nil))
                   (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'quote
                               (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="C____TYPE-POINTER-_E3REFERENCED.html">type-pointer-&gt;referenced</a> type)
                                     'nil))
                         'nil))))))
    (inst
     (<a href="COMMON-LISP____IF.html">if</a>
      fn-recursivep
      (<a href="COMMON-LISP____IF.html">if</a>
       arrayp
       (<a href="COMMON-LISP____LIST.html">list</a>
        (<a href="COMMON-LISP____CONS.html">cons</a>
         formal
         (<a href="COMMON-LISP____CONS.html">cons</a>
          (<a href="COMMON-LISP____CONS.html">cons</a> 'read-array
                (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'read-var
                            (<a href="COMMON-LISP____CONS.html">cons</a> formal-id (<a href="COMMON-LISP____CONS.html">cons</a> compst-var 'nil)))
                      (<a href="COMMON-LISP____CONS.html">cons</a> compst-var 'nil)))
          'nil)))
       (<a href="COMMON-LISP____LIST.html">list</a>
          (<a href="COMMON-LISP____CONS.html">cons</a> formal
                (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'read-var
                            (<a href="COMMON-LISP____CONS.html">cons</a> formal-id (<a href="COMMON-LISP____CONS.html">cons</a> compst-var 'nil)))
                      'nil))))
      (<a href="COMMON-LISP____IF.html">if</a>
       arrayp
       (<a href="COMMON-LISP____LIST.html">list</a>
         (<a href="COMMON-LISP____CONS.html">cons</a> formal
               (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'read-array
                           (<a href="COMMON-LISP____CONS.html">cons</a> formal-ptr (<a href="COMMON-LISP____CONS.html">cons</a> compst-var 'nil)))
                     'nil)))
       nil)))
    ((<a href="ACL2____MV.html">mv</a> more-bindings
         more-hyps more-subst more-inst)
     (<a href="C____ATC-GEN-OUTER-BINDINGS-AND-HYPS.html">atc-gen-outer-bindings-and-hyps</a> (<a href="COMMON-LISP____CDR.html">cdr</a> typed-formals)
                                      compst-var fn-recursivep)))
   (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____APPEND.html">append</a> bindings more-bindings)
       (<a href="COMMON-LISP____APPEND.html">append</a> hyps more-hyps)
       (<a href="COMMON-LISP____APPEND.html">append</a> subst? more-subst)
       (<a href="COMMON-LISP____APPEND.html">append</a> inst more-inst)))))</pre> 
<p><b>Theorem: </b>doublet-listp-of-atc-gen-outer-bindings-and-hyps.bindings</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  doublet-listp-of-atc-gen-outer-bindings-and-hyps.bindings
  (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?bindings ?pointer-hyps
            ?pointer-subst ?instantiation)
        (<a href="C____ATC-GEN-OUTER-BINDINGS-AND-HYPS.html">atc-gen-outer-bindings-and-hyps</a> typed-formals
                                         compst-var fn-recursivep)))
      (<a href="ACL2____DOUBLET-LISTP.html">doublet-listp</a> bindings))
  :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>true-listp-of-atc-gen-outer-bindings-and-hyps.pointer-hyps</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  true-listp-of-atc-gen-outer-bindings-and-hyps.pointer-hyps
  (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?bindings ?pointer-hyps
            ?pointer-subst ?instantiation)
        (<a href="C____ATC-GEN-OUTER-BINDINGS-AND-HYPS.html">atc-gen-outer-bindings-and-hyps</a> typed-formals
                                         compst-var fn-recursivep)))
      (<a href="ACL2____TRUE-LISTP.html">true-listp</a> pointer-hyps))
  :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>symbol-symbol-alistp-of-atc-gen-outer-bindings-and-hyps.pointer-subst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 symbol-symbol-alistp-of-atc-gen-outer-bindings-and-hyps.pointer-subst
 (<a href="ACL2____IMPLIES.html">implies</a>
  (<a href="C____ATC-SYMBOL-TYPE-ALISTP.html">atc-symbol-type-alistp</a> typed-formals)
  (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?bindings ?pointer-hyps
            ?pointer-subst ?instantiation)
        (<a href="C____ATC-GEN-OUTER-BINDINGS-AND-HYPS.html">atc-gen-outer-bindings-and-hyps</a> typed-formals
                                         compst-var fn-recursivep)))
      (<a href="ACL2____SYMBOL-SYMBOL-ALISTP.html">symbol-symbol-alistp</a> pointer-subst)))
 :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>doublet-listp-of-atc-gen-outer-bindings-and-hyps.instantiation</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  doublet-listp-of-atc-gen-outer-bindings-and-hyps.instantiation
  (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?bindings ?pointer-hyps
            ?pointer-subst ?instantiation)
        (<a href="C____ATC-GEN-OUTER-BINDINGS-AND-HYPS.html">atc-gen-outer-bindings-and-hyps</a> typed-formals
                                         compst-var fn-recursivep)))
      (<a href="ACL2____DOUBLET-LISTP.html">doublet-listp</a> instantiation))
  :rule-classes :rewrite)</pre> 

</body>
</html>
