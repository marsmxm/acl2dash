<html>
<head>
<meta charset="UTF-8">
<title>Elim</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____ELIM">Click for Elim in the Full Manual</a></h3>

<p>Make a destructor elimination rule</p><p>See <a href="ACL2____RULE-CLASSES.html">rule-classes</a> for a general discussion of rule classes, 
 including how they are used to build rules from formulas and a discussion of 
 the various keywords in a rule class description.</p> 
 
 <p>The following example of an <span class="v">:elim</span> rule is an important one, and is 
 built into ACL2.</p> 
 
 <pre class="code">(<a href="ACL2____DEFAXIOM.html">defaxiom</a> car-cdr-elim
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x)
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> x) (<a href="COMMON-LISP____CDR.html">cdr</a> x)) x))
  :rule-classes :elim)</pre> 
 
 <p>The class of <span class="v">:elim</span> rules is fundamentally quite different from the 
 more common class of <span class="v">:</span><span class="tt"><a href="ACL2____REWRITE.html">rewrite</a></span> rules.  Briefly put, a 
 <span class="v">:rewrite</span> rule replaces instances of its left-hand side with corresponding 
 instances of its right-hand side.  But an <span class="v">:elim</span> rule, on the other hand, 
 has the effect of generalizing so-called ``destructor'' function applications 
 to variables.  In essence, applicability of a <span class="v">:rewrite</span> rule is based on 
 matching its left-hand side, while applicability of an <span class="v">:elim</span> rule is 
 based on the presence of at least one destructor term.</p> 
 
 <p>For example, a conjecture about <span class="v">(<a href="COMMON-LISP____CAR.html">car</a> x)</span> and <span class="v">(<a href="COMMON-LISP____CDR.html">cdr</a> x)</span> can be 
 replaced by a conjecture about new variables <span class="v">x1</span> and <span class="v">x2</span>, as shown in 
 the following example.  (Run the command <span class="v">:mini-proveall</span> and search for 
 <span class="v">CAR-CDR-ELIM</span> to see the full proof containing this excerpt.)</p> 
 
 <pre class="code">Subgoal *1/1'
(<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____AND.html">AND</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> X)
              (<a href="ACL2____TRUE-LISTP.html">TRUE-LISTP</a> (<a href="ACL2____REV.html">REV</a> (<a href="COMMON-LISP____CDR.html">CDR</a> X))))
         (<a href="ACL2____TRUE-LISTP.html">TRUE-LISTP</a> (APP (<a href="ACL2____REV.html">REV</a> (<a href="COMMON-LISP____CDR.html">CDR</a> X)) (<a href="COMMON-LISP____LIST.html">LIST</a> (<a href="COMMON-LISP____CAR.html">CAR</a> X))))).

The destructor terms (<a href="COMMON-LISP____CAR.html">CAR</a> X) and (<a href="COMMON-LISP____CDR.html">CDR</a> X) can be eliminated by using
CAR-CDR-ELIM to replace X by (<a href="COMMON-LISP____CONS.html">CONS</a> X1 X2), (<a href="COMMON-LISP____CAR.html">CAR</a> X) by X1 and (<a href="COMMON-LISP____CDR.html">CDR</a> X)
by X2.  This produces the following goal.

Subgoal *1/1''
(<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____AND.html">AND</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> (<a href="COMMON-LISP____CONS.html">CONS</a> X1 X2))
              (<a href="ACL2____TRUE-LISTP.html">TRUE-LISTP</a> (<a href="ACL2____REV.html">REV</a> X2)))
         (<a href="ACL2____TRUE-LISTP.html">TRUE-LISTP</a> (APP (<a href="ACL2____REV.html">REV</a> X2) (<a href="COMMON-LISP____LIST.html">LIST</a> X1)))).

This simplifies, using primitive type reasoning, to

Subgoal *1/1'''
(<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="ACL2____TRUE-LISTP.html">TRUE-LISTP</a> (<a href="ACL2____REV.html">REV</a> X2))
         (<a href="ACL2____TRUE-LISTP.html">TRUE-LISTP</a> (APP (<a href="ACL2____REV.html">REV</a> X2) (<a href="COMMON-LISP____LIST.html">LIST</a> X1)))).</pre> 
 
 <p>The resulting conjecture is often simpler and hence more amenable to 
 proof.</p> 
 
 <p>The application of an <span class="v">:elim</span> rule thus replaces a variable by a term 
 that contains applications of so-called ``destructor'' functions to that 
 variable.  The example above is typical: the variable <span class="v">x</span> is replaced by 
 the term <span class="v">(<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> x) (<a href="COMMON-LISP____CDR.html">cdr</a> x))</span>, which applies a so-called 
 ``constructor'' function, <span class="tt"><a href="COMMON-LISP____CONS.html">cons</a></span>, to applications <span class="v">(<a href="COMMON-LISP____CAR.html">car</a> x)</span> and 
 <span class="v">(<a href="COMMON-LISP____CDR.html">cdr</a> x)</span> of destructor functions <span class="tt"><a href="COMMON-LISP____CAR.html">car</a></span> and <span class="tt"><a href="COMMON-LISP____CDR.html">cdr</a></span> to that same 
 variable, <span class="v">x</span>.  But that is only part of the story.  ACL2 then generalizes 
 the destructor applications <span class="v">(<a href="COMMON-LISP____CAR.html">car</a> x)</span> and <span class="v">(<a href="COMMON-LISP____CDR.html">cdr</a> x)</span> to new variables 
 <span class="v">x1</span> and <span class="v">x2</span>, respectively, and ultimately the result is a simpler 
 conjecture.</p> 
 
 <p>More generally, the application of an <span class="v">:elim</span> rule replaces a variable 
 by a term containing applications of destructors; there need not be a 
 clear-cut notion of ``constructor.''  But the situation described above is 
 typical, and we will focus on it, giving full details when we introduce the 
 ``General Form'' below.</p> 
 
 <p>Notice that the situation can be complicated a bit by a rule's hypotheses. 
 For example, the replacement specified by the rule <span class="v">car-cdr-elim</span> (shown 
 near the beginning of this discussion) is only valid if the variable being 
 replaced is a cons structure.  Thus, when ACL2 applies <span class="v">car-cdr-elim</span> to 
 replace a variable <span class="v">v</span>, it will split into two cases: one case in which 
 <span class="v">(<a href="COMMON-LISP____CONSP.html">consp</a> v)</span> is true, in which <span class="v">v</span> is replaced by <span class="v">(<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> v) (<a href="COMMON-LISP____CDR.html">cdr</a>
 v))</span> and then <span class="v">(<a href="COMMON-LISP____CAR.html">car</a> v)</span> and <span class="v">(<a href="COMMON-LISP____CDR.html">cdr</a> v)</span> are generalized to new variables; 
 and one case in which <span class="v">(<a href="COMMON-LISP____CONSP.html">consp</a> v)</span> is false.  In practice, <span class="v">(<a href="COMMON-LISP____CONSP.html">consp</a> v)</span> is 
 often provable, perhaps even literally present as a hypotheses; then of course 
 there is no need to introduce the second case.  That is why there is no such 
 second case in the example above.</p> 
 
 <p>You might find <span class="v">:elim</span> rules to be useful whenever you have in mind a 
 data type that can be built up from its fields with a ``constructor'' function 
 and whose fields can be accessed by corresponding ``destructor'' functions. 
 So for example, if you have a ``house'' data structure that represents a house 
 in terms of its address, price, and color, you might have a rule like the 
 following.</p> 
 
 <pre class="code">Example:
(<a href="ACL2____IMPLIES.html">implies</a> (house-p x)
         (<a href="COMMON-LISP____EQUAL.html">equal</a> (make-house (address x)
                            (price x)
                            (color x))
                x))</pre> 
 
 <p>The application of such a rule is entirely analogous to the application of 
 the rule <span class="v">car-cdr-elim</span> discussed above.  We discuss such rules and their 
 application more carefully below.</p> 
 
 <pre class="code">General Form:
(<a href="ACL2____IMPLIES.html">implies</a> hyp (equiv lhs x))</pre> 
 
 <p>where <span class="v">equiv</span> is a known equivalence relation (see <a href="ACL2____DEFEQUIV.html">defequiv</a>); 
 <span class="v">x</span> is a variable symbol; and <span class="v">lhs</span> contains one or more terms (called 
 ``destructor terms'') of the form <span class="v">(fn v1 ... vn)</span>, where <span class="v">fn</span> is a 
 function symbol and the <span class="v">vi</span> are distinct variable symbols, <span class="v">v1</span>, ..., 
 <span class="v">vn</span> include all the variable symbols in the formula, no <span class="v">fn</span> occurs in 
 <span class="v">lhs</span> in more than one destructor term, and all occurrences of <span class="v">x</span> in 
 <span class="v">lhs</span> are inside destructor terms.</p> 
 
 <p>To use an <span class="v">:elim</span> rule, the theorem prover waits until a conjecture has 
 been maximally simplified.  It then searches for an instance of some 
 destructor term <span class="v">(fn v1 ... vn)</span> in the conjecture, where the instance for 
 <span class="v">x</span> is some variable symbol, <span class="v">vi</span>, and every occurrence of <span class="v">vi</span> 
 outside the destructor terms is in an <span class="v">equiv</span>-hittable position.  If such 
 an instance is found, then the theorem prover instantiates the <span class="v">:elim</span> 
 formula as indicated by the destructor term matched; splits the conjecture 
 into two goals, according to whether the instantiated hypothesis, <span class="v">hyp</span>, 
 holds; and in the case that it does hold, generalizes all the instantiated 
 destructor terms in the conjecture to new variables and then replaces <span class="v">vi</span> 
 in the conjecture by the generalized instantiated <span class="v">lhs</span>.  An occurrence of 
 <span class="v">vi</span> is ``<span class="v">equiv</span>-hittable'' if sufficient congruence rules (see <a href="ACL2____DEFCONG.html">defcong</a>) have been proved to establish that the propositional value of the 
 clause is not altered by replacing that occurrence of <span class="v">vi</span> by some 
 <span class="v">equiv</span>-equivalent term.</p> 
 
 <p>If an <span class="v">:elim</span> rule is not applied when you think it should have been, 
 and the rule uses an equivalence relation, <span class="v">equiv</span>, other than <span class="v">equal</span>, 
 it is most likely that there is an occurrence of the variable that is not 
 <span class="v">equiv</span>-hittable.  Easy occurrences to overlook are those in the governing 
 hypotheses.  If you see an unjustified occurrence of the variable, you must 
 prove the appropriate congruence rule to allow the <span class="v">:elim</span> to fire.</p> 
 
 <p>Further examples of how ACL2 <span class="v">:elim</span> rules are used may be found in the 
 corresponding discussion of ``Elimination of Destructors'' for Nqthm, in 
 Section 10.4 of A Computational Logic Handbook.</p>
</body>
</html>
