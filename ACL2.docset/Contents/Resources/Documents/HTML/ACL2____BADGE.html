<html>
<head>
<meta charset="UTF-8">
<title>Badge</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____BADGE">Click for Badge in the Full Manual</a></h3>

<p>Syntactic requirements on a function symbol to be used by <span class="v">apply$</span></p><p>``Badge'' is both the name of an ACL2 function and the name of a 
  concept key to the <span class="tt"><a href="ACL2____APPLY_42.html">apply$</a></span> machinery.  We discuss the function named 
  <span class="v">badge</span> first.  The discussion also mentions the concept of warrants, 
  which are easily confused with badges.  See the discussion of <b>Badges 
  versus Warrants</b> at the top of <span class="v">defbadge</span>.  But roughly put, badges 
  extend the ACL2 syntax and warrants extend the proof theory.  You'll need a 
  badge for <span class="v">fn</span> to allow the system to syntactically analyze <span class="v">(<a href="ACL2____APPLY_42.html">apply$</a> 'fn
  ...)</span>.  You'll need a both a badge and a warrant for <span class="v">fn</span> if you wish to 
  reason about that term with ACL2.</p> 
 
  <p>General Form:</p> 
  <pre class="code">(<a href="ACL2____BADGE.html">badge</a> fn)</pre> 
 
  <p>The argument, <span class="v">fn</span>, is expected to be a function symbol.  If <span class="v">fn</span> is 
  one of about 800 ACL2 primitives (discussed below) or is a user-defined 
  function successfully processed by either the event <span class="tt"><a href="ACL2____DEFBADGE.html">defbadge</a></span> or the 
  event <span class="tt"><a href="ACL2____DEFWARRANT.html">defwarrant</a></span>, the result is an object, called the ``badge'' of 
  <span class="v">fn</span>, which among other things specifies the <a href="ACL2____ILK.html">ilk</a> of each formal of 
  <span class="v">fn</span>.  Otherwise, an error is caused.  We explain below, where we define 
  the concepts of the ``out arity,'' ``ilks,'' and ``tameness requirements'' of 
  <span class="v">fn</span>'s badge.</p> 
 
  <p>A function symbol must have a badge in order to <span class="v">apply$</span> the symbol and 
  it is up to you, the user, to invoke an event that will assign a badge to 
  your user-defined functions, if possible.  <span class="v">Defbadge</span> will assign a badge 
  to a function symbol, if possible, and <span class="v">defwarrant</span> will assign both a 
  badge (if the function symbol doesn't already have one) and a <span class="tt"><a href="ACL2____WARRANT.html">warrant</a></span>, if possible.  The macro <span class="tt"><a href="ACL2____DEFUN_42.html">defun$</a></span> is just an abbreviation for 
  a <span class="v">defun</span> followed by a <span class="v">defwarrant</span>.  Almost all primitive system 
  functions already have badges.</p> 
 
  <p>The complete list of badged primitives can be seen by evaluating</p> 
 
  <pre class="code">(<a href="COMMON-LISP____APPEND.html">append</a> '(<a href="ACL2____BADGE.html">BADGE</a> TAMEP TAMEP-FUNCTIONP SUITABLY-TAMEP-LISTP
                APPLY$ EV$)
        (<a href="ACL2____STRIP-CARS.html">strip-cars</a> *badge-prim-falist*))</pre> 
 
  <p><span class="v">Badge</span> is a defined function in ACL2.  You can inspect its definition 
  with</p> 
 
  <pre class="code">ACL2 !&gt;:pe badge</pre> 
 
  <p>and see that after handling the built-in symbols it defers to the 
  undefined function <span class="tt"><a href="ACL2____BADGE-USERFN.html">badge-userfn</a></span>.  In the evaluation theory, 
  <span class="v">badge-userfn</span> has an attachment that returns the badge computed by 
  <span class="v">defbadge</span> or <span class="v">defwarrant</span>.  But in the proof theory, <span class="v">badge-userfn</span> 
  is undefined and the <span class="tt"><a href="ACL2____WARRANT.html">warrant</a></span> for <span class="v">fn</span> specifies the badge of 
  <span class="v">fn</span>.  Thus, in the proof theory, you cannot reason about the application 
  of a non-primitive function unless there is a warrant for the function 
  available as a hypothesis.</p> 
 
  <p>The rest of this documentation illustrates and explains what badges mean, 
  starting with a few examples.</p> 
 
  <pre class="code">ACL2 !&gt;(<a href="ACL2____BADGE.html">badge</a> 'cons)
(APPLY$-BADGE 2 1 . T)

ACL2 !&gt;(<a href="ACL2____BADGE.html">badge</a> 'apply$)
(APPLY$-BADGE 2 1 :FN NIL)

ACL2 !&gt;(<a href="ACL2____BADGE.html">badge</a> 'foldr)
(APPLY$-BADGE 3 1 NIL :FN NIL)</pre> 
 
  <p>The last example assumes that <span class="v">foldr</span> has been defined with</p> 
 
  <pre class="code">(<a href="ACL2____DEFUN_42.html">defun$</a> foldr (lst fn init)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ENDP.html">endp</a> lst)
      init
      (<a href="ACL2____APPLY_42.html">apply$</a> fn
              (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CAR.html">car</a> lst)
                    (foldr (<a href="COMMON-LISP____CDR.html">cdr</a> lst) fn init)))))</pre> 
 
  <p>In general, badges have the form <span class="v">(APPLY$-BADGE n k . ilks)</span>, where 
  <span class="v">n</span> is the arity of <span class="v">fn</span>, <span class="v">k</span> is the out arity (i.e., the number of 
  results returned by <span class="v">fn</span>) and <span class="v">ilks</span> is either <span class="v">T</span> or a list of 
  <span class="v">n</span> tokens.  Each token is either <span class="v">:FN</span>, <span class="v">:EXPR</span>, or <span class="v">NIL</span>.</p> 
 
  <p>The badge of <span class="v">fn</span>, if any, is computed when the event <span class="v">(<a href="ACL2____DEFBADGE.html">defbadge</a>
  fn)</span> or <span class="v">(<a href="ACL2____DEFWARRANT.html">defwarrant</a> fn)</span> completes successfully.  See <span class="tt"><a href="ACL2____DEFBADGE.html">defbadge</a></span> 
  for a sketch of the algorithm used to compute badges.  Here though we are 
  just concerned with how badges impact <span class="v">apply$</span>.</p> 
 
  <p>The <span class="v">ilks</span> of a function, <span class="v">fn</span>, determines the ``tameness 
  requirements'' mentioned in the specification of <span class="tt"><a href="ACL2____APPLY_42.html">apply$</a></span>.  When the 
  <span class="v">ilks</span> component of <span class="v">fn</span>'s badge is a list, it has as many elements as 
  there are formals to <span class="v">fn</span> and each successive element is called the 
  <i>ilk</i> of the corresponding formal.  For example, given the definition of 
  <span class="v">foldr</span> above and the badge shown for it, the first and third formals, 
  <span class="v">lst</span> and <span class="v">init</span>, each have ilk <span class="v">NIL</span> and the second formal, 
  <span class="v">fn</span>, has ilk <span class="v">:FN</span>.  In the special case that <span class="v">ilks</span> is not a list 
  it is <span class="v">T</span> and we just say each formal has <i>ilk</i> <span class="v">NIL</span> -- treating 
  that <span class="v">T</span> as a suitably long list of <span class="v">NIL</span>s.</p> 
 
  <p>Each non-<span class="v">NIL</span> ilk imposes a <i>tameness requirement</i> on <span class="v">(<a href="ACL2____APPLY_42.html">apply$</a>
  fn args)</span>.  If a formal has ilk <span class="v">:FN</span> the corresponding element of 
  <span class="v">args</span> must satisfy <span class="v">tamep-functionp</span>.  If a formal has ilk <span class="v">:EXPR</span> 
  the corresponding element of <span class="v">args</span> must satisfy <span class="v">tamep</span>.  Ilk <span class="v">NIL</span> 
  imposes no requirement.  (Thus, if the <span class="v">ilks</span> of <span class="v">fn</span>'s badge is 
  <span class="v">T</span>, as it is for <span class="v">cons</span> for example, there is no tameness requirement 
  at all.)  See <a href="ACL2____TAME.html">tame</a> for a discussion of the various notions of 
  tameness.</p> 
 
  <p>Informally, if a formal's ilk is <span class="v">:FN</span>, the corresponding element of 
  <span class="v">args</span> must be a tame function symbol or well-formed <span class="v">LAMBDA</span> object. 
  If a formal's ilk is <span class="v">:EXPR</span>, the corresponding element of <span class="v">args</span> must 
  be a tame expression.</p> 
 
  <p>If a formal has ilk <span class="v">:FN</span> then you are allowed to put a <span class="tt"><a href="ACL2____LAMBDA_42.html">lambda$</a></span> 
  expression in that slot.  Any quoted <span class="v">LAMBDA</span> object you explicitly write 
  in such a slot must be well-formed (see <a href="ACL2____WELL-FORMED-LAMBDA-OBJECTP.html">well-formed-lambda-objectp</a>). 
  Well-formedness can be hard to achieve in quoted hand-written <span class="v">LAMBDA</span> 
  objects; we recommend that you use <span class="v">lambda$</span>!  But the restrictions on 
  what can occupy a <span class="v">:FN</span> slot are enforced when user input is translated 
  into formal terms.  It is possible to circumvent these syntactic checks 
  without endangering soundness: axiomatically <span class="v">apply$</span> puts no restrictions 
  on its arguments, it just doesn't behave the way you might expect on 
  ill-formed <span class="v">LAMBDA</span> objects.  See <a href="ACL2____GRATUITOUS-LAMBDA-OBJECT-RESTRICTIONS.html">gratuitous-lambda-object-restrictions</a>.</p> 
 
  <p><b>Clarification</b>: The careful reader will note that the formal 
  requirement on a <span class="v">:FN</span> argument is that it must satisfy 
  <span class="v">tamep-functionp</span>.  Inspection of the definition of <span class="v">tamep-functionp</span> 
  reveals that the argument must either be badged symbol with ilks <span class="v">T</span> or 
  else be a tame <span class="v">LAMBDA</span> object.  But in the informal description above we 
  said that it must be a ``tame function symbol or a <i>well-formed</i> 
  <span class="v">LAMBDA</span> object.''  Well-formedness implies tameness but they are not the 
  same.  What's going on?  The reason for this and related discrepancies in the 
  documentation is that there is a tension between the logical definition of 
  <span class="v">apply$</span> and the practical business of executing it.  The former involves 
  the existence of a model, soundness, and the difficulty of proving theorems 
  about <span class="v">apply$</span>.  The latter involves the Common Lisp compiler.  We want 
  the logical foundations to be simple so we -- and you -- can reason about 
  <span class="v">apply$</span>, but the compiler imposes unavoidable and complicated 
  restrictions.  The upshot is that the logical foundations assign meaning to 
  <span class="v">LAMBDA</span> objects that cannot be compiled.  Applying merely ``tame'' 
  <span class="v">LAMBDA</span>s is slower than applying ``well-formed'' ones.  In a sense by 
  acting like ``tame <span class="v">LAMBDA</span> objects'' and ``well-formed <span class="v">LAMBDA</span> 
  objects'' are the same thing we're trying to trick you!  If you ever have 
  occasion to formally express the restrictions on <span class="v">apply$</span> in some theorem, 
  use <span class="v">tamep-functionp</span>.  But when you write concrete <span class="v">LAMBDA</span> constants, 
  try to keep them well-formed.  We try to encourage this by providing 
  <span class="tt"><a href="ACL2____LAMBDA_42.html">lambda$</a></span>, which guarantees well-formedness at translate-time, and by 
  implementing full well-formedness checks -- not just tameness checks -- on 
  quoted <span class="v">LAMBDA</span> objects in <span class="v">:FN</span> slots.  And we give you ways to 
  circumvent these checks -- see <a href="ACL2____GRATUITOUS-LAMBDA-OBJECT-RESTRICTIONS.html">gratuitous-lambda-object-restrictions</a> 
  -- if you really mean to.</p>
</body>
</html>
