<html>
<head>
<meta charset="UTF-8">
<title>Eval-expr</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=PFCS____EVAL-EXPR">Click for Eval-expr in the Full Manual</a></h3>

<p>Evaluate an expression, given an assignment and a prime field.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(eval-expr asg expr p) → nat?</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">asg</span> — <font color="#606060">Guard <span class="v">(<a href="PFCS____ASSIGNMENTP.html">assignmentp</a> asg)</span>.</font>
</dd> 
  <dd>
<span class="tt">expr</span> — <font color="#606060">Guard <span class="v">(<a href="PFCS____EXPRESSIONP.html">expressionp</a> expr)</span>.</font>
</dd> 
  <dd>
<span class="tt">p</span> — <font color="#606060">Guard <span class="v">(rtl::primep p)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">nat?</span> — <font color="#606060">Type <span class="v">(<a href="ACL2____MAYBE-NATP.html">maybe-natp</a> nat?)</span>, given <span class="v">(rtl::primep p)</span>.</font>
</dd> 
 
</dl></div> 
<p>In effect, this extends the assignment from variables to expressions. 
     If a variable is not in the assignment, 
     it is an error, indicated by <span class="v">nil</span>. 
     The evaluation is in the context of a prime field, 
     so a constant expression is reduced modulo the prime. 
     An addition or multiplication expression is evaluated recursively, 
     propagating errors and combining the results 
     with the field addition and multiplication operations. 
     If the assignment is for a prime field, 
     and the evaluation returns a natural number (not an error), 
     that natural number is in the prime field.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>eval-expr</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 eval-expr (asg expr p)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="PFCS____ASSIGNMENTP.html">assignmentp</a> asg)
                             (<a href="PFCS____EXPRESSIONP.html">expressionp</a> expr)
                             (rtl::primep p))))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="PFCS____ASSIGNMENT-FOR-PRIME-P.html">assignment-for-prime-p</a> asg p)))
 (<a href="COMMON-LISP____LET.html">let</a>
    ((__function__ 'eval-expr))
    (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
    (<a href="PFCS____EXPRESSION-CASE.html">expression-case</a>
         expr
         :const (<a href="COMMON-LISP____MOD.html">mod</a> expr.value p)
         :var (<a href="ACL2____B_A2.html">b*</a> ((pair (<a href="OMAP____IN.html">omap::in</a> expr.name (<a href="PFCS____ASSIGNMENT-FIX.html">assignment-fix</a> asg))))
                  (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> pair) (<a href="ACL2____NFIX.html">nfix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> pair)) nil))
         :add (<a href="ACL2____B_A2.html">b*</a> ((val1 (<a href="PFCS____EVAL-EXPR.html">eval-expr</a> asg expr.arg1 p))
                   ((unless val1) nil)
                   (val2 (<a href="PFCS____EVAL-EXPR.html">eval-expr</a> asg expr.arg2 p))
                   ((unless val2) nil))
                  (pfield::add val1 val2 p))
         :mul (<a href="ACL2____B_A2.html">b*</a> ((val1 (<a href="PFCS____EVAL-EXPR.html">eval-expr</a> asg expr.arg1 p))
                   ((unless val1) nil)
                   (val2 (<a href="PFCS____EVAL-EXPR.html">eval-expr</a> asg expr.arg2 p))
                   ((unless val2) nil))
                  (pfield::mul val1 val2 p)))))</pre> 
<p><b>Theorem: </b>maybe-natp-of-eval-expr</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> maybe-natp-of-eval-expr
        (<a href="ACL2____IMPLIES.html">implies</a> (rtl::primep p)
                 (<a href="ACL2____B_A2.html">b*</a> ((nat? (<a href="PFCS____EVAL-EXPR.html">eval-expr</a> asg expr p)))
                     (<a href="ACL2____MAYBE-NATP.html">maybe-natp</a> nat?)))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>natp-of-eval-expr-when-not-nil</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> natp-of-eval-expr-when-not-nil
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (rtl::primep p)
                      (<a href="PFCS____ASSIGNMENTP.html">assignmentp</a> asg)
                      (<a href="PFCS____EVAL-EXPR.html">eval-expr</a> asg expr p))
                 (<a href="ACL2____NATP.html">natp</a> (<a href="PFCS____EVAL-EXPR.html">eval-expr</a> asg expr p))))</pre> 
<p><b>Theorem: </b>fep-of-eval-expr</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fep-of-eval-expr
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (rtl::primep p)
                      (<a href="PFCS____ASSIGNMENTP.html">assignmentp</a> asg)
                      (<a href="PFCS____ASSIGNMENT-FOR-PRIME-P.html">assignment-for-prime-p</a> asg p)
                      (<a href="PFCS____EVAL-EXPR.html">eval-expr</a> asg expr p))
                 (fep (<a href="PFCS____EVAL-EXPR.html">eval-expr</a> asg expr p) p)))</pre> 
<p><b>Theorem: </b>eval-expr-of-assignment-fix-asg</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> eval-expr-of-assignment-fix-asg
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="PFCS____EVAL-EXPR.html">eval-expr</a> (<a href="PFCS____ASSIGNMENT-FIX.html">assignment-fix</a> asg) expr p)
               (<a href="PFCS____EVAL-EXPR.html">eval-expr</a> asg expr p)))</pre> 
<p><b>Theorem: </b>eval-expr-assignment-equiv-congruence-on-asg</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> eval-expr-assignment-equiv-congruence-on-asg
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="PFCS____ASSIGNMENT-EQUIV.html">assignment-equiv</a> asg asg-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="PFCS____EVAL-EXPR.html">eval-expr</a> asg expr p)
                        (<a href="PFCS____EVAL-EXPR.html">eval-expr</a> asg-equiv expr p)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>eval-expr-of-expression-fix-expr</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> eval-expr-of-expression-fix-expr
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="PFCS____EVAL-EXPR.html">eval-expr</a> asg (<a href="PFCS____EXPRESSION-FIX.html">expression-fix</a> expr) p)
               (<a href="PFCS____EVAL-EXPR.html">eval-expr</a> asg expr p)))</pre> 
<p><b>Theorem: </b>eval-expr-expression-equiv-congruence-on-expr</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> eval-expr-expression-equiv-congruence-on-expr
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="PFCS____EXPRESSION-EQUIV.html">expression-equiv</a> expr expr-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="PFCS____EVAL-EXPR.html">eval-expr</a> asg expr p)
                        (<a href="PFCS____EVAL-EXPR.html">eval-expr</a> asg expr-equiv p)))
        :rule-classes :congruence)</pre> 

</body>
</html>
