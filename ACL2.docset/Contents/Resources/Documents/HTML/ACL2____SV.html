<html>
<head>
<meta charset="UTF-8">
<title>Sv</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____SV">Click for Sv in the Full Manual</a></h3>

<p>SV is a hardware verification library that features a vector-based 
expression representation (<a href="SV____SVEX.html">svex</a>), efficient symbolic simulation that is 
integrated with <a href="ACL2____GL.html">gl</a>, and support for many SystemVerilog features.  It 
generally replaces <a href="ACL2____ESIM.html">esim</a> as a backend for <a href="ACL2____VL.html">vl</a>.</p> 
 
<div class="box"><p><b><font color="#ff0000">ALPHA VERSION</font></b>.  SV is not yet ready 
for public use and may change in drastic ways without any warning.  Users who 
want to be on the bleeding edge should follow the github project to try to keep 
up to date.</p></div> 
 
 
<p><b>SV</b> is an ACL2 library for hardware verification, developed 
at <a href="http://www.centtech.com/" target="_blank"><nobr>Centaur Technology<img src="../Icon_External_Link.png" title="External link to http://www.centtech.com/"></nobr></a>, primarily by Sol 
Swords.  It is the latest in a long line of hardware description languages that 
are deeply embedded within ACL2: it replaces Centaur's <a href="ACL2____ESIM.html">esim</a>, which 
itself succeeded the E language of Hunt &amp; Boyer, which was a descendant of 
DE2 (Hunt &amp; Reeber), which followed from DUAL-EVAL (Hunt &amp; Brock).  For 
a brief comparison, see <a href="SV____SV-VERSUS-ESIM.html">sv-versus-esim</a>.</p> 
 
<p>SV combines and integrates several major components:</p> 
 
<ol> 
 
<li>
<b>Expression language</b>.  At its core, SV is based on a language of 
symbolic <a href="SV____EXPRESSIONS.html">expressions</a> that represent functions over infinite-width 
vectors of four-valued ``bits.''  We define a sensible semantics for these 
expressions (<a href="SV____SVEX-EVAL.html">svex-eval</a>) and implement tools like <a href="SV____REWRITING.html">rewriting</a> for 
simplifying these expressions in provably sound ways.  We also provide special 
support for bit-blasting SV expressions with <a href="ACL2____GL.html">gl</a>, which allows you to 
process them with efficient <a href="ACL2____BOOLEAN-REASONING.html">ACL2::boolean-reasoning</a> tools like <a href="ACL2____AIGNET.html">ACL2::aignet</a>, <a href="ACL2____SATLINK.html">ACL2::satlink</a>, <a href="ACL2____UBDDS.html">ACL2::ubdds</a>, etc.</li> 
 
<li>
<b>Modules and compilation</b>.  SV has a simple, <a href="SV____SVEX.html">svex</a>-based 
representation for hardware modules.  It also has a compiler that can assemble 
these modules into a convenient finite state machine (FSM) representation, with 
well-defined semantics, and with full observability of all parts of the 
original design.  This compilation process involves, e.g., flattening the 
module hierarchy, resolving multiply driven wires, etc.; see <a href="SV____SVEX-COMPILATION.html">svex-compilation</a>.</li> 
 
<li>
<b>SystemVerilog/Verilog loading</b>.  SV is integrated with <a href="ACL2____VL.html">vl</a> so 
that you can translate SystemVerilog and Verilog designs into its internal SV 
representation.  In practice, this is the main way to get the SV modules to 
analyze.</li> 
 
<li>
<b>Proof development and debugging</b>.  SV provides tools like <a href="SV____SVEX-STVS.html">svex-stvs</a>s for running modules, which allow you to supply inputs and extract 
outputs at particular times.  These user-interfacing tools can be used in ACL2 
theorems and provide debugging conveniences such as generating VCD files for 
use with waveform viewers.</li> 
 
</ol> 
 
<p>This documentation is mainly a reference.  New users should probably start 
with the <a href="SV____SV-TUTORIAL.html">sv-tutorial</a>, which gives a tour of using SV to verify some 
simple Verilog designs.  (This tutorial will be quite familiar if you have used 
<a href="ACL2____ESIM.html">esim</a> in the past.)</p>
</body>
</html>
