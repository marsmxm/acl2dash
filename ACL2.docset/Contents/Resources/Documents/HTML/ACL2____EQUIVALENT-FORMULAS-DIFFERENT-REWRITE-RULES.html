<html>
<head>
<meta charset="UTF-8">
<title>Equivalent-formulas-different-rewrite-rules</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____EQUIVALENT-FORMULAS-DIFFERENT-REWRITE-RULES">Click for Equivalent-formulas-different-rewrite-rules in the Full Manual</a></h3>

<p>Logically equivalent formulas can generate radically different rules</p><p>Consider the rewrite rules that would be generated from the three 
 commands below.  In all three cases, the fact being stated relates the 
 <span class="v">n</span>th element of the reverse of <span class="v">x</span> to the <span class="v">n</span>th element of <span class="v">x</span>. 
 In fact, the three formulas are simple rearrangements of each other and are 
 all equivalent.  The theorem prover treats all three formulas equivalently 
 when proving them.  But the rules generated from them are very different.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nth-rev-1
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> n)
                (<a href="COMMON-LISP_____C3.html">&lt;</a> n (<a href="ACL2____LEN.html">len</a> x)))
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTH.html">nth</a> n (<a href="ACL2____REV.html">rev</a> x))
                  (<a href="COMMON-LISP____NTH.html">nth</a> (<a href="COMMON-LISP____-.html">-</a> (<a href="ACL2____LEN.html">len</a> x) (<a href="COMMON-LISP_____B2.html">+</a> 1 n)) x))))

(<a href="ACL2____DEFTHM.html">defthm</a> nth-rev-2
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> n)
                (<a href="COMMON-LISP_____C3.html">&lt;</a> n (<a href="ACL2____LEN.html">len</a> x)))
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTH.html">nth</a> (<a href="COMMON-LISP____-.html">-</a> (<a href="ACL2____LEN.html">len</a> x) (<a href="COMMON-LISP_____B2.html">+</a> 1 n)) x)
                  (<a href="COMMON-LISP____NTH.html">nth</a> n (<a href="ACL2____REV.html">rev</a> x)))))

(<a href="ACL2____DEFTHM.html">defthm</a> nth-rev-3
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> n)
                (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTH.html">nth</a> n (<a href="ACL2____REV.html">rev</a> x))
                            (<a href="COMMON-LISP____NTH.html">nth</a> (<a href="COMMON-LISP____-.html">-</a> (<a href="ACL2____LEN.html">len</a> x) (<a href="COMMON-LISP_____B2.html">+</a> 1 n)) x))))
           (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> n (<a href="ACL2____LEN.html">len</a> x)))))</pre> 
 
 <p>Here are the three rewrite rules:</p> 
 
 <p><b>nth-rev-1</b>:<br> 
 
 Replace instances of <span class="v">(<a href="COMMON-LISP____NTH.html">NTH</a> n (<a href="ACL2____REV.html">REV</a> x))</span><br> 
 
 by <span class="v">(<a href="COMMON-LISP____NTH.html">NTH</a> (<a href="COMMON-LISP____-.html">-</a> (<a href="ACL2____LEN.html">LEN</a> x) (<a href="COMMON-LISP_____B2.html">+</a> 1 n)) x)</span>,<br> 
 
 if you can establish that <span class="v">n</span> is a natural number less than the length of 
 <span class="v">x</span>.</p> 
 
 <p><b>nth-rev-2</b>:<br> 
 
 Replace instances of <span class="v">(<a href="COMMON-LISP____NTH.html">NTH</a> (<a href="COMMON-LISP____-.html">-</a> (<a href="ACL2____LEN.html">LEN</a> x) (<a href="COMMON-LISP_____B2.html">+</a> 1 n)) x)</span><br> 
 
 by <span class="v">(<a href="COMMON-LISP____NTH.html">NTH</a> n (<a href="ACL2____REV.html">REV</a> x))</span>,<br> 
 
 if you can establish that <span class="v">n</span> is a natural number less than the length of 
 <span class="v">x</span>.</p> 
 
 <p><b>nth-rev-3</b>:<br> 
 
 Replace instances of <span class="v">(<a href="COMMON-LISP_____C3.html">&lt;</a> n (<a href="ACL2____LEN.html">LEN</a> x))</span><br> 
 
 by <span class="v">NIL</span><br> 
 
 if you can establish that <span class="v">n</span> is a natural number and that <span class="v">(<a href="COMMON-LISP____NTH.html">NTH</a> n (<a href="ACL2____REV.html">REV</a>
 x))</span> is different from <span class="v">(<a href="COMMON-LISP____NTH.html">NTH</a> (<a href="COMMON-LISP____-.html">-</a> (<a href="ACL2____LEN.html">LEN</a> x) (<a href="COMMON-LISP_____B2.html">+</a> 1 n)) x)</span>.</p> 
 
 <p>As the driver of ACL2, you have to decide which rule you want <i>when you 
 give the command to prove it</i>.</p> 
 
 <p>If you tell the theorem prover to use both <span class="v">nth-rev-1</span> and 
 <span class="v">nth-rev-2</span>, ACL2 will enter an infinite loop when it sees any term 
 matching either <span class="v">NTH</span> expression.</p> 
 
 <p>Most users would choose form <span class="v">nth-rev-1</span> of the rule.  It eliminates 
 <span class="v">rev</span> from the problem â€” at the expense of introducing some 
 arithmetic.  But arithmetic is so fundamental it is rarely possible to avoid 
 it and it is likely to be in the problem already since you're indexing into 
 <span class="v">(<a href="ACL2____REV.html">rev</a> x)</span>.  The <span class="v">nth-rev-2</span> form of the rule is ``bad'' because it 
 introduces <span class="v">rev</span> into a problem where it might not have appeared.  The 
 <span class="v">nth-rev-3</span> version is ``bad'' because it makes the theorem prover shift 
 its attention from a simple arithmetic inequality to a complicated property of 
 <span class="v">nth</span> and <span class="v">rev</span>, which might not be in the problem.</p> 
 
 <p>Use your browser's <b>Back Button</b> now to return to <a href="ACL2____INTRODUCTION-TO-REWRITE-RULES-PART-1.html">introduction-to-rewrite-rules-part-1</a>.</p>
</body>
</html>
