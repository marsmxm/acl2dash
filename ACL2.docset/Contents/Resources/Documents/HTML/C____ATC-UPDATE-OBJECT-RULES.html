<html>
<head>
<meta charset="UTF-8">
<title>Atc-update-object-rules</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=C____ATC-UPDATE-OBJECT-RULES">Click for Atc-update-object-rules in the Full Manual</a></h3>

<p>Rules about <span class="tt"><a href="C____UPDATE-OBJECT.html">update-object</a></span>.</p><p>We have rules to unconditionally push <span class="tt"><a href="C____UPDATE-OBJECT.html">update-object</a></span> 
     through all the layers except <span class="tt"><a href="C____UPDATE-OBJECT.html">update-object</a></span>.</p><p>When <span class="tt"><a href="C____UPDATE-OBJECT.html">update-object</a></span> is applied to <span class="tt"><a href="C____UPDATE-OBJECT.html">update-object</a></span>, 
     we have rules similar to the ones for <span class="tt"><a href="C____UPDATE-VAR.html">update-var</a></span>. 
     If the two object designators are the same, we overwrite the object. 
     When the object designators differ, 
     we swap the <span class="tt"><a href="C____UPDATE-VAR.html">update-var</a></span>s 
     if the right pointer is smaller than the left one, 
     where smaller is a syntactic check: 
     when the two pointer arguments are symbols 
     (which happens in the proofs of C functions), 
     we compare the symbols; 
     when the two pointer arguments are <span class="tt"><a href="C____READ-VAR.html">read-var</a></span> calls 
     (which happens in the proofs of C loops), 
     we compare the identifier terms, 
     which boils down to comparing the variable names. 
     Either way, we normalize the nests of <span class="tt"><a href="C____UPDATE-OBJECT.html">update-object</a></span> calls 
     by ordering them according to the pointer. 
     We are talking about pointers here, and not object designators, 
     because, as mentioned in <a href="C____ATC-SYMBOLIC-COMPUTATION-STATES.html">atc-symbolic-computation-states</a>, 
     during symbolic execution the object designators in question 
     have the form <span class="v">(<a href="C____VALUE-POINTER-_E3DESIGNATOR.html">value-pointer-&gt;designator</a> &lt;pointer&gt;)</span>, 
     which is what the <span class="tt"><a href="ACL2____SYNTAXP.html">syntaxp</a></span> hypotheses below are based on.</p><p>We also include a rule saying that 
     updating an object with the existing one is a no-op. 
     This is similar to <span class="v">update-var-of-read-var</span>. 
     In particular, it uses two possibly different computation states, 
     for the reasons explained for <span class="v">update-var-of-read-var</span>.</p><p>We include the rule for commutativity of <span class="tt"><a href="C____OBJECT-DISJOINTP.html">object-disjointp</a></span>, 
     so it does not matter the order of the disjoint objects 
     in the hypotheses of the rules vs. the available hypothesis 
     during the symbolic execution 
     (i.e. commutativity normalizes them, via its loop stopper).</p> 
 
<h3>Definitions and Theorems</h3><p><b>Theorem: </b>update-object-of-add-frame</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> update-object-of-add-frame
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____UPDATE-OBJECT.html">update-object</a> objdes obj (<a href="C____ADD-FRAME.html">add-frame</a> fun compst))
               (<a href="C____ADD-FRAME.html">add-frame</a> fun (<a href="C____UPDATE-OBJECT.html">update-object</a> objdes obj compst))))</pre> 
<p><b>Theorem: </b>update-object-of-enter-scope</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> update-object-of-enter-scope
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____UPDATE-OBJECT.html">update-object</a> objdes obj (<a href="C____ENTER-SCOPE.html">enter-scope</a> compst))
               (<a href="C____ENTER-SCOPE.html">enter-scope</a> (<a href="C____UPDATE-OBJECT.html">update-object</a> objdes obj compst))))</pre> 
<p><b>Theorem: </b>update-object-of-add-var</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> update-object-of-add-var
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____UPDATE-OBJECT.html">update-object</a> objdes obj (<a href="C____ADD-VAR.html">add-var</a> var val compst))
               (<a href="C____ADD-VAR.html">add-var</a> var
                        val (<a href="C____UPDATE-OBJECT.html">update-object</a> objdes obj compst))))</pre> 
<p><b>Theorem: </b>update-object-of-update-var</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     update-object-of-update-var
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____UPDATE-OBJECT.html">update-object</a> objdes obj (<a href="C____UPDATE-VAR.html">update-var</a> var val compst))
            (<a href="C____UPDATE-VAR.html">update-var</a> var
                        val (<a href="C____UPDATE-OBJECT.html">update-object</a> objdes obj compst))))</pre> 
<p><b>Theorem: </b>update-object-of-update-object-same</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     update-object-of-update-object-same
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____UPDATE-OBJECT.html">update-object</a> objdes
                           obj (<a href="C____UPDATE-OBJECT.html">update-object</a> objdes obj2 compst))
            (<a href="C____UPDATE-OBJECT.html">update-object</a> objdes obj compst)))</pre> 
<p><b>Theorem: </b>update-object-of-update-object-less-symbol</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 update-object-of-update-object-less-symbol
 (<a href="ACL2____IMPLIES.html">implies</a>
  (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SYNTAXP.html">syntaxp</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____FFN-SYMB-P.html">ffn-symb-p</a> objdes 'value-pointer-&gt;designator)
                     (<a href="ACL2____FFN-SYMB-P.html">ffn-symb-p</a> objdes2 'value-pointer-&gt;designator)
                     (<a href="ACL2____B_A2.html">b*</a> ((ptr (<a href="ACL2____FARGN.html">fargn</a> objdes 1))
                          (ptr2 (<a href="ACL2____FARGN.html">fargn</a> objdes2 1)))
                         (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> ptr)
                              (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> ptr2)
                              (<a href="ACL2____SYMBOL_C3.html">symbol&lt;</a> ptr2 ptr)))))
       (<a href="C____OBJECT-DISJOINTP.html">object-disjointp</a> objdes objdes2))
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____UPDATE-OBJECT.html">update-object</a> objdes
                        obj (<a href="C____UPDATE-OBJECT.html">update-object</a> objdes2 obj2 compst))
         (<a href="C____UPDATE-OBJECT.html">update-object</a> objdes2 obj2
                        (<a href="C____UPDATE-OBJECT.html">update-object</a> objdes obj compst)))))</pre> 
<p><b>Theorem: </b>update-object-of-update-object-less-ident</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 update-object-of-update-object-less-ident
 (<a href="ACL2____IMPLIES.html">implies</a>
  (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SYNTAXP.html">syntaxp</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____FFN-SYMB-P.html">ffn-symb-p</a> objdes 'value-pointer-&gt;designator)
                     (<a href="ACL2____FFN-SYMB-P.html">ffn-symb-p</a> objdes2 'value-pointer-&gt;designator)
                     (<a href="ACL2____B_A2.html">b*</a> ((ptr (<a href="ACL2____FARGN.html">fargn</a> objdes 1))
                          (ptr2 (<a href="ACL2____FARGN.html">fargn</a> objdes2 1)))
                         (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____FFN-SYMB-P.html">ffn-symb-p</a> ptr 'read-var)
                              (<a href="ACL2____FFN-SYMB-P.html">ffn-symb-p</a> ptr2 'read-var)
                              (<a href="ACL2_____C3_C3.html">&lt;&lt;</a> (<a href="ACL2____FARGN.html">fargn</a> ptr2 1) (<a href="ACL2____FARGN.html">fargn</a> ptr 1))))))
       (<a href="C____OBJECT-DISJOINTP.html">object-disjointp</a> objdes objdes2))
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____UPDATE-OBJECT.html">update-object</a> objdes
                        obj (<a href="C____UPDATE-OBJECT.html">update-object</a> objdes2 obj2 compst))
         (<a href="C____UPDATE-OBJECT.html">update-object</a> objdes2 obj2
                        (<a href="C____UPDATE-OBJECT.html">update-object</a> objdes obj compst)))))</pre> 
<p><b>Theorem: </b>update-object-of-read-object-same</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   update-object-of-read-object-same
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SYNTAXP.html">syntaxp</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> compst))
                 (<a href="C____COMPUSTATEP.html">compustatep</a> compst1)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____OBJDESIGN-KIND.html">objdesign-kind</a> objdes) :address)
                 (<a href="C____VALUEP.html">valuep</a> (<a href="C____READ-OBJECT.html">read-object</a> objdes compst))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____READ-OBJECT.html">read-object</a> objdes compst)
                        (<a href="C____READ-OBJECT.html">read-object</a> objdes compst1)))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____UPDATE-OBJECT.html">update-object</a> objdes (<a href="C____READ-OBJECT.html">read-object</a> objdes compst)
                                  compst1)
                   compst1)))</pre> 

</body>
</html>
