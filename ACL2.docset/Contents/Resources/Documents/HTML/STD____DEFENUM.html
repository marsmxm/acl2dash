<html>
<head>
<meta charset="UTF-8">
<title>Defenum</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=STD____DEFENUM">Click for Defenum in the Full Manual</a></h3>

<p>Introduce an enumeration type, like an <span class="v">enum</span> in C.</p><p>General form:</p> 
<pre class="code">(<a href="STD____DEFENUM.html">defenum</a> name
  elements
  &amp;key mode         ; current defun-mode by default
       parents      ; nil by default
       short        ; nil by default
       long         ; nil by default
       )</pre> 
 
<p>For example,</p> 
 
<pre class="code">(<a href="STD____DEFENUM.html">defenum</a> day-p
  (:monday :tuesday :wednesday :thursday :friday :saturday :sunday))</pre> 
 
<p>results in a new function, <span class="v">(day-p x)</span>, that recognizes <span class="v">:monday</span>, 
<span class="v">:tuesday</span>, etc.</p> 
 
<h3>Usage and Options</h3> 
 
<p>I often use keyword symbols as the elements, but any objects (even conses) 
can be used.</p> 
 
<p>The optional <span class="v">:mode</span> keyword can be set to <span class="v">:logic</span> or <span class="v">:program</span> 
to introduce the recognizer in logic or program mode.  The default is whatever 
the current default defun-mode is for ACL2, i.e., if you are already in program 
mode, it will default to program mode, etc.</p> 
 
<p>The optional <span class="v">:parents</span>, <span class="v">:short</span>, and <span class="v">:long</span> parameters are like 
those in <a href="ACL2____DEFXDOC.html">defxdoc</a>.</p> 
 
<p>If keyword <span class="v">:disable-fc</span> is set, it causes the generated forward chaining 
rule to be disabled, which can make the admission of the defenum form and 
subsequent proofs much faster when the number of elements is large.</p> 
 
<p>If keyword <span class="v">:member</span> is set, then the body of the recognizer uses a 
<span class="v">member-eq</span> check rather than an <span class="v">or</span>.  This can speed up compilation 
when the number of elements is large.  It is probably necessary to have some 
rules about <span class="v">member-equal</span> available; loading the <span class="v">std/lists/sets</span> should 
be sufficient.</p> 
 
<h3>Performance Notes</h3> 
 
<p>The recognizer just tests its argument against the elements, in order. 
Because of this, you might want to order your elements so that the most common 
elements come first.  For instance, <span class="v">day-p</span> will be fastest on <span class="v">:monday</span> 
and slowest on <span class="v">:sunday</span>.</p> 
 
<p>The recognizer uses <a href="COMMON-LISP____EQ.html">eq</a> or <a href="COMMON-LISP____EQL.html">eql</a> checks where possible, so if 
your enumeration includes a mix of, say, conses and atom like symbols, you may 
wish to put the atoms first.</p> 
 
<p>Checking the argument against each element is probably a perfectly good 
strategy when the number of elements is small (perhaps fewer than 20) and when 
the equality checks are relatively fast (e.g., symbols, characters, numbers). 
It is probably is not a good strategy otherwise.  If you want to use defenum 
for something more complex, it might be best to modify it to adaptively use a 
fast alist or other schemes, based on the elements it is given.</p>
</body>
</html>
