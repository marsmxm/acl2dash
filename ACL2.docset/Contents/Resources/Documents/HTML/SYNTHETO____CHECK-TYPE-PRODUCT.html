<html>
<head>
<meta charset="UTF-8">
<title>Check-type-product</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=SYNTHETO____CHECK-TYPE-PRODUCT">Click for Check-type-product in the Full Manual</a></h3>

<p>Check if a type product is statically well-formed.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(check-type-product tprod ctxt) → (mv err? obligs)</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">tprod</span> — <font color="#606060">Guard <span class="v">(<a href="SYNTHETO____TYPE-PRODUCTP.html">type-productp</a> tprod)</span>.</font>
</dd> 
  <dd>
<span class="tt">ctxt</span> — <font color="#606060">Guard <span class="v">(<a href="SYNTHETO____CONTEXTP.html">contextp</a> ctxt)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">obligs</span> — <font color="#606060">Type <span class="v">(<a href="SYNTHETO____PROOF-OBLIGATION-LISTP.html">proof-obligation-listp</a> obligs)</span>.</font>
</dd> 
 
</dl></div> 
<p>A type product is always checked as part of a type definition 
     (which may or may not be inside a type recursion). 
     Thus, the context in which the type product is checked 
     may have type names, 
     but never has any functions, variables, or obligtion hypotheses.</p><p>The fields must have distinct names and well-formed types. 
     If there is an invariant expression, 
     we check it in the context augmented with 
     the typed variables derived from the fields. 
     Note that these are used both to create a variable context 
     and to create the obligation variables. 
     The obligation hypotheses are initially empty.</p><p>The expression must return a single boolean value.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>check-type-product</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 check-type-product (tprod ctxt)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SYNTHETO____TYPE-PRODUCTP.html">type-productp</a> tprod)
                             (<a href="SYNTHETO____CONTEXTP.html">contextp</a> ctxt))))
 (<a href="COMMON-LISP____DECLARE.html">declare</a>
      (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NULL.html">null</a> (<a href="SYNTHETO____CONTEXT-_E3FUNCTIONS.html">context-&gt;functions</a> ctxt))
                         (<a href="OMAP____EMPTY.html">omap::empty</a> (<a href="SYNTHETO____CONTEXT-_E3VARIABLES.html">context-&gt;variables</a> ctxt))
                         (<a href="COMMON-LISP____NULL.html">null</a> (<a href="SYNTHETO____CONTEXT-_E3OBLIGATION-VARS.html">context-&gt;obligation-vars</a> ctxt))
                         (<a href="COMMON-LISP____NULL.html">null</a> (<a href="SYNTHETO____CONTEXT-_E3OBLIGATION-HYPS.html">context-&gt;obligation-hyps</a> ctxt)))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((__function__ 'check-type-product))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
  (<a href="ACL2____B_A2.html">b*</a>
   ((fields (<a href="SYNTHETO____TYPE-PRODUCT-_E3FIELDS.html">type-product-&gt;fields</a> tprod))
    ((unless (<a href="ACL2____NO-DUPLICATESP-EQUAL.html">no-duplicatesp-equal</a> (<a href="SYNTHETO____FIELD-LIST-_E3NAME-LIST.html">field-list-&gt;name-list</a> fields)))
     (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____LIST.html">list</a> :duplicate-field-names (<a href="SYNTHETO____TYPE-PRODUCT-FIX.html">type-product-fix</a> tprod))
         nil))
    ((when (<a href="COMMON-LISP____NOT.html">not</a> (<a href="SYNTHETO____CHECK-TYPE-LIST.html">check-type-list</a> (<a href="SYNTHETO____FIELD-LIST-_E3TYPE-LIST.html">field-list-&gt;type-list</a> fields)
                                 ctxt)))
     (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____LIST.html">list</a> :malformed-types (<a href="SYNTHETO____TYPE-PRODUCT-FIX.html">type-product-fix</a> tprod))
         nil))
    (invariant (<a href="SYNTHETO____TYPE-PRODUCT-_E3INVARIANT.html">type-product-&gt;invariant</a> tprod))
    ((when (<a href="COMMON-LISP____NOT.html">not</a> invariant)) (<a href="ACL2____MV.html">mv</a> nil nil))
    (tvars (<a href="SYNTHETO____FIELD-LIST-TO-TYPED-VARIABLE-LIST.html">field-list-to-typed-variable-list</a> fields))
    (var-ctxt (<a href="SYNTHETO____TYPED-VARIABLES-TO-VARIABLE-CONTEXT.html">typed-variables-to-variable-context</a> tvars))
    (ctxt (<a href="SYNTHETO____CHANGE-CONTEXT.html">change-context</a> ctxt
                          :variables var-ctxt
                          :obligation-vars tvars
                          :obligation-hyps nil))
    (result (<a href="SYNTHETO____CHECK-EXPRESSION.html">check-expression</a> invariant ctxt)))
   (<a href="SYNTHETO____TYPE-RESULT-CASE.html">type-result-case</a>
    result
    :err (<a href="ACL2____MV.html">mv</a> result.info nil)
    :ok
    (<a href="ACL2____B_A2.html">b*</a>
       ((<a href="SYNTHETO____TYPE.html">type</a> (<a href="SYNTHETO____ENSURE-SINGLE-TYPE.html">ensure-single-type</a> result.types))
        ((when (<a href="COMMON-LISP____NOT.html">not</a> type))
         (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____LIST.html">list</a> :multi-valued-invariant (<a href="SYNTHETO____TYPE-PRODUCT-FIX.html">type-product-fix</a> tprod))
             nil))
        ((unless (<a href="SYNTHETO____SUBTYPEP.html">subtypep</a> type (<a href="SYNTHETO____TYPE-BOOLEAN.html">type-boolean</a>)
                           (<a href="SYNTHETO____CONTEXT-_E3TOPS.html">context-&gt;tops</a> ctxt)))
         (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____LIST.html">list</a> :non-boolean-invariant (<a href="SYNTHETO____TYPE-PRODUCT-FIX.html">type-product-fix</a> tprod))
             nil)))
       (<a href="ACL2____MV.html">mv</a> nil result.obligations))))))</pre> 
<p><b>Theorem: </b>proof-obligation-listp-of-check-type-product.obligs</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> proof-obligation-listp-of-check-type-product.obligs
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?err? ?obligs)
              (<a href="SYNTHETO____CHECK-TYPE-PRODUCT.html">check-type-product</a> tprod ctxt)))
            (<a href="SYNTHETO____PROOF-OBLIGATION-LISTP.html">proof-obligation-listp</a> obligs))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>check-type-product-of-type-product-fix-tprod</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> check-type-product-of-type-product-fix-tprod
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____CHECK-TYPE-PRODUCT.html">check-type-product</a> (<a href="SYNTHETO____TYPE-PRODUCT-FIX.html">type-product-fix</a> tprod)
                                   ctxt)
               (<a href="SYNTHETO____CHECK-TYPE-PRODUCT.html">check-type-product</a> tprod ctxt)))</pre> 
<p><b>Theorem: </b>check-type-product-type-product-equiv-congruence-on-tprod</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> check-type-product-type-product-equiv-congruence-on-tprod
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SYNTHETO____TYPE-PRODUCT-EQUIV.html">type-product-equiv</a> tprod tprod-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____CHECK-TYPE-PRODUCT.html">check-type-product</a> tprod ctxt)
                        (<a href="SYNTHETO____CHECK-TYPE-PRODUCT.html">check-type-product</a> tprod-equiv ctxt)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>check-type-product-of-context-fix-ctxt</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> check-type-product-of-context-fix-ctxt
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____CHECK-TYPE-PRODUCT.html">check-type-product</a> tprod (<a href="SYNTHETO____CONTEXT-FIX.html">context-fix</a> ctxt))
               (<a href="SYNTHETO____CHECK-TYPE-PRODUCT.html">check-type-product</a> tprod ctxt)))</pre> 
<p><b>Theorem: </b>check-type-product-context-equiv-congruence-on-ctxt</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> check-type-product-context-equiv-congruence-on-ctxt
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SYNTHETO____CONTEXT-EQUIV.html">context-equiv</a> ctxt ctxt-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____CHECK-TYPE-PRODUCT.html">check-type-product</a> tprod ctxt)
                        (<a href="SYNTHETO____CHECK-TYPE-PRODUCT.html">check-type-product</a> tprod ctxt-equiv)))
        :rule-classes :congruence)</pre> 

</body>
</html>
