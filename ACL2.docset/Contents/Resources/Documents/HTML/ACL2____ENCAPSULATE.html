<html>
<head>
<meta charset="UTF-8">
<title>Encapsulate</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____ENCAPSULATE">Click for Encapsulate in the Full Manual</a></h3>

<p>Hide some <a href="ACL2____EVENTS.html">events</a> and/or constrain some functions</p><p><span class="v">Encapsulate</span> provides a way to execute a sequence of <a href="ACL2____EVENTS.html">events</a> and then hide some of the resulting effects.  There are two kinds of 
 encapsulations: ``trivial'' and ``non-trivial''.  We discuss these briefly 
 before providing detailed <a href="COMMON-LISP____DOCUMENTATION.html">documentation</a>.</p> 
 
 <p>A trivial encapsulation is an event of the following form.</p> 
 
 <pre class="code">(<a href="ACL2____ENCAPSULATE.html">encapsulate</a>
 () ; nil here indicates "trivial"
 &lt;event-1&gt;
 ...
 &lt;event-k&gt;)</pre> 
 
 <p>We use the term ``sub-events'' to refer to <span class="v">&lt;event-1&gt;</span> through 
 <span class="v">&lt;event-k&gt;</span>.  Each sub-event <span class="v">&lt;event-i&gt;</span> may be ``<a href="ACL2____LOCAL.html">local</a>'', that 
 is, of the form <span class="v">(<a href="ACL2____LOCAL.html">local</a> &lt;event-i'&gt;)</span>; the other sub-events are called 
 ``non-local''.  When this <span class="v">encapsulate</span> form is submitted to ACL2, it is 
 processed in two passes.  On the first pass, each sub-event is printed (by 
 default) and processed in sequence; admission of the <span class="v">encapsulate</span> fails if 
 any <span class="v">&lt;event-i&gt;</span> fails to be admitted.  Then a second pass is made after 
 rolling back the logical <a href="ACL2____WORLD.html">world</a> to what it was just before executing the 
 <span class="v">encapsulate</span> form.  In the second pass, only the non-<a href="ACL2____LOCAL.html">local</a> forms 
 <span class="v">&lt;event-i&gt;</span> are evaluated, again in order, and proofs are skipped.</p> 
 
 <p>For example, the following trivial encapsulation exports a single event, 
 <span class="v">member-equal-reverse</span>.  The lemma <span class="v">member-revappend</span> is used (as a 
 <a href="ACL2____REWRITE.html">rewrite</a> rule) to prove <span class="v">member-equal-reverse</span> on the first pass, but 
 since <span class="v">member-revappend</span> is <a href="ACL2____LOCAL.html">local</a>, it is ignored on the second 
 (final) pass.</p> 
 
 <pre class="code">(<a href="ACL2____ENCAPSULATE.html">encapsulate</a>
 ()

 (<a href="ACL2____LOCAL.html">local</a>
  (<a href="ACL2____DEFTHM.html">defthm</a> member-revappend
    (<a href="ACL2____IFF.html">iff</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> a (<a href="COMMON-LISP____REVAPPEND.html">revappend</a> x y))
         (<a href="COMMON-LISP____OR.html">or</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> a x)
             (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> a y)))
    :hints (("Goal" :induct (<a href="COMMON-LISP____REVAPPEND.html">revappend</a> x y)))))

 (<a href="ACL2____DEFTHM.html">defthm</a> member-equal-reverse
   (<a href="ACL2____IFF.html">iff</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> a (<a href="COMMON-LISP____REVERSE.html">reverse</a> x))
        (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> a x))))</pre> 
 
 <p>Of course, one might prefer to prove these <a href="ACL2____EVENTS.html">events</a> at the top level, 
 rather than within an encapsulation; but the point here is to illustrate that 
 you can have <a href="ACL2____LOCAL.html">local</a> <a href="ACL2____EVENTS.html">events</a> that do not become part of the logical 
 <a href="ACL2____WORLD.html">world</a>.  (Such a capability is also provided at the level of <a href="ACL2____BOOKS.html">books</a>; in particular, see <a href="ACL2____INCLUDE-BOOK.html">include-book</a>.)</p> 
 
 <p>Note that trivial encapsulates must introduce at least one sub-event, or 
 else they are treated as no-ops, with no effect on the logical <a href="ACL2____WORLD.html">world</a>. 
 Consider the following example.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="ACL2____ENCAPSULATE.html">encapsulate</a> nil (<a href="ACL2____LOCAL.html">local</a> (<a href="COMMON-LISP____DEFUN.html">defun</a> f (x) x)))

To verify that the encapsulated event correctly extends the current
theory we will evaluate it.  The theory thus constructed is only ephemeral.

Encapsulated Event:


ACL2 !&gt;&gt;(<a href="ACL2____LOCAL.html">LOCAL</a> (<a href="COMMON-LISP____DEFUN.html">DEFUN</a> F (X) X))

Since F is non-recursive, its admission is trivial.  We observe that
the type of F is described by the theorem (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (F X) X).

Summary
Form:  ( DEFUN F ...)
Rules: NIL
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
F

End of Encapsulated Event.

ACL2 Observation in ( ENCAPSULATE NIL (<a href="ACL2____LOCAL.html">LOCAL</a> ...) ...):  The submitted
encapsulate event has created no new ACL2 events, and thus is leaving
the ACL2 logical world unchanged.  See :DOC encapsulate.

Summary
Form:  ( ENCAPSULATE NIL (<a href="ACL2____LOCAL.html">LOCAL</a> ...) ...)
Rules: NIL
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 :EMPTY-ENCAPSULATE
ACL2 !&gt;</pre> 
 
 <p>After the above evaluation, we are left in the <a href="ACL2____WORLD.html">world</a> with which we 
 began.  For example, if you evaluate the above form in the initial ACL2 world, 
 you can see the following both before and after that evaluation.</p> 
 
 <pre class="code">ACL2 !&gt;:pbt 0
           0:x(<a href="ACL2____EXIT-BOOT-STRAP-MODE.html">EXIT-BOOT-STRAP-MODE</a>)
ACL2 !&gt;</pre> 
 
 <p>On the other hand, non-trivial encapsulations provide a way to introduce 
 axioms about new function symbols, without introducing inconsistency and 
 without introducing complete definitions.  The following example illustrates 
 how that works.</p> 
 
 <pre class="code">(<a href="ACL2____ENCAPSULATE.html">encapsulate</a>

; The following list has a single signature, introducing a function foo of
; one argument that returns one value.  (<a href="COMMON-LISP____THE.html">The</a> list is non-empty, so we call
; this a "non-trivial" encapsulation.)
 ( ((foo *) =&gt; *) )

; Introduce a ``witness'' (example) for foo, marked as local so that
; it is not exported:
 (<a href="ACL2____LOCAL.html">local</a> (<a href="COMMON-LISP____DEFUN.html">defun</a> foo (x) x))

; Introduce a non-local property to be exported:
 (<a href="ACL2____DEFTHM.html">defthm</a> foo-preserves-consp
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x)
            (<a href="COMMON-LISP____CONSP.html">consp</a> (foo x))))
)</pre> 
 
 <p>The form above introduces a new function symbol, <span class="v">foo</span>, with the 
 indicated property and no definition.  In fact, the output from ACL2 concludes 
 as follows.</p> 
 
 <pre class="code">The following constraint is associated with the function FOO:

(<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> X) (<a href="COMMON-LISP____CONSP.html">CONSP</a> (FOO X)))</pre> 
 
 <p>To understand this example, we consider how non-trivial encapsulations are 
 processed.  The same two passes are made as for trivial encapsulations, and 
 the (<a href="ACL2____LOCAL.html">local</a>) definition of <span class="v">foo</span> is ignored on the second pass, and 
 hence does not appear in the resulting ACL2 logical <a href="ACL2____WORLD.html">world</a>.  But before 
 the second pass, each <a href="ACL2____SIGNATURE.html">signature</a> is stored in the <a href="ACL2____WORLD.html">world</a>.  Thus, 
 when the theorem <span class="v">foo-preserves-consp</span> is encountered in the second pass, 
 <span class="v">foo</span> is a known function symbol with the indicated signature.</p> 
 
 <p>If any event fails while evaluating a call of <span class="v">encapsulate</span>, the entire 
 <span class="v">encapsulate</span> call is deemed to have failed, and the logical <a href="ACL2____WORLD.html">world</a> 
 is rolled back to what it was immediately before the <span class="v">encapsulate</span> 
 call.</p> 
 
 <p>We now provide detailed documentation.  But discussion of redundancy for 
 <span class="v">encapsulate</span> events may be found elsewhere; see <a href="ACL2____REDUNDANT-ENCAPSULATE.html">redundant-encapsulate</a>.</p> 
 
 <pre class="code">Other Examples:
(<a href="ACL2____ENCAPSULATE.html">encapsulate</a> (((an-element *) =&gt; *))

; The list of signatures above could also be written
;            ((an-element (lst) t))

  (<a href="ACL2____LOCAL.html">local</a> (<a href="COMMON-LISP____DEFUN.html">defun</a> an-element (lst)
           (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> lst) (<a href="COMMON-LISP____CAR.html">car</a> lst) nil)))
  (<a href="ACL2____LOCAL.html">local</a> (<a href="ACL2____DEFTHM.html">defthm</a> member-equal-car
            (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> lst (<a href="ACL2____TRUE-LISTP.html">true-listp</a> lst))
                     (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> (<a href="COMMON-LISP____CAR.html">car</a> lst) lst))))
  (<a href="ACL2____DEFTHM.html">defthm</a> thm1
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NULL.html">null</a> lst) (<a href="COMMON-LISP____NULL.html">null</a> (an-element lst))))
  (<a href="ACL2____DEFTHM.html">defthm</a> thm2
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> lst)
                   (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____NULL.html">null</a> lst)))
              (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> (an-element lst) lst))))

(<a href="ACL2____ENCAPSULATE.html">encapsulate</a>
 () ; empty signature: no constrained functions indicated

 (<a href="ACL2____LOCAL.html">local</a> (<a href="ACL2____DEFTHM.html">defthm</a> hack
          (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SYNTAXP.html">syntaxp</a> (<a href="ACL2____QUOTEP.html">quotep</a> x))
                        (<a href="ACL2____SYNTAXP.html">syntaxp</a> (<a href="ACL2____QUOTEP.html">quotep</a> y)))
                   (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP_____B2.html">+</a> x y z)
                          (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP_____B2.html">+</a> x y) z)))))

 (<a href="ACL2____DEFTHM.html">defthm</a> nthcdr-add1-conditional
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> (<a href="COMMON-LISP____1_B2.html">1+</a> n)))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> (<a href="COMMON-LISP____1_B2.html">1+</a> n) x)
                   (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> n (<a href="COMMON-LISP____CDR.html">cdr</a> x))))))

General Form:
(<a href="ACL2____ENCAPSULATE.html">encapsulate</a> (<a href="ACL2____SIGNATURE.html">signature</a> ... signature)
  ev1
  ...
  evn)</pre> 
 
 <p>where each <span class="tt"><a href="ACL2____SIGNATURE.html">signature</a></span> is a well-formed signature, each 
 <span class="v">signature</span> describes a different function symbol, and each <span class="v">evi</span> is an 
 embedded event form (see <a href="ACL2____EMBEDDED-EVENT-FORM.html">embedded-event-form</a>).  Also see <a href="ACL2____SIGNATURE.html">signature</a>, in particular for a discussion of how a signature can assign a 
 <a href="ACL2____GUARD.html">guard</a> to a function symbol.  There must be at least one <span class="v">evi</span>.  The 
 <span class="v">evi</span> inside <span class="tt"><a href="ACL2____LOCAL.html">local</a></span> special forms are called ``local'' <a href="ACL2____EVENTS.html">events</a> 
 below.  <a href="ACL2____EVENTS.html">Events</a> that are not <span class="tt"><a href="ACL2____LOCAL.html">local</a></span> are sometimes said to be 
 ``exported'' by the encapsulation.  We make the further restriction that no 
 <span class="tt"><a href="ACL2____DEFAXIOM.html">defaxiom</a></span> event may be introduced in the scope of an <span class="v">encapsulate</span> 
 (not even by <span class="v">encapsulate</span> or <span class="tt"><a href="ACL2____INCLUDE-BOOK.html">include-book</a></span> events that are among 
 the <span class="v">evi</span>).  Furthermore, no non-<span class="tt"><a href="ACL2____LOCAL.html">local</a></span> <span class="tt"><a href="ACL2____INCLUDE-BOOK.html">include-book</a></span> event 
 is permitted in the scope of any <span class="v">encapsulate</span> with a non-empty list of 
 signatures.</p> 
 
 <p>To be well-formed, an <span class="v">encapsulate</span> event must have the properties that 
 each event in the body (including the <span class="tt"><a href="ACL2____LOCAL.html">local</a></span> ones) can be successfully 
 executed in sequence and that in the resulting theory, each function mentioned 
 among the <a href="ACL2____SIGNATURE.html">signature</a>s was introduced via a <span class="tt"><a href="ACL2____LOCAL.html">local</a></span> event and has 
 the <a href="ACL2____SIGNATURE.html">signature</a> listed.  (A utility is provided to assist in debugging 
 failures of such execution; see <a href="ACL2____REDO-FLAT.html">redo-flat</a>.)  In addition, the body may 
 contain no ``local incompatibilities'' which, roughly stated, means that the 
 <a href="ACL2____EVENTS.html">events</a> that are not <span class="tt"><a href="ACL2____LOCAL.html">local</a></span> must not syntactically require 
 symbols defined by <span class="tt"><a href="ACL2____LOCAL.html">local</a></span> <span class="tt"><a href="ACL2____EVENTS.html">events</a></span>, except for the functions 
 listed in the <a href="ACL2____SIGNATURE.html">signature</a>s.  See <a href="ACL2____LOCAL-INCOMPATIBILITY.html">local-incompatibility</a>.  Finally, 
 no non-<span class="tt"><a href="ACL2____LOCAL.html">local</a></span> recursive definition in the body may involve in its 
 suggested induction scheme any function symbol listed among the <a href="ACL2____SIGNATURE.html">signature</a>s.  See <a href="ACL2____SUBVERSIVE-RECURSIONS.html">subversive-recursions</a>.</p> 
 
 <p>Observe that if the <a href="ACL2____SIGNATURE.html">signature</a>s list is empty, the resulting 
 ``trivial'' <span class="v">encapsulate</span> may still be useful for deriving theorems to be 
 exported whose proofs require lemmas you prefer to hide (i.e., made <span class="tt"><a href="ACL2____LOCAL.html">local</a></span>).  Whether trivial or not (i.e., whether the signature is empty or 
 not), <span class="v">encapsulate</span> exports the results of evaluating its non-<span class="tt"><a href="ACL2____LOCAL.html">local</a></span> 
 <a href="ACL2____EVENTS.html">events</a>, but its <span class="tt"><a href="ACL2____LOCAL.html">local</a></span> <a href="ACL2____EVENTS.html">events</a> are ignored for the 
 resulting logical <a href="ACL2____WORLD.html">world</a>.</p> 
 
 <p>The result of a non-trivial <span class="v">encapsulate</span> event is an extension of the 
 logic in which, roughly speaking, the functions listed in the <a href="ACL2____SIGNATURE.html">signature</a>s are constrained to have the <a href="ACL2____SIGNATURE.html">signature</a>s listed and to 
 satisfy the non-<span class="tt"><a href="ACL2____LOCAL.html">local</a></span> theorems proved about them.  In fact, other 
 functions introduced in the <span class="v">encapsulate</span> event may be considered to have 
 ``<a href="ACL2____CONSTRAINT.html">constraint</a>s'' as well.  (See <a href="ACL2____CONSTRAINT.html">constraint</a> for details, which are 
 only relevant to functional instantiation.)  Since the <a href="ACL2____CONSTRAINT.html">constraint</a>s were 
 all theorems in the ``ephemeral'' or ``local'' theory, we are assured that the 
 extension produced by <span class="v">encapsulate</span> is sound.  In essence, the <span class="tt"><a href="ACL2____LOCAL.html">local</a></span> definitions of the constrained functions are just ``witness functions'' 
 that establish the consistency of the <a href="ACL2____CONSTRAINT.html">constraint</a>s.  Because those 
 definitions are <span class="tt"><a href="ACL2____LOCAL.html">local</a></span>, they are not present in the theory produced by 
 encapsulation.  After a non-trivial <span class="v">encapsulate</span> event is admitted, 
 theorems about the constrained function symbols may then be proved — 
 theorems whose proofs necessarily employ only the <a href="ACL2____CONSTRAINT.html">constraint</a>s.  Thus, 
 those theorems may be later functionally instantiated, as with the 
 <span class="v">:functional-instance</span> lemma instance (see <a href="ACL2____LEMMA-INSTANCE.html">lemma-instance</a>), to 
 derive analogous theorems about different functions, provided the constraints 
 (see <a href="ACL2____CONSTRAINT.html">constraint</a>) can be proved about the new functions.</p> 
 
 <p>The <a href="ACL2____DEFAULT-DEFUN-MODE.html">default-defun-mode</a> for the first event in an encapsulation is 
 the default <a href="ACL2____DEFUN-MODE.html">defun-mode</a> ``outside'' the encapsulation.  But since <a href="ACL2____EVENTS.html">events</a> changing the <a href="ACL2____DEFUN-MODE.html">defun-mode</a> are permitted within the body of an 
 <span class="v">encapsulate</span>, the default <a href="ACL2____DEFUN-MODE.html">defun-mode</a> may be changed.  However, 
 <a href="ACL2____DEFUN-MODE.html">defun-mode</a> changes occurring within the body of the <span class="v">encapsulate</span> 
 are not exported.  In particular, the <span class="tt"><a href="ACL2____ACL2-DEFAULTS-TABLE.html">ACL2-defaults-table</a></span> after an 
 <span class="v">encapsulate</span> is always the same as it was before the <span class="v">encapsulate</span>, 
 even though the <span class="v">encapsulate</span> body might contain <a href="ACL2____DEFUN-MODE.html">defun-mode</a> changing 
 <a href="ACL2____EVENTS.html">events</a>, <span class="v">:</span><span class="tt"><a href="ACL2____PROGRAM.html">program</a></span> and <span class="v">:</span><span class="tt"><a href="ACL2____LOGIC.html">logic</a></span>.  See <a href="ACL2____DEFUN-MODE.html">defun-mode</a>.  More generally, after execution of an <span class="v">encapsulate</span> event, 
 the value of <span class="tt"><a href="ACL2____ACL2-DEFAULTS-TABLE.html">ACL2-defaults-table</a></span> is restored to what it was 
 immediately before that event was executed.  See <a href="ACL2____ACL2-DEFAULTS-TABLE.html">ACL2-defaults-table</a>.</p> 
 
 <p>We make some remarks on <a href="ACL2____GUARD.html">guard</a>s and evaluation.  Calls of functions 
 introduced in the <a href="ACL2____SIGNATURE.html">signature</a>s list cannot be evaluated in the ACL2 
 read-eval-print loop.  See <a href="ACL2____DEFATTACH.html">defattach</a> for a way to overcome this 
 limitation.  Moreover, any <span class="v">:</span><span class="tt"><a href="ACL2____GUARD.html">guard</a></span> supplied in the signature is 
 automatically associated in the <a href="ACL2____WORLD.html">world</a> with its corresponding function 
 symbol, with no requirement beyond what is required for a legal <a href="ACL2____SIGNATURE.html">signature</a> other than that all of the guard's function symbols are in 
 <span class="v">:</span><span class="tt"><a href="ACL2____LOGIC.html">logic</a></span> mode with their <a href="ACL2____GUARD.html">guard</a>s verified.  In particular, 
 there need not be any relationship between a guard in a signature and the 
 guard in a <span class="v">local</span> witness function.  Finally, note that for functions 
 introduced non-<a href="ACL2____LOCAL.html">local</a>ly inside a non-trivial <span class="v">encapsulate</span> event, 
 <a href="ACL2____GUARD.html">guard</a> verification is illegal unless ACL2 determines that the proof 
 obligations hold outside the <span class="tt"><a href="ACL2____ENCAPSULATE.html">encapsulate</a></span> event as well.</p> 
 
 <pre class="code">(<a href="ACL2____ENCAPSULATE.html">encapsulate</a>
 ((f (x) t))
 (<a href="ACL2____LOCAL.html">local</a> (<a href="COMMON-LISP____DEFUN.html">defun</a> f (x) (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t)) (<a href="COMMON-LISP____CONSP.html">consp</a> x)))
 ;; ERROR!
 (<a href="COMMON-LISP____DEFUN.html">defun</a> g (x)
   (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (f x)))
   (<a href="COMMON-LISP____CAR.html">car</a> x)))</pre> 
 
 <p>The order of the <a href="ACL2____EVENTS.html">events</a> in the vicinity of an <span class="v">encapsulate</span> is 
 confusing.  We discuss it in some detail here because when logical names are 
 being used with theory functions to compute sets of rules, it is sometimes 
 important to know the order in which <a href="ACL2____EVENTS.html">events</a> were executed.  (See <a href="ACL2____LOGICAL-NAME.html">logical-name</a> and see <a href="ACL2____THEORY-FUNCTIONS.html">theory-functions</a>.)  What, for example, is the set 
 of function names extant in the middle of an encapsulation?</p> 
 
 <p>If the most recent event is <span class="v">previous</span> and then you execute an 
 <span class="v">encapsulate</span> constraining <span class="v">an-element</span> with two non-<span class="tt"><a href="ACL2____LOCAL.html">local</a></span> <a href="ACL2____EVENTS.html">events</a> in its body, <span class="v">thm1</span> and <span class="v">thm2</span>, then the order of the <a href="ACL2____EVENTS.html">events</a> after the encapsulation is (reading chronologically forward): 
 <span class="v">previous</span>, <span class="v">thm1</span>, <span class="v">thm2</span>, <span class="v">an-element</span> (the <span class="v">encapsulate</span> 
 itself).  Actually, between <span class="v">previous</span> and <span class="v">thm1</span> certain extensions 
 were made to the <a href="ACL2____WORLD.html">world</a> by the superior <span class="v">encapsulate</span>, to permit 
 <span class="v">an-element</span> to be used as a function symbol in <span class="v">thm1</span>.</p> 
 
 <p>Remark on return value.  As with all <a href="ACL2____EVENTS.html">events</a>, a call of 
 <span class="v">encapsulate</span> returns an <a href="ACL2____ERROR-TRIPLE.html">error-triple</a>, <span class="v">(<a href="ACL2____MV.html">mv</a> erp val state)</span>, 
 where <span class="v">erp</span> is nil when the event is successfully admitted.  In that case, 
 <span class="v">val</span> is <span class="v">t</span> if the list of signatures is <span class="v">nil</span>; <span class="v">val</span> is <span class="v">fn</span> 
 if there is a single signature, which introduces the function symbol, <span class="v">fn</span>; 
 and otherwise is the list of function symbols introduced in the 
 signatures.</p> 
 
 <p>Remark on implicit <a href="ACL2____CONSTRAINT.html">constraint</a>s (unknown-constraints).  See <a href="ACL2____PARTIAL-ENCAPSULATE.html">partial-encapsulate</a> for a related utility that allows some of the constraints 
 to be unspecified.  This is an advanced capability that is useful when one 
 installs special-purpose code, possibly in raw Lisp, using a trust tag (see 
 <a href="ACL2____DEFTTAG.html">defttag</a>).</p> 
 
 <p>Remark for ACL2(r) (see <a href="COMMON-LISP____REAL.html">real</a>).  For ACL2(r), <span class="tt"><a href="ACL2____ENCAPSULATE.html">encapsulate</a></span> can 
 be used to introduce classical and non-classical functions, as determined by 
 the signatures; see <a href="ACL2____SIGNATURE.html">signature</a>.  Those marked as classical (respectively 
 non-classical) must have classical (respectively, non-classical) <span class="tt"><a href="ACL2____LOCAL.html">local</a></span> 
 witness functions.  A related requirement applies to functional instantiation; 
 see <a href="ACL2____LEMMA-INSTANCE.html">lemma-instance</a>.</p> 
 
 <p>Remark on the value returned.  As with all <a href="ACL2____EMBEDDED-EVENT-FORM.html">embedded-event-form</a>s, a 
 successful call of <span class="v">encapsulate</span> returns an <a href="ACL2____ERROR-TRIPLE.html">error-triple</a> of the form 
 <span class="v">(<a href="ACL2____MV.html">mv</a> nil val state)</span>.  By default, you will therefore see <span class="v">val</span> printed, 
 preceded by a space, before the next prompt is printed.  But what is that 
 value returned, <span class="v">val</span>?  If the value returned by the final event 
 <span class="v">event-k</span> in the second (or sole) pass through the <span class="tt"><a href="ACL2____ENCAPSULATE.html">encapsulate</a></span> 
 event is of the form <span class="v">(:return-value name)</span> — for example, if 
 <span class="v">event-k</span> is <span class="v">(<a href="ACL2____VALUE-TRIPLE.html">value-triple</a> '(:return-value name) :on-skip-proofs t)</span> 
 — then that <span class="v">name</span> is the value returned for the <span class="v">encapsulate</span>. 
 Otherwise, if the <a href="ACL2____SIGNATURE.html">signature</a> list is non-empty, then the value returned 
 is the list of names introduced by the signatures except when there is just 
 one name, in which case the value returned is that name.  Otherwise, the value 
 returned is <span class="v">T</span>.</p>
</body>
</html>
