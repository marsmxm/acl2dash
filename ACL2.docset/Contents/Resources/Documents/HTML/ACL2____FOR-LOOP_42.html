<html>
<head>
<meta charset="UTF-8">
<title>For-loop$</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____FOR-LOOP_42">Click for For-loop$ in the Full Manual</a></h3>

<p>Iteration with <span class="tt"><a href="ACL2____LOOP_42.html">loop$</a></span> over an interval of integers or a list</p><p>This topic assumes that you have read the introduction to 
  <span class="v">loop$</span> expressions in ACL2; see <a href="ACL2____LOOP_42.html">loop$</a>.  Here we give more complete 
  documentation on <span class="v">FOR</span> <span class="v">loop$</span> expressions, beginning with informal 
  discussion and then continuing with detailed syntax (General Form) and 
  semantics.</p> 
 
  <p>Examples of <span class="tt"><a href="ACL2____LOOP_42.html">loop$</a></span> expressions, including <span class="v">FOR</span> <span class="v">loop$</span>s, may 
  be found in <a href="ACL2____COMMUNITY-BOOK.html">community-book</a> <span class="v">projects/apply/loop-tests.lisp</span>.</p> 
 
  <p>The only allowed iteration clauses are <span class="v">IN</span>, where the variable ranges 
  over the elements of the given true list; <span class="v">ON</span>, where the variable ranges 
  over the tails of the given true-list; and <span class="v">FROM/TO/BY</span>, where the 
  variable ranges over the integers between two bounds, stepping by a positive 
  integer increment (or by 1 if no <span class="v">BY</span> clause is provided).</p> 
 
  <p>You may have as many iteration clauses as you wish, connected with 
  <span class="v">AS</span>.  Each must introduce a unique iteration variable and that variable 
  may be optionally followed by an <span class="v">of-type</span> <a href="ACL2____TYPE-SPEC.html">type-spec</a> specification. 
  <span class="v">Of-type</span> is a Common Lisp feature that allows the compiler to optimize 
  operations on the variable in question.  Here is an example.</p> 
 
  <pre class="code">(<a href="ACL2____LOOP_42.html">loop$</a> for v of-type (<a href="COMMON-LISP____AND.html">and</a> integer (<a href="COMMON-LISP____NOT.html">not</a> (satisfies zerop)))
             from 1 to 100
       sum (<a href="COMMON-LISP_____F2.html">/</a> 1 v))</pre> 
 
  <p>Here is that same example with a more concise type specification.</p> 
 
  <pre class="code">(<a href="ACL2____LOOP_42.html">loop$</a> for v of-type (integer 1 *)
             from 1 to 100
       sum (<a href="COMMON-LISP_____F2.html">/</a> 1 v))</pre> 
 
  <p>After all of the iteration clauses, you may have a termination test, 
  signaled by <span class="v">UNTIL</span>, and/or a conditional test, signaled by <span class="v">WHEN</span>.  If 
  both are provided, the <span class="v">UNTIL</span> test must come first.  Iteration stops when 
  the <span class="v">UNTIL</span> test is satisfied.  The conditional test determines whether 
  the loop body is executed for the current value of the iteration 
  variables.</p> 
 
  <p>Between the <span class="v">UNTIL</span> symbol and the expression to be tested, and between 
  the <span class="v">WHEN</span> symbol and its expression, you may include a <span class="v">:GUARD</span> 
  clause.  This is useful if <a href="ACL2____GUARD.html">guard</a> verification requires an invariant 
  relating multiple iteration variables.  An example of a guarded <span class="v">UNTIL</span> 
  clause is</p> 
 
  <pre class="code">(<a href="ACL2____LOOP_42.html">loop$</a> for u in lst1 as v in lst2
       until :guard (invariantp u v) (test u v)
       collect (<a href="ACL2____BODY.html">body</a> u v))</pre> 
 
  <p>ACL2 supports only five operators in <span class="v">FOR</span> <span class="v">loop$</span>s: <span class="v">SUM</span>, 
  <span class="v">COLLECT</span>, <span class="v">ALWAYS</span>, <span class="v">THEREIS</span> and <span class="v">APPEND</span>.  We anticipate 
  adding other Common Lisp operators eventually.</p> 
 
  <p>The special symbols noted above, sometimes called ``<span class="v">FOR</span> <span class="v">loop$</span> 
  keywords'' or just ``<span class="v">loop$</span> keywords'' may be in any package.  These are 
  <span class="v">FOR</span>, <span class="v">IN</span>, <span class="v">ON</span>, <span class="v">FROM</span>, <span class="v">TO</span>, <span class="v">BY</span>, <span class="v">OF-TYPE</span>, 
  <span class="v">WHEN</span>, <span class="v">UNTIL</span>, <span class="v">SUM</span>, <span class="v">COLLECT</span>, <span class="v">ALWAYS</span>, <span class="v">THEREIS</span>, and 
  <span class="v">APPEND</span>.</p> 
 
  <p>Between the operator, e.g., <span class="v">SUM</span> or <span class="v">COLLECT</span>, and the 
  <span class="v">loop$</span> body you may include a <span class="v">:GUARD</span> clause as in</p> 
 
  <pre class="code">(<a href="ACL2____LOOP_42.html">loop$</a> for u in lst1 as v in lst2
       collect :guard (invariantp u v) (<a href="ACL2____BODY.html">body</a> u v))</pre> 
 
  <p>This is sometimes necessary in the verification of the <a href="ACL2____GUARD.html">guard</a>s for 
  the <span class="v">loop$</span> body because Common Lisp's <span class="v">OF-TYPE</span> clauses do not permit 
  you to relate one variable to another.</p> 
 
  <h3>General Form</h3> 
 
  <p>The syntax of Common Lisp <span class="v">loop</span> expressions is extremely complicated. 
  Rather than try to write the abstract syntax of ACL2's <span class="v">loop$</span> expressions 
  in the same formal style, we take a different approach, which is workable 
  because <span class="v">loop$</span> allows fewer options.</p> 
 
  <p>First we introduce the syntax of a ``target clause,'' a ``type-spec,'' and 
  the ``operators.''  Then we describe the most elaborate form of a <span class="v">loop$</span> 
  expression in terms of these elements and ordinary ACL2 terms.  Every legal 
  <span class="v">loop$</span> expression can be produced by omitting certain optional elements 
  from the most elaborate <span class="v">loop$</span> form.  So we conclude the syntactic 
  description of <span class="v">loop$</span> by listing the elements that can be omitted.</p> 
 
  <p>A <i>target clause</i> has one of four forms</p> 
 
  <ul> 
 
  <li>
<span class="v">IN</span> <i>list-expr</i>
</li> 
 
  <li>
<span class="v">ON</span> <i>list-expr</i>
</li> 
 
  <li>
<span class="v">FROM</span> <i>lo-expr</i> <span class="v">TO</span> <i>hi-expr</i>
</li> 
 
  <li>
<span class="v">FROM</span> <i>lo-expr</i> <span class="v">TO</span> <i>hi-expr</i> <span class="v">BY</span> 
  <i>step-expr</i>
</li> 
 
  </ul> 
 
  <p>where <i>list-expr</i> is a term (which is expected to evaluate to a true 
  list), <i>lo-expr</i> and <i>hi-expr</i> are terms (which are expected to 
  evaluate to integers), and <i>step-expr</i> is a term (which is expected to 
  evaluate to a positive integer).</p> 
 
  <p>The legal <i>type-specs</i> are listed in <span class="tt"><a href="ACL2____TYPE-SPEC.html">type-spec</a></span>.</p> 
 
  <p>The legal <i>operators</i> are <span class="v">SUM</span>, <span class="v">COLLECT</span>, <span class="v">ALWAYS</span>, 
  <span class="v">THEREIS</span>, and <span class="v">APPEND</span>.</p> 
 
  <p>The most elaborate <span class="v">loop$</span> expression is of the form</p> 
 
  <p>        <span class="v">(<a href="ACL2____LOOP_42.html">LOOP$</a> FOR </span><i>v1</i><span class="v"> OF-TYPE </span><i>spec1 
  target1</i><br>                 
          <span class="v">AS </span>   <i>v2</i><span class="v"> OF-TYPE </span><i>spec2 
  target2</i><br>                 
          ...<br>           
                <span class="v">AS </span>   <i>vn</i><span class="v">
  OF-TYPE </span><i>specn targetn</i><br>             
              <span class="v">UNTIL :GUARD </span><i>guard1 
  until-expr</i><br>                 
          <span class="v">WHEN </span>   <span class="v">:GUARD </span><i>guard2 
  when-expr</i><br>             
              ; Note the <span class="v">ALWAYS</span>/<span class="v">THEREIS</span> Exceptions 
  below!<br>                   
        <i>op</i><span class="v"> :GUARD </span><i>guard3 
  body-expr</i><span class="v">)</span><br></p> 
 
  <p>where each <i>vi</i>   is a legal variable symbol and they are all 
  distinct, each <i>type-speci</i>   is a <span class="tt"><a href="ACL2____TYPE-SPEC.html">type-spec</a></span>, each 
  <i>targeti</i>   is a target clause, each <i>guardi</i>, 
  <i>until-expr</i>, and <i>when-expr</i>   is a term, <i>op</i>   is 
  an operator, and <i>body-expr</i>   is a term.  Furthermore, 
  <i>until-expr</i>, <i>when-expr</i>, and <i>body-expr</i>   must be 
  <a href="ACL2____TAME.html">tame</a>!</p> 
 
  <p><i>The <span class="v">ALWAYS</span>/<span class="v">THEREIS</span> Exception:</i> Common Lisp prohibits loops 
  with both a <span class="v">WHEN</span> clause and either an <span class="v">ALWAYS</span> or a <span class="v">THEREIS</span> 
  operator.  For example, if you are tempted to use <span class="v">WHEN</span> <i>p</i> with 
  <span class="v">ALWAYS</span> <i>q</i> you can instead write <span class="v">ALWAYS</span> <span class="v">(<a href="ACL2____IMPLIES.html">implies</a> </span><i>p 
  q</i><span class="v">)</span> or, if you want to evaluate <span class="v">q</span> only when <span class="v">p</span> is true, you 
  can write <span class="v">ALWAYS</span> <span class="v">(<a href="COMMON-LISP____IF.html">if</a> </span><i>p q</i> <span class="v">t)</span>.</p> 
 
  <p>The following elements may be omitted.</p> 
 
  <ul> 
  <li>any line beginning with <span class="v">AS</span>, <span class="v">UNTIL</span> or <span class="v">WHEN</span>,</li> 
 
  <li>any <span class="v">OF-TYPE</span> <i>speci</i>, and</li> 
 
  <li>any <span class="v">:GUARD</span> <i>guardi</i>.</li> 
 
  </ul> 
 
  <p>As noted above, the <span class="v">FOR</span> <span class="v">loop$</span> keywords (as used above) may be in 
  any package.  These are <span class="v">FOR</span>, <span class="v">IN</span>, <span class="v">ON</span>, <span class="v">FROM</span>, <span class="v">TO</span>, 
  <span class="v">BY</span>, <span class="v">OF-TYPE</span>, <span class="v">WHEN</span>, <span class="v">UNTIL</span>, <span class="v">SUM</span>, <span class="v">COLLECT</span>, 
  <span class="v">ALWAYS</span>, <span class="v">THEREIS</span>, and <span class="v">APPEND</span>.</p> 
 
  <p>We give names to certain classes of the syntactic entities above.  The 
  <i>v1</i>, ..., <i>vn</i> are called the <i>iteration variables</i>.  The 
  <i>spec1</i>, ..., <i>specn</i> are called <i>type specs</i>, each 
  corresponds to a certain iteration variable, and each gives rise to a <i>type 
  term</i> about its variable in the sense that ``<span class="v">X OF-TYPE (SATISFIES
  NATP)</span>'' gives rise to the type term <span class="v">(<a href="ACL2____NATP.html">NATP</a> X)</span> and ``<span class="v">I OF-TYPE
  INTEGER</span>'' gives rise to the type term <span class="v">(<a href="COMMON-LISP____INTEGERP.html">INTEGERP</a> I)</span>.  The terms 
  involved in the target expressions, e.g., the <i>list-expr</i> in ``<span class="v">IN</span> 
  <i>list-expr</i>'' and ``<span class="v">ON</span> <i>list-expr</i>'' and the <i>lo-expr</i>, 
  <i>hi-expr</i> and optional <i>step-expr</i> in the ``<span class="v">FROM</span> 
  <i>lo-expr</i> <span class="v">TO</span> <i>hi-expr</i> <span class="v">BY</span> <i>step-expr</i>'' targets are 
  called <i>target terms</i>.  Finally, the <i>until-expr</i>, 
  <i>when-expr</i>, and <i>body-expr</i> are called <i>iterative forms</i>.</p> 
 
  <p>We distinguish the target terms from the iterative forms because they are 
  handled very differently at evaluation time.  When a <span class="v">loop$</span> is evaluated, 
  the target terms are evaluated just once.  But the iterative forms are 
  evaluated multiple times as the iteration variables range over the values of 
  the targets.</p> 
 
  <p>A <span class="v">FOR</span> <span class="v">loop$</span> expression with just one iteration variable and in 
  which the iterative forms mention no free variable other than the iteration 
  variable is called a <i>simple <span class="v">loop$</span></i> (or, sometimes, a <i>simple 
  loop</i>).  An example of a simple loop is</p> 
 
  <pre class="code">(<a href="ACL2____LOOP_42.html">loop$</a> for x in lst when (<a href="COMMON-LISP____EVENP.html">evenp</a> x) collect (<a href="COMMON-LISP_____B2.html">+</a> 1 (sq x)))</pre> 
 
  <p>A <span class="v">FOR</span> <span class="v">loop$</span> expression is called a <i>fancy <span class="v">loop$</span></i> if it 
  is not simple.  Both of the following <span class="v">loop$</span>s are fancy.</p> 
 
  <pre class="code">(<a href="ACL2____LOOP_42.html">loop$</a> for x in xlst as y on ylst collect (expr x y))

(<a href="ACL2____LOOP_42.html">loop$</a> for x in xlst collect (expr x z))</pre> 
 
  <p>The first is fancy because it has two iteration variables.  The second is 
  fancy because the body freely uses the variable <span class="v">z</span> which is not the 
  iteration variable.</p> 
 
  <h3>Semantics</h3> 
 
  <p><span class="v">FOR</span> <span class="v">loop$</span> expressions are translated into calls of <a href="ACL2____SCION.html">scion</a>s, with the <span class="v">UNTIL</span> and <span class="v">WHEN</span> clauses translated into 
  preprocessors of the targets.  But which scions are used depend on whether 
  the loop is simple or fancy.  Recall that a fancy loop is one that has either 
  or both of the following characteristics: (a) there is one or more <span class="v">as</span> 
  clauses, and/or (b) one of the iterative forms (the <span class="v">UNTIL</span>, <span class="v">WHEN</span> or 
  loop body expression) refers to variables other than an iteration variable. 
  If the <span class="v">loop$</span> expression is simple, the simple scions are used; otherwise 
  the fancy scions are used.</p> 
 
  <pre class="code">loop$               simple          fancy
keyword             scion           scion
______________________________________________
SUM                 sum$            sum$+
COLLECT             collect$        collect$+
ALWAYS              always$         always$+
THEREIS             thereis$        thereis$+
APPEND              append$         append$+
UNTIL               until$          until$+
WHEN                when$           when$+</pre> 
 
  <p>We deal with simple <span class="v">loop$</span>s first.</p> 
 
  <h4>Semantics of Simple Loop$s</h4> 
 
  <p>For example, the simple <span class="v">loop$</span></p> 
  <pre class="code">(<a href="ACL2____LOOP_42.html">loop$</a> for x in lst collect (<a href="COMMON-LISP_____B2.html">+</a> 1 (sq x)))</pre> 
  <p>translates to (a term equivalent to)</p> 
 
  <pre class="code">(<a href="ACL2____COLLECT_42.html">collect$</a> (<a href="ACL2____LAMBDA_42.html">lambda$</a> (x)
                   (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> x))
                   (<a href="COMMON-LISP_____B2.html">+</a> 1 (sq x)))
          lst).</pre> 
 
  <p><b>Note:</b> The actual translation is tagged with various markers that 
  play a role in evaluation but which are logically irrelevant and which are 
  removed during proof.  In this discussion we will not display the marked-up 
  translations but logically equivalent terms instead.  You can see the actual 
  translations for yourself with <span class="tt"><a href="ACL2____TRANS.html">trans</a></span>.</p> 
 
  <p>In the translation the target term, <span class="v">lst</span>, appears as an ordinary 
  subterm of the translation.  But the iterative form, <span class="v">(<a href="COMMON-LISP_____B2.html">+</a> 1 (sq x))</span>, 
  becomes the body of a <span class="tt"><a href="ACL2____LAMBDA_42.html">lambda$</a></span> expression, which means its translation 
  becomes a component of a quoted <span class="v">LAMBDA</span> object.  When the <span class="v">collect$</span> 
  is evaluated, the target term is evaluated once but the iterative form is 
  evaluated once for each element of the value of the target.</p> 
 
  <p><span class="v">UNTIL</span> and <span class="v">WHEN</span> clauses are handled by preprocessing the target. 
  E.g.,</p> 
 
  <pre class="code">(<a href="ACL2____LOOP_42.html">loop$</a> for x in lst
       until (<a href="COMMON-LISP_____E3.html">&gt;</a> x 100)
       when (<a href="COMMON-LISP____EVENP.html">evenp</a> x)
       collect (<a href="COMMON-LISP_____B2.html">+</a> 1 (sq x)))</pre> 
 
  <p>becomes</p> 
 
  <pre class="code">(<a href="ACL2____COLLECT_42.html">collect$</a> (<a href="ACL2____LAMBDA_42.html">lambda$</a> (x)
                   (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> x))
                   (<a href="COMMON-LISP_____B2.html">+</a> 1 (sq x)))
          (<a href="ACL2____WHEN_42.html">when$</a> (<a href="ACL2____LAMBDA_42.html">lambda$</a> (x)
                          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> x))
                          (<a href="COMMON-LISP____EVENP.html">evenp</a> x))
                 (<a href="ACL2____UNTIL_42.html">until$</a> (<a href="ACL2____LAMBDA_42.html">lambda$</a> (x)
                                  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> x))
                                  (<a href="COMMON-LISP_____E3.html">&gt;</a> x 100))
                         lst)))</pre> 
 
  <p>So from a logical perspective, the presence of an <span class="v">UNTIL</span> and/or 
  <span class="v">WHEN</span> clause in a <span class="v">collect</span> iteration over <span class="v">lst</span> ``copies'' the 
  target value.  The <span class="v">until$</span> copies <span class="v">lst</span> until encountering the first 
  element on which its functional argument is true.  The <span class="v">when$</span> then copies 
  that (shortened?) target, keeping only the elements that satisfy its 
  functional argument.  Finally, the <span class="v">collect$</span> then applies its functional 
  argument and collects all the values.</p> 
 
  <p><span class="v">ON</span> and <span class="v">FROM/TO/BY</span> targets are handled by listing all the 
  elements in the given target.  For example,</p> 
 
  <pre class="code">(<a href="ACL2____LOOP_42.html">loop$</a> for x on lst collect (expr x))</pre> 
 
  <p>which maps <span class="v">x</span> over successive non-empty tails of <span class="v">lst</span> and collects 
  the value of <span class="v">expr</span> has the logical meaning</p> 
 
  <pre class="code">(<a href="ACL2____COLLECT_42.html">collect$</a> (<a href="ACL2____LAMBDA_42.html">lambda$</a> (x) (expr x))
          (tails lst))</pre> 
 
  <p>where, for example, <span class="v">(tails '(1 2 3))</span> is <span class="v">((1 2 3) (2 3) (3))</span>.</p> 
 
  <p>Spiritually similarly,</p> 
  <pre class="code">(<a href="ACL2____LOOP_42.html">loop$</a> for i from 1 to max by step collect (expr x))</pre> 
 
  <p>becomes</p> 
 
  <pre class="code">(<a href="ACL2____COLLECT_42.html">collect$</a> (<a href="ACL2____LAMBDA_42.html">lambda$</a> (x) (expr x))
          (from-to-by 1 max step))</pre> 
 
  <p>where, for example, <span class="v">(from-to-by 1 10 2)</span> is <span class="v">(1 3 5 7 9)</span>.</p> 
 
  <p>Similar translations are done for the other operators, e.g., <span class="v">SUM</span> and 
  <span class="v">ALWAYS</span>.  The advantage of this translation style is that it allows 
  compositional reasoning.  We discuss this further below.</p> 
 
  <p>The following example illustrates basic <a href="ACL2____GUARD.html">guard</a> proof obligations, in 
  particular showing that <span class="v">WHEN</span> clauses do not help with verifying guards 
  for the <span class="v">loop$</span> bodies.  (Similarly, <span class="v">UNTIL</span> clauses do not help 
  either.)  The basic problem is that ACL2 requires that <span class="tt"><a href="COMMON-LISP____LAMBDA.html">lambda</a></span> objects 
  be guard verifiable in isolation, not confined to the context in which a 
  particular <span class="v">lambda</span> object appears.  Consider the following.</p> 
 
  <pre class="code">(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "projects/apply/top" :dir :system)
(<a href="ACL2____DEFUN_42.html">defun$</a> sq (n)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____NATP.html">natp</a> n)))
  (<a href="COMMON-LISP_____A2.html">*</a> n n))
(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (lst)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____NAT-LISTP.html">nat-listp</a> lst)))
  (<a href="ACL2____LOOP_42.html">loop$</a> for x of-type (satisfies nat-listp) on lst
         when (<a href="COMMON-LISP____CONSP.html">consp</a> x)
         sum (sq (<a href="COMMON-LISP____CAR.html">car</a> x))))</pre> 
 
  <p>Guard verification fails for <span class="v">foo</span>.  The summary says that a goal of 
  <span class="v">NIL</span> was generated.  Using <span class="v">:</span><span class="tt"><a href="ACL2____PSO.html">pso</a></span> we can see that the <span class="v">NIL</span> 
  goal came from:</p> 
 
  <pre class="code">Subgoal 1
(<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="ACL2____NAT-LISTP.html">NAT-LISTP</a> X) (<a href="ACL2____NATP.html">NATP</a> (<a href="COMMON-LISP____CAR.html">CAR</a> X))).</pre> 
 
  <p>Let's see what is going on by looking at the following abbreviated 
  translation of the <span class="v">loop$</span> expression.</p> 
 
  <pre class="code">(<a href="ACL2____SUM_42.html">sum$</a> '(<a href="COMMON-LISP____LAMBDA.html">lambda</a> (x)
         (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (satisfies nat-listp) x)
                  (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____NAT-LISTP.html">nat-listp</a> x)
                         :split-types t)
                  (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> x))
         (sq (<a href="COMMON-LISP____CAR.html">car</a> x)))
      (<a href="ACL2____WHEN_42.html">when$</a> '(<a href="COMMON-LISP____LAMBDA.html">lambda</a> ...) (tails lst)))</pre> 
 
  <p>Notice that the <span class="v">lambda</span> object supplied to <span class="v">sum$</span> cannot be guard 
  verified in isolation: <span class="v">nil</span> satisfies the <span class="v">:guard</span> and <span class="v">(<a href="COMMON-LISP____CAR.html">car</a> nil)</span> 
  violates the guard of <span class="v">sq</span>.  The following modification, which adds a 
  <span class="v">:guard</span> directive after the <span class="v">SUM</span> op keyword, solves the problem.</p> 
 
  <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (lst)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____NAT-LISTP.html">nat-listp</a> lst)))
  (<a href="ACL2____LOOP_42.html">loop$</a> for x of-type (satisfies nat-listp) on lst
         when (<a href="COMMON-LISP____CONSP.html">consp</a> x)
         sum :guard (<a href="COMMON-LISP____CONSP.html">consp</a> x)  ; note new :guard
         (sq (<a href="COMMON-LISP____CAR.html">car</a> x))))</pre> 
 
  <p>This new <span class="v">:guard</span> may feel redundant, coming as it does after the 
  <span class="v">when (<a href="COMMON-LISP____CONSP.html">consp</a> x)</span> clause.  But it is necessary given the compositional 
  semantics.</p> 
 
  <p>The abbreviated translation of the <span class="v">defun</span> above shows that the 
  application <span class="v">(sq (<a href="COMMON-LISP____CAR.html">car</a> x))</span> is protected by a suitable guard in the 
  <span class="v">lambda</span> object.</p> 
 
  <pre class="code">(<a href="ACL2____SUM_42.html">sum$</a> '(<a href="COMMON-LISP____LAMBDA.html">lambda</a> (x)
         (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (satisfies nat-listp) x)
                  (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____NAT-LISTP.html">nat-listp</a> x) (<a href="COMMON-LISP____CONSP.html">consp</a> x) 'nil)
                         :split-types t)
                  (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> x))
         (sq (<a href="COMMON-LISP____CAR.html">car</a> x)))
      (<a href="ACL2____WHEN_42.html">when$</a> '(<a href="COMMON-LISP____LAMBDA.html">lambda</a> ...) (tails lst)))</pre> 
 
  <p>Naively we might have expected that the guard proof obligation for the 
  <span class="v">loop$</span> body <span class="v">(sq (<a href="COMMON-LISP____CAR.html">car</a> x))</span> could assume the <span class="v">WHEN</span> clause, but that 
  expectation would be wrong because of the compositional semantics we use and 
  the fact that <span class="tt"><a href="COMMON-LISP____LAMBDA.html">lambda</a></span> objects must be guard-verifiable on their own. 
  The reason for the latter requirement is that our implementation caches 
  guard-verified <span class="v">lambda</span> objects for evaluation in raw Lisp, which may take 
  place in other contexts different from that in which the <span class="v">lambda</span> first 
  appeared.  See <a href="ACL2____PRINT-CL-CACHE.html">print-cl-cache</a>.</p> 
 
  <h4>Semantics of Fancy Loop$s</h4> 
 
  <p>An example of a fancy <span class="v">loop$</span> is</p> 
 
  <pre class="code">(<a href="ACL2____LOOP_42.html">loop$</a> for x in xlst as y in ylst collect (expr x y z))</pre> 
 
  <p>This loop exhibits both characteristics (a) and (b): it has an <span class="v">AS</span> 
  clause and the variable <span class="v">z</span> appears in the loop body.  Either 
  characteristic is sufficient to classify the loop as fancy.  So fancy scions 
  are used.  Here is its semantic counterpart, i.e., its translation.</p> 
 
  <pre class="code">(<a href="ACL2____COLLECT_42_B2.html">collect$+</a>
 (<a href="ACL2____LAMBDA_42.html">lambda$</a> (loop$-gvars loop$-ivars)
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> loop$-gvars)
                                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> loop$-gvars) 1)
                                      (<a href="ACL2____TRUE-LISTP.html">true-listp</a> loop$-ivars)
                                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> loop$-ivars) 2))))
          (<a href="COMMON-LISP____LET.html">let</a> ((z (<a href="COMMON-LISP____CAR.html">car</a> loop$-gvars))
                (x (<a href="COMMON-LISP____CAR.html">car</a> loop$-ivars))
                (y (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CDR.html">cdr</a> loop$-ivars))))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> x y))
            (expr x y z)))
 (<a href="COMMON-LISP____LIST.html">list</a> z)
 (loop$-as (<a href="COMMON-LISP____LIST.html">list</a> xlst ylst)))</pre> 
 
  <p>Before we show the definition of <span class="v">collect$+</span> note that the arguments 
  above to <span class="v">collect$+</span> are (i) a <span class="v">lambda$</span> expression that handles the 
  evaluation of the iterative form, in this case <span class="v">(expr x y z)</span>, where 
  <span class="v">x</span> and <span class="v">y</span> are iteration variables and <span class="v">z</span> is a ``global'' variable 
  not among the iteration variables; (ii) the list of values of the ``global'' 
  variables, in this case the list containing <span class="v">z</span>; and (iii) a target list 
  constructed by <span class="v">loop$-as</span> from the various targets provided in the 
  <span class="v">loop$</span>, in this case <span class="v">xlst</span> and <span class="v">ylst</span>, supplying values for 
  iteration variables <span class="v">x</span> and <span class="v">y</span> respectively.  For example, 
  <span class="v">(loop$-as (<a href="COMMON-LISP____LIST.html">list</a> '(a b c d e) '(1 2 3)))</span> is <span class="v">((a 1) (b 2) (c 3))</span>. 
  These tuples contain successive corresponding values of <span class="v">x</span> and 
  <span class="v">y</span>.</p> 
 
  <p>The definition of <span class="v">collect$+</span> is essentially</p> 
  <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> collect$+ (fn loop$-gvars lst)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ENDP.html">endp</a> lst)
      nil
      (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="ACL2____APPLY_42.html">apply$</a> fn (<a href="COMMON-LISP____LIST.html">list</a> loop$-gvars (<a href="COMMON-LISP____CAR.html">car</a> lst)))
            (<a href="ACL2____COLLECT_42_B2.html">collect$+</a> fn loop$-gvars (<a href="COMMON-LISP____CDR.html">cdr</a> lst)))))</pre> 
 
  <p>We have omitted the guard and an <span class="tt"><a href="ACL2____MBE.html">mbe</a></span> form that make it run more 
  efficiently.  All the fancy <span class="v">loop$</span> scions are defined analogously.</p> 
 
  <p>Inspection of the <span class="v">lambda$</span> expression above reveals that it takes a 
  list of global variable values and a list of iteration variable values, 
  unpacks them with a <span class="v">let</span> that binds the global variables, here just 
  <span class="v">z</span>, to their values and binds the iteration variables, here <span class="v">x</span> and 
  <span class="v">y</span>, to the corresponding pair of values from the target, and then 
  evaluates the <span class="v">loop$</span> body, <span class="v">(expr x y z)</span>.</p> 
 
  <p>The names of the formals for the <span class="v">lambda$</span> expressions generated by 
  fancy <span class="v">loop$</span> expressions are always <span class="v">loop$-gvars</span> and 
  <span class="v">loop$-ivars</span>, for ``<span class="v">loop$</span> global variables'' and ``<span class="v">loop$</span> 
  iteration variables.''</p> 
 
  <p><span class="v">UNTIL</span> and <span class="v">WHEN</span> clauses in a fancy <span class="v">loop$</span> are handled exactly 
  as they are in simple <span class="v">loop$</span>s, except that the fancy scions are used 
  since the target list is a list of tuples of iteration variable values and 
  the <span class="v">UNTIL</span> and <span class="v">WHEN</span> forms may refer to global variables.</p> 
 
  <h4>Special Guard Conjectures for <span class="v">FOR</span> <span class="v">loop$</span>s</h4> 
 
  <p>Since every <span class="v">loop$</span> expands to a call of a <span class="v">loop$</span> scion on a lambda 
  object and a target, one would expect that <a href="ACL2____GUARD.html">guard</a> verification would 
  generate the guard conjectures for that scion and target.  Indeed, it does. 
  In particular, the lambda object must have the correct number of 
  formals (which is guaranteed by translation) and the target must satisfy 
  <span class="tt"><a href="ACL2____TRUE-LISTP.html">true-listp</a></span>.</p> 
 
  <p>But in addition to the expected guard conjectures, we generate some 
  special ones for the terms produced by translating <span class="v">FOR</span> <span class="v">loop$</span> 
  expressions.  We discuss the reasons in the next section, but here we just 
  state what the special conjectures are.  We limit ourselves to a simple 
  <span class="v">loop$</span>.  Fancy <span class="v">loop$</span> generalize in the obvious way.  The three 
  classes of ``special guard conjectures'' for <span class="v">FOR</span> <span class="v">loop$</span> expressions 
  are:</p> 
 
  <p>First, every element (or tail, in the case of <span class="v">ON</span> <span class="v">loop$</span>s) 
  satisfies the type-spec, if any.  Note that in the case of <span class="v">ON</span> 
  <span class="v">loop$</span>s <i>every</i> tail, including the empty one, must satisfy the 
  type-spec.</p> 
 
  <p>Second, the type-spec, if any, implies the guards of the <span class="v">loop$</span> 
  body.</p> 
 
  <p>Third, the <span class="v">loop$</span> body produces a value acceptable to the <span class="v">loop$</span> 
  operator, e.g., the body of <span class="v">SUM</span> <span class="v">loop$</span> produces a number and 
  the body of an <span class="v">APPEND</span> <span class="v">loop$</span> produces a true list.</p> 
 
  <h4>Discussion of Why LOOP$s Have Special Guards</h4> 
 
  <p>All of the simple <span class="v">loop$</span> scions have the same guard, namely</p> 
 
  <pre class="code">(<a href="COMMON-LISP____AND.html">AND</a> (<a href="ACL2____APPLY_42-GUARD.html">APPLY$-GUARD</a> FN '(NIL))
     (<a href="ACL2____TRUE-LISTP.html">TRUE-LISTP</a> LST)),</pre> 
 
  <p>and all the fancy <span class="v">loop$</span> scions have the same guard, namely</p> 
 
  <pre class="code">(<a href="COMMON-LISP____AND.html">AND</a> (<a href="ACL2____APPLY_42-GUARD.html">APPLY$-GUARD</a> FN '(NIL NIL))
     (<a href="ACL2____TRUE-LISTP.html">TRUE-LISTP</a> LOOP$-GVARS)
     (<a href="ACL2____TRUE-LIST-LISTP.html">TRUE-LIST-LISTP</a> LST)).</pre> 
 
  <p>In addition to the normal guard conjectures that would be generated by 
  calls of these scions, ACL2 generates some special guard conjectures because 
  the normal guard conjectures are insufficient to guarantee the error-free 
  execution of the corresponding Common Lisp <span class="v">loop</span> expressions.</p> 
 
  <p>For example, the logical meaning of</p> 
 
  <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (lst)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (foo-guardp lst)))
  (<a href="ACL2____LOOP_42.html">loop$</a> for x of-type (satisfies spec) on lst sum (expr x)))</pre> 
 
  <p>is</p> 
 
  <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (lst)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (foo-guardp lst)))
  (<a href="ACL2____SUM_42.html">sum$</a> (<a href="ACL2____LAMBDA_42.html">lambda$</a> (x)
                 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (satisfies spec) x))
                 (expr x))
        (tails lst))).</pre> 
 
  <p>Prior to the provision for special guards, the normal guard conjectures 
  generated for <span class="v">foo</span> would be</p> 
 
  <pre class="code">(<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____IMPLIES.html">implies</a> (foo-guardp lst)                                 ; [1]
              (<a href="ACL2____APPLY_42-GUARD.html">apply$-guard</a>
               (<a href="ACL2____LAMBDA_42.html">lambda$</a> (x)
                 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (satisfies spec) x))
                 (expr x))
               '(nil)))
     (<a href="ACL2____IMPLIES.html">implies</a> (foo-guardp lst)                                 ; [2]
              (<a href="ACL2____TRUE-LISTP.html">true-listp</a> (tails lst)))
     (<a href="ACL2____IMPLIES.html">implies</a> (foo-guardp lst)                                 ; [3]
              (<a href="ACL2____TRUE-LISTP.html">true-listp</a> lst))
     (<a href="ACL2____IMPLIES.html">implies</a> (spec x) (expr-guardp x)))                       ; [4]</pre> 
 
  <p>Conjectures [1] and [2] stem from the guard for <span class="v">sum$</span> and establish 
  that the guard for <span class="v">foo</span> implies that <span class="v">sum$</span> is passed a function 
  object of one argument and a true-list.  Conjecture [3] establishes the guard 
  of <span class="v">tails</span>.  And conjecture [4] establishes that the guard on the 
  <span class="v">lambda$</span> implies the guard of its body.</p> 
 
  <p>But consider the raw Lisp <span class="v">loop</span> generated by the <span class="v">loop$</span> in the raw 
  Lisp definition of <span class="v">foo</span>,</p> 
 
  <pre class="code">(loop for x of-type (satisfies spec) on lst sum (expr x)).</pre> 
 
  <p>For this <span class="v">loop</span> to execute without error we need to know that [5] every 
  non-empty tail of <span class="v">lst</span> satisfies <span class="v">spec</span>, [6] that for every tail, 
  <span class="v">x</span>, of <span class="v">lst</span>, <span class="v">(expr x)</span> returns a number, and [7] that <span class="v">nil</span> 
  satisfies <span class="v">spec</span>.  The last is somewhat surprising but inspection of 
  Common Lisp reveals that even though <span class="v">(expr x)</span> is never called on the 
  empty tail of <span class="v">lst</span>, implementations running with high safety settings 
  check that the empty list satisfies <span class="v">spec</span>.</p> 
 
  <p>So when ACL2's guard verification process encounters a <span class="v">sum$</span> like that 
  in the logical <span class="v">defun</span> of <span class="v">foo</span>, it generates three additional guard 
  conjectures</p> 
 
  <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____WARRANT.html">warrant</a> ...) ; see below                   ; [5]
              (foo-guardp lst)
              (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> newv (tails lst)))
         (spec newv))

(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____WARRANT.html">warrant</a> ...) ; see below                   ; [6]
              (foo-guardp lst)
              (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> newv (tails lst)))
         (<a href="ACL2____ACL2-NUMBERP.html">acl2-numberp</a>
          (<a href="ACL2____APPLY_42.html">apply$</a> (<a href="ACL2____LAMBDA_42.html">lambda$</a> (x)
                    (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (satisfies spec) x))
                    (expr x))
                  (<a href="COMMON-LISP____LIST.html">list</a> newv))))

(<a href="ACL2____IMPLIES.html">implies</a> (foo-guardp lst)                                 ; [7]
         (spec nil))</pre> 
 
  <p>Notice the addition of hypotheses above of the form <span class="v">(<a href="ACL2____WARRANT.html">warrant</a> ...)</span>. 
  ACL2 adds such <i><a href="ACL2____WARRANT.html">warrant</a> hypotheses</i> for function symbols that 
  might be <span class="tt"><a href="ACL2____APPLY_42.html">apply$</a></span>'d during evaluation of a scion call (in this case, 
  <span class="v">sum$</span>).</p> 
 
  <p>In general, you may notice that ACL2 generates such ``special'' guard 
  conjectures for all calls of <span class="v">FOR</span> <span class="v">loop$</span> scions, whether or not they 
  stemmed from uses of <span class="v">loop$</span>.  <span class="v">FROM/TO/BY</span> targets require that the 
  bounds and step all satisfy the <span class="v">of-type</span> specification, and the 
  <span class="v">append</span> operator requires that the loop body generate a <span class="tt"><a href="ACL2____TRUE-LISTP.html">true-listp</a></span> (instead of an <span class="tt"><a href="ACL2____ACL2-NUMBERP.html">ACL2-numberp</a></span> as required by the <span class="v">sum</span> 
  operator).</p> 
 
  <h4>The Compromise Between Reasoning and Efficiency</h4> 
 
  <p>The translation of <span class="v">loop$</span> expressions into formal terms reflects a 
  compromise between facilitating compositional reasoning and efficient 
  execution.</p> 
 
  <p>One sign of that compromise is our use of scions to handle <span class="v">UNTIL</span> and 
  <span class="v">WHEN</span> clauses.  As noted above, by translating</p> 
 
  <pre class="code">(<a href="ACL2____LOOP_42.html">loop$</a> for x in lst until ... when ... collect ...)</pre> 
 
  <p>into</p> 
 
  <pre class="code">(<a href="ACL2____COLLECT_42.html">collect$</a> ... (<a href="ACL2____WHEN_42.html">when$</a> ... (<a href="ACL2____UNTIL_42.html">until$</a> ... lst)))</pre> 
 
  <p>we're forcing the evaluation of the formal semantics to copy the target 
  twice before collecting.  But it gives us the ability to reason 
  compositionally about <span class="v">collect$</span>, <span class="v">when$</span>, and <span class="v">until$</span>.  We could 
  have defined a version of <span class="v">collect$</span> that took three <span class="v">lambda$</span> 
  expressions, one to terminate the collection, one to filter for the elements 
  we're interested in, and one to transform those elements into the values we 
  wish to collect.  This would avoid copying upon evaluation but make it more 
  difficult to reason.</p> 
 
  <p>Another example of compositionality is to consider a simple <span class="v">loop$</span> 
  over the <span class="v">IN</span> target <span class="v">(<a href="COMMON-LISP____APPEND.html">append</a> a b)</span>.  There are 8 different ways you 
  can do a simple <span class="v">COLLECT</span> over an <span class="v">(<a href="COMMON-LISP____APPEND.html">append</a> a b)</span> target,</p> 
 
  <pre class="code">(<a href="ACL2____LOOP_42.html">loop$</a> for x in (<a href="COMMON-LISP____APPEND.html">append</a> a b) collect (expr x))
(<a href="ACL2____LOOP_42.html">loop$</a> for x on (<a href="COMMON-LISP____APPEND.html">append</a> a b) collect (expr x))
(<a href="ACL2____LOOP_42.html">loop$</a> for x in (<a href="COMMON-LISP____APPEND.html">append</a> a b) until (stop x) collect (expr x))
(<a href="ACL2____LOOP_42.html">loop$</a> for x on (<a href="COMMON-LISP____APPEND.html">append</a> a b) until (stop x) collect (expr x))
(<a href="ACL2____LOOP_42.html">loop$</a> for x in (<a href="COMMON-LISP____APPEND.html">append</a> a b) when (test x) collect (expr x))
(<a href="ACL2____LOOP_42.html">loop$</a> for x on (<a href="COMMON-LISP____APPEND.html">append</a> a b) when (test x) collect (expr x))
(<a href="ACL2____LOOP_42.html">loop$</a> for x in (<a href="COMMON-LISP____APPEND.html">append</a> a b) until (stop x) when (test x)
       collect (expr x))
(<a href="ACL2____LOOP_42.html">loop$</a> for x on (<a href="COMMON-LISP____APPEND.html">append</a> a b) until (stop x) when (test x)
       collect (expr x))</pre> 
 
  <p>Similarly, there are 8 ways to <span class="v">SUM</span> over an <span class="v">(<a href="COMMON-LISP____APPEND.html">append</a> a b)</span> target, 
  8 ways to <span class="v">APPEND</span> over an <span class="v">(<a href="COMMON-LISP____APPEND.html">append</a> a b)</span>, and 4 ways each to 
  <span class="v">ALWAYS</span> or <span class="v">THEREIS</span> over an <span class="v">(<a href="COMMON-LISP____APPEND.html">append</a> a b)</span> target.  Thus, there 
  are 32 different simple <span class="v">loop$</span>s over <span class="v">(<a href="COMMON-LISP____APPEND.html">append</a> a b)</span>.  And you can 
  arrange to distribute the simple <span class="v">loop$</span> over the <span class="v">(<a href="COMMON-LISP____APPEND.html">append</a> a b)</span> with 
  just seven rewrite rules.</p> 
 
  <pre class="code">(<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____COLLECT_42.html">collect$</a> fn (<a href="COMMON-LISP____APPEND.html">append</a> a b))
       (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="ACL2____COLLECT_42.html">collect$</a> fn a)
               (<a href="ACL2____COLLECT_42.html">collect$</a> fn b)))

(<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____SUM_42.html">sum$</a> fn (<a href="COMMON-LISP____APPEND.html">append</a> a b))
       (<a href="COMMON-LISP_____B2.html">+</a> (<a href="ACL2____SUM_42.html">sum$</a> fn a)
          (<a href="ACL2____SUM_42.html">sum$</a> fn b)))

(<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____ALWAYS_42.html">always$</a> fn (<a href="COMMON-LISP____APPEND.html">append</a> a b))
       (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____ALWAYS_42.html">always$</a> fn a)
            (<a href="ACL2____ALWAYS_42.html">always$</a> fn b)))

(<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____THEREIS_42.html">thereis$</a> fn (<a href="COMMON-LISP____APPEND.html">append</a> a b))
       (<a href="COMMON-LISP____OR.html">or</a> (<a href="ACL2____THEREIS_42.html">thereis$</a> fn a)
           (<a href="ACL2____THEREIS_42.html">thereis$</a> fn b)))

(<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____APPEND_42.html">append$</a> fn (<a href="COMMON-LISP____APPEND.html">append</a> a b))
       (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="ACL2____APPEND_42.html">append$</a> fn a)
               (<a href="ACL2____APPEND_42.html">append$</a> fn b)))

(<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____UNTIL_42.html">until$</a> fn (<a href="COMMON-LISP____APPEND.html">append</a> a b))
       (<a href="COMMON-LISP____IF.html">if</a> (exists$ fn a)
           (<a href="ACL2____UNTIL_42.html">until$</a> fn a)
           (<a href="COMMON-LISP____APPEND.html">append</a> a (<a href="ACL2____UNTIL_42.html">until$</a> fn b))))

(<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____WHEN_42.html">when$</a> fn (<a href="COMMON-LISP____APPEND.html">append</a> a b))
       (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="ACL2____WHEN_42.html">when$</a> fn a)
               (<a href="ACL2____WHEN_42.html">when$</a> fn b)))</pre> 
 
  <p>Thus, you can reason about <span class="v">WHEN</span> and <span class="v">UNTIL</span> clauses without having 
  to consider how they are used in the superior <span class="v">loop$</span> expression.</p> 
 
  <p>To deal with fancy <span class="v">loop$</span> you need seven more rewrite rules, one for 
  each fancy <span class="v">loop$</span> scion.  But since every simple <span class="v">loop$</span> can be 
  expressed by an appropriate use of fancy scions, we could have translated 
  every <span class="v">FOR</span> <span class="v">loop$</span> to fancy scions.  We chose to break 
  compositionality here because we think simple <span class="v">loop$</span>s are most common and 
  wanted to keep their semantics simple.  I.e., we compromised.</p> 
 
  <p>By the way, if you want the prover to convert every simple scion to its 
  fancy counterpart you could prove rewrite rules like that below.</p> 
 
  <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> convert-collect$-to-collect$+
  (<a href="ACL2____IMPLIES.html">implies</a> (ok-fnp fn)
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____COLLECT_42.html">collect$</a> fn lst)
                  (<a href="ACL2____COLLECT_42_B2.html">collect$+</a> `(<a href="COMMON-LISP____LAMBDA.html">lambda</a> (loop$-gvars loop$-ivars)
                                (,fn (<a href="COMMON-LISP____CAR.html">car</a> loop$-ivars)))
                             nil
                             (loop$-as (<a href="COMMON-LISP____LIST.html">list</a> lst)))))
  :hints (("[1]Goal"
           :expand ((<a href="ACL2____TAMEP.html">tamep</a> (<a href="COMMON-LISP____CONS.html">cons</a> fn '(x)))
                    (<a href="ACL2____TAMEP.html">tamep</a> (<a href="COMMON-LISP____CONS.html">cons</a> fn '((<a href="COMMON-LISP____CAR.html">car</a> loop$-ivars))))))))</pre>
</body>
</html>
