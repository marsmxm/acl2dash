<html>
<head>
<meta charset="UTF-8">
<title>Insert</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=SET____INSERT">Click for Insert in the Full Manual</a></h3>

<p><span class="tt">(insert a x)</span> adds the element <span class="v">a</span> to the set <span class="v">X</span>.</p><p>This is the fundamental set constructor.  It is similar to <a href="COMMON-LISP____CONS.html">cons</a> for lists, but of course performs an ordered insertion.  It respects the 
non-set convention and treats any ill-formed input as the empty set.</p> 
 
<p>Efficiency note.  Insert is <span class="v">O(n)</span>.  It is very inefficient to call it 
repeatedly.  Instead, consider building sets with <a href="SET____MERGESORT.html">mergesort</a> or out of 
other sets using <a href="SET____UNION.html">union</a>.</p> 
 
<p>The :exec version just inlines the set primitives and does one level of loop 
unrolling.  On CCL, it runs about 1.65x faster than the :logic version on the 
following loop:</p> 
 
<pre class="code">;; 1.92 seconds :logic, 1.16 seconds :exec
(<a href="COMMON-LISP____LET.html">let</a> ((acc nil))
 (<a href="ACL2____GC_42.html">gc$</a>)
 (<a href="ACL2____TIME_42.html">time$</a> (loop for i fixnum from 1 to 10000 do
              (setq acc (<a href="SET____INSERT.html">set::insert</a> i acc)))))</pre> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>insert</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
  insert (a x)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SET____SETP.html">setp</a> x)))
  (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="SET____EMPTY.html">empty</a> x) (<a href="COMMON-LISP____LIST.html">list</a> a))
                    ((<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SET____HEAD.html">head</a> x) a) x)
                    ((<a href="ACL2_____C3_C3.html">&lt;&lt;</a> a (<a href="SET____HEAD.html">head</a> x)) (<a href="COMMON-LISP____CONS.html">cons</a> a x))
                    (t (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="SET____HEAD.html">head</a> x) (<a href="SET____INSERT.html">insert</a> a (<a href="SET____TAIL.html">tail</a> x)))))
       :exec (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____NULL.html">null</a> x) (<a href="COMMON-LISP____CONS.html">cons</a> a nil))
                   ((<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> x) a) x)
                   ((<a href="ACL2____FAST-LEXORDER.html">fast-lexorder</a> a (<a href="COMMON-LISP____CAR.html">car</a> x)) (<a href="COMMON-LISP____CONS.html">cons</a> a x))
                   ((<a href="COMMON-LISP____NULL.html">null</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x))
                    (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> x) (<a href="COMMON-LISP____CONS.html">cons</a> a nil)))
                   ((<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CADR.html">cadr</a> x) a) x)
                   ((<a href="ACL2____FAST-LEXORDER.html">fast-lexorder</a> a (<a href="COMMON-LISP____CADR.html">cadr</a> x))
                    (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> x) (<a href="COMMON-LISP____CONS.html">cons</a> a (<a href="COMMON-LISP____CDR.html">cdr</a> x))))
                   (t (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> x)
                            (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CADR.html">cadr</a> x) (<a href="SET____INSERT.html">insert</a> a (<a href="COMMON-LISP____CDDR.html">cddr</a> x))))))))</pre> 
<p><b>Theorem: </b>insert-produces-set</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> insert-produces-set (<a href="SET____SETP.html">setp</a> (<a href="SET____INSERT.html">insert</a> a x)))</pre> 
<p><b>Theorem: </b>insert-sfix-cancel</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> insert-sfix-cancel
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SET____INSERT.html">insert</a> a (<a href="SET____SFIX.html">sfix</a> x))
               (<a href="SET____INSERT.html">insert</a> a x)))</pre> 
<p><b>Theorem: </b>insert-never-empty</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> insert-never-empty
        (<a href="COMMON-LISP____NOT.html">not</a> (<a href="SET____EMPTY.html">empty</a> (<a href="SET____INSERT.html">insert</a> a x))))</pre> 
<p><b>Theorem: </b>insert-when-empty</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> insert-when-empty
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SYNTAXP.html">syntaxp</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> x ''nil)))
                      (<a href="SET____EMPTY.html">empty</a> x))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SET____INSERT.html">insert</a> a x) (<a href="SET____INSERT.html">insert</a> a nil))))</pre> 
<p><b>Theorem: </b>head-of-insert-a-nil</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> head-of-insert-a-nil
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SET____HEAD.html">head</a> (<a href="SET____INSERT.html">insert</a> a nil)) a))</pre> 
<p><b>Theorem: </b>tail-of-insert-a-nil</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> tail-of-insert-a-nil
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SET____TAIL.html">tail</a> (<a href="SET____INSERT.html">insert</a> a nil)) nil))</pre> 
<p><b>Theorem: </b>head-insert</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> head-insert
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SET____HEAD.html">head</a> (<a href="SET____INSERT.html">insert</a> a x))
               (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="SET____EMPTY.html">empty</a> x) a)
                     ((<a href="ACL2_____C3_C3.html">&lt;&lt;</a> a (<a href="SET____HEAD.html">head</a> x)) a)
                     (t (<a href="SET____HEAD.html">head</a> x)))))</pre> 
<p><b>Theorem: </b>tail-insert</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> tail-insert
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SET____TAIL.html">tail</a> (<a href="SET____INSERT.html">insert</a> a x))
               (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="SET____EMPTY.html">empty</a> x) (<a href="SET____SFIX.html">sfix</a> x))
                     ((<a href="ACL2_____C3_C3.html">&lt;&lt;</a> a (<a href="SET____HEAD.html">head</a> x)) (<a href="SET____SFIX.html">sfix</a> x))
                     ((<a href="COMMON-LISP____EQUAL.html">equal</a> a (<a href="SET____HEAD.html">head</a> x)) (<a href="SET____TAIL.html">tail</a> x))
                     (t (<a href="SET____INSERT.html">insert</a> a (<a href="SET____TAIL.html">tail</a> x))))))</pre> 
<p><b>Theorem: </b>repeated-insert</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> repeated-insert
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SET____INSERT.html">insert</a> a (<a href="SET____INSERT.html">insert</a> a x))
               (<a href="SET____INSERT.html">insert</a> a x)))</pre> 
<p><b>Theorem: </b>insert-insert</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> insert-insert
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SET____INSERT.html">insert</a> a (<a href="SET____INSERT.html">insert</a> b x))
               (<a href="SET____INSERT.html">insert</a> b (<a href="SET____INSERT.html">insert</a> a x)))
        :rule-classes ((:rewrite :loop-stopper ((a b)))))</pre> 
<p><b>Theorem: </b>insert-head</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> insert-head
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="SET____EMPTY.html">empty</a> x))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SET____INSERT.html">insert</a> (<a href="SET____HEAD.html">head</a> x) x) x)))</pre> 
<p><b>Theorem: </b>insert-head-tail</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> insert-head-tail
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="SET____EMPTY.html">empty</a> x))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SET____INSERT.html">insert</a> (<a href="SET____HEAD.html">head</a> x) (<a href="SET____TAIL.html">tail</a> x)) x)))</pre> 
<p><b>Theorem: </b>insert-induction-case</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> insert-induction-case
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2_____C3_C3.html">&lt;&lt;</a> a (<a href="SET____HEAD.html">head</a> x)))
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> a (<a href="SET____HEAD.html">head</a> x)))
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="SET____EMPTY.html">empty</a> x)))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SET____INSERT.html">insert</a> (<a href="SET____HEAD.html">head</a> x) (<a href="SET____INSERT.html">insert</a> a (<a href="SET____TAIL.html">tail</a> x)))
                        (<a href="SET____INSERT.html">insert</a> a x))))</pre> 
 
 
<p><b>Theorem: </b>insert-identity</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> insert-identity
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SET____IN.html">in</a> a x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SET____INSERT.html">insert</a> a x) x)))</pre> 
<p><b>Theorem: </b>in-insert</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> in-insert
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SET____IN.html">in</a> a (<a href="SET____INSERT.html">insert</a> b x))
               (<a href="COMMON-LISP____OR.html">or</a> (<a href="SET____IN.html">in</a> a x) (<a href="COMMON-LISP____EQUAL.html">equal</a> a b))))</pre> 

</body>
</html>
