<html>
<head>
<meta charset="UTF-8">
<title>Progn!</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____PROGN_12">Click for Progn! in the Full Manual</a></h3>

<p>Evaluate some forms, not necessarily <a href="ACL2____EVENTS.html">events</a></p><p><b>WARNING!</b> This event is intended for advanced users who, in 
 essence, want to build extensions of ACL2.  See see <a href="ACL2____DEFTTAG.html">defttag</a>, in 
 particular, the ``WARNING'' there, and see the warning about <a href="ACL2____STOBJ.html">stobj</a>s at 
 the end of this documentation topic.</p> 
 
 <p><span class="v">Progn!</span> can be used like <span class="tt"><a href="COMMON-LISP____PROGN.html">progn</a></span>, even in <a href="ACL2____BOOKS.html">books</a>.  But 
 unlike <span class="tt"><a href="COMMON-LISP____PROGN.html">progn</a></span>, <span class="v">progn!</span> does not require its constituent forms to be 
 <a href="ACL2____EVENTS.html">events</a> (see <a href="ACL2____EMBEDDED-EVENT-FORM.html">embedded-event-form</a>), except that the first form 
 cannot be a symbol unless it is <span class="v">:state-global-bindings</span> (advanced feature, 
 described below).  However, see <a href="ACL2____MAKE-EVENT.html">make-event</a> for a ``Restriction to the 
 Top Level'' that still applies under a call of <span class="v">progn!</span>.</p> 
 
 <p>Because <span class="v">progn!</span> allows non-events, it differs from <span class="v">progn</span> in 
 another important respect: <span class="v">progn!</span> is illegal unless there is an active 
 ttag; see <a href="ACL2____DEFTTAG.html">defttag</a>.</p> 
 
 <p>See community book <a href="ACL2____HACKER.html">hacker</a> for two macros, <a href="ACL2____WITH-RAW-MODE.html">with-raw-mode</a> and 
 <a href="ACL2____WITH-REDEF-ALLOWED.html">with-redef-allowed</a>, each defined in terms of <span class="v">progn!</span>, that allow 
 arbitrary forms in contexts that would normally require legal embedded event 
 forms.</p> 
 
 <p>Given a form <span class="v">(<a href="ACL2____PROGN_12.html">progn!</a> form1 form2 ... formk)</span>, ACL2 will evaluate each 
 <span class="v">formi</span> in turn (for i from 1 to k).  If a form returns more than one value 
 (see <a href="ACL2____MV.html">mv</a>) where the first value returned is not <span class="v">nil</span>, then no later 
 form will be evaluated and the result returned by the <span class="v">progn!</span> call will be 
 <span class="v">(<a href="ACL2____MV.html">mv</a> erp val state)</span> for some non-<span class="v">nil</span> value <span class="v">erp</span>, signifying an 
 error (see <a href="ACL2____LD-ERROR-TRIPLES.html">ld-error-triples</a>).  Otherwise the evaluation is considered 
 to have succeeded, and will continue with later forms.  The value returned by 
 a call of <span class="v">progn!</span> with no such error is of the form <span class="v">(<a href="ACL2____MV.html">mv</a> nil v state)</span>, 
 where <span class="v">v</span> depends on the last form as follows.  If the last form evaluates 
 to a single value, then <span class="v">v</span> is that value, except if the value is a <a href="ACL2____STOBJ.html">stobj</a>, say <span class="v">ST</span>, then <span class="v">v</span> is the symbol <span class="v">REPLACED-ST</span>.  Otherwise 
 the last form evaluates to some <span class="v">(<a href="ACL2____MV.html">mv</a> nil x ...)</span>, and <span class="v">v</span> is <span class="v">x</span> 
 unless after the final form's evaluation we are in raw-mode (see <a href="ACL2____SET-RAW-MODE.html">set-raw-mode</a>), in which case the <span class="v">progn!</span> call returns <span class="v">nil</span> (so that 
 ACL2 can at least print the result â€” imagine Lisp returning a pathname 
 object from a <span class="v">load</span> call, for example).</p> 
 
 <p>The normal undoing mechanism does not generally apply to forms within a 
 <span class="v">progn!</span> that are not legal ACL2 <a href="ACL2____EVENTS.html">events</a> (see <a href="ACL2____EMBEDDED-EVENT-FORM.html">embedded-event-form</a>).  In particular, note that a non-<span class="tt"><a href="ACL2____LOCAL.html">local</a></span> call of 
 <span class="v">progn!</span> in an <span class="tt"><a href="ACL2____ENCAPSULATE.html">encapsulate</a></span> event will generally be evaluated twice: 
 once on each pass.  This fact is worth keeping in mind if you are using 
 <span class="v">progn!</span> to change the state of the system; ask yourself if it is 
 acceptable to apply that state-changing operation more than once.</p> 
 
 <p>Please note that <span class="v">progn!</span> may differ from <span class="tt"><a href="COMMON-LISP____PROGN.html">progn</a></span> in the following 
 sense: definitions within a call of <span class="v">progn!</span> might not be compiled.  For 
 example, consider the following book.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____IN-PACKAGE.html">in-package</a> "ACL2")
(<a href="ACL2____DEFTTAG.html">defttag</a> :test)
(<a href="COMMON-LISP____PROGN.html">progn</a>  (<a href="COMMON-LISP____DEFUN.html">defun</a> f1 (x) x))
(<a href="ACL2____PROGN_12.html">progn!</a> (<a href="COMMON-LISP____DEFUN.html">defun</a> f2 (x) x))</pre> 
 
 <p>If the underlying Lisp is GCL 2.6.7, then after including this certified 
 book (where the default certification took place, creating a compiled file), 
 then <span class="v">f1</span> is a compiled function but <span class="v">f2</span> is not.  For other Lisps 
 supported by ACL2, both <span class="v">f1</span> and <span class="v">f2</span> are compiled, though we are not 
 sure that every function under every call of <span class="v">progn!</span> would similarly be 
 compiled.</p> 
 
 <p>We now describe, for system hackers only, a sophisticated extension of 
 <span class="v">progn!</span> not mentioned above: support for keyword argument 
 <span class="v">:state-global-bindings</span>.  If the first argument of <span class="v">progn!</span> is this 
 keyword, then the second argument is treated as a list of bindings as expected 
 by ACL2 system function <span class="tt"><a href="ACL2____STATE-GLOBAL-LET_A2.html">state-global-let*</a></span>.  Thus, in the ACL2 
 loop,</p> 
 
 <pre class="code">(<a href="ACL2____PROGN_12.html">progn!</a> :state-global-bindings bindings form1 form2 ... formk)</pre> 
 
 <p>is treated as follows:</p> 
 
 <pre class="code">(<a href="ACL2____PROGN_12.html">progn!</a> (<a href="ACL2____STATE-GLOBAL-LET_A2.html">state-global-let*</a> bindings (<a href="ACL2____PROGN_12.html">progn!</a> form1 form2 ... formk)))</pre> 
 
 <p>However, in raw Lisp the former is just:</p> 
 
 <pre class="code">(<a href="COMMON-LISP____PROGN.html">progn</a> form1 form2 ... formk)</pre> 
 
 <p>Thus, one should use the <span class="v">:state-global-bindings</span> argument with care, 
 since the behavior in the ACL2 loop can differ from that in Common Lisp.  The 
 intention is that one bind only <a href="ACL2____STATE.html">state</a> global variables that are 
 relevant to evaluation of the forms within the ACL2 loop and are harmlessly 
 ignored for evaluation of those forms in raw Lisp.  Here is a typical sort of 
 example, as <a href="ACL2____STATE.html">state</a> global <span class="v">ld-redefinition-action</span> is not relevant to 
 the evaluation of <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> in raw Lisp.</p> 
 
 <pre class="code">(<a href="ACL2____PROGN_12.html">progn!</a> (<a href="ACL2____REMOVE-UNTOUCHABLE.html">remove-untouchable</a> 'ld-redefinition-action nil)
        (<a href="ACL2____PROGN_12.html">progn!</a> :state-global-bindings
                ((<a href="ACL2____LD-REDEFINITION-ACTION.html">ld-redefinition-action</a> '(:doit . :overwrite)))
                (<a href="COMMON-LISP____DEFUN.html">defun</a> foo (x)
                  (<a href="COMMON-LISP____CONS.html">cons</a> x x)))
        (<a href="ACL2____PUSH-UNTOUCHABLE.html">push-untouchable</a> 'ld-redefinition-action nil))</pre> 
 
 <p>Finally, we point out a pitfall of <span class="v">progn!</span> related to <a href="ACL2____STOBJ.html">stobj</a>s. 
 The following book can cause a hard Lisp error, depending on the host Common 
 Lisp and whether certifying or including it, when certified with a 
 non-<span class="v">nil</span> value for <span class="v">compile-flg</span> (see <a href="ACL2____CERTIFY-BOOK.html">certify-book</a>).</p> 
 
 <pre class="code">(<a href="COMMON-LISP____IN-PACKAGE.html">in-package</a> "ACL2")
(<a href="ACL2____DEFSTOBJ.html">defstobj</a> st fld)
(<a href="ACL2____DEFTTAG.html">defttag</a> :my-ttag)
(<a href="ACL2____PROGN_12.html">progn!</a> (update-fld 3 st))</pre> 
 
 <p>The problem is that the <a href="ACL2____STOBJ.html">stobj</a> variable <span class="v">st</span> is not known to raw 
 Lisp.  The compilation problem disappears if the last form above is replaced 
 with the following two forms.</p> 
 
 <pre class="code">(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "hacking/hacker" :dir :system)
(<a href="ACL2____WITH-RAW-MODE.html">with-raw-mode</a>
 (<a href="COMMON-LISP____LET.html">let</a> ((live-st (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="ACL2____ASSOC-EQ.html">assoc-eq</a> 'st *user-stobj-alist*))))
   (update-fld 3 live-st)))</pre>
</body>
</html>
