<html>
<head>
<meta charset="UTF-8">
<title>Lstate-match-renamevarp</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=YUL____LSTATE-MATCH-RENAMEVARP">Click for Lstate-match-renamevarp in the Full Manual</a></h3>

<p>Value matching part of the 
          variable renaming relation over local states.</p><p>The full relation is defined in <span class="tt"><a href="YUL____LSTATE-RENAMEVARP.html">lstate-renamevarp</a></span>, 
     as consisting of three conditions. 
     This quantified function expresses one of these conditions. 
     The condition is that every pair of variables in the renaming 
     have the same value (if any) in the old and new local states. 
     Note that this allows the local states to have no values 
     for some variable pairs in the renaming, 
     so long as they both do not have it; 
     or they both have it, and it is the same value in that case.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Theorem: </b>lstate-match-renamevarp-necc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  lstate-match-renamevarp-necc
  (<a href="ACL2____IMPLIES.html">implies</a>
       (<a href="YUL____LSTATE-MATCH-RENAMEVARP.html">lstate-match-renamevarp</a> old new ren)
       (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> (<a href="COMMON-LISP____CONS.html">cons</a> old-var new-var)
                              (<a href="YUL____RENAMING-_E3LIST.html">renaming-&gt;list</a> ren))
                (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="OMAP____IN.html">omap::in</a> old-var (<a href="YUL____LSTATE-FIX.html">lstate-fix</a> old)))
                       (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="OMAP____IN.html">omap::in</a> new-var (<a href="YUL____LSTATE-FIX.html">lstate-fix</a> new)))))))</pre> 
<p><b>Theorem: </b>booleanp-of-lstate-match-renamevarp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> booleanp-of-lstate-match-renamevarp
        (<a href="ACL2____B_A2.html">b*</a> ((yes/no (<a href="YUL____LSTATE-MATCH-RENAMEVARP.html">lstate-match-renamevarp</a> old new ren)))
            (<a href="ACL2____BOOLEANP.html">booleanp</a> yes/no))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>lstate-match-renamevarp-of-lstate-fix-old</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lstate-match-renamevarp-of-lstate-fix-old
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="YUL____LSTATE-MATCH-RENAMEVARP.html">lstate-match-renamevarp</a> (<a href="YUL____LSTATE-FIX.html">lstate-fix</a> old)
                                        new ren)
               (<a href="YUL____LSTATE-MATCH-RENAMEVARP.html">lstate-match-renamevarp</a> old new ren)))</pre> 
<p><b>Theorem: </b>lstate-match-renamevarp-lstate-equiv-congruence-on-old</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     lstate-match-renamevarp-lstate-equiv-congruence-on-old
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="YUL____LSTATE-EQUIV.html">lstate-equiv</a> old old-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="YUL____LSTATE-MATCH-RENAMEVARP.html">lstate-match-renamevarp</a> old new ren)
                     (<a href="YUL____LSTATE-MATCH-RENAMEVARP.html">lstate-match-renamevarp</a> old-equiv new ren)))
     :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>lstate-match-renamevarp-of-lstate-fix-new</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lstate-match-renamevarp-of-lstate-fix-new
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="YUL____LSTATE-MATCH-RENAMEVARP.html">lstate-match-renamevarp</a> old (<a href="YUL____LSTATE-FIX.html">lstate-fix</a> new)
                                        ren)
               (<a href="YUL____LSTATE-MATCH-RENAMEVARP.html">lstate-match-renamevarp</a> old new ren)))</pre> 
<p><b>Theorem: </b>lstate-match-renamevarp-lstate-equiv-congruence-on-new</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     lstate-match-renamevarp-lstate-equiv-congruence-on-new
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="YUL____LSTATE-EQUIV.html">lstate-equiv</a> new new-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="YUL____LSTATE-MATCH-RENAMEVARP.html">lstate-match-renamevarp</a> old new ren)
                     (<a href="YUL____LSTATE-MATCH-RENAMEVARP.html">lstate-match-renamevarp</a> old new-equiv ren)))
     :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>lstate-match-renamevarp-of-renaming-fix-ren</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lstate-match-renamevarp-of-renaming-fix-ren
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="YUL____LSTATE-MATCH-RENAMEVARP.html">lstate-match-renamevarp</a> old new (<a href="YUL____RENAMING-FIX.html">renaming-fix</a> ren))
               (<a href="YUL____LSTATE-MATCH-RENAMEVARP.html">lstate-match-renamevarp</a> old new ren)))</pre> 
<p><b>Theorem: </b>lstate-match-renamevarp-renaming-equiv-congruence-on-ren</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     lstate-match-renamevarp-renaming-equiv-congruence-on-ren
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="YUL____RENAMING-EQUIV.html">renaming-equiv</a> ren ren-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="YUL____LSTATE-MATCH-RENAMEVARP.html">lstate-match-renamevarp</a> old new ren)
                     (<a href="YUL____LSTATE-MATCH-RENAMEVARP.html">lstate-match-renamevarp</a> old new ren-equiv)))
     :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>lstate-match-renamevarp-rewrite</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lstate-match-renamevarp-rewrite
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="YUL____LSTATE-MATCH-RENAMEVARP.html">lstate-match-renamevarp</a> old new ren)
                      (<a href="YUL____LSTATEP.html">lstatep</a> old)
                      (<a href="YUL____LSTATEP.html">lstatep</a> new)
                      (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> (<a href="COMMON-LISP____CONS.html">cons</a> old-var new-var)
                                    (<a href="YUL____RENAMING-_E3LIST.html">renaming-&gt;list</a> ren)))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="OMAP____IN.html">omap::in</a> old-var old))
                        (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="OMAP____IN.html">omap::in</a> new-var new)))))</pre> 
<p><b>Theorem: </b>lstate-match-renamevarp-of-nil</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lstate-match-renamevarp-of-nil
        (<a href="YUL____LSTATE-MATCH-RENAMEVARP.html">lstate-match-renamevarp</a> nil nil (<a href="YUL____RENAMING.html">renaming</a> nil)))</pre> 

</body>
</html>
