<html>
<head>
<meta charset="UTF-8">
<title>Exec-arrsub-of-memberp</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=C____EXEC-ARRSUB-OF-MEMBERP">Click for Exec-arrsub-of-memberp in the Full Manual</a></h3>

<p>Execute an array subscripting expression 
          of a structure pointer member expression.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(exec-arrsub-of-memberp str mem sub compst) → result</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">str</span> — <font color="#606060">Guard <span class="v">(<a href="C____VALUE-RESULTP.html">value-resultp</a> str)</span>.</font>
</dd> 
  <dd>
<span class="tt">mem</span> — <font color="#606060">Guard <span class="v">(<a href="C____IDENTP.html">identp</a> mem)</span>.</font>
</dd> 
  <dd>
<span class="tt">sub</span> — <font color="#606060">Guard <span class="v">(<a href="C____VALUE-RESULTP.html">value-resultp</a> sub)</span>.</font>
</dd> 
  <dd>
<span class="tt">compst</span> — <font color="#606060">Guard <span class="v">(<a href="C____COMPUSTATEP.html">compustatep</a> compst)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">result</span> — <font color="#606060">Type <span class="v">(<a href="C____VALUE-RESULTP.html">value-resultp</a> result)</span>.</font>
</dd> 
 
</dl></div> 
<p>This is a combination of <span class="tt"><a href="C____EXEC-ARRSUB.html">exec-arrsub</a></span> and <span class="tt"><a href="C____EXEC-MEMBERP.html">exec-memberp</a></span>, 
     but it is defined as a separate function because currently 
     those two functions are not really compositional. 
     Our current semantics of C is correct for the purposes of ATC, 
     but it is not full-fledged and compositional. 
     In particular, it should (and will) be extended so that 
     expression execution returns either a value or an object designator.</p><p>So here we formalize the execution of expressions of the form <span class="v">s-&gt;m[i]</span>, 
     where <span class="v">s</span> is a pointer to a structure, 
     <span class="v">m</span> is the name of a member of the structure of array type, 
     and <span class="v">i</span> is an index into the array.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>exec-arrsub-of-memberp</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 exec-arrsub-of-memberp
 (str mem sub compst)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="C____VALUE-RESULTP.html">value-resultp</a> str)
                             (<a href="C____IDENTP.html">identp</a> mem)
                             (<a href="C____VALUE-RESULTP.html">value-resultp</a> sub)
                             (<a href="C____COMPUSTATEP.html">compustatep</a> compst))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((__function__ 'exec-arrsub-of-memberp))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
  (<a href="ACL2____B_A2.html">b*</a>
   ((str (<a href="C____VALUE-RESULT-FIX.html">value-result-fix</a> str))
    ((when (<a href="C____ERRORP.html">errorp</a> str)) str)
    ((unless (<a href="C____VALUE-CASE.html">value-case</a> str :pointer))
     (<a href="C____ERROR.html">error</a> (<a href="COMMON-LISP____LIST.html">list</a> :mistype-arrsub-of-memberp
                  :required :pointer
                  :supplied (<a href="C____TYPE-OF-VALUE.html">type-of-value</a> str))))
    ((when (<a href="C____VALUE-POINTER-NULLP.html">value-pointer-nullp</a> str))
     (<a href="C____ERROR.html">error</a> (<a href="COMMON-LISP____LIST.html">list</a> :null-pointer)))
    (objdes (<a href="C____VALUE-POINTER-_E3DESIGNATOR.html">value-pointer-&gt;designator</a> str))
    (reftype (<a href="C____VALUE-POINTER-_E3REFTYPE.html">value-pointer-&gt;reftype</a> str))
    (struct (<a href="C____READ-OBJECT.html">read-object</a> objdes compst))
    ((when (<a href="C____ERRORP.html">errorp</a> struct))
     (<a href="C____ERROR.html">error</a> (<a href="COMMON-LISP____LIST.html">list</a> :struct-not-found
                  str (<a href="C____COMPUSTATE-FIX.html">compustate-fix</a> compst))))
    ((unless (<a href="C____VALUE-CASE.html">value-case</a> struct :struct))
     (<a href="C____ERROR.html">error</a> (<a href="COMMON-LISP____LIST.html">list</a> :not-struct
                  str (<a href="C____COMPUSTATE-FIX.html">compustate-fix</a> compst))))
    ((unless (<a href="COMMON-LISP____EQUAL.html">equal</a> reftype
                    (<a href="C____TYPE-STRUCT.html">type-struct</a> (<a href="C____VALUE-STRUCT-_E3TAG.html">value-struct-&gt;tag</a> struct))))
     (<a href="C____ERROR.html">error</a> (<a href="COMMON-LISP____LIST.html">list</a> :mistype-struct-read
                  :pointer reftype
                  :array (<a href="C____TYPE-STRUCT.html">type-struct</a> (<a href="C____VALUE-STRUCT-_E3TAG.html">value-struct-&gt;tag</a> struct)))))
    (arr (<a href="C____VALUE-STRUCT-READ.html">value-struct-read</a> mem struct))
    ((when (<a href="C____ERRORP.html">errorp</a> arr)) arr)
    ((unless (<a href="C____VALUE-CASE.html">value-case</a> arr :array))
     (<a href="C____ERROR.html">error</a> (<a href="COMMON-LISP____LIST.html">list</a> :not-array arr)))
    (sub (<a href="C____VALUE-RESULT-FIX.html">value-result-fix</a> sub))
    ((when (<a href="C____ERRORP.html">errorp</a> sub)) sub)
    ((unless (<a href="C____VALUE-INTEGERP.html">value-integerp</a> sub))
     (<a href="C____ERROR.html">error</a> (<a href="COMMON-LISP____LIST.html">list</a> :mistype-array :index
                  :required :integer
                  :supplied (<a href="C____TYPE-OF-VALUE.html">type-of-value</a> sub))))
    (index (<a href="C____EXEC-INTEGER.html">exec-integer</a> sub))
    ((when (<a href="COMMON-LISP_____C3.html">&lt;</a> index 0))
     (<a href="C____ERROR.html">error</a> (<a href="COMMON-LISP____LIST.html">list</a> :negative-array-index
                  :array arr
                  :index sub))))
   (<a href="C____VALUE-ARRAY-READ.html">value-array-read</a> index arr))))</pre> 
<p><b>Theorem: </b>value-resultp-of-exec-arrsub-of-memberp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> value-resultp-of-exec-arrsub-of-memberp
        (<a href="ACL2____B_A2.html">b*</a> ((result (<a href="C____EXEC-ARRSUB-OF-MEMBERP.html">exec-arrsub-of-memberp</a> str mem sub compst)))
            (<a href="C____VALUE-RESULTP.html">value-resultp</a> result))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>exec-arrsub-of-memberp-of-value-result-fix-str</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> exec-arrsub-of-memberp-of-value-result-fix-str
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____EXEC-ARRSUB-OF-MEMBERP.html">exec-arrsub-of-memberp</a> (<a href="C____VALUE-RESULT-FIX.html">value-result-fix</a> str)
                                       mem sub compst)
               (<a href="C____EXEC-ARRSUB-OF-MEMBERP.html">exec-arrsub-of-memberp</a> str mem sub compst)))</pre> 
<p><b>Theorem: </b>exec-arrsub-of-memberp-value-result-equiv-congruence-on-str</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 exec-arrsub-of-memberp-value-result-equiv-congruence-on-str
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____VALUE-RESULT-EQUIV.html">value-result-equiv</a> str str-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____EXEC-ARRSUB-OF-MEMBERP.html">exec-arrsub-of-memberp</a> str mem sub compst)
                 (<a href="C____EXEC-ARRSUB-OF-MEMBERP.html">exec-arrsub-of-memberp</a> str-equiv mem sub compst)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>exec-arrsub-of-memberp-of-ident-fix-mem</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> exec-arrsub-of-memberp-of-ident-fix-mem
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____EXEC-ARRSUB-OF-MEMBERP.html">exec-arrsub-of-memberp</a> str (<a href="C____IDENT-FIX.html">ident-fix</a> mem)
                                       sub compst)
               (<a href="C____EXEC-ARRSUB-OF-MEMBERP.html">exec-arrsub-of-memberp</a> str mem sub compst)))</pre> 
<p><b>Theorem: </b>exec-arrsub-of-memberp-ident-equiv-congruence-on-mem</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 exec-arrsub-of-memberp-ident-equiv-congruence-on-mem
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____IDENT-EQUIV.html">ident-equiv</a> mem mem-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____EXEC-ARRSUB-OF-MEMBERP.html">exec-arrsub-of-memberp</a> str mem sub compst)
                 (<a href="C____EXEC-ARRSUB-OF-MEMBERP.html">exec-arrsub-of-memberp</a> str mem-equiv sub compst)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>exec-arrsub-of-memberp-of-value-result-fix-sub</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     exec-arrsub-of-memberp-of-value-result-fix-sub
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____EXEC-ARRSUB-OF-MEMBERP.html">exec-arrsub-of-memberp</a> str mem (<a href="C____VALUE-RESULT-FIX.html">value-result-fix</a> sub)
                                    compst)
            (<a href="C____EXEC-ARRSUB-OF-MEMBERP.html">exec-arrsub-of-memberp</a> str mem sub compst)))</pre> 
<p><b>Theorem: </b>exec-arrsub-of-memberp-value-result-equiv-congruence-on-sub</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 exec-arrsub-of-memberp-value-result-equiv-congruence-on-sub
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____VALUE-RESULT-EQUIV.html">value-result-equiv</a> sub sub-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____EXEC-ARRSUB-OF-MEMBERP.html">exec-arrsub-of-memberp</a> str mem sub compst)
                 (<a href="C____EXEC-ARRSUB-OF-MEMBERP.html">exec-arrsub-of-memberp</a> str mem sub-equiv compst)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>exec-arrsub-of-memberp-of-compustate-fix-compst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 exec-arrsub-of-memberp-of-compustate-fix-compst
 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____EXEC-ARRSUB-OF-MEMBERP.html">exec-arrsub-of-memberp</a> str mem sub (<a href="C____COMPUSTATE-FIX.html">compustate-fix</a> compst))
        (<a href="C____EXEC-ARRSUB-OF-MEMBERP.html">exec-arrsub-of-memberp</a> str mem sub compst)))</pre> 
<p><b>Theorem: </b>exec-arrsub-of-memberp-compustate-equiv-congruence-on-compst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 exec-arrsub-of-memberp-compustate-equiv-congruence-on-compst
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____COMPUSTATE-EQUIV.html">compustate-equiv</a> compst compst-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____EXEC-ARRSUB-OF-MEMBERP.html">exec-arrsub-of-memberp</a> str mem sub compst)
                 (<a href="C____EXEC-ARRSUB-OF-MEMBERP.html">exec-arrsub-of-memberp</a> str mem sub compst-equiv)))
 :rule-classes :congruence)</pre> 

</body>
</html>
