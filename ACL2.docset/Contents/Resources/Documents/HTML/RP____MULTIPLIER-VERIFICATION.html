<html>
<head>
<meta charset="UTF-8">
<title>Multiplier-verification</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=RP____MULTIPLIER-VERIFICATION">Click for Multiplier-verification in the Full Manual</a></h3>

<p>An efficient library to verify large integer multiplier designs 
 following the S-C-Rewriting algorithm.</p> <p> Implemented and verified  completely in ACL2, we  provide a new 
 method to  verify complex integer  multiplier designs implemented  in (System) 
 Verilog. With a very efficient proof-time scaling factor, this tool can verify 
 integer  multipliers that  may  be implemented  with  Booth Encoding,  various 
 summation trees  such as Wallace  and Dadda,  and numerous final  stage adders 
 such as carry-lookahead.  For example,  we can verify 64x64-bit multipliers in 
 around  a  second;  128x128  in  2-4 seconds;  256x256  in  6-12  seconds  and 
 1024x1024-bit  multipliers in  around  5  minutes as  tested  with almost  100 
 different  designs.  This library  can  also  verify other  multiplier-centric 
 designs such as multiply-accumulate and dot-product. Designs can be truncated, 
 right-shifted, bit-masked, rounded, saturated, and input sizes can be arbitrary.</p> 
 
  <p>  The outline  of  this  new verification  method  first  appeared in  CAV 
2020 (Automated  and Scalable  Verification of  Integer Multipliers  by Mertcan 
Temel,   Anna  Slobodova,   Warren   A.   Hunt,   Jr.)    available  here:   <a href="http://doi.org/10.1007/978-3-030-53288-8_23" target="_blank"><nobr> 
http://doi.org/10.1007/978-3-030-53288-8_23<img src="../Icon_External_Link.png" title="External link to http://doi.org/10.1007/978-3-030-53288-8_23"></nobr></a>. A follow-up study is to appear 
in FMCAD21 by Mertcan Temel and Warran A. Hunt, Jr.. This method is also 
described in Mertcan Temel's PhD thesis from University of Texas at Austin.  </p> 
 
<p> Our framework currently supports  (System) Verilog with design hierarchy as 
inputs only.  These  designs are translated to <a href="ACL2____SVL.html">svl</a> design without 
flattening the adder  modules such as full-adders and  final stage-adders. Then 
<a href="ACL2____RP-REWRITER.html">RP-Rewriter</a> are  used  as the  clause-processor to  carry  out all  the 
rewriting instead  of the  built-in rewriter,  and our  meta rules  and rewrite 
rules dedicated for multiplier designs are used to simplify them and prove them 
equivalent to their specification. </p> 
 
<p>  Our  library  uses  various  heuristics  and  modes  to  simplify  various 
designs. We give the users the  option to enable/disable some of the heuristics 
that might help speed-up the proofs (and/or reduce memory use) or in some cases 
help proofs finish.   We enable very aggressive heuristics by  default for best 
coverage.   If   you  wish  to   tune  the   performance  of  your   proofs  by 
enabling/disabling    these   heuristics,    you    can    check   out    <a href="RP____MULTIPLIER-VERIFICATION-HEURISTICS.html">Multiplier-Verification-Heuristics</a>. Enabling/disabling these heuristics might 
help a proof attempt to go through. </p> 
 
<p>  We  present  two demos  that  show  how  this  tool  can be  used  in  new 
designs. <a href="RP____MULTIPLIER-VERIFICATION-DEMO-1.html">Multiplier-Verification-demo-1</a> shows  a very basic verification 
case  on  a  stand-alone  64x64-bit  Booth  Encoded  Dadda  multiplier.   <a href="RP____MULTIPLIER-VERIFICATION-DEMO-2.html">Multiplier-Verification-demo-2</a> shows  how this tool  can be used on  much more 
complex designs where a stand-alone integer multiplier is reused as a submodule 
for various operations  such as MAC dot-product and  merged multiplication. It 
also shows a simple verification case on a sequential circuit.  </p> 
 
<p>  Alternatively,   we  present  a   different  framework  that   uses  <a href="ACL2____DEFSVTV.html">defsvtv</a> instead of <a href="ACL2____SVL.html">svl</a>. Defsvtv is more capable than SVL at 
handling combinational loops but it  flattens designs completely. This prevents 
our method from working properly because we need to identify instantiated adder 
modules. Therefore,  we soundly replace  adder modules with  their identifiable 
copies even when  flattened. Then, we call defsvtv on  the redefined multiplier 
design and we can verify this test vector with out tool. This mechanism is 
described in <a href="RP____MULTIPLIER-VERIFICATION-DEMO-3.html">Multiplier-Verification-demo-3</a>. 
</p> 
 
<p> This library can be used to quickly generate counterexamples using an 
external SAT solver, or help finish proofs with a SAT solver when our library 
fails to finish the job. You may include the book 
projects/rp-rewriter/lib/mult3/fgl, <a href="FGL____FGL.html">fgl::fgl</a> book and use 
rp::defthmrp-then-fgl utility instead of rp::defthmrp to submit conjectures to 
ACL2. </p> 
 
<p> There  are two older  versions of  this library. If  you would like  to use 
those   for    some   reason,    you   may   view    their   demo    files   at 
<span class="v">&lt;your-acl2-directory&gt;/books/projects/rp-rewriter/lib/mult/demo.lisp</span>    and 
<span class="v">&lt;your-acl2-directory&gt;/books/projects/rp-rewriter/lib/mult2/demo.lisp</span>     . 
The second  version implements the  exact method as  described in our  CAV 2020 
paper. The third version (i.e., the  library we describe in this documentation) 
have some  significant improvements but  the methods are essentially  the same. 
</p> 

</body>
</html>
