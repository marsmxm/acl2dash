<html>
<head>
<meta charset="UTF-8">
<title>Modinsts-to-eoccs</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=VL2014____MODINSTS-TO-EOCCS">Click for Modinsts-to-eoccs in the Full Manual</a></h3>

<p>How we convert Verilog modules instances into (preliminary) E module 
occurrences.</p><p>This documentation assumes you have already read <a href="VL2014____E-CONVERSION.html">e-conversion</a>.  Note that the E occurrences we generate in this initial pass 
are only preliminary and might include multiple drivers of certain wires.  See 
also <a href="VL2014____EXPLODING-VECTORS.html">exploding-vectors</a>, since we are going to be doing a lot of 
that.</p> 
 
<p>To convert each Verilog module instance into preliminary E occurrences, we 
need to create E language <a href="ACL2____PATTERNS.html">ACL2::patterns</a> that represent (1) the inputs 
and outputs of each module, i.e., the <span class="v">:i</span> and <span class="v">:o</span> patterns for each 
module, and (2) the corresponding "actuals" of each module instance, i.e., 
the <span class="v">:i</span> and <span class="v">:o</span> patterns for each occurrence.</p> 
 
 
<h4>Basic Idea</h4> 
 
<p>Suppose we have a module with port declarations like:</p> 
 
<pre class="code">input [3:0] a;
input b;
input [5:3] c;

...</pre> 
 
<p>Then we are going to generate an input pattern like:</p> 
 
<pre class="code">:i ( (a[0] a[1] a[2] a[3])
     (b)
     (c[3] c[4] c[5])
     ...)</pre> 
 
<p>Here, individual bits like <span class="v">a[2]</span> and <span class="v">b</span> are <a href="VL2014____VL-EMODWIRE-P.html">vl-emodwire-p</a>s. 
The bits for each vector form a <a href="VL2014____VL-EMODWIRELIST-P.html">vl-emodwirelist-p</a> like <span class="v">(a[0] a[1]
a[2] a[3])</span> or <span class="v">(b)</span>.  Finally, our full <span class="v">:i</span> and <span class="v">:o</span> patterns are 
lists of such vectors, and are recognized with <a href="VL2014____VL-EMODWIRELISTLIST-P.html">vl-emodwirelistlist-p</a>.</p> 
 
 
<h4>Module I/O Patterns</h4> 
 
<p>Recall the difference between port declarations (see <a href="VL2014____VL-PORTDECL-P.html">vl-portdecl-p</a>) 
and ports (see <a href="VL2014____VL-PORT-P.html">vl-port-p</a>).  For instance:</p> 
 
<pre class="code">module mymod (.low(vec[3:0]), .high(vec[5:4]), foo)   &lt;-- ports
  input foo;
  input [5:0] vec;   &lt;-- port declarations
endmodule</pre> 
 
<p>We generate the <span class="v">:i</span> and <span class="v">:o</span> patterns for each module from their port 
<i>declarations</i>, not from thir ports; see <a href="VL2014____VL-PORTDECLS-TO-I_F2O.html">vl-portdecls-to-i/o</a> for 
details.  Because of this, the actual input pattern for <span class="v">mymod</span> would look 
like this:</p> 
 
<pre class="code">:i ((foo)
    (vec[0] vec[1] vec[2] vec[3] vec[4] vec[5]))</pre> 
 
 
<h4>Port Patterns</h4> 
 
<p>An instance of this mymod might look something like this:</p> 
 
<pre class="code">mymod myinstance (a[3:0], b[1:0], c[7]);</pre> 
 
<p>Unfortunately, the I/O patterns we have generated for <span class="v">mymod</span> are not 
very useful when we want to translate <span class="v">myinstance</span>, because its entries are 
not at all in the same shape or order as the ports.</p> 
 
<p>To correct for this, we build a <b>port pattern</b> for each module.  For 
instance, the port pattern for <span class="v">mymod</span> would be:</p> 
 
<pre class="code">((vec[3] vec[2] vec[1] vec[0])
 (vec[5] vec[4])
 (foo))</pre> 
 
<p>The port pattern matches the shape of the module's port expressions, and 
lists the wires each port is connected to, in MSB-first order.</p> 
 
<p>Port patterns are generated by <a href="VL2014____VL-PORTLIST-MSB-BIT-PATTERN.html">vl-portlist-msb-bit-pattern</a>.  We can 
carry out certain checking to ensure that the port pattern mentions every input 
and output wire without duplication; see <a href="VL2014____PORT-BIT-CHECKING.html">port-bit-checking</a>.</p> 
 
 
<h4>Preliminary E Occurrences</h4> 
 
<p>Port patterns make it pretty easy to create the E occurrence for a module 
instance.  In particular, for any valid module instance, we can explode the 
"actuals" into wires that line up perfectly with the port pattern.  In the 
case of <span class="v">myinstance</span>, we sort of intuitively might imagine generating the 
following "actual pattern":</p> 
 
<pre class="code">((a[3] a[2] a[1] a[0])
 (b[1] b[0])
 (c[7]))</pre> 
 
<p>We don't actually build this pattern.  Instead, we directly construct an 
alist that binds each formal to its actual; see <a href="VL2014____VL-MODINST-EOCC-BINDINGS.html">vl-modinst-eocc-bindings</a>.</p> 
 
<p>The <span class="v">:i</span> and <span class="v">:o</span> patterns for the module may then be instantiated 
with this pattern to form the <span class="v">:i</span> and <span class="v">:o</span> fields for the occurrence. 
The main function that does all of this is <a href="VL2014____VL-MODINST-TO-EOCC.html">vl-modinst-to-eocc</a>.</p>
</body>
</html>
