<html>
<head>
<meta charset="UTF-8">
<title>Tag</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____TAG">Click for Tag in the Full Manual</a></h3>

<p>Get the tag from a tagged object.</p><p>The <span class="v">tag</span> function is simply an alias for <span class="v">car</span> that is 
especially meant to be used for accessing the <i>tag</i> of a <i>tagged 
object</i>.</p> 
 
<p>When new types are introduced by macros such as <a href="STD____DEFAGGREGATE.html">defaggregate</a>, <a href="FTY____DEFPROD.html">fty::defprod</a>, <a href="FTY____DEFTAGSUM.html">fty::deftagsum</a>, etc., they may be tagged.  When a type is 
tagged, its objects have the form <span class="v">(<a href="ACL2____TAG.html">tag</a> . data)</span>, where the <span class="v">tag</span> says 
what kind of object is being represented (e.g., ``employee'', ``student'', 
etc.) and <span class="v">data</span> contains the actual information for this kind of 
structure (e.g., name, age, ...).  Tagging objects has some runtime/memory 
cost (an extra cons for each object), but makes it easy to tell different kinds 
of objects apart by inspecting their tags.</p> 
 
<p>We could (of course) just get the tag with <a href="COMMON-LISP____CAR.html">car</a>, but <span class="v">car</span> is a 
widely used function and we do not want to slow down reasoning about it. 
Instead, we introduce <span class="v">tag</span> as an alias for <span class="v">car</span> and keep it disabled so 
that reasoning about the tags of objects does not slow down reasoning about 
<span class="v">car</span> in general.</p> 
 
<p>Even so, tag reasoning can occasionally get expensive.  Macros like 
<span class="v">defaggregate</span>, <a href="FTY____DEFPROD.html">fty::defprod</a>, etc., generally add their tag-related 
rules to the <span class="v">tag-reasoning</span> ruleset; see <a href="ACL2____RULESETS.html">ACL2::rulesets</a>.  You may 
generally want to keep this ruleset disabled, and only enable it when you 
really want to use tags to distinguish between objects.</p> 
 
<p>Note: if you are using the <a href="ACL2____FTY.html">ACL2::fty</a> framework, it is generally best 
to avoid using <span class="v">tag</span> to distinguish between members of the same sum of 
products type.  Instead, consider using the custom <span class="v">-kind</span> macros that are 
introduced by macros such as <a href="FTY____DEFTAGSUM.html">fty::deftagsum</a> and <a href="FTY____DEFTRANSSUM.html">fty::deftranssum</a>.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>tag$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> acl2::tag$inline (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="COMMON-LISP____CAR.html">car</a> x)
            :exec (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x) (<a href="COMMON-LISP____CAR.html">car</a> x) nil)))</pre> 
<p><b>Theorem: </b>tag-forward-to-consp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> tag-forward-to-consp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____TAG.html">tag</a> x) (<a href="COMMON-LISP____CONSP.html">consp</a> x))
        :rule-classes :forward-chaining)</pre> 

</body>
</html>
