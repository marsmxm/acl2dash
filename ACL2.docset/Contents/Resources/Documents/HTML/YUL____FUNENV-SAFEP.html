<html>
<head>
<meta charset="UTF-8">
<title>Funenv-safep</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=YUL____FUNENV-SAFEP">Click for Funenv-safep in the Full Manual</a></h3>

<p>Check the safey of a function environment.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(funenv-safep funenv) → yes/no</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">funenv</span> — <font color="#606060">Guard <span class="v">(<a href="YUL____FUNENVP.html">funenvp</a> funenv)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">yes/no</span> — <font color="#606060">Type <span class="v">(<a href="ACL2____BOOLEANP.html">booleanp</a> yes/no)</span>.</font>
</dd> 
 
</dl></div> 
<p>The invariant alluded to in <span class="tt"><a href="YUL____FUNINFO-SAFEP.html">funinfo-safep</a></span> is here defined. 
     Recall that a function enviroment is a stack of function scope. 
     The invariant is that each function scope is safe 
     (i.e. all the functions in the scope are safe) 
     with respect to the function table consisting of 
     that scope and all the preceding scopes in the stack. 
     In fact, as a new function scope is pushed onto the stack, 
     the functions are safe with respect to 
     not only the functions already in scope, 
     but also the functions of the new scope: 
     a function is always in its own scope, 
     making recursive calls possible.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>funenv-safep</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> funenv-safep (<a href="YUL____FUNENV.html">funenv</a>)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="YUL____FUNENVP.html">funenvp</a> funenv)))
       (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'funenv-safep))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
            (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____ENDP.html">endp</a> funenv)
                (<a href="COMMON-LISP____AND.html">and</a> (<a href="YUL____FUNSCOPE-SAFEP.html">funscope-safep</a> (<a href="COMMON-LISP____CAR.html">car</a> funenv)
                                     (<a href="YUL____FUNENV-TO-FUNTABLE.html">funenv-to-funtable</a> funenv))
                     (<a href="YUL____FUNENV-SAFEP.html">funenv-safep</a> (<a href="COMMON-LISP____CDR.html">cdr</a> funenv))))))</pre> 
<p><b>Theorem: </b>booleanp-of-funenv-safep</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> booleanp-of-funenv-safep
        (<a href="ACL2____B_A2.html">b*</a> ((yes/no (<a href="YUL____FUNENV-SAFEP.html">funenv-safep</a> funenv)))
            (<a href="ACL2____BOOLEANP.html">booleanp</a> yes/no))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>funenv-safep-of-funenv-fix-funenv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> funenv-safep-of-funenv-fix-funenv
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="YUL____FUNENV-SAFEP.html">funenv-safep</a> (<a href="YUL____FUNENV-FIX.html">funenv-fix</a> funenv))
               (<a href="YUL____FUNENV-SAFEP.html">funenv-safep</a> funenv)))</pre> 
<p><b>Theorem: </b>funenv-safep-funenv-equiv-congruence-on-funenv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> funenv-safep-funenv-equiv-congruence-on-funenv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="YUL____FUNENV-EQUIV.html">funenv-equiv</a> funenv funenv-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="YUL____FUNENV-SAFEP.html">funenv-safep</a> funenv)
                        (<a href="YUL____FUNENV-SAFEP.html">funenv-safep</a> funenv-equiv)))
        :rule-classes :congruence)</pre> 

</body>
</html>
