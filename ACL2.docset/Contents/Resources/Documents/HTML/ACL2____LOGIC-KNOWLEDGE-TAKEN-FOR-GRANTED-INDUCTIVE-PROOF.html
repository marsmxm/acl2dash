<html>
<head>
<meta charset="UTF-8">
<title>Logic-knowledge-taken-for-granted-inductive-proof</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____LOGIC-KNOWLEDGE-TAKEN-FOR-GRANTED-INDUCTIVE-PROOF">Click for Logic-knowledge-taken-for-granted-inductive-proof in the Full Manual</a></h3>

<p>A brief explanation of induction</p><p>We start by showing classical induction on the natural numbers in 
 an ACL2 setting before turning to a more general treatment of induction.</p> 
 
 <p><b>Classical Induction on Natural Numbers</b>: Induction is familiar in the 
 arithmetic setting.  Let <span class="v">(p n)</span> denote some formula involving the variable 
 <span class="v">n</span> (and perhaps some other variables which we don't exhibit).  Then to 
 prove <span class="v">(p n)</span>, for all <span class="v">n</span>, by classical induction on the construction 
 of the natural numbers, prove each of the following:</p> 
 
 <pre class="code"><i>Base Case</i>: 
(implies (zp n) (p n)) 
</pre> 
 
 <pre class="code"><i>Induction Step</i>: 
(implies (and (not (zp n)) 
              (p (- n 1))) 
         (p n)) 
</pre> 
 
 <p>The Base Case establishes that <span class="v">p</span> holds for <span class="v">0</span>.  In fact, because 
 of the definition of <span class="tt"><a href="ACL2____ZP.html">zp</a></span> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a>, it 
 establishes that <span class="v">(p n)</span> holds when <span class="v">n</span> is <span class="v">0</span> and it holds when 
 <span class="v">n</span> is not a natural number.</p> 
 
 <p>The Induction Step establishes that if <span class="v">n</span> is a natural number other 
 than <span class="v">0</span>, and if <span class="v">p</span> holds for <span class="v">n</span>-1, then <span class="v">p</span> holds for <span class="v">n</span>. 
 The hypothesis <span class="v">(p (<a href="COMMON-LISP____-.html">-</a> n 1))</span> above is called the <i>induction 
 hypothesis</i>.</p> 
 
 <p>Note that if the Base Case and Induction Step are valid, then we know <span class="v">(p
 n)</span>, for all <span class="v">n</span>.  You can convince yourself of this by picking any object 
 and asking ``how do I know <span class="v">p</span> holds for this object?''  For example, <span class="v">(p
 -7)</span>, <span class="v">(p 'abc)</span>, and <span class="v">(p 0)</span> are all established by the Base Case. 
 What about <span class="v">(p 1)</span>?  That follows from <span class="v">(p 0)</span>, given the Induction 
 Step.  Why?  To prove <span class="v">(p 1)</span> using the Induction Step, you have to 
 establish <span class="v">(<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> 1))</span>, which is true, and <span class="v">(p (<a href="COMMON-LISP____-.html">-</a> 1 1))</span>, which is 
 <span class="v">(p 0)</span>, which is true by the Base Case.  So <span class="v">(p 1)</span> is true.  Similar 
 reasoning proves <span class="v">(p 2)</span> from from <span class="v">(p 1)</span>, etc.  Clearly, for every 
 natural number other than <span class="v">0</span> we could reason like this to show that <span class="v">p</span> 
 holds.  Since the Base Case handled all the objects that are not natural 
 numbers, and handled <span class="v">0</span>, we know <span class="v">(p n)</span>, for all <span class="v">n</span>.</p> 
 
 <p>There is a duality between recursion and induction that ACL2 exploits.  The 
 fact that the Base and Induction steps above are sufficient to prove <span class="v">p</span> 
 for all objects is related to the fact that the following recursion defines a 
 total, terminating function:</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> nat-recursion (n)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> n)
      n
      (nat-recursion (<a href="COMMON-LISP____-.html">-</a> n 1))))</pre> 
 
 <p>When this function is admitted we have to prove that if <span class="v">(<a href="ACL2____ZP.html">zp</a> n)</span> does 
 not hold, then <span class="v">(<a href="COMMON-LISP____-.html">-</a> n 1)</span> is smaller, in some sense, than <span class="v">n</span>.  This 
 sense of ``smaller'' is determined by some <i>measure</i> of the arguments. 
 That measure must return an ordinal (see <a href="ACL2____ORDINALS.html">ordinals</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a>), 
 but the most common measures return natural numbers, which are among the 
 ordinals.  Furthermore, that measure should ensure that the terms in the 
 recursive calls are smaller than the formals, i.e., the measure of <span class="v">(<a href="COMMON-LISP____-.html">-</a> n
 1)</span> must be smaller than the measure of <span class="v">n</span>, when the recursive branches 
 are taken.  This sense of ``smaller'' must be <i>well-founded</i>: it must be 
 impossible to have an infinitely descending chain of smaller things.  This is 
 true of the less-than relation on the ordinals (see <span class="tt"><a href="ACL2____O_C3.html">o&lt;</a></span> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a>). 
 Well-foundedness means that eventually any recursion must ``bottom out'' 
 because things can't keep getting smaller forever.</p> 
 
 <p>The recursion in <span class="v">nat-recursion</span> <b>suggests</b> the induction shown 
 above: the Base Case is defined by the <span class="v">if</span> branch that does not lead to a 
 recursive call.  The Induction Step is defined by the other branch.  The 
 induction hypothesis is defined by what we recur on, i.e., <span class="v">(<a href="COMMON-LISP____-.html">-</a> n 1)</span>.  The 
 theorems proved when <span class="v">nat-recursion</span> is introduced <i>justify</i> the 
 classical induction scheme noted above.</p> 
 
 <p>Every recursively defined ACL2 function suggests a legal induction and vice 
 versa.</p> 
 
 <p>Furthermore, every call of a recursively defined function on distinct 
 variable symbols also suggests a legal induction: just take the induction 
 suggested by the function's recursive definition after renaming the formal 
 parameters to be the variables in the call.</p> 
 
 <p>For example, it should be clear that <span class="v">(nat-recursion a)</span> suggests a Base 
 Case defined by <span class="v">(<a href="ACL2____ZP.html">zp</a> a)</span>, and induction step defined by <span class="v">(<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> a))</span> 
 and an induction hypothesis about <span class="v">(<a href="COMMON-LISP____-.html">-</a> a 1)</span>.</p> 
 
 <p>Note that the term <span class="v">(fact n)</span> suggests the same classical induction on 
 natural numbers shown above, where <span class="v">fact</span> is defined as follows (even 
 though we've used the formal parameter <span class="v">k</span> below).</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> fact (k)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> k)
      1
      (<a href="COMMON-LISP_____A2.html">*</a> k (fact (<a href="COMMON-LISP____-.html">-</a> k 1)))))</pre> 
 
 <p>The induction suggested by a term like <span class="v">(fact n)</span> is insensitive to the 
 name of the formal parameter used in the <span class="v">defun</span>.</p> 
 
 <p>The induction suggested by a function or term is insensitive to the value 
 returned by the function or term.</p> 
 
 <p>It doesn't matter what the function returns in its ``base case'' (e.g., 
 <span class="v">1</span> in <span class="v">fact</span>) or what the function ``does'' to its recursive call 
 (e.g., multiply by <span class="v">k</span> in the <span class="v">defun</span> of <span class="v">fact</span>).</p> 
 
 <p>All that matters is (i) how the <span class="v">if</span> structure breaks down the cases on 
 <span class="v">k</span>, (ii) which branches lead to recursion, and (iii) what arguments are 
 passed to the recursive calls.  Those things determine (i) the case analysis 
 of the induction scheme, (ii) which cases are Base Cases and which are 
 Induction Steps, and (iii) what the induction hypotheses are.</p> 
 
 <p>For a selection of common inductions schemes in ACL2 (e.g., on the 
 structure of natural numbers, lists, and trees and on several variables at 
 once, multiple base cases, multiple induction hypotheses, multiple induction 
 steps, etc.)  <a href="ACL2____EXAMPLE-INDUCTIONS.html">check this 
 link</a>.</p> 
 
 <p>Every legal ACL2 induction corresponds to an admissible recursive function 
 and vice versa.  Similarly, every legal ACL2 induction corresponds to a call 
 of a recursively defined function on distinct variables.</p> 
 
 <p>ACL2 chooses which induction to do by looking at the terms that occur in 
 the conjecture.  For many elementary theorems, ACL2 chooses the right 
 induction by itself.</p> 
 
 <p>You may occasionally need to tell it what induction to do.  You do that by 
 showing it a term that suggests the induction you want.  We'll explain how you 
 communicate this to ACL2 later.  If you understand how recursive functions 
 suggest inductions, then you know what you need to know to use ACL2.</p> 
 
 <p>The main point of this discussion of induction is familiarize you with the 
 basic terms: <i>Base Case</i> (of which there may be several), <i>Induction 
 Step</i> (of which there may be several), <i>Induction Hypothesis</i> (of 
 which there may be several in each Induction Step), <i>measure</i> and 
 <i>well-founded relation</i> <i>justifying</i> an induction, and the induction 
 <i>suggested</i> by a term or recursive function definition.  Furthermore, 
 every Induction Hypothesis is always an <a href="ACL2____LOGIC-KNOWLEDGE-TAKEN-FOR-GRANTED-INSTANCE.html">instance</a> of the conjecture 
 being proved: each induction hypothesis is obtained from the conjecture being 
 proved by applying a <i>substitution</i> replacing variables by terms.</p> 
 
 <p>If you are reviewing the material taken for granted about logic while 
 working your way through the introduction to the theorem prover, please use 
 your browser's <b>Back Button</b> to return to the example proof in <a href="ACL2____LOGIC-KNOWLEDGE-TAKEN-FOR-GRANTED.html">logic-knowledge-taken-for-granted</a>.</p>
</body>
</html>
