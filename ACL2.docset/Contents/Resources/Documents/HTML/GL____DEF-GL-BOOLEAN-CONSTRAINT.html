<html>
<head>
<meta charset="UTF-8">
<title>Def-gl-boolean-constraint</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=GL____DEF-GL-BOOLEAN-CONSTRAINT">Click for Def-gl-boolean-constraint in the Full Manual</a></h3>

<p>Define a rule that recognizes constraints among GL generated Boolean variables</p> 
<p>When using GL in a term-level style (see <a href="GL____TERM-LEVEL-REASONING.html">term-level-reasoning</a>), GL 
may generate new Boolean variables from terms that appear as IF tests.</p> 
 
<p>Sometimes, the terms from which these variables are generated have 
interdependent meanings.  For example, if Boolean variable <span class="v">a</span> represents 
<span class="v">(<a href="COMMON-LISP____LOGBITP.html">logbitp</a> 5 x)</span> and Boolean variable <span class="v">b</span> represents <span class="v">(<a href="COMMON-LISP____INTEGERP.html">integerp</a> x)</span>, it 
should be impossible for <span class="v">a</span> to be true when <span class="v">b</span> is false.  However, by 
default, the Boolean variables generated this way are unconstrained.  When 
this sort of interdependency among variables exists but is not accounted for, 
it can cause GL to find <a href="GL____FALSE-COUNTEREXAMPLES.html">false-counterexamples</a>.</p> 
 
<p><span class="v">Def-gl-boolean-constraint</span> provides a mechanism to make such constraints 
known to GL.  While symbolically executing a form, GL maintains a constraint, a 
Boolean formula known to always be true (under the evolving assignment of 
Boolean variables to terms).  A constraint rule generated by 
<span class="v">def-gl-boolean-constraint</span> is triggered when a Boolean variable is 
generated from an IF condition term and can cause the constraint to be updated 
with a new conjunct.</p> 
 
<p>A Boolean constraint rule is formulated as follows:</p> 
<pre class="code">(<a href="GL____DEF-GL-BOOLEAN-CONSTRAINT.html">def-gl-boolean-constraint</a> gl-logbitp-implies-integerp
   :bindings ((bit    (<a href="COMMON-LISP____LOGBITP.html">logbitp</a> n x))
              (intp   (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x)))
   :body (<a href="ACL2____IMPLIES.html">implies</a> bit intp)
   ;; optional arguments:
   :syntaxp ...
   :hints ...)</pre> 
<p>This generates a proof obligation:</p> 
<pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> gl-logbitp-implies-integerp
  (<a href="COMMON-LISP____LET.html">let</a> ((bit    (gl-bool-fix (<a href="COMMON-LISP____LOGBITP.html">logbitp</a> n x)))
        (intp   (gl-bool-fix (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x))))
    (<a href="ACL2____IMPLIES.html">implies</a> bit intp))
 :hints ...
 :rule-classes nil)</pre> 
<p>(The optional :hints argument to def-gl-boolean-constraint provides the 
hints for the proof obligation.)</p> 
 
<p>Once this rule is established, GL will generate constraints as follows:</p> 
<ul> 
<li>When a Boolean variable <span class="v">a</span> is generated from an IF condition matching 
<span class="v">(<a href="COMMON-LISP____LOGBITP.html">logbitp</a> n x)</span>, GL will search for an existing generated Boolean variable 
<span class="v">b</span> whose IF condition was <span class="v">(<a href="COMMON-LISP____INTEGERP.html">integerp</a> x)</span> and, if it exists, add the 
constraint <span class="v">(<a href="ACL2____IMPLIES.html">implies</a> a b)</span>.</li> 
 
<li>Conversely, when a Boolean variable <span class="v">b</span> is generated from an IF 
condition matching <span class="v">(<a href="COMMON-LISP____INTEGERP.html">integerp</a> x)</span>, GL will search for existing generated 
Boolean variables <span class="v">ai</span> matching <span class="v">(<a href="COMMON-LISP____LOGBITP.html">logbitp</a> n x)</span>, and for each of them, 
add the constraint <span class="v">(<a href="ACL2____IMPLIES.html">implies</a> ai b)</span>.</li> 
</ul> 
 
<p>To show that this rule works, you can verify that the following events fail 
prior to introducing the constraint rule above, but succeed after:</p> 
 
<pre class="code">(<a href="ACL2____DEF-GL-THM.html">def-gl-thm</a> foo1
   :hyp t
   :concl (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x) t (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____LOGBITP.html">logbitp</a> n x)))
   :g-bindings nil
   :rule-classes nil)

(<a href="ACL2____DEF-GL-THM.html">def-gl-thm</a> foo2
   :hyp t
   :concl (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____LOGBITP.html">logbitp</a> n x) (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x) t)
   :g-bindings nil
   :rule-classes nil)</pre> 
 
 

</body>
</html>
