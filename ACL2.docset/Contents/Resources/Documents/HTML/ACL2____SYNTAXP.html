<html>
<head>
<meta charset="UTF-8">
<title>Syntaxp</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____SYNTAXP">Click for Syntaxp in the Full Manual</a></h3>

<p>Attach a heuristic filter on a rule</p><p>A call of <span class="v">syntaxp</span> in the hypothesis of a <span class="v">:</span><span class="tt"><a href="ACL2____REWRITE.html">rewrite</a></span>, <span class="v">:</span><span class="tt"><a href="ACL2____DEFINITION.html">definition</a></span>, or <span class="v">:</span><span class="tt"><a href="ACL2____LINEAR.html">linear</a></span> rule is treated 
 specially, as described below.  Similar treatment is given to the evaluation 
 of a <span class="v">:</span><span class="tt"><a href="ACL2____META.html">meta</a></span> rule's hypothesis function call.</p> 
 
 <p>For example, consider the <span class="v">:</span><span class="tt"><a href="ACL2____REWRITE.html">rewrite</a></span> rule created from the 
 following formula.</p> 
 
 <pre class="code">Example:
(<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="ACL2____SYNTAXP.html">SYNTAXP</a> (<a href="COMMON-LISP____NOT.html">NOT</a> (<a href="COMMON-LISP____AND.html">AND</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> X)
                            (<a href="COMMON-LISP____EQ.html">EQ</a> (<a href="COMMON-LISP____CAR.html">CAR</a> X) 'NORM))))
         (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (LXD X)
                (LXD (NORM X)))).</pre> 
 
 <p>The <span class="v">syntaxp</span> hypothesis in this rule will allow the rule to be applied 
 to <span class="v">(lxd (trn a b))</span> but will not allow it to be applied to <span class="v">(lxd (norm
 a))</span>.</p> 
 
 <pre class="code">General Form:
(<a href="ACL2____SYNTAXP.html">SYNTAXP</a> test)</pre> 
 
 <p><span class="v">Syntaxp</span> always returns <span class="v">t</span> and so may be added as a vacuous 
 hypothesis.  However, when relieving the hypothesis, the test ``inside'' the 
 <span class="v">syntaxp</span> form is actually treated as a meta-level proposition about the 
 proposed instantiation of the rule's variables and that proposition must 
 evaluate to true (non-<span class="v">nil</span>) to ``establish'' the <span class="v">syntaxp</span> 
 hypothesis.</p> 
 
 <p>Note that the test of a <span class="v">syntaxp</span> hypothesis does not, in general, deal 
 with the meaning or semantics or values of the terms, but rather with their 
 syntactic forms.  In the example above, the <span class="v">syntaxp</span> hypothesis allows the 
 rule to be applied to every target of the form <span class="v">(lxd u)</span>, provided <span class="v">u</span> 
 is not of the form <span class="v">(norm v)</span>.  Observe that without this syntactic 
 restriction the rule above could loop, producing a sequence of increasingly 
 complex targets <span class="v">(lxd a)</span>, <span class="v">(lxd (norm a))</span>, <span class="v">(lxd (norm (norm a)))</span>, 
 etc.  An intuitive reading of the rule might be ``<span class="v">norm</span> the argument of 
 <span class="v">lxd</span> unless it has already been <span class="v">norm</span>ed.''</p> 
 
 <p>Note also that a <span class="v">syntaxp</span> hypothesis deals with the syntactic form used 
 internally by ACL2, rather than that seen by the user.  In some cases these 
 are the same, but there can be subtle differences with which the writer of a 
 <span class="v">syntaxp</span> hypothesis must be aware.  You can use <span class="v">:</span><span class="tt"><a href="ACL2____TRANS.html">trans</a></span> to 
 display this internal representation.</p> 
 
 <p>There are two types of <span class="v">syntaxp</span> hypotheses.  The simpler type may be a 
 hypothesis of a <span class="v">:</span><span class="tt"><a href="ACL2____REWRITE.html">rewrite</a></span>, <span class="v">:</span><span class="tt"><a href="ACL2____DEFINITION.html">definition</a></span>, or 
 <span class="v">:</span><span class="tt"><a href="ACL2____LINEAR.html">linear</a></span> rule provided <span class="v">test</span> contains at least one variable 
 but no free variables (see <a href="ACL2____FREE-VARIABLES.html">free-variables</a>).  In particular, <span class="v">test</span> 
 may not use <a href="ACL2____STOBJ.html">stobj</a>s; any stobj name will be treated as an ordinary 
 variable.  The case of <span class="v">:</span><span class="tt"><a href="ACL2____META.html">meta</a></span> rules is similar to the above, 
 except that it applies to the result of applying the hypothesis metafunction. 
 (Later below we will describe the second type, an <i>extended</i> <span class="v">syntaxp</span> 
 hypothesis, which may use <span class="tt"><a href="ACL2____STATE.html">state</a></span>.)</p> 
 
 <p>We illustrate the use of simple <span class="v">syntaxp</span> hypotheses by slightly 
 elaborating the example given above.  Consider a <span class="v">:</span><span class="tt"><a href="ACL2____REWRITE.html">rewrite</a></span> 
 rule:</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____AND.html">AND</a> (<a href="COMMON-LISP____RATIONALP.html">RATIONALP</a> X)
              (<a href="ACL2____SYNTAXP.html">SYNTAXP</a> (<a href="COMMON-LISP____NOT.html">NOT</a> (<a href="COMMON-LISP____AND.html">AND</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> X)
                                 (<a href="COMMON-LISP____EQ.html">EQ</a> (<a href="COMMON-LISP____CAR.html">CAR</a> X) 'NORM)))))
         (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (LXD X)
                (LXD (NORM X))))</pre> 
 
 <p>How is this rule applied to <span class="v">(lxd (trn a b))</span>?  First, we form a 
 substitution that instantiates the left-hand side of the conclusion of the 
 rule so that it is identical to the target term.  In the present case, the 
 substitution replaces <span class="v">x</span> with <span class="v">(trn a b)</span>.</p> 
 
 <pre class="code">(LXD X) ==&gt; (LXD (trn a b)).</pre> 
 
 <p>Then we backchain to establish the hypotheses, in order.  Ordinarily this 
 means that we instantiate each hypothesis with our substitution and then 
 attempt to rewrite the resulting instance to true.  Thus, in order to relieve 
 the first hypothesis above, we rewrite</p> 
 
 <pre class="code">(<a href="COMMON-LISP____RATIONALP.html">RATIONALP</a> (trn a b)).</pre> 
 
 <p>If this rewrites to true, we continue.</p> 
 
 <p>Of course, many users are aware of some exceptions to this general 
 description of the way we relieve hypotheses.  For example, if a hypothesis 
 contains a ``free-variable'' — one not bound by the current substitution 
 — we attempt to extend the substitution by searching for an instance of 
 the hypothesis among known truths.  See <a href="ACL2____FREE-VARIABLES.html">free-variables</a>.  <span class="tt"><a href="ACL2____FORCE.html">Force</a></span>d 
 hypotheses are another exception to the general rule of how hypotheses are 
 relieved.</p> 
 
 <p>Hypotheses marked with <span class="v">syntaxp</span>, as in <span class="v">(<a href="ACL2____SYNTAXP.html">syntaxp</a> test)</span>, are also 
 exceptions.  We instantiate such a hypothesis; but instead of rewriting the 
 instantiated instance, we evaluate the instantiated <span class="v">test</span>.  More 
 precisely, we evaluate <span class="v">test</span> in an environment in which its variable 
 symbols are bound to the quotations of the terms to which those variables are 
 bound in the instantiating substitution.  So in the case in point, we (in 
 essence) evaluate</p> 
 
 <pre class="code">(<a href="COMMON-LISP____NOT.html">NOT</a> (<a href="COMMON-LISP____AND.html">AND</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> '(trn a b)) (<a href="COMMON-LISP____EQ.html">EQ</a> (<a href="COMMON-LISP____CAR.html">CAR</a> '(trn a b)) 'NORM))).</pre> 
 
 <p>This clearly evaluates to <span class="v">t</span>.  When a <span class="v">syntaxp</span> test evaluates to 
 true, we consider the <span class="v">syntaxp</span> hypothesis to have been established; this 
 is sound because logically <span class="v">(<a href="ACL2____SYNTAXP.html">syntaxp</a> test)</span> is <span class="v">t</span> regardless of 
 <span class="v">test</span>.  If the test evaluates to <span class="v">nil</span> (or fails to evaluate because of 
 <a href="ACL2____GUARD.html">guard</a> violations) we act as though we cannot establish the hypothesis 
 and abandon the attempt to apply the rule; it is always sound to give up.</p> 
 
 <p>The acute reader will have noticed something odd about the form</p> 
 
 <pre class="code">(<a href="COMMON-LISP____NOT.html">NOT</a> (<a href="COMMON-LISP____AND.html">AND</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> '(trn a b)) (<a href="COMMON-LISP____EQ.html">EQ</a> (<a href="COMMON-LISP____CAR.html">CAR</a> '(trn a b)) 'NORM))).</pre> 
 
 <p>When relieving the first hypothesis, <span class="v">(<a href="COMMON-LISP____RATIONALP.html">RATIONALP</a> X)</span>, we substituted 
 <span class="v">(trn a b)</span> for <span class="v">X</span>; but when relieving the second hypothesis, 
 <span class="v">(<a href="ACL2____SYNTAXP.html">SYNTAXP</a> (<a href="COMMON-LISP____NOT.html">NOT</a> (<a href="COMMON-LISP____AND.html">AND</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> X) (<a href="COMMON-LISP____EQ.html">EQ</a> (<a href="COMMON-LISP____CAR.html">CAR</a> X) 'NORM))))</span>, we substituted the 
 quotation of <span class="v">(trn a b)</span> for <span class="v">X</span>.  Why the difference?  Remember that in 
 the first hypothesis we are talking about the value of <span class="v">(trn a b)</span> — 
 is it rational — while in the second one we are talking about its 
 syntactic form.  Remember also that Lisp, and hence ACL2, evaluates the 
 arguments to a function before applying the function to the resulting 
 values. Thus, we are asking ``Is the list <span class="v">(trn a b)</span> a <span class="tt"><a href="COMMON-LISP____CONSP.html">consp</a></span> and 
 if so, is its <span class="tt"><a href="COMMON-LISP____CAR.html">car</a></span> the symbol <span class="v">NORM</span>?''  The <span class="v">quote</span>s on both 
 <span class="v">(trn a b)</span> and <span class="v">NORM</span> are therefore necessary.  One can verify this by 
 defining <span class="v">trn</span> to be, say <span class="tt"><a href="COMMON-LISP____CONS.html">cons</a></span>, and then evaluating forms such 
 as</p> 
 
 <pre class="code">(<a href="COMMON-LISP____AND.html">AND</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> '(trn a b)) (<a href="COMMON-LISP____EQ.html">EQ</a> (<a href="COMMON-LISP____CAR.html">CAR</a> '(trn a b)) 'NORM))
(<a href="COMMON-LISP____AND.html">AND</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> (trn a b)) (<a href="COMMON-LISP____EQ.html">EQ</a> (<a href="COMMON-LISP____CAR.html">CAR</a> (trn a b)) NORM))
(<a href="COMMON-LISP____AND.html">AND</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> (trn 'a 'b)) (<a href="COMMON-LISP____EQ.html">EQ</a> (<a href="COMMON-LISP____CAR.html">CAR</a> (trn 'a 'b)) NORM))
(<a href="COMMON-LISP____AND.html">AND</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> '(trn a b)) (<a href="COMMON-LISP____EQ.html">EQ</a> '(<a href="COMMON-LISP____CAR.html">CAR</a> (trn a b)) ''NORM))</pre> 
 
 <p>at the top-level ACL2 prompt.</p> 
 
 <p>See <a href="ACL2____SYNTAXP-EXAMPLES.html">syntaxp-examples</a> for more examples of the use of 
 <span class="v">syntaxp</span>.</p> 
 
 <p>An extended <span class="v">syntaxp</span> hypothesis is similar to the simple type described 
 above, but it uses two additional variables, <span class="v">mfc</span> and <span class="v">state</span>, which 
 must not be bound by the left hand side or an earlier hypothesis of the rule. 
 They must be the last two variables mentioned by <span class="v">form</span>; first <span class="v">mfc</span>, 
 then <span class="v">state</span>.  These two variables give access to the functions 
 <span class="v">mfc-</span>xxx; see <a href="ACL2____EXTENDED-METAFUNCTIONS.html">extended-metafunctions</a>.  As described there, <span class="v">mfc</span> 
 is bound to the so-called metafunction-context and <span class="v">state</span> to ACL2's <span class="tt"><a href="ACL2____STATE.html">state</a></span>.  See <a href="ACL2____SYNTAXP-EXAMPLES.html">syntaxp-examples</a> for an example of the use of these 
 extended <span class="v">syntaxp</span> hypotheses.</p> 
 
 <p>We conclude with an example illustrating an error that may occur if you 
 forget that a <span class="v">syntaxp</span> hypothesis will be evaluated in an environment 
 where variables are bound to syntactic terms, not to values.  Consider the 
 following <a href="ACL2____STOBJ.html">stobj</a> introduction (see <a href="ACL2____DEFSTOBJ.html">defstobj</a>).</p> 
 
 <pre class="code">(<a href="ACL2____DEFSTOBJ.html">defstobj</a> st
  (fld1 :type (signed-byte 3) :initially 0)
  fld2)</pre> 
 
 <p>The following <span class="v">syntaxp</span> hypothesis is ill-formed for evaluation. 
 Indeed, ACL2 causes an error because it anticipates that when trying to 
 relieve the <span class="v">syntaxp</span> hypothesis of this rule, ACL2 would be evaluating 
 <span class="v">(fld1 st)</span> where <span class="v">st</span> is bound to a term, not to an actual <span class="v">stobj</span> 
 as required by the function <span class="v">fld1</span>.  The error message is intended to 
 explain this problem.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="ACL2____DEFTHM.html">defthm</a> bad
         (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____SYNTAXP.html">syntaxp</a> (<a href="ACL2____QUOTEP.html">quotep</a> (fld1 st)))
                  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____STP.html">stp</a> st)
                         (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> st)
                              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> st) 2)
                              (fld1p (<a href="COMMON-LISP____CAR.html">car</a> st))))))

ACL2 Error in ( DEFTHM BAD ...):  The form (<a href="ACL2____QUOTEP.html">QUOTEP</a> (FLD1 ST)), from
a SYNTAXP hypothesis, is not suitable for evaluation in an environment
where its variables are bound to terms.  See :DOC SYNTAXP.  Here is
further explanation:
     The form ST is being used, as an argument to a call of FLD1, where
the single-threaded object of that name is required.  But in the current
context, the only declared stobj name is STATE.  Note:  this error
occurred in the context (FLD1 ST).

Summary
Form:  ( DEFTHM BAD ...)
Rules: NIL
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)

ACL2 Error in ( DEFTHM BAD ...):  See :DOC failure.

******** FAILED ********
ACL2 !&gt;</pre> 
 
 <p>Presumably the intention was to rewrite the term <span class="v">(<a href="ACL2____STP.html">stp</a> st)</span> when the 
 <span class="v">fld1</span> component of <span class="v">st</span> is seen to be an explicit constant.  As 
 explained elsewhere (see <a href="ACL2____FREE-VARIABLES.html">free-variables</a>), we can obtain the result of 
 rewriting <span class="v">(fld1 st)</span> by binding a fresh variable to that term using 
 <span class="v">EQUAL</span>, as follows.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> good
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> f (fld1 st))
                (<a href="ACL2____SYNTAXP.html">syntaxp</a> (<a href="ACL2____QUOTEP.html">quotep</a> f)))
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____STP.html">stp</a> st)
                  (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> st)
                       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> st) 2)
                       (fld1p (<a href="COMMON-LISP____CAR.html">car</a> st))))))</pre> 
 
 <p>The event above is admitted by ACL2.  We can see it in action by disabling 
 the definition of <span class="v">stp</span> so that only the rule above, <span class="v">good</span>, is 
 available for reasoning about <span class="v">stp</span>.</p> 
 
 <pre class="code">(<a href="ACL2____IN-THEORY.html">in-theory</a> (<a href="ACL2____DISABLE.html">disable</a> stp))</pre> 
 
 <p>Then the proof fails for the following, because the <span class="v">syntaxp</span> hypothesis 
 of the rule, <span class="v">good</span>, fails: <span class="v">(<a href="ACL2____QUOTEP.html">quotep</a> f)</span> evaluates to <span class="v">nil</span> when 
 <span class="v">f</span> is bound to the term <span class="v">(fld1 st)</span>.</p> 
 
 <pre class="code">(<a href="ACL2____THM.html">thm</a> (<a href="ACL2____STP.html">stp</a> st))</pre> 
 
 <p>However, the proof succeeds for the next form, as we explain below.</p> 
 
 <pre class="code">(<a href="ACL2____THM.html">thm</a> (<a href="ACL2____STP.html">stp</a> (<a href="COMMON-LISP____LIST.html">list</a> 3 rest)))</pre> 
 
 <p>Consider what happens in that case when rule <span class="v">good</span> is applied to the 
 term <span class="v">(<a href="ACL2____STP.html">stp</a> (<a href="COMMON-LISP____LIST.html">list</a> 3 rest))</span>.  (See <a href="ACL2____FREE-VARIABLES.html">free-variables</a> for relevant 
 background.)  The first hypothesis of <span class="v">good</span> binds the variable <span class="v">f</span> to 
 the result of rewriting <span class="v">(fld1 st)</span>, where <span class="v">st</span> is bound to the 
 (internal form of) the term <span class="v">(<a href="COMMON-LISP____LIST.html">list</a> 3 rest)</span> — and that result is 
 clearly the term, <span class="v">'3</span>.  Then the <span class="v">syntaxp</span> hypothesis is successfully 
 relieved, because the evaluation of <span class="v">(<a href="ACL2____QUOTEP.html">quotep</a> f)</span> returns <span class="v">t</span> in the 
 environment that binds <span class="v">f</span> to <span class="v">'3</span>.</p>
</body>
</html>
