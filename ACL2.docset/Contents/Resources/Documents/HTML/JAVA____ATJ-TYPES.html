<html>
<head>
<meta charset="UTF-8">
<title>Atj-types</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=JAVA____ATJ-TYPES">Click for Atj-types in the Full Manual</a></h3>

<p>Types used by ATJ for code generation.</p><p>In order to make the generated Java code more efficient and idiomatic, 
     ATJ uses types that correspond to both ACL2 predicates and Java types. 
     These ATJ types are used only when 
     <span class="v">:deep</span> is <span class="v">nil</span> and <span class="v">:guards</span> is <span class="v">t</span>.</p><p>For example, consider a unary ACL2 function 
     whose guard is or implies <span class="tt"><a href="COMMON-LISP____STRINGP.html">stringp</a></span>, 
     and the corresponding Java method generated by ATJ. 
     Since under the assumption of guard satisfaction 
     this method will always be called 
     with an <span class="v">Acl2Value</span> that is an <span class="v">Acl2String</span>, 
     the method can use <span class="v">Acl2String</span> instead of <span class="v">Acl2Value</span> 
     as the type of the argument. 
     Furthermore, suppose that, under the guard, 
     the ACL2 function always returns <span class="tt"><a href="COMMON-LISP____INTEGERP.html">integerp</a></span>. 
     Then the Java method can use <span class="v">Acl2Integer</span> instead of <span class="v">Acl2Value</span> 
     as the return type. 
     In other words, 
     narrower types than the one for all ACL2 values (i.e. <span class="v">Acl2Value</span>) 
     can be used for the argument and result of this Java method. 
     This narrowing is also used to generate methods 
     that operate on Java primitive values and primitive arrays.</p><p>In general, establishing the narrower input and output types 
     for a Java method generated from an ACL2 function 
     may involve arbitrarily hard theorem proving: 
     (i) proving that the guard implies that the inputs of the ACL2 function 
     satisfy the ACL2 predicates corresponding to the input types, and 
     (ii) proving that the guard implies that the outputs of the ACL2 function 
     satisfy the ACL2 predicates corresponding to the output types; 
     the number of outputs of an ACL2 function is greater than 1 
     if the function returns an <span class="tt"><a href="ACL2____MV.html">mv</a></span> value; 
     otherwise the number of outputs is 1. 
     Since we do not want ATJ to attempt any theorem proving, 
     we provide a macro <span class="tt"><a href="JAVA____ATJ-MAIN-FUNCTION-TYPE.html">atj-main-function-type</a></span> 
     to perform those theorem proving tasks under user control 
     and to record the input and output types of ACL2 functions in a table, 
     and we have ATJ look up types in this table. 
     Note that these types are different from 
     ACL2's built-in types used for typeset reasoning, 
     ACL2's tau system types, 
     and our ACL2 model of Java types.</p><p>With a table of the types of the involved ACL2 functions at hand 
     (the table being constructed via calls of <span class="tt"><a href="JAVA____ATJ-MAIN-FUNCTION-TYPE.html">atj-main-function-type</a></span>), 
     ATJ performs a type analysis of the ACL2 terms in function bodies 
     before translating them to Java; 
     this analysis is part of ATJ's pre-translation steps. 
     Generally speaking, 
     ATJ compares the type inferred for an actual argument of a function 
     (this type is inferred by analyzing terms recursively) 
     with the type of the corresponding formal argument of the function 
     (this type is retrieved from the table of function types): 
     if they differ, ATJ inserts code to convert from the former to the latter, 
     unless the former is a subtype of the latter in Java. 
     The conversion may be a type cast, 
     e.g. to convert from <span class="v">Acl2Value</span> to <span class="v">Acl2String</span>; 
     the cast is guaranteed to succeed, 
     assuming that the ACL2 guards are verified. 
     The conversion may also be a change in representation in other cases.</p><p>The ATJ type information stored in the table 
     determines/specifies the input and output types of the Java methods 
     generated for the corresponding ACL2 functions. 
     In general, there may be different possible choices of types 
     for certain ACL2 functions: 
     different choices will lead to different Java code. 
     For instance, 
     if a function's guard implies that an argument satisfies <span class="tt"><a href="COMMON-LISP____INTEGERP.html">integerp</a></span>, 
     that function's argument can be assigned 
     a type corresponding to <span class="v">Acl2Integer</span>, 
     or a type corresponding to <span class="v">Acl2Rational</span>. 
     The types of these Java methods are part of the ``API'' 
     that the generated Java code provides to external Java code.</p><p>In some cases, ACL2 functions return outputs of narrower types 
     when given inputs of narrower types. 
     Prime examples are the arithmetic operations 
     <span class="tt"><a href="ACL2____BINARY-_B2.html">binary-+</a></span>, <span class="tt"><a href="ACL2____BINARY-_A2.html">binary-*</a></span>, and <span class="tt"><a href="ACL2____UNARY--.html">unary--</a></span>. 
     All of their input and output types are 
     the type corresponding to <span class="tt"><a href="ACL2____ACL2-NUMBERP.html">ACL2-numberp</a></span>, 
     based on their guards: 
     this can be recorded via <span class="tt"><a href="JAVA____ATJ-MAIN-FUNCTION-TYPE.html">atj-main-function-type</a></span>. 
     Based on these types, the corresponding Java methods 
     will take and return <span class="v">Acl2Number</span> values. 
     Now, consider a unary function <span class="v">f</span> that takes integers 
     (i.e. it has a recorded input type corresponding to <span class="tt"><a href="COMMON-LISP____INTEGERP.html">integerp</a></span>), 
     and a term <span class="v">(f (<a href="ACL2____BINARY-_B2.html">binary-+</a> &lt;i&gt; &lt;j&gt;))</span>, 
     where <span class="v">&lt;i&gt;</span> and <span class="v">&lt;j&gt;</span> are integer-valued terms. 
     When this term is translated to Java, 
     a cast (from <span class="v">Acl2Number</span>) to <span class="v">Acl2Integer</span> will be inserted 
     around the call of the method corresponding to <span class="tt"><a href="ACL2____BINARY-_B2.html">binary-+</a></span>, 
     in order to fit the <span class="v">Acl2Integer</span> type of 
     the argument of the method corresponding to <span class="v">f</span>.</p><p>However, due to well-known closure properties, 
     <span class="tt"><a href="ACL2____BINARY-_B2.html">binary-+</a></span>, like <span class="tt"><a href="ACL2____BINARY-_B2.html">binary-+</a></span> and <span class="tt"><a href="ACL2____UNARY--.html">unary--</a></span>, 
     maps <span class="tt"><a href="COMMON-LISP____RATIONALP.html">rationalp</a></span> inputs to <span class="tt"><a href="COMMON-LISP____RATIONALP.html">rationalp</a></span> outputs, 
     and <span class="tt"><a href="COMMON-LISP____INTEGERP.html">integerp</a></span> inputs to <span class="tt"><a href="COMMON-LISP____INTEGERP.html">integerp</a></span> outputs. 
     This means that we could generate three overloaded methods 
     for each such ACL2 function: 
     one with <span class="v">Acl2Number</span> argument and result types (as above), 
     one with <span class="v">Acl2Rational</span> argument and result types, and 
     one with <span class="v">Acl2Integer</span> argument and result types. 
     This will make the cast in the example above unnecessary: 
     since the Java expressions that translate <span class="v">&lt;i&gt;</span> and <span class="v">&lt;j&gt;</span> 
     statically have type <span class="v">Acl2Integer</span>, 
     the Java compiler will pick the most specific overloaded method, 
     which returns <span class="v">Acl2Integer</span>.</p><p>This is not limited to primitive arithmetic operations. 
     Any ACL2 function may have the property of 
     returning outputs of narrower types when given inputs of narrower types. 
     Even if the output types are not narrower, 
     the internal computations may be more efficient on narrower inputs, 
     e.g. the cast in the example above can be avoided 
     when that call of <span class="v">f</span> is part of some function <span class="v">g</span> 
     that may not even return numbers (e.g. it may return booleans).</p><p>Thus, we provide another macro, <span class="tt"><a href="JAVA____ATJ-OTHER-FUNCTION-TYPE.html">atj-other-function-type</a></span>, 
     to record additional input and output types for ACL2 functions. 
     ATJ makes use of these additional types 
     to generate multiple overloaded methods for single ACL2 functions. 
     In general, via these two macros, each ACL2 function may have 
     more than one input/output type associated with it 
     (where an input/output type is a full function type, 
     consisting of zero or more input types and one or more output types): 
     (i) a primary (`main') input/output type, 
     provable from the guards as described above; and 
     (ii) zero or more secondary (`other') input/output types. 
     The secondary input types are narrower than the primary ones, 
     but do not have to be provable from the guard; 
     what must be proved, 
     via a theorem generated by <span class="tt"><a href="JAVA____ATJ-OTHER-FUNCTION-TYPE.html">atj-other-function-type</a></span>, 
     is that the guard and the input types imply the output type.</p><p>The above is just an overview of the use of types by ATJ. 
     More details are in the documentation of their implementation 
     and of the code generation functions that use them.</p>
</body>
</html>
