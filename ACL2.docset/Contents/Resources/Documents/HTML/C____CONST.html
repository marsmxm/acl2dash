<html>
<head>
<meta charset="UTF-8">
<title>Const</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=C____CONST">Click for Const in the Full Manual</a></h3>

<p>Fixtype of constants [C:6.4.4].</p><p>This is a tagged union type, introduced by <a href="FTY____DEFTAGSUM.html">fty::deftagsum</a>.</p> 
<h5>Member Tags → Types</h5><dl>
<dt>
<span class="tt">:int</span> → <a href="C____CONST-INT.html">const-int</a>
</dt> 
<dt>
<span class="tt">:float</span> → <a href="C____CONST-FLOAT.html">const-float</a>
</dt> 
<dt>
<span class="tt">:enum</span> → <a href="C____CONST-ENUM.html">const-enum</a>
</dt> 
<dt>
<span class="tt">:char</span> → <a href="C____CONST-CHAR.html">const-char</a>
</dt> 
</dl> 
<p>For now we only capture integer and enumeration constants, 
     but we include placeholders for floating and character constants.</p><p>The C grammar for enumeration constants [C:6.4.4.3/1] [C:6.4.4/1] 
     is actually ambiguous in expressions [C:6.5.1/1]: 
     an identifier that appears where an expression is expected 
     could be either a primary expression identifier (e.g. denoting an object) 
     or an enumeration constant. 
     The two cases cannot be disambiguated during parsing, 
     as they need to take into account static semantic constraints.</p><p>Despite this ambiguity, 
     for now we keep enumeration constants in this abstract syntax. 
     In a future extension of our formalization of C, 
     concrete syntax could be parsed 
     into abstract syntax without enumeration constants, 
     and then the static semantics could turn some identifier expressions 
     into enumeration constants, 
     according to the static semantics constraints. 
     Alternatively, in the future we may remove enumeration constants from here, 
     and just use identifiers in expressions, 
     which may denote either enumeration constants or other things.</p>
</body>
</html>
