<html>
<head>
<meta charset="UTF-8">
<title>Defbytetype</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____DEFBYTETYPE">Click for Defbytetype in the Full Manual</a></h3>

<p>A macro for defining integer subrange types.</p><p>The "byte types" defined by DEFBYTETYPE correspond to the Common 
Lisp concept of a "byte", that is, an integer with a fixed number of bits. 
We extend the Common Lisp concept to allow signed bytes.</p> 
 
<p>Example:</p> 
 
<pre class="code">(<a href="ACL2____DEFBYTETYPE.html">DEFBYTETYPE</a> WORD 32 :SIGNED)</pre> 
 
<p>Defines a new integer type of 32-bit signed integers, recognized by 
<span class="v">(WORD-P i)</span>.</p> 
 
<p>General Form:</p> 
 
<pre class="code">(<a href="ACL2____DEFBYTETYPE.html">DEFBYTETYPE</a> name size s/u &amp;key saturating-coercion)</pre> 
 
<p>The argument name should be a symbol, size should be a constant 
expression (suitable for DEFCONST) for a positive integer, s/u is 
either :SIGNED or :UNSIGNED, saturating-coercion should be a symbol (default 
NIL).</p> 
 
<p>Each data type defined by DEFBYTETYPE produces a number of events:</p> 
 
<ul> 
 
<li>A constant <span class="v">*&lt;name&gt;-MAX*</span>, set to the maximum value of the type.</li> 
 
<li>A constant <span class="v">*&lt;name&gt;-MIN*</span>, set to the minimum value of the type.</li> 
 
<li>A predicate, <span class="v">(&lt;pred&gt; x)</span>, that recognizes either <span class="v">(<a href="ACL2____UNSIGNED-BYTE-P.html">UNSIGNED-BYTE-P</a>
size x)</span> or <span class="v">(<a href="ACL2____SIGNED-BYTE-P.html">SIGNED-BYTE-P</a> size x)</span>, depending on whether s/u 
was :UNSIGNED or :SIGNED respectively. This predicate is DISABLED.  The name of 
the predicate will be <span class="v">&lt;name&gt;-p</span>.</li> 
 
<li>A coercion function, <span class="v">(&lt;name&gt; i)</span>, that coerces any object <span class="v">i</span> to the 
correct type by LOGHEAD and LOGEXT for unsigned and signed integers 
respectively.  This function is DISABLED.</li> 
 
<li>A lemma showing that the coercion function actually does the correct 
coercion.</li> 
 
<li>A lemma that reduces calls of the coercion function when its argument 
satisfies the predicate.</li> 
 
<li>A forward chaining lemma from the predicate to the appropriate type 
information.</li> 
 
<li>If :SATURATING-COERCION is specified, the value of this keyword argument 
should be a symbol.  A function of this name will be defined to provide a 
saturating coercion.  `Saturation' in this context means that values outside of 
the legal range for the type are coerced to the type by setting them to the 
nearest legal value, which will be either the minimum or maximum value of the 
type. This function will be DISABLEd, and a lemma will be generated that proves 
that this function returns the correct type.  Note that 
the :SATURATING-COERCION option is only valid for :SIGNED types.</li> 
 
<li>A theory named <span class="v">&lt;name&gt;</span>-THEORY that includes the lemmas and the 
DEFUN-TYPE/EXEC-THEORY of the functions.</li> 
 
</ul> 
 

</body>
</html>
