<html>
<head>
<meta charset="UTF-8">
<title>Vl-patternkey-ambiguity</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=VL____VL-PATTERNKEY-AMBIGUITY">Click for Vl-patternkey-ambiguity in the Full Manual</a></h3>

<p>Notes about our handling of <a href="VL____VL-PATTERNKEY.html">vl-patternkey</a>s.</p><p>The keys in assignment patterns can be expressions (which should 
resolve to array indexes, for array patterns), structure member names, type 
names, or the special keyword <span class="v">default</span>.  Here are some examples:</p> 
 
<pre class="code">'{ 0: a, 1: b, 2: c, default: 0 }    // assign to some array indices, default others...
'{ foo: 3, bar: 5 }                  // assign to struct members by name (maybe)
'{ integer: 5, opcode_t: 7 }         // assign to struct members by type (maybe)</pre> 
 
<p>Simple names are particularly ambiguous here.  For instance, a name like 
<span class="v">place</span> might perhaps refer to any of (1) a parameter value to be used as an 
array index, as in:</p> 
 
<pre class="code">int arr [3:0];
parameter place = 0;
assign arr = '{place: 3, default: 0 };</pre> 
 
<p>or (2) a structure member name, as in:</p> 
 
<pre class="code">typedef struct { int place; int value; } slot_t;
slot_t s = '{ place: 3, value: 4 };</pre> 
 
<p>or (3) the name of some type, as in:</p> 
 
<pre class="code">typedef logic [3:0] place;
typedef struct { place src; place dest; int data; } msg_t;
msg_t m = '{ place: 0, data: 0 };</pre> 
 
<p>This ambiguity is problematic in early parts of <a href="VL____ANNOTATE.html">annotate</a>, such as 
<a href="VL____SHADOWCHECK.html">shadowcheck</a>, where we want to check that, e.g., wires are used declared 
before they are used.  Here, because of type parameters, we might not be able 
to tell the names of a structure's members until elaboration time.  For 
example, suppose there is no type named <span class="v">place</span> and that, in some module, we 
are have a type parameter <span class="v">mytype_t</span> and an assignment like:</p> 
 
<pre class="code">mytype_t foo = '{ place: 0, ... }</pre> 
 
<p>In this case, we won't know whether <span class="v">place</span> is the name of a structure 
field of <span class="v">mytype_t</span> until elaboration provides us with a definition for 
<span class="v">mytype_t</span>.  If <span class="v">mytype_t</span> ends up having a member named <span class="v">place</span>, then 
it's fine for <span class="v">place</span> not to be declared here.  But if it doesn't have such 
a member, then the only way this makes sense is for <span class="v">place</span> to be the name 
of some parameter that's being used as an array index, in which case <span class="v">place</span> 
needs to be declared here.</p> 
 
<p>Rather than further intertwine shadowcheck and elaborate, our approach is to 
avoid this ambiguity by require that all simple names used in assignment 
pattern keys <b>must</b> be either the names of types or structure members. 
Although NCVerilog doesn't impose this restriction, it appears that our 
behavior matches that of VCS.  For instance, when we submit the following to 
VCS J-2014.12-SP3-1:</p> 
 
<pre class="code">module foo1 ;
  int arr [3:0];
  parameter place = 0;
  assign arr = '{place: 3, default: 0 };
endmodule</pre> 
 
<p>we find that it reports the following error:</p> 
 
<pre class="code">Error-[IAP] Illegal assignment pattern
test.sv, 5
foo1, "place:3"
  Assignment pattern is illegal due to: Assignment Pattern with named fields 
  cannot be assigned to a non-structure target</pre> 
 
<h3>Implementation notes, disambiguation strategy</h3> 
 
<p>Upon parsing a <a href="VL____VL-PATTERNKEY.html">vl-patternkey</a> there are four possibilities:</p> 
 
<ol> 
<li>It is the <span class="v">default</span> keyword, which is no problem.</li> 
<li>It is unambiguously an index expression, e.g., <span class="v">3 + 5</span>.</li> 
<li>It is unambiguously a built-in type expression, e.g., <span class="v">integer</span>.</li> 
<li>It is ambiguously a simple name like <span class="v">foo</span>, which might be a structure 
member, type name, or parameter name.</li> 
</ol> 
 
<p>To reduce insanity we are going to assume that any such <span class="v">foo</span> must not 
be a parameter.</p> 
 
<p>At parse time, after dealing with <span class="v">default</span>, we try to parse an 
expression and then (to account for core type names like <span class="v">integer</span> which 
aren't expressions) fall back to trying to parse a type.  If we get anything 
other than a simple name then it's already unambiguous.</p> 
 
<p>On the other hand, if we get an expression which is a simple name, then we 
will <b>immediately convert it to a structmem</b> instead of an <b>expr</b> 
<a href="VL____VL-PATTERNKEY.html">vl-patternkey</a>.  Note that we don't yet know whether it's a structure 
name or a type name; structmems will need to be further disambiguated before 
we're sure they aren't types.</p> 
 
<p>During shadowcheck, we have enough information to tell whether a structmem 
is actually a type.  We can then check for tricky shadowing as per usual.  Type 
disambiguation can then make the final conversion of structmems to types as 
necessary.</p> 
 
<p>Later on, in svex conversion: if we encounter a struct pattern, we should 
probably also explicitly check that any type keys such as <span class="v">foo_t</span> are NOT 
also the names of structure members.  If so, there might be confusion about 
what we are assigning to.  We might want this to be smart enough to handle 
things like <span class="v">struct mystruct { foo foo; bar bar; }</span>, or maybe those aren't 
handled by other Verilog tools anyway.</p>
</body>
</html>
