<html>
<head>
<meta charset="UTF-8">
<title>Solution-to-ACL2-quantifier-exercise-2</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____SOLUTION-TO-ACL2-QUANTIFIER-EXERCISE-2">Click for Solution-to-ACL2-quantifier-exercise-2 in the Full Manual</a></h3>

<p>A solution to <span class="tt"><a href="ACL2____QUANTIFIER-TUTORIAL.html">quantifier-tutorial</a></span> Exercise 2</p><p> In <a href="ACL2____QUANTIFIER-TUTORIAL.html">quantifier-tutorial</a> exercise 2, it asks if we can prove 
  or disprove the conjecture below.</p> 
 
  <blockquote>
<b>Exercise 2</b>. If there is an ACL2 object <span class="v">x</span> which 
  satisfies <span class="v">M</span>, then there exists a least ACL2 object <span class="v">y</span> that satisfies 
  <span class="v">M</span>.</blockquote> 
 
  <p>This hypothesis can be disproved. Here is one possible solution, provided 
  by Yan Peng..</p> 
 
  <pre class="code">(<a href="COMMON-LISP____IN-PACKAGE.html">in-package</a> "ACL2")
(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "misc/total-order" :dir :system)

;; This hypothesis can be disproved.
;; The intuition: find a function M that can be satisfied and does not have a
;; minimal object that satisfies it.

;; For example, if M is evenp, then for any ACL2 object that satisfies M, one
;; can always construct a smaller object by subtracting 2 from it, which also
;; satisfies M.

;; Instead of using defstub, we provide an implementation for M which calls
;; evenp.
(<a href="COMMON-LISP____DEFUN.html">defun</a> M (x) (<a href="COMMON-LISP____EVENP.html">evenp</a> x))

;; We prove a helper lemma that says if x satisfies M, then (<a href="COMMON-LISP____-.html">-</a> x 2) also
;; satisfies M and it is a smaller object.
(<a href="ACL2____DEFTHM.html">defthm</a> -2-satisfies-M-and-&lt;&lt;
  (<a href="ACL2____IMPLIES.html">implies</a> (M x)
           (<a href="COMMON-LISP____AND.html">and</a> (M (<a href="COMMON-LISP____-.html">-</a> x 2)) (<a href="ACL2_____C3_C3.html">&lt;&lt;</a> (<a href="COMMON-LISP____-.html">-</a> x 2) x)))
  :hints (("Goal"
           :in-theory (<a href="ACL2____ENABLE.html">enable</a> &lt;&lt; lexorder alphorder))))
(<a href="ACL2____IN-THEORY.html">in-theory</a> (<a href="ACL2____DISABLE.html">disable</a> evenp M))

(<a href="ACL2____DEFUN-SK.html">defun-sk</a> some-M () (<a href="ACL2____EXISTS.html">exists</a> x (M x)))
(<a href="ACL2____IN-THEORY.html">in-theory</a> (<a href="ACL2____DISABLE.html">disable</a> some-M some-M-suff))

;; We prove M can be satisfied by providing a witness 0.
(<a href="ACL2____DEFTHM.html">defthm</a> some-M-lemma
  (some-M)
  :hints (("Goal" :use ((:instance some-M-suff (x 0))))))

;; We negate none-below-2
(<a href="ACL2____DEFUN-SK.html">defun-sk</a> exists-below (y)
  (<a href="ACL2____EXISTS.html">exists</a> r (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2_____C3_C3.html">&lt;&lt;</a> r y) (M r))))
(<a href="ACL2____IN-THEORY.html">in-theory</a> (<a href="ACL2____DISABLE.html">disable</a> exists-below exists-below-suff))

;; We negate min-M2
(<a href="ACL2____DEFUN-SK.html">defun-sk</a> not-min-M () (<a href="ACL2____FORALL.html">forall</a> y (<a href="ACL2____IMPLIES.html">implies</a> (M y) (exists-below y))))
(<a href="ACL2____IN-THEORY.html">in-theory</a> (<a href="ACL2____DISABLE.html">disable</a> not-min-M not-min-M-necc))

;; We prove that forall y, if y satisfies M, then there exists another smaller
;; object that satisfies M.
(<a href="ACL2____DEFTHM.html">defthm</a> not-min-M-lemma
  (not-min-M)
  :hints (("Goal"
           :use (;; The definition of not-min-M provides a witness
                 ;; (not-min-M-witness) that satisfies M but doesn't satisfy
                 ;; exists-below.
                 (:instance (:definition not-min-M))
                 ;; By instantiating exists-below-suff, we provide a smaller
                 ;; object r:(<a href="COMMON-LISP____-.html">-</a> (not-min-M-witness) 2) than
                 ;; y:(not-min-M-witness), and satisfies M. This makes
                 ;; (not-min-M-witness) vacuous, allowing us to prove the
                 ;; forall.
                 (:instance exists-below-suff
                            (r (<a href="COMMON-LISP____-.html">-</a> (not-min-M-witness) 2))
                            (y (not-min-M-witness)))))))

;; We prove both some-M and not-min-M
(<a href="ACL2____DEFTHM.html">defthm</a> |minimal does not exist|
  (<a href="COMMON-LISP____AND.html">and</a> (some-M) (not-min-M)))</pre>
</body>
</html>
