<html>
<head>
<meta charset="UTF-8">
<title>Syntaxp-examples</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____SYNTAXP-EXAMPLES">Click for Syntaxp-examples in the Full Manual</a></h3>

<p>Examples pertaining to syntaxp hypotheses</p><p>See <a href="ACL2____SYNTAXP.html">syntaxp</a> for a basic discussion of the use of 
 <span class="v">syntaxp</span> to control rewriting.</p> 
 
 <p>A common syntactic restriction is</p> 
 
 <pre class="code">(<a href="ACL2____SYNTAXP.html">SYNTAXP</a> (<a href="COMMON-LISP____AND.html">AND</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> X) (<a href="COMMON-LISP____EQ.html">EQ</a> (<a href="COMMON-LISP____CAR.html">CAR</a> X) 'QUOTE)))</pre> 
 
 <p>or, equivalently,</p> 
 
 <pre class="code">(<a href="ACL2____SYNTAXP.html">SYNTAXP</a> (<a href="ACL2____QUOTEP.html">QUOTEP</a> X)).</pre> 
 
 <p>A rule with such a hypothesis can be applied only if <span class="v">x</span> is bound to a 
 specific constant.  Thus, if <span class="v">x</span> is <span class="v">23</span> (which is actually represented 
 internally as <span class="v">(<a href="COMMON-LISP____QUOTE.html">quote</a> 23)</span>), the test evaluates to <span class="v">t</span>; but if <span class="v">x</span> 
 prints as <span class="v">(<a href="COMMON-LISP_____B2.html">+</a> 11 12)</span> then the test evaluates to <span class="v">nil</span> (because <span class="v">(<a href="COMMON-LISP____CAR.html">car</a>
 x)</span> is the symbol <span class="tt"><a href="ACL2____BINARY-_B2.html">binary-+</a></span>).  We see the use of this restriction in 
 the rule</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SYNTAXP.html">syntaxp</a> (<a href="ACL2____QUOTEP.html">quotep</a> c))
              (<a href="ACL2____SYNTAXP.html">syntaxp</a> (<a href="ACL2____QUOTEP.html">quotep</a> d)))
         (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP_____B2.html">+</a> c d x)
                (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP_____B2.html">+</a> c d) x))).</pre> 
 
 <p>If <span class="v">c</span> and <span class="v">d</span> are constants, then the <span class="tt"><a href="ACL2____EXECUTABLE-COUNTERPART.html">executable-counterpart</a></span> 
 of <span class="tt"><a href="ACL2____BINARY-_B2.html">binary-+</a></span> will evaluate the sum of <span class="v">c</span> and <span class="v">d</span>.  For instance, 
 under the influence of this rule</p> 
 
 <pre class="code">(<a href="COMMON-LISP_____B2.html">+</a> 11 12 foo)</pre> 
 
 <p>rewrites to</p> 
 
 <pre class="code">(<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP_____B2.html">+</a> 11 12) foo)</pre> 
 
 <p>which in turn rewrites to <span class="v">(<a href="COMMON-LISP_____B2.html">+</a> 23 foo)</span>.  Without the syntactic 
 restriction, this rule would loop with the built-in rules 
 <span class="v">ASSOCIATIVITY-OF-+</span> or <span class="v">COMMUTATIVITY-OF-+</span>.</p> 
 
 <p>We here recommend that the reader try the affects of entering expressions 
 such as the following at the top level ACL2 prompt.</p> 
 
 <pre class="code">(<a href="COMMON-LISP_____B2.html">+</a> 11 23)
(<a href="COMMON-LISP_____B2.html">+</a> '11 23)
(<a href="COMMON-LISP_____B2.html">+</a> '11 '23)
(<a href="COMMON-LISP_____B2.html">+</a> ''11 ''23)
:trans (<a href="COMMON-LISP_____B2.html">+</a> 11 23)
:trans (<a href="COMMON-LISP_____B2.html">+</a> '11 23)
:trans (<a href="COMMON-LISP_____B2.html">+</a> ''11 23)
:trans (<a href="COMMON-LISP_____B2.html">+</a> c d x)
:trans (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP_____B2.html">+</a> c d) x)</pre> 
 
 <p>We also recommend that the reader verify our claim above about looping by 
 trying the affect of each of the following rules individually.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> good
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SYNTAXP.html">syntaxp</a> (<a href="ACL2____QUOTEP.html">quotep</a> c))
                 (<a href="ACL2____SYNTAXP.html">syntaxp</a> (<a href="ACL2____QUOTEP.html">quotep</a> d)))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP_____B2.html">+</a> c d x)
                   (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP_____B2.html">+</a> c d) x))))

(<a href="ACL2____DEFTHM.html">defthm</a> bad
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____ACL2-NUMBERP.html">acl2-numberp</a> c)
                 (<a href="ACL2____ACL2-NUMBERP.html">acl2-numberp</a> d))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP_____B2.html">+</a> c d x)
                   (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP_____B2.html">+</a> c d) x))))</pre> 
 
 <p>on (the false) theorems:</p> 
 
 <pre class="code">(<a href="ACL2____THM.html">thm</a>
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP_____B2.html">+</a> 11 12 x) y))

(<a href="ACL2____THM.html">thm</a>
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____ACL2-NUMBERP.html">acl2-numberp</a> c)
                (<a href="ACL2____ACL2-NUMBERP.html">acl2-numberp</a> d)
                (<a href="ACL2____ACL2-NUMBERP.html">acl2-numberp</a> x))
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP_____B2.html">+</a> c d x) y))).</pre> 
 
 <p>One can use <span class="v">:</span><span class="tt"><a href="ACL2____BRR.html">brr</a></span>, perhaps in conjunction with <span class="tt"><a href="ACL2____CW-GSTACK.html">cw-gstack</a></span>, to investigate any looping.</p> 
 
 <p>Here is a simple example showing the value of rule <span class="v">good</span> above. 
 Without <span class="v">good</span>, the <span class="v">thm</span> form below fails.</p> 
 
 <pre class="code">(<a href="ACL2____DEFSTUB.html">defstub</a> foo (x) t)

(<a href="ACL2____THM.html">thm</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (foo (<a href="COMMON-LISP_____B2.html">+</a> 3 4 x)) (foo (<a href="COMMON-LISP_____B2.html">+</a> 7 x))))</pre> 
 
 <p>The next three examples further explore the use of <span class="v">quote</span> in <span class="tt"><a href="ACL2____SYNTAXP.html">syntaxp</a></span> hypotheses.</p> 
 
 <p>We continue the examples of <span class="tt"><a href="ACL2____SYNTAXP.html">syntaxp</a></span> hypotheses with a rule from 
 community book <span class="v">books/finite-set-theory/set-theory.lisp</span>.  We will not 
 discuss here the meaning of this rule, but it is necessary to point out that 
 <span class="v">(ur-elementp nil)</span> is true in this book.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> scons-nil
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SYNTAXP.html">syntaxp</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> a ''nil)))
                (ur-elementp a))
           (<a href="COMMON-LISP_____D3.html">=</a> (scons e a)
              (scons e nil)))).</pre> 
 
 <p>Here also, <span class="tt"><a href="ACL2____SYNTAXP.html">syntaxp</a></span> is used to prevent looping.  Without the 
 restriction, <span class="v">(scons e nil)</span> would be rewritten to itself since 
 <span class="v">(ur-elementp nil)</span> is true.<br> 
 
 Question: Why the use of two quotes in <span class="v">''nil</span>?<br> 
 
 Hints: <span class="v">Nil</span> is a constant just as 23 is.  Try <span class="v">:trans (<a href="COMMON-LISP____CONS.html">cons</a> a nil)</span>, 
 <span class="v">:trans (<a href="COMMON-LISP____CONS.html">cons</a> 'a 'nil)</span>, and <span class="v">:trans (<a href="COMMON-LISP____CONS.html">cons</a> ''a ''nil)</span>.  Also, don't 
 forget that the arguments to a function are evaluated before the function is 
 applied.</p> 
 
 <p>The next two rules move negative constants to the other side of an 
 inequality.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> |(<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP____-.html">-</a> c) x) y)|
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SYNTAXP.html">syntaxp</a> (<a href="ACL2____QUOTEP.html">quotep</a> c))
                (<a href="ACL2____SYNTAXP.html">syntaxp</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="COMMON-LISP____CADR.html">cadr</a> c) 0))
                (<a href="ACL2____ACL2-NUMBERP.html">acl2-numberp</a> y))
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="COMMON-LISP_____B2.html">+</a> c x) y)
                  (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____FIX.html">fix</a> x) (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP____-.html">-</a> c) y)))))

(<a href="ACL2____DEFTHM.html">defthm</a> |(<a href="COMMON-LISP_____C3.html">&lt;</a> y (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP____-.html">-</a> c) x))|
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SYNTAXP.html">syntaxp</a> (<a href="ACL2____QUOTEP.html">quotep</a> c))
                (<a href="ACL2____SYNTAXP.html">syntaxp</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="COMMON-LISP____CADR.html">cadr</a> c) 0))
                (<a href="ACL2____ACL2-NUMBERP.html">acl2-numberp</a> y))
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> y (<a href="COMMON-LISP_____B2.html">+</a> c x))
                  (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP____-.html">-</a> c) y) (<a href="ACL2____FIX.html">fix</a> x)))))</pre> 
 
 <p>Questions: What would happen if <span class="v">(<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="COMMON-LISP____CADR.html">cadr</a> c) '0)</span> were used?  What about 
 <span class="v">(<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="COMMON-LISP____CADR.html">cadr</a> c) ''0)</span>?</p> 
 
 <p>One can also use <span class="v">syntaxp</span> to restrict the application of a rule to a 
 particular set of variable bindings as in the following taken from the <a href="ACL2____IHS.html">ihs</a> library.</p> 
 
 <pre class="code">(<a href="ACL2____ENCAPSULATE.html">encapsulate</a> ()

  (<a href="ACL2____LOCAL.html">local</a>
   (<a href="ACL2____DEFTHM.html">defthm</a> floor-+-crock
     (<a href="ACL2____IMPLIES.html">implies</a>
      (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____REAL_F2RATIONALP.html">real/rationalp</a> x)
           (<a href="ACL2____REAL_F2RATIONALP.html">real/rationalp</a> y)
           (<a href="ACL2____REAL_F2RATIONALP.html">real/rationalp</a> z)
           (<a href="ACL2____SYNTAXP.html">syntaxp</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____EQ.html">eq</a> x 'x) (<a href="COMMON-LISP____EQ.html">eq</a> y 'y) (<a href="COMMON-LISP____EQ.html">eq</a> z 'z))))
      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____FLOOR.html">floor</a> (<a href="COMMON-LISP_____B2.html">+</a> x y) z)
             (<a href="COMMON-LISP____FLOOR.html">floor</a> (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP____MOD.html">mod</a> x z) (<a href="COMMON-LISP____MOD.html">mod</a> y z))
                       (<a href="COMMON-LISP_____A2.html">*</a> (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP____FLOOR.html">floor</a> x z) (<a href="COMMON-LISP____FLOOR.html">floor</a> y z)) z)) z)))))

  (<a href="ACL2____DEFTHM.html">defthm</a> floor-+
    (<a href="ACL2____IMPLIES.html">implies</a>
     (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____FORCE.html">force</a> (<a href="ACL2____REAL_F2RATIONALP.html">real/rationalp</a> x))
          (<a href="ACL2____FORCE.html">force</a> (<a href="ACL2____REAL_F2RATIONALP.html">real/rationalp</a> y))
          (<a href="ACL2____FORCE.html">force</a> (<a href="ACL2____REAL_F2RATIONALP.html">real/rationalp</a> z))
          (<a href="ACL2____FORCE.html">force</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> z 0))))
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____FLOOR.html">floor</a> (<a href="COMMON-LISP_____B2.html">+</a> x y) z)
            (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP____FLOOR.html">floor</a> (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP____MOD.html">mod</a> x z) (<a href="COMMON-LISP____MOD.html">mod</a> y z)) z)
               (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP____FLOOR.html">floor</a> x z) (<a href="COMMON-LISP____FLOOR.html">floor</a> y z))))))

  )</pre> 
 
 <p>We recommend the use of <span class="v">:</span><span class="v">brr</span> to investigate the use of 
 <span class="v">floor-+-crock</span>.</p> 
 
 <p>Another useful restriction is defined by</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> rewriting-goal-literal (x mfc state)

  ;; Are we rewriting a top-level goal literal, rather than rewriting
  ;; to establish a hypothesis from a rewrite (<a href="COMMON-LISP____OR.html">or</a> other) rule?

  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORE.html">ignore</a> x state))
  (<a href="COMMON-LISP____NULL.html">null</a> (<a href="ACL2____ACCESS.html">access</a> metafunction-context mfc :ancestors))).</pre> 
 
 <p>We use this restriction in the rule</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> |(<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="COMMON-LISP_____A2.html">*</a> x y) 0)|
    (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SYNTAXP.html">syntaxp</a> (rewriting-goal-literal x mfc state))
                  (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x)
                  (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> y))
             (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="COMMON-LISP_____A2.html">*</a> x y) 0)
                    (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____EQUAL.html">equal</a> x 0)
                           nil)
                          ((<a href="COMMON-LISP____EQUAL.html">equal</a> y 0)
                           nil)
                          ((<a href="COMMON-LISP_____C3.html">&lt;</a> x 0)
                           (<a href="COMMON-LISP_____C3.html">&lt;</a> 0 y))
                          ((<a href="COMMON-LISP_____C3.html">&lt;</a> 0 x)
                           (<a href="COMMON-LISP_____C3.html">&lt;</a> y 0))))))</pre> 
 
 <p>which has been found to be useful, but which also leads to excessive 
 thrashing in the linear arithmetic package if used indiscriminately.</p> 
 
 <p>See <a href="ACL2____EXTENDED-METAFUNCTIONS.html">extended-metafunctions</a> for information on the use of <span class="v">mfc</span> 
 and <span class="v">metafunction-context</span>.</p>
</body>
</html>
