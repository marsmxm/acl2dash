<html>
<head>
<meta charset="UTF-8">
<title>Abelian-groups</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____ABELIAN-GROUPS">Click for Abelian-groups in the Full Manual</a></h3>

<p>Axiomatization of an associative and commutative binary operation 
with an identity and an unary inverse operation, developed by John Cowles.</p><h3>Theory of Abelian Groups</h3> 
 
<p><span class="v">ACL2-AGP::op</span> is an associative and commutative binary operation on the 
set (of equivalence classes formed by the equivalence relation, 
<span class="v">ACL2-AGP::equiv</span>, on the set)</p> 
 
<pre class="code">GP = { x | (ACL2-AGP::pred x) != nil }</pre> 
 
<p><span class="v">ACL2-AGP::id</span> is a constant in the set GP which acts as an unit for 
<span class="v">ACL2-AGP::op</span> in GP.</p> 
 
<p><span class="v">ACL2-AGP::inv</span> is an unary operation on the set (of equivalence classes 
formed by the equivalence relation, <span class="v">ACL2-AGP::equiv</span>, on the set) GP which 
acts as an <span class="v">ACL2-AGP::op-inverse</span> for <span class="v">ACL2-AGP:: id</span>.</p> 
 
<p>For example, let</p> 
 
<ul> 
<li>
<span class="v">ACL2-AGP::pred</span> = Booleanp, </li> 
<li>
<span class="v">ACL2-AGP::op</span>   = exclusive-or, </li> 
<li>
<span class="v">ACL2-AGP::id</span>   = nil, and </li> 
<li>
<span class="v">ACL2-AGP::inv</span>  = identity function. </li> 
</ul> 
 
<h3>Axioms of the theory of Abelian Groups</h3> 
 
<p>Using <a href="ACL2____ENCAPSULATE.html">encapsulate</a>, we introduce constrained functions:</p> 
 
<ul> 
<li><span class="tt">(equiv x y)</span></li> 
<li><span class="tt">(pred x)</span></li> 
<li><span class="tt">(op x y)</span></li> 
<li><span class="tt">(id)</span></li> 
<li><span class="tt">(inv x)</span></li> 
</ul> 
 
<p>with the following, constraining axioms:</p> 
 
<p><b>Theorem: </b>equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 equiv-is-an-equivalence
 (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (equiv x y))
      (equiv x x)
      (<a href="ACL2____IMPLIES.html">implies</a> (equiv x y) (equiv y x))
      (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (equiv x y) (equiv y z))
               (equiv x z)))
 :rule-classes
 (:equivalence
      (:type-prescription :corollary (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (equiv x y) t)
                                         (<a href="COMMON-LISP____EQUAL.html">equal</a> (equiv x y) nil)))))</pre> 
<p><b>Theorem: </b>equiv-implies-iff-pred-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equiv-implies-iff-pred-1
        (<a href="ACL2____IMPLIES.html">implies</a> (equiv x x-equiv)
                 (<a href="ACL2____IFF.html">iff</a> (pred x) (pred x-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>equiv-implies-equiv-op-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equiv-implies-equiv-op-1
        (<a href="ACL2____IMPLIES.html">implies</a> (equiv x x-equiv)
                 (equiv (op x y) (op x-equiv y)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>equiv-implies-equiv-op-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equiv-implies-equiv-op-2
        (<a href="ACL2____IMPLIES.html">implies</a> (equiv y y-equiv)
                 (equiv (op x y) (op x y-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>equiv-implies-equiv-inv-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equiv-implies-equiv-inv-1
        (<a href="ACL2____IMPLIES.html">implies</a> (equiv x x-equiv)
                 (equiv (inv x) (inv x-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>closure-of-op-for-pred</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> closure-of-op-for-pred
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (pred x) (pred y))
                 (pred (op x y))))</pre> 
<p><b>Theorem: </b>closure-of-id-for-pred</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> closure-of-id-for-pred (pred (id)))</pre> 
<p><b>Theorem: </b>closure-of-inv-for-pred</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> closure-of-inv-for-pred
        (<a href="ACL2____IMPLIES.html">implies</a> (pred x) (pred (inv x))))</pre> 
<p><b>Theorem: </b>commutativity-of-op</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> commutativity-of-op
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (pred x) (pred y))
                 (equiv (op x y) (op y x))))</pre> 
<p><b>Theorem: </b>associativity-of-op</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> associativity-of-op
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (pred x) (pred y) (pred z))
                 (equiv (op (op x y) z)
                        (op x (op y z)))))</pre> 
<p><b>Theorem: </b>left-unicity-of-id-for-op</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> left-unicity-of-id-for-op
        (<a href="ACL2____IMPLIES.html">implies</a> (pred x)
                 (equiv (op (id) x) x)))</pre> 
<p><b>Theorem: </b>right-inverse-of-inv-for-op</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> right-inverse-of-inv-for-op
        (<a href="ACL2____IMPLIES.html">implies</a> (pred x)
                 (equiv (op x (inv x)) (id))))</pre> 
 
<h3>Theorems of the theory of Abelian Groups</h3> 
 
<p><b>Theorem: </b>commutativity-2-of-op</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> commutativity-2-of-op
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (pred x) (pred y) (pred z))
                 (equiv (op x (op y z))
                        (op y (op x z)))))</pre> 
<p><b>Theorem: </b>right-unicity-of-id-for-op</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> right-unicity-of-id-for-op
        (<a href="ACL2____IMPLIES.html">implies</a> (pred x)
                 (equiv (op x (id)) x)))</pre> 
<p><b>Theorem: </b>left-inverse-of-inv-for-op</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> left-inverse-of-inv-for-op
        (<a href="ACL2____IMPLIES.html">implies</a> (pred x)
                 (equiv (op (inv x) x) (id))))</pre> 
<p><b>Theorem: </b>right-cancellation-for-op</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> right-cancellation-for-op
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (pred x) (pred y) (pred z))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (equiv (op x z) (op y z))
                        (equiv x y)))
        :rule-classes nil)</pre> 
<p><b>Theorem: </b>left-cancellation-for-op</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> left-cancellation-for-op
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (pred x) (pred y) (pred z))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (equiv (op x y) (op x z))
                        (equiv y z))))</pre> 
<p><b>Theorem: </b>uniqueness-of-id-as-op-idempotent</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> uniqueness-of-id-as-op-idempotent
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (pred x) (equiv (op x x) x))
                 (equiv x (id)))
        :rule-classes nil)</pre> 
<p><b>Theorem: </b>uniqueness-of-op-inverses</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> uniqueness-of-op-inverses
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (pred x)
                      (pred y)
                      (equiv (op x y) (id)))
                 (equiv y (inv x)))
        :rule-classes nil)</pre> 
<p><b>Theorem: </b>involution-of-inv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> involution-of-inv
        (<a href="ACL2____IMPLIES.html">implies</a> (pred x)
                 (equiv (inv (inv x)) x)))</pre> 
<p><b>Theorem: </b>uniqueness-of-op-inverses-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> uniqueness-of-op-inverses-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (pred x)
                      (pred y)
                      (equiv (op x (inv y)) (id)))
                 (equiv x y))
        :rule-classes nil)</pre> 
<p><b>Theorem: </b>distributivity-of-inv-over-op</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> distributivity-of-inv-over-op
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (pred x) (pred y))
                 (equiv (inv (op x y))
                        (op (inv x) (inv y)))))</pre> 
<p><b>Theorem: </b>id-is-its-own-invese</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> id-is-its-own-invese
        (equiv (inv (id)) (id)))</pre> 
<p><b>Theorem: </b>inv-cancellation-on-right</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> inv-cancellation-on-right
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (pred x) (pred y))
                 (equiv (op x (op y (inv x))) y)))</pre> 
<p><b>Theorem: </b>inv-cancellation-on-left</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> inv-cancellation-on-left
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (pred x) (pred y))
                 (equiv (op x (op (inv x) y)) y)))</pre> 

</body>
</html>
