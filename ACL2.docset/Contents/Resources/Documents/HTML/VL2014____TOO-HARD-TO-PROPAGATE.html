<html>
<head>
<meta charset="UTF-8">
<title>Too-hard-to-propagate</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=VL2014____TOO-HARD-TO-PROPAGATE">Click for Too-hard-to-propagate in the Full Manual</a></h3>

<p>Identify wires that are too hard to propagate.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(too-hard-to-propagate x) → names</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">x</span> — <font color="#606060">Guard <span class="v">(<a href="VL2014____VL-MODULE-P.html">vl-module-p</a> x)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">names</span> — <font color="#606060">Type <span class="v">(<a href="ACL2____STRING-LISTP.html">string-listp</a> names)</span>, given the <a href="ACL2____GUARD.html">guard</a>.</font>
</dd> 
 
</dl></div> 
<p>To keep propagation simple, we don't want to try to propagate an 
assignment to a wire that is ever selected from.  The goal is to avoid having 
to deal with things like this:</p> 
 
<pre class="code">assign foo = a + b;
assign bar = foo[2] + 3;</pre> 
 
<p>Naive propagation of foo would result in:</p> 
 
<pre class="code">assign bar = (a + b)[2] + 3;</pre> 
 
<p>And we don't want to try to think about how to handle this.  Even if we just 
had something like assign foo = bar, it'd be complicated because foo/bar could 
have different ranges, e.g., if we have</p> 
 
<pre class="code">wire [3:0] foo;
wire [4:1] bar;
assign foo = bar;
assign baz = foo[2] + 3;</pre> 
 
<p>Then we would need to be careful to fix up the indicides when substituting 
into baz, i.e., the correct substitution would be:</p> 
 
<pre class="code">assign baz = bar[3] + 3;</pre> 
 
<p>And that's getting tricky.  So, the basic idea is: if the wire is ever 
selected from anywhere, then just don't try to propagate it.</p> 
 
<p>Also, for propagation to be safe, we need to make sure that we are not 
propagating wires that have multiple drivers.  For instance, if we had:</p> 
 
<pre class="code">assign A = B;
assign A = C;</pre> 
 
<p>Then it wouldn't be safe to just go around replacing uses of A with either B 
or C, because neither B nor C captures the whole value being assigned to A. 
Hence, we need some code for detecting what wires are driven.</p> 
 
<p>Another new restriction: we now allow ourselves to propagate into modules 
that have always blocks, initial blocks, and function declarations.  But to 
hopefully make this safe, we consider any names that are actually used in these 
places to be unsafe.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>too-hard-to-propagate</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 too-hard-to-propagate (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="VL2014____VL-MODULE-P.html">vl-module-p</a> x)))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((__function__ 'too-hard-to-propagate))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
  (<a href="ACL2____B_A2.html">b*</a>
   (((<a href="VL2014____VL-MODULE.html">vl-module</a> x) x))
   (<a href="SET____MERGESORT.html">mergesort</a>
    (<a href="COMMON-LISP____APPEND.html">append</a>
        (<a href="VL2014____VL-PORTDECLLIST-_E3NAMES.html">vl-portdecllist-&gt;names</a> x.portdecls)
        (<a href="VL2014____VL-MAYBE-DRIVEN-BY-MODINSTS.html">vl-maybe-driven-by-modinsts</a> x.modinsts)
        (<a href="VL2014____VL-MAYBE-DRIVEN-BY-GATEINSTS.html">vl-maybe-driven-by-gateinsts</a> x.gateinsts)
        (duplicated-members (<a href="VL2014____VL-DRIVEN-BY-ASSIGNS.html">vl-driven-by-assigns</a> x.assigns))
        (<a href="VL2014____USED-IN-SOME-SELECT-P.html">used-in-some-select-p</a> x)
        (<a href="VL2014____VL-EXPRLIST-NAMES.html">vl-exprlist-names</a> (<a href="VL2014____VL-FUNDECLLIST-ALLEXPRS.html">vl-fundecllist-allexprs</a> x.fundecls))
        (<a href="VL2014____VL-EXPRLIST-NAMES.html">vl-exprlist-names</a> (<a href="VL2014____VL-ALWAYSLIST-ALLEXPRS.html">vl-alwayslist-allexprs</a> x.alwayses))
        (<a href="VL2014____VL-EXPRLIST-NAMES.html">vl-exprlist-names</a> (<a href="VL2014____VL-INITIALLIST-ALLEXPRS.html">vl-initiallist-allexprs</a> x.initials))
        (<a href="VL2014____VL-EXPRLIST-NAMES.html">vl-exprlist-names</a> (<a href="VL2014____VL-TASKDECLLIST-ALLEXPRS.html">vl-taskdecllist-allexprs</a> x.taskdecls))
        (<a href="VL2014____VL-EXPRLIST-NAMES.html">vl-exprlist-names</a> (<a href="VL2014____VL-PARAMDECLLIST-ALLEXPRS.html">vl-paramdecllist-allexprs</a> x.paramdecls))
        (<a href="VL2014____VL-TASKDECLLIST-_E3NAMES.html">vl-taskdecllist-&gt;names</a> x.taskdecls)
        (<a href="VL2014____VL-PARAMDECLLIST-_E3NAMES.html">vl-paramdecllist-&gt;names</a> x.paramdecls))))))</pre> 
<p><b>Theorem: </b>string-listp-of-too-hard-to-propagate</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> string-listp-of-too-hard-to-propagate
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____FORCE.html">force</a> (<a href="VL2014____VL-MODULE-P.html">vl-module-p</a> x)))
                 (<a href="ACL2____B_A2.html">b*</a> ((names (<a href="VL2014____TOO-HARD-TO-PROPAGATE.html">too-hard-to-propagate</a> x)))
                     (<a href="ACL2____STRING-LISTP.html">string-listp</a> names)))
        :rule-classes :rewrite)</pre> 

</body>
</html>
