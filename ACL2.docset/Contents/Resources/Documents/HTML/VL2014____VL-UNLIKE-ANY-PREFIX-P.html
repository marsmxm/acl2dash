<html>
<head>
<meta charset="UTF-8">
<title>Vl-unlike-any-prefix-p</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=VL2014____VL-UNLIKE-ANY-PREFIX-P">Click for Vl-unlike-any-prefix-p in the Full Manual</a></h3>

<p><span class="tt">(vl-unlike-any-prefix-p name prefixes)</span> determines whether for all <span class="v">p</span> in 
<span class="v">prefixes</span>, <span class="v">(<a href="VL2014____VL-PGENSTR-P.html">vl-pgenstr-p</a> p name)</span> is false.</p><p>We use this function in the implementation of <a href="VL2014____VL-NAMEDB-PLAIN-NAME.html">vl-namedb-plain-name</a>.  When requesting a plain name, one might ask for a name 
like <span class="v">foo_3</span>, which could screw up the prefix map if we are using <span class="v">foo</span> 
as a prefix.</p> 
 
<p>One solution would be to fix up the prefix map when this occurs.  But we 
take the easier approach of just not allowing you to request any name that 
matches a current prefix.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>vl-unlike-any-prefix-p</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> vl-unlike-any-prefix-p (name prefixes)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____STRINGP.html">stringp</a> name)
                                   (<a href="ACL2____STRING-LISTP.html">string-listp</a> prefixes))))
       (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____ATOM.html">atom</a> prefixes)
           (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="VL2014____VL-PGENSTR-P.html">vl-pgenstr-p</a> (<a href="COMMON-LISP____CAR.html">car</a> prefixes) name))
                (<a href="VL2014____VL-UNLIKE-ANY-PREFIX-P.html">vl-unlike-any-prefix-p</a> name (<a href="COMMON-LISP____CDR.html">cdr</a> prefixes)))))</pre> 
<p><b>Theorem: </b>vl-unlike-any-prefix-p-when-atom</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> vl-unlike-any-prefix-p-when-atom
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____ATOM.html">atom</a> prefixes)
                 (<a href="VL2014____VL-UNLIKE-ANY-PREFIX-P.html">vl-unlike-any-prefix-p</a> name prefixes)))</pre> 
<p><b>Theorem: </b>vl-unlike-any-prefix-p-of-cons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> vl-unlike-any-prefix-p-of-cons
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="VL2014____VL-UNLIKE-ANY-PREFIX-P.html">vl-unlike-any-prefix-p</a> name (<a href="COMMON-LISP____CONS.html">cons</a> a x))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="VL2014____VL-PGENSTR-P.html">vl-pgenstr-p</a> a name))
                    (<a href="VL2014____VL-UNLIKE-ANY-PREFIX-P.html">vl-unlike-any-prefix-p</a> name x))))</pre> 
<p><b>Theorem: </b>vl-pgenstr-p-when-vl-unlike-any-prefix-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> vl-pgenstr-p-when-vl-unlike-any-prefix-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> key prefixes)
                      (<a href="VL2014____VL-UNLIKE-ANY-PREFIX-P.html">vl-unlike-any-prefix-p</a> name prefixes))
                 (<a href="COMMON-LISP____NOT.html">not</a> (<a href="VL2014____VL-PGENSTR-P.html">vl-pgenstr-p</a> key name))))</pre> 
<p><b>Theorem: </b>vl-unlike-any-prefix-p-preserves-set-equiv-prefixes</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     vl-unlike-any-prefix-p-preserves-set-equiv-prefixes
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____SET-EQUIV.html">set-equiv</a> prefixes prefixes-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="VL2014____VL-UNLIKE-ANY-PREFIX-P.html">vl-unlike-any-prefix-p</a> name prefixes)
                     (<a href="VL2014____VL-UNLIKE-ANY-PREFIX-P.html">vl-unlike-any-prefix-p</a> name prefixes-equiv)))
     :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>vl-prefix-map-correct-p-aux-when-vl-unlike-any-prefix-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  vl-prefix-map-correct-p-aux-when-vl-unlike-any-prefix-p
  (<a href="ACL2____IMPLIES.html">implies</a>
       (<a href="COMMON-LISP____AND.html">and</a> (vl-prefix-map-correct-p-aux domain pmap names)
            (<a href="VL2014____VL-UNLIKE-ANY-PREFIX-P.html">vl-unlike-any-prefix-p</a> name (<a href="ACL2____ALIST-KEYS.html">alist-keys</a> pmap)))
       (vl-prefix-map-correct-p-aux domain pmap (<a href="COMMON-LISP____CONS.html">cons</a> name names))))</pre> 
<p><b>Theorem: </b>vl-prefix-map-correct-p-when-vl-unlike-any-prefix-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     vl-prefix-map-correct-p-when-vl-unlike-any-prefix-p
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (vl-prefix-map-correct-p pset names)
                   (<a href="VL2014____VL-UNLIKE-ANY-PREFIX-P.html">vl-unlike-any-prefix-p</a> name (<a href="ACL2____ALIST-KEYS.html">alist-keys</a> pset)))
              (vl-prefix-map-correct-p pset (<a href="COMMON-LISP____CONS.html">cons</a> name names))))</pre> 

</body>
</html>
