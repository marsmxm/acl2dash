<html>
<head>
<meta charset="UTF-8">
<title>Soft-future-work</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=SOFT____SOFT-FUTURE-WORK">Click for Soft-future-work in the Full Manual</a></h3>

<p>Some possible improvements and extensions to SOFT.</p><h4>Mutual Recursion</h4><p>SOFT should be extended with the ability to introduce and instantiate 
     mutually recursive functions, 
     perhaps via a new <span class="v">mutual-recursion2</span> macro.</p><h4>Other Well-Founded Relations</h4><p>Currently recursive second-order functions 
     must use <span class="tt"><a href="ACL2____O_C3.html">o&lt;</a></span> as their well-founded relation. 
     This could be relaxed, perhaps even to the point of 
     allowing second-order well-founded relations.</p><h4>Other Function and Theorem Introduction Macros</h4><p>Besides second-order versions of 
     <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span>, 
     <span class="tt"><a href="ACL2____DEFCHOOSE.html">defchoose</a></span>, 
     <span class="tt"><a href="ACL2____DEFUN-SK.html">defun-sk</a></span>, 
     <span class="tt"><a href="SOFT____DEFINE2.html">define2</a></span>, and 
     <span class="tt"><a href="SOFT____DEFINE-SK2.html">define-sk2</a></span>, 
     we could add support for second-order versions of 
     <span class="tt"><a href="ACL2____DEFUN-NX.html">defun-nx</a></span>, <span class="tt"><a href="ACL2____DEFPUN.html">defpun</a></span>, and other function introduction events. 
     <span class="tt"><a href="SOFT____DEFUN-INST.html">defun-inst</a></span> would generate the same macros for instances. 
     The macros could be called <span class="v">defun-nx2</span>, <span class="v">defpun2</span>, etc.</p><p>Under some conditions, it would make sense for <span class="tt"><a href="SOFT____DEFUN-INST.html">defun-inst</a></span> 
     to instantiate a partial second-order function 
     (introduced, say, via a future <span class="v">defpun2</span> macro) 
     to a total second-order function (i.e. a <span class="tt"><a href="SOFT____DEFUN2.html">defun2</a></span> or <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span>), 
     when the instantiated <span class="v">:domain</span> or <span class="v">:gdomain</span> restrictions 
     are theorems.</p><p><span class="tt"><a href="SOFT____DEFTHM-INST.html">defthm-inst</a></span> could also generate instances with the same macros 
     from second-order theorems introduced via 
     <span class="tt"><a href="ACL2____DEFTHM.html">defthm</a></span>, <span class="tt"><a href="ACL2____DEFRULE.html">defrule</a></span>, and other theorem introduction events.</p><h4>Program Mode</h4><p>Currently SOFT only supports logic-mode second-order functions. 
     Supporting program-mode functions as well may be useful.</p><h4>Guards of Instances of Second-Order Functions</h4><p>It would be useful to allow 
     the default guards of instances of second-order functions 
     (obtained by instantiating the guards of the second-order functions) 
     to be overridden by stronger guards.</p><p>The <a href="ACL2____GUARD-THEOREM.html">guard theorem</a> 
     of a second-order function may be useful 
     (although not sufficient in general) 
     to verifies the guards of instances of the second-order function. 
     A mechanism to enable the use of that theorem would be useful.</p><p>See the future work section of the 
     <a href="http://eptcs.web.cse.unsw.edu.au/paper.cgi?ACL22015.3" target="_blank"><nobr>Workshop paper<img src="../Icon_External_Link.png" title="External link to http://eptcs.web.cse.unsw.edu.au/paper.cgi?ACL22015.3"></nobr></a> 
     for a more detailed discussion with examples.</p><h4>Lambda Expressions</h4><p>Instantiations could be extended to allow function variables 
     to be replaces with lambda expressions, besides named functions.</p><h4>Transitivity of Instantiations</h4><p>Intuitively, 
     if <span class="v">f</span> is an instance of <span class="v">g</span> 
     and <span class="v">g</span> is an instance of <span class="v">h</span>, 
     then <span class="v">f</span> should be an instance of <span class="v">h</span>. 
     This is currently not supported by <span class="tt"><a href="SOFT____DEFUN-INST.html">defun-inst</a></span>, 
     but probably it should be.</p><p>See the future work section of the 
     <a href="http://eptcs.web.cse.unsw.edu.au/paper.cgi?ACL22015.3" target="_blank"><nobr>Workshop paper<img src="../Icon_External_Link.png" title="External link to http://eptcs.web.cse.unsw.edu.au/paper.cgi?ACL22015.3"></nobr></a> 
     for a more detailed discussion with examples.</p><h4>More Constraints on Function Variables</h4><p>The types of function variables are currently limited to 
     <a href="ACL2____SIGNATURE.html">signatures</a> 
     with single-value results and with no stobjs. 
     This could be extended to allow multiple-value results and stobjs. 
     Instantiations will have to respect these additional type structures.</p><p>Other than their types, function variables are currently unconstrained. 
     In some cases, it may be useful to specify some logical constraints, 
     resulting in a constrained function as in non-trivial <span class="tt"><a href="ACL2____ENCAPSULATE.html">encapsulate</a></span>s. 
     Instantiations will have to respect these additional constraints.</p><p>The latter extension would overlap with some existing tools, 
     such as <span class="v">instance-of-defspec</span> and <span class="v">make-generic-theory</span>. 
     Ideally, the functionality of SOFT and those tools would be integrated.</p><p>Function variables current have guard <span class="v">t</span>. 
     It may be useful to allow guards to be specified for function variables. 
     Instantiations will have to match these guards.</p><h4>Automatic Instances</h4><p>Currently, when an instantiation is applied to a term, 
     the table of instances of second-order functions is consulted 
     to find replacements for certain second-order functions, 
     and the application of the instantiation fails 
     if replacements are not found. 
     Thus, all the needed instances must be introduced 
     before applying the instantiation. 
     SOFT could be extended to generate automatically 
     the needed instances of second-order functions.</p><p>SOFT could also be extended with a macro <span class="v">defthm2</span> 
     to prove a second-order theorem via <span class="tt"><a href="ACL2____DEFTHM.html">defthm</a></span> 
     and to record the theorem in a new table, 
     along with information about the involved second-order functions. 
     <span class="tt"><a href="SOFT____DEFUN-INST.html">defun-inst</a></span> could be extended with 
     the option to generate instances of the second-order theorems 
     that involve the second-order function being instantiated. 
     <span class="v">defthm2</span> could include the option to generate 
     instances of the theorem that correspond 
     to the known instances of the second-order functions 
     that the theorem involves. 
     These extensions would reduce the use of explicit <span class="tt"><a href="SOFT____DEFTHM-INST.html">defthm-inst</a></span>s.</p><p>The convention of including function variables in square brackets 
     in the names of second-order functions and theorems, 
     could be exploited to name the automatically generated 
     function and theorem instances.</p><h4>Default Rule Classes</h4><p>Currently the default rule classes 
     of an instance of a second-order theorem are <span class="v">(:rewrite)</span>, 
     but perhaps the default should be the rule classes 
     of the second-order theorem that is being instantiated.</p>
</body>
</html>
