<html>
<head>
<meta charset="UTF-8">
<title>Expdata</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=APT____EXPDATA">Click for Expdata in the Full Manual</a></h3>

<p>APT expanded data transformation: 
          change function arguments and results 
          into expanded representations.</p><h3>Introduction</h3><p>This transformation changes the representation of 
      one or more of a function's arguments and results 
      into an expanded representation 
      in the sense that the same element in the old representation 
      may correspond to multiple elements in the new representation. 
      This is more general than <span class="tt"><a href="APT____ISODATA.html">isodata</a></span>, 
      where old and new representation are isomorphic: 
      in <span class="v">expdata</span>, there is a surjection 
      from the new representation to the old representation. 
      The <span class="v">expdata</span> transformation is useful 
      to carry out certain data type refinements 
      (when synthesizing programs), 
      or perhaps also to raise the level of abstraction of certain types 
      (when analyzing programs); 
      however, its usefulness in program analysis 
      is not as obvious as <span class="tt"><a href="APT____ISODATA.html">isodata</a></span>, 
      given that isomorphisms are inherently invertible 
      while mere surjections are not.</p><p>For a given (user-specified) surjective conversion 
      from the new representation to the old representation 
      there may be different possible right inverse conversions 
      from the old representation to the new representation. 
      Different such inverse conversions could be used 
      in different parts of the new function generated by <span class="v">expdata</span>. 
      The current version of this transformation, for simplicity, 
      use the same (user-specified) inverse conversion; 
      future versions of <span class="v">expdata</span> may support different conversions, 
      which may be necessary to make <span class="v">expdata</span> more practically useful. 
      Thus, the current version of <span class="v">expdata</span> 
      is very similar to <span class="tt"><a href="APT____ISODATA.html">isodata</a></span>, 
      except that the conversions are not necessarily isomorphisms.</p><p>When at least one argument's representation is being changed, 
      then by regarding the arguments whose representation is not changed 
      as being changed via an indentity surjection, 
      we can say that this transformation changes the representation of 
      (the tuple of) all the function's arguments 
      into a new representation that consists of 
      (the tuple of) all the new function's arguments. 
      In this case, there are two variants of this transformation:</p><ul>
<li>When the function operates only on argument tuples 
       in the old representation 
       (i.e. when the function's guard is a subset of the old representation), 
       the function is transformed to operate in the same way on 
       exactly the argument tuples in the new representation 
       that are in the surjection's preimage of the old guard.</li>
<li>When the function operates on 
       at least all the tuples in the old representation (and possibly more) 
       (i.e. the function's guard is a superset of the old representation), 
       and is used as a predicate to recognize 
       a subset of argument tuples all of which are in the old representation, 
       the function is transformed to recognize 
       exactly the argument tuples in the new representation 
       that are in the surjection's preimage of 
       the ones recognized by the old function.</li>
</ul><p>These two variants involve slightly different applicability conditions 
      and produce slightly different results. 
      These two variants are selected 
      via the <span class="v">:predicate</span> input (see below).</p><p>If only the representation of some results (and of no arguments) 
      is changed, then there is a single variant of this transformation, 
      namely one that operates on the same tuples as the old function 
      but returns results in the new representation 
      that are in the surjection's preimage.</p><p>The <span class="v">expdata</span> <a href="res/kestrel-apt-design-notes/expdata.pdf" target="_blank"><nobr>design notes<img src="../Icon_External_Link.png" title="External link to res/kestrel-apt-design-notes/expdata.pdf"></nobr></a>, which use <a href="res/kestrel-design-notes/notation.pdf" target="_blank"><nobr>this notation<img src="../Icon_External_Link.png" title="External link to res/kestrel-design-notes/notation.pdf"></nobr></a>, provide the mathematical concepts and template proofs 
      upon which this transformation is based. 
      These notes should be read alongside this reference documentation, 
      which refers to the them in numerous places. 
      Given that, as noted above, 
      the current version of <span class="v">expdata</span> is very similar to <span class="tt"><a href="APT____ISODATA.html">isodata</a></span>, 
      the <span class="v">expdata</span> design notes mostly refer to 
      the <span class="v">isodata</span> <a href="res/kestrel-apt-design-notes/isodata.pdf" target="_blank"><nobr>design notes<img src="../Icon_External_Link.png" title="External link to res/kestrel-apt-design-notes/isodata.pdf"></nobr></a>; 
      thus, the <span class="tt"><a href="APT____ISODATA.html">isodata</a></span> design notes should be read as well.</p><h3>General Form</h3><pre class="code">(<a href="APT____EXPDATA.html">expdata</a> old
         surjmaps
         :predicate           ; default nil
         :new-name            ; default :auto
         :new-enable          ; default :auto
         :old-to-new-name     ; default from table
         :old-to-new-enable   ; default from table
         :new-to-old-name     ; default from table
         :new-to-old-enable   ; default from table
         :newp-of-new-name    ; default :auto
         :newp-of-new-enable  ; default t
         :verify-guards       ; default :auto
         :untranslate         ; default :nice
         :hints               ; default nil
         :print               ; default :result
         :show-only           ; default nil
  )</pre><h3>Inputs</h3><p><span class="v">old</span></p><blockquote>
<p>Denotes the target function to transform.</p>
<p>It must be the name of a function, 
      or a <a href="ACL2____NUMBERED-NAMES.html">numbered name</a> 
      with a wildcard index that 
      <a href="ACL2____RESOLVE-NUMBERED-NAME-WILDCARD.html">resolves</a> 
      to the name of a function. 
      In the rest of this documentation page, for expository convenience, 
      it is assumed that <span class="v">old</span> is the name of the denoted function.</p>
<p><span class="v">old</span> must 
       be in logic mode, 
       be <a href="ACL2____FUNCTION-DEFINEDNESS.html">defined</a>, and 
       have no input or output <a href="ACL2____STOBJ.html">stobjs</a>. If the <span class="v">:predicate</span> input (see below) is <span class="v">t</span>, 
       then <span class="v">old</span> must return 
       a non-<a href="ACL2____MV.html">multiple</a> value. 
       If <span class="v">old</span> is recursive, it must 
       be singly (not mutually) recursive, 
       not have a <span class="v">:?</span> measure, and 
       not occur in its own <a href="ACL2____TTHM.html">termination theorem</a> (i.e. not occur in the tests and arguments of its own recursive calls). 
       If the <span class="v">:verify-guards</span> input is <span class="v">t</span>, 
       <span class="v">old</span> must be guard-verified.</p>
<p>In the rest of this documentation page:</p>
<ul>
<li>Let <span class="v">x1</span>, ..., <span class="v">xn</span> be the arguments of <span class="v">old</span>, 
        where <span class="v">n</span> &gt; 0.</li>
<li>Let <span class="v">m</span> &gt; 0 be the number of results of <span class="v">old</span>.</li>
<li>Let <span class="v">old-guard&lt;x1,...,xn&gt;</span> be the guard term of <span class="v">old</span>.</li>
<li>If <span class="v">old</span> is not recursive, let 
        <pre class="code">old-body&lt;x1,...,xn&gt;</pre> 
        be the body of <span class="v">old</span>.</li>
<li>If <span class="v">old</span> is recursive, let 
        <pre class="code">old-body&lt;x1,...,xn,
         (old update1-x1&lt;x1,...,xn&gt;
              ...
              update1-xn&lt;x1,...,xn&gt;)
         ...
         (old updater-x1&lt;x1,...,xn&gt;
              ...
              updater-xn&lt;x1,...,xn&gt;)&gt;</pre> 
        be the body of <span class="v">old</span>, 
        where <span class="v">r</span> &gt; 0 is the number of recursive calls 
        in the body of <span class="v">old</span> 
        and each <span class="v">updatek-xi&lt;x1,...,xn&gt;</span> is 
        the <span class="v">i</span>-th actual argument passed to the <span class="v">k</span>-th recursive call. 
        Furthermore, 
        let <span class="v">contextk&lt;x1,...,xn&gt;</span> be the context (i.e. controlling tests) 
        in which the <span class="v">k</span>-th recursive call occurs, 
        and let <span class="v">measure&lt;x1,...,xn&gt;</span> be the measure term of <span class="v">old</span>.</li>
</ul>
<p>In the <span class="v">isodata</span> <a href="res/kestrel-apt-design-notes/isodata.pdf" target="_blank"><nobr>design notes<img src="../Icon_External_Link.png" title="External link to res/kestrel-apt-design-notes/isodata.pdf"></nobr></a>, 
       referenced by the <span class="v">expdata</span> <a href="res/kestrel-apt-design-notes/expdata.pdf" target="_blank"><nobr>design notes<img src="../Icon_External_Link.png" title="External link to res/kestrel-apt-design-notes/expdata.pdf"></nobr></a>, 
       <span class="v">old</span> is denoted by 
       f when <span class="v">:predicate</span> is <span class="v">nil</span>, 
       and p when <span class="v">:predicate</span> is <span class="v">t</span>.</p>
</blockquote><p><span class="v">surjmaps</span></p><blockquote>
<p>Specifies the arguments and results of <span class="v">old</span> that are transformed 
       and the way in which they are transformed.</p>
<p>It must be a non-empty list of doublets 
       <span class="v">((arg/res-list1 surj) ... (arg/res-listq surjq))</span>, 
       where:</p>
<ul>
<li>
<p>Each <span class="v">arg/res-listk</span> denotes 
         the subset of the arguments and results of <span class="v">old</span> 
         whose representation is transformed according to <span class="v">surjk</span>.</p>
<p>It must be one of the following:</p>
<ul>
<li>A non-empty list without duplicates of elements among 
          <span class="v">x1</span>, ... <span class="v">xn</span>, <span class="v">:result1</span>, ..., <span class="v">:resultm</span>, 
          in any order.</li>
<li>A single element among 
          <span class="v">x1</span>, ... <span class="v">xn</span>, <span class="v">:result1</span>, ..., <span class="v">:resultm</span>, 
          abbreviating the singleton list with that element.</li>
<li>The single element <span class="v">:result</span>, 
          abbreviating the singleton list <span class="v">:result1</span>. 
          This is allowed only if <span class="v">m</span> is 1.</li>
</ul>
</li>
<li>
<p>Each <span class="v">surjk</span> denotes the surjective mapping 
         to apply to the arguments and results in <span class="v">arg/res-listk</span>. 
         Each <span class="v">surjk</span> specifies 
         old and new representations 
         and the surjection between them, 
         along with a right inverse of the surjection.</p>
<p>It must be one of the following:</p>
<ul>
<li>A symbol that references 
          a previous successful call of <span class="tt"><a href="ACL2____DEFSURJ.html">defsurj</a></span>, 
          i.e. the symbol must be the <span class="v">name</span> input of that call. 
          The domains and conversions recorded under that name specify: 
          the recognizer of the old representation (<span class="v">domb</span>), 
          which we call <span class="v">oldp</span> here; 
          the recognizer of the new representation (<span class="v">doma</span>), 
          which we call <span class="v">newp</span> here; 
          the surjective conversion 
          from the new to the old representation (<span class="v">alpha</span>), 
          which we call <span class="v">back</span> here; and 
          the right inverse conversion 
          from the old to the new representation (<span class="v">beta</span>), 
          which we call <span class="v">forth</span> here. 
          Both <span class="v">oldp</span> and <span class="v">newp</span> must be unary. 
          If the generated function is guard-verified 
          (which is determined by the <span class="v">:verify-guards</span> input; see below), 
          the call of <span class="tt"><a href="ACL2____DEFSURJ.html">defsurj</a></span> 
          must have <span class="v">:guard-thms</span> equal to <span class="v">t</span>, 
          i.e. it must have proved and recorded the guard-related theorems.</li>
<li>A list <span class="v">(newp oldp back forth :hints hints)</span> 
          such that the call 
          <span class="v">(<a href="ACL2____DEFSURJ.html">defsurj</a> name newp oldp back forth
               :guard-thms guard-thms :thm-names thm-names :hints hints)</span> 
          is successful, 
          where <span class="v">name</span> and <span class="v">thm-names</span> consist of suitably fresh names, 
          and where <span class="v">guard-thms</span> is 
          <span class="v">t</span> if the generated function is guard-verified 
          (which is determined by the <span class="v">:verify-guards</span> input; see below) 
          and <span class="v">nil</span> otherwise. 
          A list <span class="v">(newp oldp back forth)</span> 
          abbreviates <span class="v">(newp oldp back forth :hints nil)</span>. 
          The <span class="v">expdata</span> transformation generates 
          this call of <span class="tt"><a href="ACL2____DEFSURJ.html">defsurj</a></span>, 
          and uses it in the same way as it uses a call referenced by <span class="v">surj</span> 
          when <span class="v">surj</span> is a symbol; 
          however, this generated <span class="tt"><a href="ACL2____DEFSURJ.html">defsurj</a></span> call 
          is local to the <span class="tt"><a href="ACL2____ENCAPSULATE.html">encapsulate</a></span> generated by <span class="v">expdata</span>, 
          and cannot be therefore referenced 
          after the call of <span class="v">expdata</span>.</li>
</ul>
</li>
<li><p>The lists <span class="v">arg/res-list1</span>, ..., <span class="v">arg/res-listq</span> 
         are pairwise disjoint, 
         i.e. each <span class="v">xi</span> and <span class="v">:result</span> appears 
         in at most one of those lists.</p></li>
</ul>
<p>In the rest of this documentation page, 
       for each <span class="v">i</span> from 1 to <span class="v">n</span>, 
       let <span class="v">oldpi</span>, <span class="v">newpi</span>, <span class="v">forthi</span>, and <span class="v">backi</span> be:</p>
<ul>
<li>The <span class="v">oldp</span>, <span class="v">newp</span>, <span class="v">forth</span>, and <span class="v">back</span> 
        of the (pre-existing or locally generated) <span class="tt"><a href="ACL2____DEFSURJ.html">defsurj</a></span> 
        specified by <span class="v">surjk</span>, 
        if <span class="v">xi</span> is in <span class="v">arg/res-listk</span>.</li>
<li>The functions 
        <span class="v">(<a href="COMMON-LISP____LAMBDA.html">lambda</a> (x) t)</span>, 
        <span class="v">(<a href="COMMON-LISP____LAMBDA.html">lambda</a> (x) t)</span>, 
        <span class="v">(<a href="COMMON-LISP____LAMBDA.html">lambda</a> (x) x)</span>, and 
        <span class="v">(<a href="COMMON-LISP____LAMBDA.html">lambda</a> (x) x)</span> 
        that form the identity surjective mapping over all values, 
        if <span class="v">xi</span> is not in any <span class="v">arg/res-listk</span>.</li>
</ul>
<p>Furthermore, 
       for each <span class="v">j</span> from 1 to <span class="v">m</span>, 
       let <span class="v">oldp_rj</span>, <span class="v">newp_rj</span>, <span class="v">forth_rj</span>, and <span class="v">back_rj</span> be:</p>
<ul>
<li>The <span class="v">oldp</span>, <span class="v">newp</span>, <span class="v">forth</span>, and <span class="v">back</span> 
        of the (pre-existing or locally generated) <span class="tt"><a href="ACL2____DEFSURJ.html">defsurj</a></span> 
        specified by <span class="v">surjk</span>, 
        if <span class="v">:resultj</span> is in <span class="v">arg/res-listk</span>.</li>
<li>The functions 
        <span class="v">(<a href="COMMON-LISP____LAMBDA.html">lambda</a> (x) t)</span>, 
        <span class="v">(<a href="COMMON-LISP____LAMBDA.html">lambda</a> (x) t)</span>, 
        <span class="v">(<a href="COMMON-LISP____LAMBDA.html">lambda</a> (x) x)</span>, and 
        <span class="v">(<a href="COMMON-LISP____LAMBDA.html">lambda</a> (x) x)</span> 
        that form the identity surjective mapping over all values, 
        if <span class="v">:resultj</span> is not in any <span class="v">arg/res-listk</span>.</li>
</ul>
<p>In the <span class="v">isodata</span> <a href="res/kestrel-apt-design-notes/isodata.pdf" target="_blank"><nobr>design notes<img src="../Icon_External_Link.png" title="External link to res/kestrel-apt-design-notes/isodata.pdf"></nobr></a>, 
       referenced by the <span class="v">expdata</span> <a href="res/kestrel-apt-design-notes/expdata.pdf" target="_blank"><nobr>design notes<img src="../Icon_External_Link.png" title="External link to res/kestrel-apt-design-notes/expdata.pdf"></nobr></a>, 
       the section 
       `Compositional Establishment of Isomorphic Mappings on Tuples' 
       describes the compositional establishment of an isomorphic mapping 
       between the inputs of old and new function; 
       the same concepts apply to surjective mappings. 
       The <span class="v">surjmaps</span> input currently supported by <span class="v">expdata</span> 
       amounts to the following partitioning and sub-mappings:</p>
<ul>
<li>The new function's arguments are the same (i.e. have the same names) 
        as the old function's arguments, i.e. <span class="v">x1</span>, ..., <span class="v">xn</span>.</li>
<li>The new function has the same number of results as the old function.</li>
<li>The arguments are partitioned into <span class="v">n</span> singleton partitions.</li>
<li>The results are partitioned into <span class="v">m</span> singleton partitions.</li>
<li>The surjective mapping consisting of 
        <span class="v">oldpi</span>, <span class="v">newpi</span>, <span class="v">forthi</span>, and <span class="v">backi</span> 
        is used for the partition consisting of argument <span class="v">xi</span>.</li>
<li>The surjective mapping consisting of 
        <span class="v">oldp_rj</span>, <span class="v">newp_rj</span>, <span class="v">forth_rj</span>, and <span class="v">back_rj</span> 
        is used for the partition consisting of result <span class="v">j</span>.</li>
<li>The identity surjective mapping 
        is used for the partitions of all the results, 
        if <span class="v">:result</span> is not in any <span class="v">arg/res-listk</span>.</li>
</ul>
<p>In the <span class="v">expdata</span> <a href="res/kestrel-apt-design-notes/expdata.pdf" target="_blank"><nobr>design notes<img src="../Icon_External_Link.png" title="External link to res/kestrel-apt-design-notes/expdata.pdf"></nobr></a>, 
       the resulting surjecive mapping over all function arguments 
       is denoted as consisting of 
       the domains A and A' and 
       the conversions \alpha and \alpha', 
       and the resulting surjective mapping over all function results 
       is denoted as consisting of 
       the domains B and B' and 
       the conversions \beta and \beta'. 
       The design notes allow these domains and conversions 
       to be specified via (the design notes counterparts of) 
       either <span class="tt"><a href="ACL2____DEFINJ.html">definj</a></span> or <span class="tt"><a href="ACL2____DEFSURJ.html">defsurj</a></span> 
       (in opposite directions); 
       for the currently implemented <span class="v">expdata</span>, 
       only <span class="tt"><a href="ACL2____DEFSURJ.html">defsurj</a></span> may be used.</p>
</blockquote><p><span class="v">:predicate</span> — default <span class="v">nil</span></p><blockquote>
<p>Selects between the two variants of this transformation:</p>
<ul>
<li>
<span class="v">t</span>, to select the variant in which <span class="v">old</span> 
        is treated like a predicate that recognizes 
        argument tuples that are all in the old representation.</li>
<li>
<span class="v">nil</span>, to select the variant in which <span class="v">old</span> 
        is treated as a function that operates 
        only on argument tuples that are all in the old representation.</li>
</ul>
<p>This input may be <span class="v">t</span> only if <span class="v">surjmaps</span> 
       does not include <span class="v">:result</span>.</p>
<p>In the <span class="v">isodata</span> <a href="res/kestrel-apt-design-notes/isodata.pdf" target="_blank"><nobr>design notes<img src="../Icon_External_Link.png" title="External link to res/kestrel-apt-design-notes/isodata.pdf"></nobr></a>, 
       referenced by the <span class="v">expdata</span> <a href="res/kestrel-apt-design-notes/expdata.pdf" target="_blank"><nobr>design notes<img src="../Icon_External_Link.png" title="External link to res/kestrel-apt-design-notes/expdata.pdf"></nobr></a>, 
       the sections with `Function' in their title 
       refer to the case in which <span class="v">:predicate</span> is <span class="v">nil</span>, 
       while the sections with `Predicate' in their title 
       refer to the case in which <span class="v">:predicate</span> is <span class="v">t</span>.</p>
</blockquote><p><span class="v">:new-name</span> — default <span class="v">:auto</span></p><blockquote>
<p>Determines the name of the generated new function.</p>
<p>It must be one of the following:</p>
<ul>
<li>
<span class="v">:auto</span>, to generate the name automatically 
       as described in <a href="APT____FUNCTION-NAME-GENERATION.html">function-name-generation</a>.</li>
<li>Any other symbol, to use as the name of the function.</li>
</ul>
<p>In the rest of this documentation page, 
      let <span class="v">new</span> be this function.</p>
</blockquote><p><span class="v">:new-enable</span> — default <span class="v">:auto</span></p><blockquote>
<p>Determines whether <span class="v">new</span> is enabled.</p>
<p>It must be one of the following:</p>
<ul>
<li>
<span class="v">t</span>, to enable it.</li>
<li>
<span class="v">nil</span>, to disable it.</li>
<li>
<span class="v">:auto</span>, to enable it iff <span class="v">old</span> is enabled.</li>
</ul>
</blockquote><p><span class="v">:old-to-new-name</span> — 
     default from <a href="APT____DEFAULTS-TABLE.html">table</a></p><blockquote>
<p>Determines the name of the theorem that 
      rewrites the old function in terms of the new function.</p>
<p>It must be one of the following:</p>
<ul>
<li>A keyword, to use as separator between 
       the names of <span class="v">old</span> and <span class="v">new</span>. 
       A keyword <span class="v">:kwd</span> specifies the theorem name <span class="v">oldkwdnew</span>, 
       in the same package as <span class="v">new</span>.</li>
<li>Any other symbol, to use as the name of the theorem.</li>
<li>Absent, to use the value from the APT defaults table, 
       which is set via <span class="tt"><a href="APT____SET-DEFAULT-INPUT-OLD-TO-NEW-NAME.html">set-default-input-old-to-new-name</a></span>.</li>
</ul>
<p>In the rest of this documentation page, 
      let <span class="v">old-to-new</span> be the name of this theorem.</p>
</blockquote><p><span class="v">:old-to-new-enable</span> — 
     default from <a href="APT____DEFAULTS-TABLE.html">table</a></p><blockquote>
<p>Determines whether the <span class="v">old-to-new</span> theorem is enabled.</p>
<p>It must be one of the following:</p>
<ul>
<li>
<span class="v">t</span>, to enable the theorem.</li>
<li>
<span class="v">nil</span>, to disable the theorem.</li>
<li>Absent, to use the value from the APT defaults table, 
       which is set via <span class="tt"><a href="APT____SET-DEFAULT-INPUT-OLD-TO-NEW-ENABLE.html">set-default-input-old-to-new-enable</a></span>.</li>
</ul>
<p>If this input is <span class="v">t</span>, 
      the <span class="v">:new-to-old-enable</span> input must be <span class="v">nil</span>. 
      At most one of these two inputs may be <span class="v">t</span> at any time.</p>
</blockquote><p><span class="v">:new-to-old-name</span> — 
     default from <a href="APT____DEFAULTS-TABLE.html">table</a></p><blockquote>
<p>Determines the name of the theorem that 
      rewrites the new function in terms of the old function.</p>
<p>It must be one of the following:</p>
<ul>
<li>A keyword, to use as separator between 
       the names of <span class="v">new</span> and <span class="v">old</span>. 
       A keyword <span class="v">:kwd</span> specifies the theorem name <span class="v">newkwdold</span>, 
       in the same package as <span class="v">new</span>.</li>
<li>Any other symbol, to use as the name of the theorem.</li>
<li>Absent, to use the value from the APT defaults table, 
       which is set via <span class="tt"><a href="APT____SET-DEFAULT-INPUT-NEW-TO-OLD-NAME.html">set-default-input-new-to-old-name</a></span>.</li>
</ul>
<p>In the rest of this documentation page, 
      let <span class="v">new-to-old</span> be the name of this theorem.</p>
</blockquote><p><span class="v">:new-to-old-enable</span> — 
     default from <a href="APT____DEFAULTS-TABLE.html">table</a></p><blockquote>
<p>Determines whether the <span class="v">new-to-old</span> theorem is enabled.</p>
<p>It must be one of the following:</p>
<ul>
<li>
<span class="v">t</span>, to enable the theorem.</li>
<li>
<span class="v">nil</span>, to disable the theorem.</li>
<li>Absent, to use the value from the APT defaults table, 
       which is set via <span class="tt"><a href="APT____SET-DEFAULT-INPUT-NEW-TO-OLD-ENABLE.html">set-default-input-new-to-old-enable</a></span>.</li>
</ul>
<p>If this input is <span class="v">t</span>, 
      the <span class="v">:old-to-new-enable</span> input must be <span class="v">nil</span>. 
      At most one of these two inputs may be <span class="v">t</span> at any time.</p>
</blockquote><p><span class="v">:newp-of-new-name</span> — default <span class="v">:auto</span></p><blockquote>
<p>Determines the name of the theorem asserting that <span class="v">new</span> maps 
       arguments in the new representation 
       to results in the new representation.</p>
<p>It must be one of the following:</p>
<ul>
<li>
<span class="v">:auto</span>, to use the concatenation of 
        the name of <span class="v">new</span> followed by <span class="v">-new-representation</span>, 
        in the same package as <span class="v">new</span>.</li>
<li>Any other symbol, to use as the name of the theorem.</li>
</ul>
<p>This input may be present only if 
       <span class="v">surjmaps</span> includes some <span class="v">:resultj</span>.</p>
<p>In the rest of this documentation page, 
       let <span class="v">newp-of-new</span> be the name of this theorem.</p>
</blockquote><p><span class="v">:newp-of-new-enable</span> — default <span class="v">t</span></p><blockquote>
<p>Determines whether <span class="v">newp-of-new</span> is enabled.</p>
<p>It must be one of the following:</p>
<ul>
<li>
<span class="v">t</span>, to enable the theorem.</li>
<li>
<span class="v">nil</span>, to disable the theorem.</li>
</ul>
<p>This input may be present only if 
       <span class="v">surjmaps</span> includes some <span class="v">:resultj</span>.</p>
</blockquote><p><span class="v">:verify-guards</span> — default <span class="v">:auto</span></p><blockquote>
<p>Determines whether the guards of the generated functions are verified or not.</p>
<p>It must be one of the following:</p>
<ul>
<li>
<span class="v">t</span>, to verify the guards.</li>
<li>
<span class="v">nil</span>, to not verify guards.</li>
<li>
<span class="v">:auto</span>, to verify the guards if and only if 
       the guards of the target function <span class="v">old</span> are verified.</li>
</ul>
</blockquote><p><span class="v">:untranslate</span> — default <span class="v">:nice</span></p><blockquote>
<p>Specifies if and how the body of <span class="v">new</span> should be turned 
      from internal translated form to external untranslated form.</p>
<p>It must be an <a href="APT____UNTRANSLATE-SPECIFIER.html">untranslate specifier</a>; see that documentation topic for details.</p>
</blockquote><p><span class="v">:hints</span> — default <span class="v">nil</span></p><blockquote>
<p>Hints to prove the applicability conditions.</p>
<p>It must be one of the following:</p>
<ul>
<li>A <a href="ACL2____KEYWORD-VALUE-LISTP.html">keyword-value list</a> <span class="v">(appcond1 hints1 appcond2 hints2 ...)</span>, 
         where each <span class="v">appcondk</span> is a keyword 
         that identifies one of the applicability conditions 
         listed in the `Applicability Conditions' section and each <span class="v">hintsk</span> is a list of hints of the kind 
         that may appear just after <span class="v">:hints</span> in a <span class="tt"><a href="ACL2____DEFTHM.html">defthm</a></span>. 
         The hints <span class="v">hintsk</span> are used 
         to prove applicability condition <span class="v">appcondk</span>. 
         The <span class="v">appcond1</span>, <span class="v">appcond2</span>, ... keywords must be all distinct. 
         An <span class="v">appcondk</span> keyword is allowed only if 
         the corresponding applicability condition is present, 
         as specified in the `Applicability Conditions' section.</li>
<li>A list of hints of the kind 
         that may appear just after <span class="v">:hints</span> in a <span class="tt"><a href="ACL2____DEFTHM.html">defthm</a></span>. 
         In this case, these same hints are used 
         to prove every applicability condition,.</li>
</ul>
</blockquote><p><span class="v">:print</span> — default <span class="v">:result</span></p><blockquote>
<p>Specifies what is printed on the screen 
        (see <a href="ACL2____EVENT-MACRO-SCREEN-PRINTING.html">ACL2::event-macro-screen-printing</a>).</p>
<p>It must be one of the following:</p>
<ul>
<li>
<span class="v">nil</span>, to print nothing (not even error output).</li>
<li>
<span class="v">:error</span>, to print only error output (if any).</li>
<li>
<span class="v">:result</span>, to print, besides any error output, 
         also the <a href="ACL2____EVENT-MACRO-RESULTS.html">results</a> of <span class="v">expdata</span>. 
         This is the default value of the <span class="v">:print</span> input.</li>
<li>
<span class="v">:info</span>, to print, 
         besides any error output and the results, 
         also some additional information about 
         the internal operations of <span class="v">expdata</span>.</li>
<li>
<span class="v">:all</span>, to print, 
          besides any error output, 
          the results, 
          and the additional information, 
          also ACL2's output in response to all the submitted events.</li>
</ul>
<p>If the call of <span class="v">expdata</span> is redundant, 
        an indication to that effect is printed on the screen, 
        unless <span class="v">:print</span> is <span class="v">nil</span>.</p>
</blockquote><p><span class="v">:show-only</span> — default <span class="v">nil</span></p><blockquote>
<p>Determines whether the event expansion of <span class="v">expdata</span> is submitted to ACL2 or just printed on the screen:</p>
<ul>
<li>
<span class="v">nil</span>, to submit it.</li>
<li>
<span class="v">t</span>, to just print it. 
            In this case: 
            the event expansion is printed even if <span class="v">:print</span> is <span class="v">nil</span> 
            (because the user has explicitly asked to show the event expansion); 
            the resulting events are not re-printed separately 
            (other than their appearance in the printed event expansion) 
            even if <span class="v">:print</span> is <span class="v">:result</span> or <span class="v">:info</span> or <span class="v">:all</span>; 
            no ACL2 output is printed for the event expansion 
            even if <span class="v">:print</span> is <span class="v">:all</span> 
            (because the event expansion is not submitted). 
            If the call of <span class="v">expdata</span> is redundant 
            (as defined in the `Redundancy' section), the event expansion generated by the existing call 
            is printed.</li>
</ul>
</blockquote><h3>Applicability Conditions</h3><p>In order for <span class="v">expdata</span> to apply, 
        in addition to the requirements on the inputs 
        stated in the `Inputs' section, the following <a href="ACL2____EVENT-MACRO-APPLICABILITY-CONDITIONS.html">applicability conditions</a> must be proved. 
         The proofs are attempted when <span class="v">expdata</span> is called, 
        using the hints optionally supplied as the <span class="v">:hints</span> input 
        described in the `Inputs' section.</p><p>The following conditions must be proved 
      in order for the transformation to apply.</p><p><span class="v">:oldp-of-old</span></p><blockquote>
<p><span class="v">old</span> maps arguments in the old representation 
        to results in the old representation:</p>
<pre class="code">;; when m = 1:
(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (oldp1 x1)
              ...
              (oldpn xn))
         (oldp_r1 (old x1 ... xn)))

;; when m &gt; 1:
(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (oldp1 x1)
              ...
              (oldpn xn))
         (<a href="ACL2____MV-LET.html">mv-let</a> (y1 ... ym)
           (old x1 ... xn)
           (<a href="COMMON-LISP____AND.html">and</a> (oldp_r1 y1)
                ...
                (oldp_rm ym))))</pre>
<p>This corresponds to fAB in the <span class="v">isodata</span> <a href="res/kestrel-apt-design-notes/isodata.pdf" target="_blank"><nobr>design notes<img src="../Icon_External_Link.png" title="External link to res/kestrel-apt-design-notes/isodata.pdf"></nobr></a>, referenced by the <span class="v">expdata</span> <a href="res/kestrel-apt-design-notes/expdata.pdf" target="_blank"><nobr>design notes<img src="../Icon_External_Link.png" title="External link to res/kestrel-apt-design-notes/expdata.pdf"></nobr></a>,.</p>
<p>This applicability condition is present if and only if <span class="v">surjmaps</span> includes some <span class="v">:resultj</span>.</p>
</blockquote><p><span class="v">:oldp-when-old</span></p><blockquote>
<p><span class="v">old</span> holds only on argument tuples 
        such that <span class="v">x1</span>, ..., <span class="v">xn</span> are all in the old representation:</p>
<pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (old x1 ... xn)
         (<a href="COMMON-LISP____AND.html">and</a> (oldp1 x1)
              ...
              (oldpn xn)))</pre>
<p>This corresponds to pA in the <span class="v">isodata</span> <a href="res/kestrel-apt-design-notes/isodata.pdf" target="_blank"><nobr>design notes<img src="../Icon_External_Link.png" title="External link to res/kestrel-apt-design-notes/isodata.pdf"></nobr></a>, referenced by the <span class="v">expdata</span> <a href="res/kestrel-apt-design-notes/expdata.pdf" target="_blank"><nobr>design notes<img src="../Icon_External_Link.png" title="External link to res/kestrel-apt-design-notes/expdata.pdf"></nobr></a>,.</p>
<p>This applicability condition is present if and only if <span class="v">:predicate</span> is <span class="v">t</span>.</p>
</blockquote><p><span class="v">:oldp-of-rec-call-args</span></p><blockquote>
<p>The old representation is preserved on 
        the arguments of the recursive calls of <span class="v">old</span>:</p>
<pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (oldp1 x1)
              ...
              (oldpn xn))
         (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____IMPLIES.html">implies</a> context1&lt;x1,...,xn&gt;
                       (<a href="COMMON-LISP____AND.html">and</a> (oldp1 update1-x1&lt;x1,...,xn&gt;)
                            ...
                            (oldpn update1-xn&lt;x1,...,xn&gt;)))
              ...
              (<a href="ACL2____IMPLIES.html">implies</a> contextr&lt;x1,...,xn&gt;
                       (<a href="COMMON-LISP____AND.html">and</a> (oldp1 updater-x1&lt;x1,...,xn&gt;)
                            ...
                            (oldpn updater-xp&lt;x1,...,xn&gt;)))))</pre>
<p>This corresponds to Ad in the <span class="v">isodata</span> <a href="res/kestrel-apt-design-notes/isodata.pdf" target="_blank"><nobr>design notes<img src="../Icon_External_Link.png" title="External link to res/kestrel-apt-design-notes/isodata.pdf"></nobr></a>, referenced by the <span class="v">expdata</span> <a href="res/kestrel-apt-design-notes/expdata.pdf" target="_blank"><nobr>design notes<img src="../Icon_External_Link.png" title="External link to res/kestrel-apt-design-notes/expdata.pdf"></nobr></a>,.</p>
<p>This applicability condition is present if and only if <span class="v">old</span> is recursive.</p>
</blockquote><p><span class="v">:old-guard</span></p><blockquote>
<p><span class="v">old</span> is well-defined (according to its guard) 
        only on tuples in the old representation:</p>
<pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> old-guard&lt;x1,...,xn&gt;
         (<a href="COMMON-LISP____AND.html">and</a> (oldp1 x1)
              ...
              (oldpn xn)))</pre>
<p>This corresponds to Gf in the <span class="v">isodata</span> <a href="res/kestrel-apt-design-notes/isodata.pdf" target="_blank"><nobr>design notes<img src="../Icon_External_Link.png" title="External link to res/kestrel-apt-design-notes/isodata.pdf"></nobr></a>, referenced by the <span class="v">expdata</span> <a href="res/kestrel-apt-design-notes/expdata.pdf" target="_blank"><nobr>design notes<img src="../Icon_External_Link.png" title="External link to res/kestrel-apt-design-notes/expdata.pdf"></nobr></a>,.</p>
<p>This applicability condition is present if and only if the generated function is guard-verified 
                (which is determined by the <span class="v">:verify-guards</span> input; 
                see above) 
                and <span class="v">:predicate</span> is <span class="v">nil</span>.</p>
</blockquote><p><span class="v">:old-guard-pred</span></p><blockquote>
<p><span class="v">old</span> is well-defined (according to its guard) 
        on all tuples in the old representation:</p>
<pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (oldp1 x1)
              ...
              (oldpn xn))
         old-guard&lt;x1,...,xn&gt;)</pre>
<p>This corresponds to Gp in the <span class="v">isodata</span> <a href="res/kestrel-apt-design-notes/isodata.pdf" target="_blank"><nobr>design notes<img src="../Icon_External_Link.png" title="External link to res/kestrel-apt-design-notes/isodata.pdf"></nobr></a>, referenced by the <span class="v">expdata</span> <a href="res/kestrel-apt-design-notes/expdata.pdf" target="_blank"><nobr>design notes<img src="../Icon_External_Link.png" title="External link to res/kestrel-apt-design-notes/expdata.pdf"></nobr></a>,.</p>
<p>This applicability condition is present if and only if the generated function is guard-verified 
                (which is determined by the <span class="v">:verify-guards</span> input; 
                see above) 
                and <span class="v">:predicate</span> is <span class="v">t</span>.</p>
</blockquote><p>Unless <span class="v">surj1</span>, ..., <span class="v">surjq</span> 
      are all names of pre-existing <span class="tt"><a href="ACL2____DEFSURJ.html">defsurj</a></span>s, 
      there are additional applicability conditions 
      that pertain to the locally generated <span class="tt"><a href="ACL2____DEFSURJ.html">defsurj</a></span>s. 
      These additional applicability conditions are described 
      in the documentation of <span class="tt"><a href="ACL2____DEFSURJ.html">defsurj</a></span>.</p><h3>Generated Events</h3><p><span class="v">new</span></p><blockquote>
<p>Expanded version of <span class="v">old</span>:</p>
<pre class="code">;; when old is not recursive
;; and :predicate is t:
(<a href="COMMON-LISP____DEFUN.html">defun</a> new (x1 ... xn)
  (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____MBT_42.html">mbt$</a> (<a href="COMMON-LISP____AND.html">and</a> (newp1 x1)
                  ...
                  (newpn xn)))
       old-body&lt;(back1 x1),...,(backn xn)&gt;))

;; when old is not recursive,
;; :predicate is nil:
;; and surjmaps includes no :resultj:
(<a href="COMMON-LISP____DEFUN.html">defun</a> new (x1 ... xn)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____MBT_42.html">mbt$</a> (<a href="COMMON-LISP____AND.html">and</a> (newp1 x1)
                 ...
                 (newpn xn)))
      old-body&lt;(back1 x1),...,(backn xn)&gt;
    nil)) ; or (<a href="ACL2____MV.html">mv</a> nil ... nil)

;; when old is not recursive,
;; :predicate is nil,
;; m = 1,
;; and surjmaps includes :result1 (<a href="COMMON-LISP____OR.html">or</a> :result):

(<a href="COMMON-LISP____DEFUN.html">defun</a> new (x1 ... xn)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____MBT_42.html">mbt$</a> (<a href="COMMON-LISP____AND.html">and</a> (newp1 x1)
                 ...
                 (newpn xn)))
      (forth_r1 old-body&lt;(back1 x1),...,(backn xn)&gt;)
    nil))

;; when old is not recursive,
;; :predicate is nil,
;; m &gt; 1,
;; and surjmaps includes some :resultj:
(<a href="COMMON-LISP____DEFUN.html">defun</a> new (x1 ... xn)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____MBT_42.html">mbt$</a> (<a href="COMMON-LISP____AND.html">and</a> (newp1 x1)
                 ...
                 (newpn xn)))
      (<a href="ACL2____MV-LET.html">mv-let</a> (y1 ... ym)
        old-body&lt;(back1 x1),...,(backn xn)&gt;
        (<a href="ACL2____MV.html">mv</a> (forth_r1 y1) ... (forth_rm ym)))
    (<a href="ACL2____MV.html">mv</a> nil ... nil)))

;; when old is recursive
;; and :predicate is t:
(<a href="COMMON-LISP____DEFUN.html">defun</a> new (x1 ... xn)
  (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____MBT_42.html">mbt$</a> (<a href="COMMON-LISP____AND.html">and</a> (newp1 x1)
                  ...
                  (newpn xn)))
       old-body&lt;(back1 x1),...,(backn xn),
                (new (forth1 update1-x1&lt;(back1 x1),
                                        ...,
                                        (backn xn)&gt;)
                     ...
                     (forthn update1-xn&lt;(back1 x1),
                                        ...,
                                        (backn xn)&gt;)),
                ...
                (new (forth1 updater-x1&lt;(back1 x1),
                                        ...,
                                        (backn xn)&gt;)
                     ...
                     (forthn updater-xn&lt;(back1 x1),
                                        ...,
                                        (backn xn)&gt;))&gt;))

;; when old is recursive,
;; :predicate is nil,
;; and surjmaps includes no :resultj:
(<a href="COMMON-LISP____DEFUN.html">defun</a> new (x1 ... xn)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____MBT_42.html">mbt$</a> (<a href="COMMON-LISP____AND.html">and</a> (newp1 x1)
                 ...
                 (newpn xn)))
      old-body&lt;(back1 x1),...,(backn xn),
               (new (forth1 update1-x1&lt;(back1 x1),
                                       ...,
                                       (backn xn)&gt;)
                    ...
                    (forthn update1-xn&lt;(back1 x1),
                                       ...,
                                       (backn xn)&gt;)),
               ...
               (new (forth1 updater-x1&lt;(back1 x1),
                                       ...,
                                       (backn xn)&gt;)
                    ...
                    (forthn updater-xn&lt;(back1 x1),
                                       ...,
                                       (backn xn)&gt;))&gt;
    nil)) ; or (<a href="ACL2____MV.html">mv</a> nil ... nil)

;; when old is recursive,
;; :predicate is nil,
;; m = 1,
;; and surjmaps include :result1 (<a href="COMMON-LISP____OR.html">or</a> :result):
(<a href="COMMON-LISP____DEFUN.html">defun</a> new (x1 ... xn)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____MBT_42.html">mbt$</a> (<a href="COMMON-LISP____AND.html">and</a> (newp1 x1)
                 ...
                 (newpn xn)))
      (forth_r1 old-body&lt;(back1 x1),...,(backn xn),
                         (back_r1
                          (new (forth1 update1-x1&lt;(back1 x1),
                                                  ...,
                                                  (backn xn)&gt;)
                               ...
                               (forthn update1-xn&lt;(back1 x1),
                                                  ...,
                                                  (backn xn)&gt;))),
                         ...
                         (back_r1
                          (new (forth1 updater-x1&lt;(back1 x1),
                                                  ...,
                                                  (backn xn)&gt;)
                               ...
                               (forthn updater-xn&lt;(back1 x1),
                                                  ...,
                                                  (backn xn)&gt;)))&gt;)
    nil))

;; when old is recursive,
;; :predicate is nil,
;; m &gt; 1,
;; and surjmaps includes some :resultj:
(<a href="COMMON-LISP____DEFUN.html">defun</a> new (x1 ... xn)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____MBT_42.html">mbt$</a> (<a href="COMMON-LISP____AND.html">and</a> (newp1 x1)
                 ...
                 (newpn xn)))
      (<a href="ACL2____MV-LET.html">mv-let</a> (y1 ... ym)
        old-body&lt;(back1 x1),...,(backn xn),
                 (<a href="ACL2____MV-LET.html">mv-let</a> (y1 ... ym)
                   (new (forth1 update1-x1&lt;(back1 x1),
                                           ...,
                                           (backn xn)&gt;)
                        ...
                        (forthn update1-xn&lt;(back1 x1),
                                           ...,
                                           (backn xn)&gt;))
                   (<a href="ACL2____MV.html">mv</a> (forth_r1 y1) ... (forth_rm ym))),
                 ...
                 (<a href="ACL2____MV-LET.html">mv-let</a> (y1 ... ym)
                   (new (forth1 updater-x1&lt;(back1 x1),
                                           ...,
                                           (backn xn)&gt;)
                        ...
                        (forthn updater-xn&lt;(back1 x1),
                                           ...,
                                           (backn xn)&gt;))
                   (<a href="ACL2____MV.html">mv</a> (forth_r1 y1) ... (forth_rm ym)))&gt;
        (<a href="ACL2____MV.html">mv</a> (forth_r1 y1) ... (forth_rm ym)))
    (<a href="ACL2____MV.html">mv</a> nil ... nil)))</pre>
<p>If <span class="v">old</span> is recursive, 
       the measure term of <span class="v">new</span> is 
       <span class="v">measure&lt;(back1 x1),...,(backn xn)&gt;</span> 
       and the well-founded relation of <span class="v">new</span> is 
       the same as <span class="v">old</span>.</p>
<p>The guard of <span class="v">new</span> is:</p>
<pre class="code">;; when :predicate is nil:
(<a href="COMMON-LISP____AND.html">and</a> (newp1 x1)
     ...
     (newpn xn)
     old-guard&lt;(back1 x1),...,(backn xn)&gt;)

;; when :predicate is t:
(<a href="COMMON-LISP____AND.html">and</a> (newp1 x1)
     ...
     (newpn xn))</pre>
<p>That is, when <span class="v">:predicate</span> is <span class="v">t</span> 
       the guard consists of the new representation; 
       when <span class="v">:predicate</span> is <span class="v">nil</span>, 
       the guard consists of the argument tuples 
       that are in the surjection's preimage of the guard of <span class="v">old</span>.</p>
<p>In the <span class="v">isodata</span> <a href="res/kestrel-apt-design-notes/isodata.pdf" target="_blank"><nobr>design notes<img src="../Icon_External_Link.png" title="External link to res/kestrel-apt-design-notes/isodata.pdf"></nobr></a>, 
       referenced by the <span class="v">expdata</span> <a href="res/kestrel-apt-design-notes/expdata.pdf" target="_blank"><nobr>design notes<img src="../Icon_External_Link.png" title="External link to res/kestrel-apt-design-notes/expdata.pdf"></nobr></a>, 
       <span class="v">new</span> is denoted by 
       f' when <span class="v">:predicate</span> is <span class="v">nil</span>, 
       and p' when <span class="v">:predicate</span> is <span class="v">t</span>.</p>
<p>Note that:</p>
<ul>
<li>When <span class="v">:predicate</span> is <span class="v">t</span>, 
        <span class="v">new</span> is defined to hold exactly 
        on the argument tuples in the new representation 
        that are in the surjection's preimage of 
        the argument tuples in the old representation 
        on which <span class="v">old</span> holds.</li>
<li>When <span class="v">:predicate</span> is <span class="v">nil</span>, 
        <span class="v">new</span> is defined to map 
        each argument tuple in the new representation 
        to the same or corresponding value 
        (where `corresponding' here means in the surjection's preimage) 
        that <span class="v">old</span> maps 
        the corresponding argument tuple in the old representation 
        (where `corresponding' here means in the surjection's image).</li>
</ul>
</blockquote><p><span class="v">new-to-old</span></p><blockquote>
<p>Theorem that relates <span class="v">new</span> to <span class="v">old</span>:</p>
<pre class="code">;; when :predicate is t:
(<a href="ACL2____DEFTHM.html">defthm</a> new-to-old
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (newp1 x1)
                ...
                (newpn xn))
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (new x1 ... xn)
                  (old (back1 x1) ... (backn xn)))))

;; when :predicate is nil
;; and surjmaps includes no :resultj:
(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (newp1 x1)
              ...
              (newpn xn))
         (<a href="COMMON-LISP____EQUAL.html">equal</a> (new x1 ... xn)
                (old (back1 x1) ... (backn xn))))

;; when :predicate is nil,
;; m = 1,
;; and surjmaps includes :result1 (<a href="COMMON-LISP____OR.html">or</a> :result):
(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (newp1 x1)
              ...
              (newp1 xn))
         (<a href="COMMON-LISP____EQUAL.html">equal</a> (new x1 ... xn)
                (forth_r1 (old (back1 x1) ... (backn xn)))))

;; when :predicate is nil,
;; m &gt; 1,
;; and surjmaps includes some :resultj:
(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (newp1 x1)
              ...
              (newp1 xn))
         (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> 0 (new x1 ... xn))
                     (forth_r1 (<a href="ACL2____MV-NTH.html">mv-nth</a> 0 (old (back1 x1)
                                              ...
                                              (backn xn)))))
              ...
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> m-1 (new x1 ... xn))
                     (forth_rm (<a href="ACL2____MV-NTH.html">mv-nth</a> m-1 (old (back1 x1)
                                                ...
                                                (backn xn)))))))</pre>
<p>In the <span class="v">isodata</span> <a href="res/kestrel-apt-design-notes/isodata.pdf" target="_blank"><nobr>design notes<img src="../Icon_External_Link.png" title="External link to res/kestrel-apt-design-notes/isodata.pdf"></nobr></a>, 
       referenced by the <span class="v">expdata</span> <a href="res/kestrel-apt-design-notes/expdata.pdf" target="_blank"><nobr>design notes<img src="../Icon_External_Link.png" title="External link to res/kestrel-apt-design-notes/expdata.pdf"></nobr></a>, 
       <span class="v">new-to-old</span> is denoted by 
       f'f when <span class="v">:predicate</span> is <span class="v">nil</span>, 
       and 'pp when <span class="v">:predicate</span> is <span class="v">t</span>.</p>
</blockquote><p><span class="v">old-to-new</span></p><blockquote>
<p>Theorem that relates <span class="v">old</span> to <span class="v">new</span>:</p>
<pre class="code">;; when :predicate is t:
(<a href="ACL2____DEFTHM.html">defthm</a> old-to-new
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (oldp1 x1)
                ...
                (oldpn xn))
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (old x1 ... xn)
                  (new (forth1 x1) ... (forthn xn)))))

;; when :predicate is nil
;; and surjmaps includes no :resultj:
(<a href="ACL2____DEFTHM.html">defthm</a> old-to-new
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (oldp1 x1)
                ...
                (oldpn xn))
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (old x1 ... xn)
                  (new (forth1 x1) ... (forthn xn)))))

;; when :predicate is nil,
;; m = 1,
;; and surjmaps includes :result1 (<a href="COMMON-LISP____OR.html">or</a> :result):
(<a href="ACL2____DEFTHM.html">defthm</a> old-to-new
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (oldp1 x1)
                ...
                (oldpn xn))
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (old x1 ... xn)
                  (back_r1 (new (forth1 x1) ... (forthn xn))))))

;; when :predicate is nil,
;; m &gt; 1,
;; and surjmaps includes some :resultj:
(<a href="ACL2____DEFTHM.html">defthm</a> old-to-new
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (oldp1 x1)
                ...
                (oldpn xn))
           (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> 0 (old x1 ... xn))
                       (back_r1 (<a href="ACL2____MV-NTH.html">mv-nth</a> 0 (new (forth1 x1)
                                               ...
                                               (forthn xn)))))
                ...
                (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> m-1 (old x1 ... xn))
                       (back_rm (<a href="ACL2____MV-NTH.html">mv-nth</a> m-1 (new (forth1 x1)
                                                 ...
                                                 (forthn xn))))))))</pre>
<p>In the <span class="v">isodata</span> <a href="res/kestrel-apt-design-notes/isodata.pdf" target="_blank"><nobr>design notes<img src="../Icon_External_Link.png" title="External link to res/kestrel-apt-design-notes/isodata.pdf"></nobr></a>, 
       referenced by the <span class="v">expdata</span> <a href="res/kestrel-apt-design-notes/expdata.pdf" target="_blank"><nobr>design notes<img src="../Icon_External_Link.png" title="External link to res/kestrel-apt-design-notes/expdata.pdf"></nobr></a>, 
       <span class="v">old-to-new</span> is denoted by 
       ff' when <span class="v">:predicate</span> is <span class="v">nil</span>, 
       and pp' when <span class="v">:predicate</span> is <span class="v">t</span>.</p>
</blockquote><p><span class="v">newp-of-new</span></p><blockquote>
<p>Theorem asserting that <span class="v">new</span> maps 
       arguments in the new representation 
       to results in the new representation:</p>
<pre class="code">;; when m = 1:
(<a href="ACL2____DEFTHM.html">defthm</a> newp-of-new
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (newp1 x1)
                ...
                (newpn xn))
           (newp_r1 (new x1 ... xn))))

;; when m &gt; 1:
(<a href="ACL2____DEFTHM.html">defthm</a> newp-of-new
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (newp1 x1)
                ...
                (newpn xn))
           (<a href="ACL2____MV-LET.html">mv-let</a> (y1 ... ym)
             (new x1 ... xn)
             (<a href="COMMON-LISP____AND.html">and</a> (newp_r1 y1)
                  ...
                  (newp_rm ym)))))</pre>
<p>In the <span class="v">isodata</span> <a href="res/kestrel-apt-design-notes/isodata.pdf" target="_blank"><nobr>design notes<img src="../Icon_External_Link.png" title="External link to res/kestrel-apt-design-notes/isodata.pdf"></nobr></a>, 
       referenced by the <span class="v">expdata</span> <a href="res/kestrel-apt-design-notes/expdata.pdf" target="_blank"><nobr>design notes<img src="../Icon_External_Link.png" title="External link to res/kestrel-apt-design-notes/expdata.pdf"></nobr></a>, 
       <span class="v">newp-of-new</span> is denoted by f'A'B'.</p>
<p>This is generated if and only if 
       <span class="v">surjmaps</span> includes some <span class="v">:resultj</span>.</p>
</blockquote><p>A theory invariant is also generated to prevent 
       both <span class="v">new-to-old</span> and <span class="v">old-to-new</span> 
       from being enabled at the same time.</p><h3>Redundancy</h3><p>A call of <span class="v">expdata</span> is redundant if and only if 
         it is identical to a previous successful call of <span class="v">expdata</span> whose <span class="v">:show-only</span> input is not <span class="v">t</span>, 
         except that the two calls may differ in 
         their <span class="v">:print</span> and <span class="v">:show-only</span> inputs. 
         These inputs do not affect the generated events, 
         and thus they are ignored for the purpose of redundancy.</p><p>A call of <span class="v">expdata</span> whose <span class="v">:show-only</span> input is <span class="v">t</span> 
         does not generate any event. 
         Thus, no successive call may be redundant with such a call.</p>
</body>
</html>
