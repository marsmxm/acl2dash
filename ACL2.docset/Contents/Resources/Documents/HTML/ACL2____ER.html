<html>
<head>
<meta charset="UTF-8">
<title>Er</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____ER">Click for Er in the Full Manual</a></h3>

<p>Print an error message and ``cause an error''</p><p>See <a href="ACL2____FMT.html">fmt</a> for a general discussion of formatted printing in 
 ACL2.  All calls of <span class="v">er</span> print formatted strings, just as is done by <span class="tt"><a href="ACL2____FMT.html">fmt</a></span>.</p> 
 
 <pre class="code">Example Forms:
(<a href="ACL2____ER.html">er</a> hard  'top-level "Illegal inputs, ~x0 and ~x1." a b)
(<a href="ACL2____ER.html">er</a> hard? 'top-level "Illegal inputs, ~x0 and ~x1." a b)
(<a href="ACL2____ER.html">er</a> hard! 'top-level "Illegal inputs, ~x0 and ~x1." a b)
(<a href="ACL2____ER.html">er</a> soft  'top-level "Illegal inputs, ~x0 and ~x1." a b)
(<a href="ACL2____ER-SOFT.html">er-soft</a>  'top-level "Illegal-inputs" "Illegal inputs, ~x0 and ~x1." a b)</pre> 
 
 <p>The examples above all print an error message to standard output saying 
 that <span class="v">a</span> and <span class="v">b</span> are illegal inputs.  However, the first three abort 
 evaluation after printing an error message (while logically returning 
 <span class="v">nil</span>, though in ordinary evaluation the return value is never seen); while 
 the last two return <span class="v">(<a href="ACL2____MV.html">mv</a> t nil state)</span> after printing an error message. 
 The result in each of the last two cases can be interpreted as an ``error'' 
 when programming with the ACL2 <span class="tt"><a href="ACL2____STATE.html">state</a></span>, something most ACL2 users will 
 probably not want to do unless they are building systems of some sort; see 
 <a href="ACL2____PROGRAMMING-WITH-STATE.html">programming-with-state</a>.  If state is not available in the current 
 context then you will probably want to use a call other than the last to cause 
 an error; for example, if you are returning two values, you may write 
 <span class="v">(<a href="ACL2____MV.html">mv</a> (<a href="ACL2____ER.html">er</a> hard ...) nil)</span>.</p> 
 
 <p>The difference between the <span class="v">hard</span> and <span class="v">hard?</span> forms is one of guards. 
 Use <span class="v">hard</span> if you want the call to generate a (clearly impossible) guard 
 proof obligation of (essentially) <span class="v">NIL</span>.  But use <span class="v">hard?</span> if you want to 
 be able to call this function in guard-verified code, since the call generates 
 a (trivially satisfied) guard proof obligation of <span class="v">T</span>.</p> 
 
 <p>The difference between the <span class="v">hard</span> and <span class="v">hard!</span> forms is that there are 
 situations in which <span class="v">(<a href="ACL2____ER.html">er</a> hard ...)</span> returns <span class="v">nil</span> rather than causing an 
 error, while <span class="v">(<a href="ACL2____ER.html">er</a> hard! ...)</span> will always cause an error (though such 
 errors are sometimes ``caught'', for example during proofs).  You will 
 probably be happy using <span class="v">hard</span> rather than considering the use of 
 <span class="v">hard!</span>, which is really provided mostly for system implementors; but you 
 can try <span class="v">hard!</span> if you are not getting the errors you expect.  There is 
 even an additional option, <span class="v">hard?!</span>, which avoids guard proof obligations 
 like <span class="v">hard?</span> but ensures errors like <span class="v">hard!</span>.</p> 
 
 <p><span class="v">Er</span> is a macro, and the above examples expand to calls of ACL2 
 functions, as shown below.  See <a href="ACL2____ILLEGAL.html">illegal</a>, see <a href="ACL2____HARD-ERROR.html">hard-error</a>, and see 
 <a href="ACL2____ERROR1.html">error1</a>.  The <span class="v">hard?</span>/<span class="v">hard?!</span> forms have guards of (essentially) 
 <span class="v">NIL</span> while the <span class="v">hard</span>/<span class="v">hard!</span> forms have guards of (essentially) 
 <span class="v">T</span>.  <span class="tt"><a href="ACL2____ERROR1.html">Error1</a></span>, on the other hand, is in <span class="v">:</span><span class="tt"><a href="ACL2____PROGRAM.html">program</a></span> 
 mode; for variants of <span class="v">(<a href="ACL2____ER.html">er</a> soft ...)</span> that generate <span class="v">:</span><span class="tt"><a href="ACL2____LOGIC.html">logic</a></span> 
 mode code, see <a href="ACL2____ER-SOFT-LOGIC.html">er-soft-logic</a> and <a href="ACL2____ER-SOFT_B2.html">er-soft+</a>.</p> 
 
 <pre class="code">General Forms:
(<a href="ACL2____ER.html">er</a> hard  ctx fmt-string arg1 arg2 ... argk)
  ==&gt; {macroexpands, in essence, to:}
(<a href="ACL2____ILLEGAL.html">ILLEGAL</a>    CTX FMT-STRING
            (<a href="COMMON-LISP____LIST.html">LIST</a> (<a href="COMMON-LISP____CONS.html">CONS</a> #\0 ARG1) (<a href="COMMON-LISP____CONS.html">CONS</a> #\1 ARG2) ... (<a href="COMMON-LISP____CONS.html">CONS</a> #\k ARGk)))

(<a href="ACL2____ER.html">er</a> hard? ctx fmt-string arg1 arg2 ... argk)
  ==&gt; {macroexpands, in essence, to:}
(<a href="ACL2____HARD-ERROR.html">HARD-ERROR</a> CTX FMT-STRING
            (<a href="COMMON-LISP____LIST.html">LIST</a> (<a href="COMMON-LISP____CONS.html">CONS</a> #\0 ARG1) (<a href="COMMON-LISP____CONS.html">CONS</a> #\1 ARG2) ... (<a href="COMMON-LISP____CONS.html">CONS</a> #\k ARGk)))

(<a href="ACL2____ER.html">er</a> hard! ctx fmt-string arg1 arg2 ... argk)
  ; logically is same as (<a href="ACL2____ER.html">er</a> hard ...), but always produces an error

(<a href="ACL2____ER.html">er</a> soft  ctx fmt-string arg1 arg2 ... argk)
  ==&gt; {macroexpands, in essence, to:}
(<a href="ACL2____ERROR1.html">ERROR1</a>     CTX NIL FMT-STRING
            (<a href="COMMON-LISP____LIST.html">LIST</a> (<a href="COMMON-LISP____CONS.html">CONS</a> #\0 ARG1) (<a href="COMMON-LISP____CONS.html">CONS</a> #\1 ARG2) ... (<a href="COMMON-LISP____CONS.html">CONS</a> #\k ARGk)))

(<a href="ACL2____ER-SOFT.html">er-soft</a>  ctx summary fmt-string arg1 arg2 ... argk)
  ==&gt; {macroexpands, in essence, to:}
(<a href="ACL2____ERROR1.html">ERROR1</a>     CTX SUMMARY FMT-STRING
            (<a href="COMMON-LISP____LIST.html">LIST</a> (<a href="COMMON-LISP____CONS.html">CONS</a> #\0 ARG1) (<a href="COMMON-LISP____CONS.html">CONS</a> #\1 ARG2) ... (<a href="COMMON-LISP____CONS.html">CONS</a> #\k ARGk)))</pre> 
 
 <p>See <a href="ACL2____CTX.html">ctx</a> for the possible forms of the <span class="v">ctx</span> argument.</p> 
 
 <p>Technical note for raw Lisp programmers only: It is possible to cause hard 
 errors to signal actual raw Lisp errors.  See <a href="ACL2____HARD-ERROR.html">hard-error</a>.</p>
</body>
</html>
