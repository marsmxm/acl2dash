<html>
<head>
<meta charset="UTF-8">
<title>Statement-renamefun</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=YUL____STATEMENT-RENAMEFUN">Click for Statement-renamefun in the Full Manual</a></h3>

<p>Check if two statements are 
            related by function renaming.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(statement-renamefun old new ren) → _</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">old</span> — <font color="#606060">Guard <span class="v">(<a href="YUL____STATEMENTP.html">statementp</a> old)</span>.</font>
</dd> 
  <dd>
<span class="tt">new</span> — <font color="#606060">Guard <span class="v">(<a href="YUL____STATEMENTP.html">statementp</a> new)</span>.</font>
</dd> 
  <dd>
<span class="tt">ren</span> — <font color="#606060">Guard <span class="v">(<a href="YUL____RENAMINGP.html">renamingp</a> ren)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">_</span> — <font color="#606060">Type <span class="v">(<a href="FTY____RESULTERR-OPTIONP.html">resulterr-optionp</a> _)</span>.</font>
</dd> 
 
</dl></div> 
<p>In case of success, 
       this function returns nothing, 
       because we extend the funcion renaming 
       only ephemerally, prior to processing blocks or loops.</p><p>Old and new statement must be of the same kind, 
       and have constituents recursively related.</p><p>We treat the initialization blocks of a loop specially, 
       as usual (e.g. in the static safety checks and in dynamic execution): 
       we extend the renaming list according to 
       the function definitions in the initialization block, 
       and then we process the rest of the statement 
       with the updated renaming list. 
       However, the renaming list after the loop is the same as the one before: 
       a loop does not permanently introduce new variables.</p> 
 

</body>
</html>
