<html>
<head>
<meta charset="UTF-8">
<title>Def-meta-extract</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____DEF-META-EXTRACT">Click for Def-meta-extract in the Full Manual</a></h3>

<p>Generate macros and theorems convenient for using <a href="ACL2____META-EXTRACT.html">meta-extract</a> with a given evaluator.</p><p>Using the <a href="ACL2____META-EXTRACT.html">meta-extract</a> feature in proofs of meta rules and 
clause processors is fairly inconvenient when starting from scratch. 
Def-meta-extract generates a set of theorems for a given evaluator that are 
a more convenient starting point for reasoning about meta-extract.</p> 
 
<p>Usage:</p> 
 
<pre class="code">(<a href="ACL2____DEFEVALUATOR.html">defevaluator</a> mx-ev mx-ev-lst
  ((<a href="ACL2____TYPESPEC-CHECK.html">typespec-check</a> ts x)
   (<a href="COMMON-LISP____IF.html">if</a> a b c)
   (<a href="COMMON-LISP____EQUAL.html">equal</a> a b)
   (<a href="COMMON-LISP____NOT.html">not</a> a)
   (<a href="ACL2____IFF.html">iff</a> a b)
   (<a href="ACL2____IMPLIES.html">implies</a> a b)
   ...))   ;; other functions as needed for the application

(<a href="ACL2____DEF-META-EXTRACT.html">def-meta-extract</a> mx-ev mx-ev-lst)</pre> 
 
<p>We will use the above invocation on <span class="v">mx-ev</span> as an example; 
<span class="v">def-meta-extract</span> should be applicable to any evaluator that supports the 
six functions listed in the defevaluator form above.</p> 
 
<p>The above invocation of <span class="v">def-meta-extract</span> produces two macros that 
expand to well-formed meta-extract hypotheses:</p> 
<pre class="code">(mx-ev-meta-extract-contextual-facts a :mfc mfc :state state)
(mx-ev-meta-extract-global-facts :state state)</pre> 
<p>(Note: The keyword arguments listed default to the variable names <span class="v">mfc</span> 
and <span class="v">state</span>, which are usually the right arguments.)</p> 
 
<p>The exact meta-extract hypotheses produced use a bad-guy function as the 
<span class="v">obj</span> argument to the meta-extract function, and for the global macro, for 
the <span class="v">st</span> argument to <span class="v">meta-extract-global-fact+</span>, so that they 
effectively universally quantify them, as shown by the following two theorems:</p> 
<p><b>Theorem: </b>mx-ev-meta-extract-contextual-badguy-sufficient</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mx-ev-meta-extract-contextual-badguy-sufficient
        (<a href="ACL2____IMPLIES.html">implies</a> (mx-ev-meta-extract-contextual-facts a)
                 (mx-ev (<a href="ACL2____META-EXTRACT-CONTEXTUAL-FACT.html">meta-extract-contextual-fact</a> obj mfc state)
                        a)))</pre> 
<p><b>Theorem: </b>mx-ev-meta-extract-global-badguy-sufficient</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mx-ev-meta-extract-global-badguy-sufficient
        (<a href="ACL2____IMPLIES.html">implies</a> (mx-ev-meta-extract-global-facts)
                 (mx-ev (<a href="ACL2____META-EXTRACT-GLOBAL-FACT_B2.html">meta-extract-global-fact+</a> obj st state)
                        a)))</pre> 
 
<p>However, <span class="v">def-meta-extract</span> proves several theorems for the given 
evaluator so that the user doesn't need to reason directly about invocations of 
<a href="ACL2____META-EXTRACT-CONTEXTUAL-FACT.html">meta-extract-contextual-fact</a> and <a href="ACL2____META-EXTRACT-GLOBAL-FACT_B2.html">meta-extract-global-fact+</a>.  For 
example, to show that an invocation of <span class="v">meta-extract-formula</span> is true under 
<span class="v">mx-ev</span>, you could prove:</p> 
<pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (mx-ev (<a href="ACL2____META-EXTRACT-GLOBAL-FACT_B2.html">meta-extract-global-fact+</a> (<a href="COMMON-LISP____LIST.html">list</a> :formula name) st state) a)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____W.html">w</a> st) (<a href="ACL2____W.html">w</a> state)))
         (mx-ev (<a href="ACL2____META-EXTRACT-FORMULA.html">meta-extract-formula</a> name st) a))</pre> 
<p>But the following theorem proved by <span class="v">def-meta-extract</span> obviates the need 
to reason directly about <a href="ACL2____META-EXTRACT-GLOBAL-FACT_B2.html">meta-extract-global-fact+</a> and provide the correct 
<span class="v">obj = (<a href="COMMON-LISP____LIST.html">list</a> :formula name)</span> in this manner:</p> 
<pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (mx-ev-meta-extract-global-facts)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____W.html">w</a> st) (<a href="ACL2____W.html">w</a> state)))
         (mx-ev (<a href="ACL2____META-EXTRACT-FORMULA.html">meta-extract-formula</a> name st) a))</pre> 
 
<p>(Note: <span class="v">st</span>, the state from which the formula is extracted, and 
<span class="v">state</span>, the original state on which the metafunction or clause processor 
was invoked, may differ in the case of a clause processor because the clause 
processor can update state.  As long as the <span class="v">w</span> field (holding the ACL2 
logical world) of the state is not updated, global facts can still be extracted 
from the state and assumed correct.)</p> 
 
<h3>List of theorems proved by <span class="v">def-meta-extract</span>
</h3> 
 
<h4>Typset reasoning with <a href="ACL2____MFC-TS.html">mfc-ts</a>
</h4> 
<p>The following theorem allows the user to conclude that a typeset returned by 
<a href="ACL2____MFC-TS.html">mfc-ts</a> correctly describes the type of a term:</p> 
<p><b>Theorem: </b>mx-ev-meta-extract-typeset</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mx-ev-meta-extract-typeset
        (<a href="ACL2____IMPLIES.html">implies</a> (mx-ev-meta-extract-contextual-facts a)
                 (<a href="ACL2____TYPESPEC-CHECK.html">typespec-check</a> (<a href="ACL2____MFC-TS.html">mfc-ts</a> term mfc state :forcep nil)
                                 (mx-ev term a)))
        :rule-classes ((:rewrite)))</pre> 
 
<h4>Rewriting with <a href="ACL2____MFC-RW.html">mfc-rw</a> and under substitution with <a href="ACL2____MFC-RW_B2.html">mfc-rw+</a>
</h4> 
<p>The following six theorems allow the user to conclude that a call of <a href="ACL2____MFC-RW.html">mfc-rw</a> returns an equivalent term, or that a call of <a href="ACL2____MFC-RW_B2.html">mfc-rw+</a> returns a 
term equivalent to the substitution of <span class="v">alist</span> into <span class="v">term</span>, with the 
equivalence given by the <span class="v">equiv-info</span> argument provided (<span class="v">nil</span> for 
equality, <span class="v">t</span> for <span class="v">iff</span>, or the name of an equivalence relation):</p> 
<p><b>Theorem: </b>mx-ev-meta-extract-rw-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mx-ev-meta-extract-rw-equal
        (<a href="ACL2____IMPLIES.html">implies</a> (mx-ev-meta-extract-contextual-facts a)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (mx-ev (<a href="ACL2____MFC-RW.html">mfc-rw</a> term obj nil mfc state
                                       :forcep nil)
                               a)
                        (mx-ev (<a href="ACL2____SUBLIS-VAR.html">sublis-var</a> nil term) a)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>mx-ev-meta-extract-rw-iff</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mx-ev-meta-extract-rw-iff
        (<a href="ACL2____IMPLIES.html">implies</a> (mx-ev-meta-extract-contextual-facts a)
                 (<a href="ACL2____IFF.html">iff</a> (mx-ev (<a href="ACL2____MFC-RW.html">mfc-rw</a> term obj t mfc state
                                     :forcep nil)
                             a)
                      (mx-ev (<a href="ACL2____SUBLIS-VAR.html">sublis-var</a> nil term) a)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>mx-ev-meta-extract-rw-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  mx-ev-meta-extract-rw-equiv
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (mx-ev-meta-extract-contextual-facts a)
                equiv (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> equiv t))
                (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> equiv)
                (<a href="ACL2____GETPROP.html">getprop</a> equiv 'coarsenings
                         nil 'current-acl2-world
                         (<a href="ACL2____W.html">w</a> state)))
           (mx-ev (<a href="COMMON-LISP____CONS.html">cons</a> equiv
                        (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="ACL2____SUBLIS-VAR.html">sublis-var</a> nil term)
                              (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="ACL2____MFC-RW.html">mfc-rw</a> term obj equiv mfc state
                                            :forcep nil)
                                    'nil)))
                  a))
  :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>mx-ev-meta-extract-rw+-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mx-ev-meta-extract-rw+-equal
        (<a href="ACL2____IMPLIES.html">implies</a> (mx-ev-meta-extract-contextual-facts a)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (mx-ev (<a href="ACL2____MFC-RW_B2.html">mfc-rw+</a> term alist obj nil mfc state
                                        :forcep nil)
                               a)
                        (mx-ev (<a href="ACL2____SUBLIS-VAR.html">sublis-var</a> alist term) a)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>mx-ev-meta-extract-rw+-iff</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mx-ev-meta-extract-rw+-iff
        (<a href="ACL2____IMPLIES.html">implies</a> (mx-ev-meta-extract-contextual-facts a)
                 (<a href="ACL2____IFF.html">iff</a> (mx-ev (<a href="ACL2____MFC-RW_B2.html">mfc-rw+</a> term alist obj t mfc state
                                      :forcep nil)
                             a)
                      (mx-ev (<a href="ACL2____SUBLIS-VAR.html">sublis-var</a> alist term) a)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>mx-ev-meta-extract-rw+-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 mx-ev-meta-extract-rw+-equiv
 (<a href="ACL2____IMPLIES.html">implies</a>
    (<a href="COMMON-LISP____AND.html">and</a> (mx-ev-meta-extract-contextual-facts a)
         equiv (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> equiv t))
         (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> equiv)
         (<a href="ACL2____GETPROP.html">getprop</a> equiv 'coarsenings
                  nil 'current-acl2-world
                  (<a href="ACL2____W.html">w</a> state)))
    (mx-ev (<a href="COMMON-LISP____CONS.html">cons</a> equiv
                 (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="ACL2____SUBLIS-VAR.html">sublis-var</a> alist term)
                       (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="ACL2____MFC-RW_B2.html">mfc-rw+</a> term alist obj equiv mfc state
                                      :forcep nil)
                             'nil)))
           a))
 :rule-classes ((:rewrite)))</pre> 
 
<h4>Detecting linear arithmetic contradictions with <a href="ACL2____MFC-AP.html">mfc-ap</a>
</h4> 
<p>The following theorem allows the user to conclude that a term is false under 
the given environment <span class="v">a</span> when <a href="ACL2____MFC-AP.html">mfc-ap</a> returns <span class="v">t</span> indicating a 
linear arithmetic contradiction:</p> 
<p><b>Theorem: </b>mx-ev-meta-extract-mfc-ap</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mx-ev-meta-extract-mfc-ap
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (mx-ev-meta-extract-contextual-facts a)
                      (mx-ev term a))
                 (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____MFC-AP.html">mfc-ap</a> term mfc state :forcep nil)))
        :rule-classes ((:rewrite)))</pre> 
 
<h4>Proving terms true with <a href="ACL2____MFC-RELIEVE-HYP.html">mfc-relieve-hyp</a>
</h4> 
<p><b>Theorem: </b>mx-ev-meta-extract-relieve-hyp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    mx-ev-meta-extract-relieve-hyp
    (<a href="ACL2____IMPLIES.html">implies</a>
         (<a href="COMMON-LISP____AND.html">and</a> (mx-ev-meta-extract-contextual-facts a)
              (<a href="COMMON-LISP____NOT.html">not</a> (mx-ev (<a href="ACL2____SUBLIS-VAR.html">sublis-var</a> alist hyp) a)))
         (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____MFC-RELIEVE-HYP.html">mfc-relieve-hyp</a> hyp alist rune target bkptr mfc state
                               :forcep nil)))
    :rule-classes ((:rewrite)))</pre> 
 
<h4>Looking up formulas by name using <a href="ACL2____META-EXTRACT-FORMULA.html">meta-extract-formula</a>
</h4> 
<p>(Note: <span class="v">meta-extract-formula</span> can be used to look up a theorem, 
definition of a defined function, or constraint of a constrained function.)</p> 
<p><b>Theorem: </b>mx-ev-meta-extract-formula</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mx-ev-meta-extract-formula
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (mx-ev-meta-extract-global-facts)
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____W.html">w</a> st) (<a href="ACL2____W.html">w</a> state)))
                 (mx-ev (<a href="ACL2____META-EXTRACT-FORMULA.html">meta-extract-formula</a> name st)
                        a))
        :rule-classes ((:rewrite)))</pre> 
 
<h4>Looking up rewrite rules from a <span class="v">lemmas</span> property</h4> 
<p>The following two theorems conclude that a rewrite rule extracted from a 
function's <span class="v">lemmas</span> property is valid (the second somewhat more explicitly 
than the first):</p> 
<p><b>Theorem: </b>mx-ev-meta-extract-lemma-term</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mx-ev-meta-extract-lemma-term
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (mx-ev-meta-extract-global-facts)
                      (<a href="COMMON-LISP____MEMBER.html">member</a> rule (fgetprop fn 'lemmas nil (<a href="ACL2____W.html">w</a> st)))
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____W.html">w</a> st) (<a href="ACL2____W.html">w</a> state)))
                 (mx-ev (rewrite-rule-term rule) a))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>mx-ev-meta-extract-lemma</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   mx-ev-meta-extract-lemma
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (mx-ev-meta-extract-global-facts)
                 (<a href="COMMON-LISP____MEMBER.html">member</a> rule (fgetprop fn 'lemmas nil (<a href="ACL2____W.html">w</a> st)))
                 (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQ.html">eq</a> (<a href="ACL2____ACCESS.html">access</a> rewrite-rule rule :subclass)
                          'meta))
                 (mx-ev (<a href="ACL2____CONJOIN.html">conjoin</a> (<a href="ACL2____ACCESS.html">access</a> rewrite-rule rule :hyps))
                        a)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____W.html">w</a> st) (<a href="ACL2____W.html">w</a> state)))
            (mx-ev (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="ACL2____ACCESS.html">access</a> rewrite-rule rule :equiv)
                         (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="ACL2____ACCESS.html">access</a> rewrite-rule rule :lhs)
                               (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="ACL2____ACCESS.html">access</a> rewrite-rule rule :rhs)
                                     'nil)))
                   a))
   :rule-classes ((:rewrite)))</pre> 
 
<h4>Calling a function with <a href="ACL2____MAGIC-EV-FNCALL.html">magic-ev-fncall</a>
</h4> 
<p><b>Theorem: </b>mx-ev-meta-extract-fncall</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mx-ev-meta-extract-fncall
        (<a href="ACL2____MV-LET.html">mv-let</a> (erp val)
                (<a href="ACL2____MAGIC-EV-FNCALL.html">magic-ev-fncall</a> fn arglist st t nil)
                (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (mx-ev-meta-extract-global-facts)
                              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____W.html">w</a> st) (<a href="ACL2____W.html">w</a> state))
                              (<a href="COMMON-LISP____NOT.html">not</a> erp)
                              (<a href="ACL2____LOGICP.html">logicp</a> fn (<a href="ACL2____W.html">w</a> st)))
                         (<a href="COMMON-LISP____EQUAL.html">equal</a> val
                                (mx-ev (<a href="COMMON-LISP____CONS.html">cons</a> fn (<a href="ACL2____KWOTE-LST.html">kwote-lst</a> arglist))
                                       nil))))
        :rule-classes ((:rewrite)))</pre> 
 
<h4>Evaluating a term with <a href="ACL2____MAGIC-EV.html">magic-ev</a> or termlist with <a href="ACL2____MAGIC-EV-LST.html">magic-ev-lst</a>
</h4> 
<p><b>Theorem: </b>mx-ev-meta-extract-magic-ev</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mx-ev-meta-extract-magic-ev
        (<a href="ACL2____MV-LET.html">mv-let</a> (erp val)
                (<a href="ACL2____MAGIC-EV.html">magic-ev</a> x alist st hard-errp aokp)
                (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (mx-ev-meta-extract-global-facts)
                              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____W.html">w</a> st) (<a href="ACL2____W.html">w</a> state))
                              (<a href="COMMON-LISP____NOT.html">not</a> erp)
                              (<a href="COMMON-LISP____EQUAL.html">equal</a> hard-errp t)
                              (<a href="COMMON-LISP____EQUAL.html">equal</a> aokp nil)
                              (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> x)
                              (<a href="ACL2____LOGIC-FNSP.html">logic-fnsp</a> x (<a href="ACL2____W.html">w</a> st)))
                         (<a href="COMMON-LISP____EQUAL.html">equal</a> val (mx-ev x alist))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>mx-ev-meta-extract-magic-ev-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mx-ev-meta-extract-magic-ev-lst
        (<a href="ACL2____MV-LET.html">mv-let</a> (erp val)
                (<a href="ACL2____MAGIC-EV-LST.html">magic-ev-lst</a> x alist st hard-errp aokp)
                (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (mx-ev-meta-extract-global-facts)
                              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____W.html">w</a> st) (<a href="ACL2____W.html">w</a> state))
                              (<a href="COMMON-LISP____NOT.html">not</a> erp)
                              (<a href="COMMON-LISP____EQUAL.html">equal</a> hard-errp t)
                              (<a href="COMMON-LISP____EQUAL.html">equal</a> aokp nil)
                              (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> x)
                              (<a href="ACL2____LOGIC-FNS-LISTP.html">logic-fns-listp</a> x (<a href="ACL2____W.html">w</a> st)))
                         (<a href="COMMON-LISP____EQUAL.html">equal</a> val (mx-ev-lst x alist))))
        :rule-classes ((:rewrite)))</pre> 
 
<h4>Looking up a function definition with <a href="ACL2____FN-GET-DEF.html">fn-get-def</a>
</h4> 
<p>The following theorem allows a function call to be expaneded to its body 
when the function definition is successfully looked up in the world with <a href="ACL2____FN-GET-DEF.html">fn-get-def</a>.  Note: The term <span class="v">(<a href="ACL2____MV-NTH.html">mv-nth</a> 0 (<a href="ACL2____FN-GET-DEF.html">fn-get-def</a> ...))</span> indicating 
success of the <a href="ACL2____FN-GET-DEF.html">fn-get-def</a> call is rewritten to the call of <a href="ACL2____FN-CHECK-DEF.html">fn-check-def</a>:</p> 
<p><b>Theorem: </b>mx-ev-meta-extract-fn-check-def</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     mx-ev-meta-extract-fn-check-def
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____FN-CHECK-DEF.html">fn-check-def</a> fn st formals body)
                   (mx-ev-meta-extract-global-facts)
                   (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____W.html">w</a> st) (<a href="ACL2____W.html">w</a> state))
                   (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> args) (<a href="ACL2____LEN.html">len</a> formals)))
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (mx-ev (<a href="COMMON-LISP____CONS.html">cons</a> fn args) a)
                     (mx-ev body
                            (<a href="ACL2____PAIRLIS_42.html">pairlis$</a> formals (mx-ev-lst args a)))))
     :rule-classes ((:rewrite)))</pre> 
 
<h4>Technical lemmas about pairing formals with actuals</h4> 
<p>The following three theorems may help in reasoning about expansions of 
function calls and lambdas:</p> 
<p><b>Theorem: </b>mx-ev-lst-of-pairlis</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mx-ev-lst-of-pairlis
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NO-DUPLICATESP.html">no-duplicatesp</a> keys)
                      (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> keys)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____MEMBER.html">member</a> nil keys)))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (mx-ev-lst keys (<a href="ACL2____PAIRLIS_42.html">pairlis$</a> keys vals))
                        (<a href="ACL2____TAKE.html">take</a> (<a href="ACL2____LEN.html">len</a> keys) vals)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>mx-ev-lst-of-pairlis-append-rest</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 mx-ev-lst-of-pairlis-append-rest
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NO-DUPLICATESP.html">no-duplicatesp</a> keys)
               (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> keys)
               (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____MEMBER.html">member</a> nil keys)))
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (mx-ev-lst keys (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="ACL2____PAIRLIS_42.html">pairlis$</a> keys vals) rest))
                 (<a href="ACL2____TAKE.html">take</a> (<a href="ACL2____LEN.html">len</a> keys) vals)))
 :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>mx-ev-lst-of-pairlis-append-head-rest</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 mx-ev-lst-of-pairlis-append-head-rest
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NO-DUPLICATESP.html">no-duplicatesp</a> keys)
               (<a href="ACL2____ALISTP.html">alistp</a> head)
               (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____INTERSECTP.html">intersectp</a> keys (<a href="ACL2____STRIP-CARS.html">strip-cars</a> head)))
               (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> keys)
               (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____MEMBER.html">member</a> nil keys)))
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (mx-ev-lst keys
                            (<a href="COMMON-LISP____APPEND.html">append</a> head (<a href="ACL2____PAIRLIS_42.html">pairlis$</a> keys vals) rest))
                 (<a href="ACL2____TAKE.html">take</a> (<a href="ACL2____LEN.html">len</a> keys) vals)))
 :rule-classes ((:rewrite)))</pre>
</body>
</html>
