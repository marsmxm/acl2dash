<html>
<head>
<meta charset="UTF-8">
<title>Simplify-defun-sk-examples</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=APT____SIMPLIFY-DEFUN-SK-EXAMPLES">Click for Simplify-defun-sk-examples in the Full Manual</a></h3>

<p>Examples illustrating <span class="tt"><a href="APT____SIMPLIFY-DEFUN-SK.html">simplify-defun-sk</a></span>.</p> 
 <p>The examples below are deliberately quite trivial, in order to make clear 
 how <span class="v">simplify-defun-sk</span> behaves with various keyword arguments.  For all 
 those examples, we assume that the following event has already been 
 evaluated.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> member-equal-fix-true-list
  (<a href="ACL2____IFF.html">iff</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> a (<a href="ACL2____FIX-TRUE-LIST.html">fix-true-list</a> lst))
       (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> a lst)))</pre> 
 
 <h3>Example Set 1: Basics</h3> 
 
 <p>We start with the following basic example.  The keywords can all be omitted 
 with minimal change to the outcome, but we include them as a way to introduce 
 some of the simplest keywords.</p> 
 
 <pre class="code">(<a href="ACL2____DEFUN-SK.html">defun-sk</a> foo (lst)
  (<a href="ACL2____EXISTS.html">exists</a> x (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> x (<a href="ACL2____FIX-TRUE-LIST.html">fix-true-list</a> lst))))
; redundant (see above)
(<a href="ACL2____DEFTHM.html">defthm</a> member-equal-fix-true-list
  (<a href="ACL2____IFF.html">iff</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> a (<a href="ACL2____FIX-TRUE-LIST.html">fix-true-list</a> lst))
       (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> a lst)))
(<a href="APT____SIMPLIFY-DEFUN-SK.html">simplify-defun-sk</a> foo
                   :new-name foo-simp
                   :thm-name foo-simplified
                   :function-disabled nil
                   :thm-enable t
                   :skolem-name foo-simp-sk)</pre> 
 
 <p>ACL2 responds to the call above of <span class="v">simplify-defun-sk</span> by creating the 
 following <span class="v">DEFUN-SK</span> form among others, silently submitting the created 
 forms, and then returning the new <span class="v">DEFUN-SK</span> form (as the value component 
 of an <a href="ACL2____ERROR-TRIPLE.html">ACL2::error-triple</a>).  The new function is named <span class="v">foo-simp</span> 
 because that is what we specified with the <span class="v">:new-name</span> argument above. 
 Similarly, the <span class="v">:skolem-name</span> below comes directly from the keyword above 
 and otherwise would be omitted below.  Notice that the rewrite rule 
 <span class="v">member-fix-true-listp</span>, displayed above, was applied to create the new 
 definition.</p> 
 
 <pre class="code">(<a href="ACL2____DEFUN-SK.html">DEFUN-SK</a> FOO-SIMP (LST)
          (<a href="ACL2____EXISTS.html">EXISTS</a> (X) (<a href="ACL2____MEMBER-EQUAL.html">MEMBER-EQUAL</a> X LST))
          :QUANT-OK T
          :SKOLEM-NAME FOO-SIMP-SK)</pre> 
 
 <p>You can add <span class="v">:verbose t</span>, to get output from the prover when evaluating 
 the <a href="ACL2____EVENTS.html">ACL2::events</a> generated by the <span class="v">simplify-defun-sk</span> call.</p> 
 
 <p>To see the full expansion produced by the call of <span class="v">simplify-defun-sk</span> 
 above, we can use <span class="v">show-simplify-defun-sk</span> instead of 
 <span class="v">simplify-defun-sk</span>, on the same arguments (or, simply add keyword argument 
 <span class="v">:show-only t</span> to your <span class="v">simplify-defun-sk</span> call).  The result is as 
 follows (elided somewhat).</p> 
 
 <pre class="code">(<a href="ACL2____ENCAPSULATE.html">ENCAPSULATE</a>
     NIL
     ... ; helpful stuff local to the encapsulate
     (<a href="ACL2____DEFUN-SK.html">DEFUN-SK</a> FOO-SIMP ...)  ; as shown above
     ... ; local helper events, not shown here
     (<a href="ACL2____DEFTHM.html">DEFTHM</a> FOO-SIMPLIFIED ; the value of keyword argument :thm-name
             (<a href="ACL2____IFF.html">IFF</a> (FOO LST) (FOO-SIMP LST))
             :HINTS ...)
     (<a href="ACL2____IN-THEORY.html">IN-THEORY</a> (<a href="ACL2____DISABLE.html">DISABLE</a> FOO-SIMP)))</pre> 
 
 <p>Notice that new function symbol <span class="v">FOO-SIMP</span> and new theorem 
 <span class="v">FOO-SIMPLIFIED</span> are disabled and enabled, respectively, because of keyword 
 arguments supplied <span class="v">:function-disabled t</span> and <span class="v">:thm-enable t</span>, 
 respectively.</p> 
 
 <p>On the other hand, if you want less output, not more, use 
 <span class="v">simplify-defun-sk</span> with <span class="v">:print nil</span>.  For example:</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="APT____SIMPLIFY-DEFUN-SK.html">simplify-defun-sk</a> foo
                          :new-name foo-simp
                          :thm-name foo-simplified
                          :function-disabled t
                          :thm-enable t
                          :skolem-name foo-simp-sk
                          :print nil)
 T
ACL2 !&gt;:pe foo-simp
   d       4:x(<a href="APT____SIMPLIFY-DEFUN-SK.html">SIMPLIFY-DEFUN-SK</a> FOO
                                 :NEW-NAME ...)
              
&gt;L d           (<a href="COMMON-LISP____DEFUN.html">DEFUN</a> FOO-SIMP (LST)
                      (<a href="COMMON-LISP____DECLARE.html">DECLARE</a> (<a href="ACL2____XARGS.html">XARGS</a> :NON-EXECUTABLE T :MODE :LOGIC))
                      (<a href="ACL2____PROG2_42.html">PROG2$</a> (THROW-NONEXEC-ERROR 'FOO-SIMP
                                                   (<a href="COMMON-LISP____LIST.html">LIST</a> LST))
                              (<a href="COMMON-LISP____LET.html">LET</a> ((X (FOO-SIMP-SK LST)))
                                   (<a href="ACL2____MEMBER-EQUAL.html">MEMBER-EQUAL</a> X LST))))
ACL2 !&gt;</pre> 
 
 <h3>Example Set 2: Assumptions</h3> 
 
 <p>The following trivial example illustrates the use of assumptions.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fix-true-list-is-identity
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> x)
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____FIX-TRUE-LIST.html">fix-true-list</a> x)
                  x)))
(<a href="ACL2____DEFUN-SK.html">defun-sk</a> foo (lst1 lst2)
  (<a href="ACL2____FORALL.html">forall</a> x (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> x (<a href="ACL2____FIX-TRUE-LIST.html">fix-true-list</a> lst1))
                   (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> x (<a href="ACL2____FIX-TRUE-LIST.html">fix-true-list</a> lst2)))))
(<a href="APT____SIMPLIFY-DEFUN-SK.html">simplify-defun-sk</a> foo :assumptions ((<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> lst1)
                                          (<a href="ACL2____TRUE-LISTP.html">true-listp</a> lst2))))</pre> 
 
 <p>Here is the result.  Notice that since we did not specify 
 <span class="v">:new-name</span>, the generated function name is obtained by adding a 
 suffix <span class="v">"$1"</span> to the given function symbol's name.  In general, the least 
 natural number <span class="v">n</span> will be used that results in a new function symbol when 
 adding the suffix <span class="v">"$n"</span>.</p> 
 
 <pre class="code">(<a href="ACL2____DEFUN-SK.html">DEFUN-SK</a> FOO$1 (LST1 LST2)
          (<a href="ACL2____FORALL.html">FORALL</a> (X)
                  (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="ACL2____MEMBER-EQUAL.html">MEMBER-EQUAL</a> X LST1)
                         (<a href="ACL2____MEMBER-EQUAL.html">MEMBER-EQUAL</a> X LST2)))
          :QUANT-OK T)</pre> 
 
 <p>Notice that the body was simplified under the given assumption that 
 <span class="v">lst1</span> and <span class="v">lst2</span> satisfy <span class="tt"><a href="ACL2____TRUE-LISTP.html">true-listp</a></span>; without any such 
 assumption, no simplification would have taken place.</p> 
 
 <p>The following example has a non-trivial <a href="ACL2____GUARD.html">guard</a>, and illustrates that 
 the value of keyword <span class="v">:assumptions</span> can be <span class="v">:guard</span>, which means that 
 the <span class="v">:assumptions</span> value is taken to be the given function's guard.</p> 
 
 <pre class="code">(<a href="ACL2____DEFUN-SK.html">defun-sk</a> foo (lst1 lst2)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> lst1)
                             (<a href="ACL2____TRUE-LISTP.html">true-listp</a> lst2))
                 :verify-guards nil))
  (<a href="ACL2____FORALL.html">forall</a> x (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> x (<a href="ACL2____FIX-TRUE-LIST.html">fix-true-list</a> lst1))
                   (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> x (<a href="ACL2____FIX-TRUE-LIST.html">fix-true-list</a> lst2)))))
(<a href="APT____SIMPLIFY-DEFUN-SK.html">simplify-defun-sk</a> foo :assumptions :guard)</pre> 
 
 <p>Here is the result.  Notice that the simplified body is the same as 
 before.</p> 
 
 <pre class="code">(<a href="ACL2____DEFUN-SK.html">DEFUN-SK</a> FOO$1 (LST1 LST2)
          (<a href="COMMON-LISP____DECLARE.html">DECLARE</a> (<a href="ACL2____XARGS.html">XARGS</a> :NON-EXECUTABLE NIL))
                         (<a href="COMMON-LISP____DECLARE.html">DECLARE</a> (<a href="ACL2____XARGS.html">XARGS</a> :GUARD (<a href="COMMON-LISP____AND.html">AND</a> (<a href="ACL2____TRUE-LISTP.html">TRUE-LISTP</a> LST1)
                                                     (<a href="ACL2____TRUE-LISTP.html">TRUE-LISTP</a> LST2))
                                         :VERIFY-GUARDS NIL))
          (<a href="ACL2____FORALL.html">FORALL</a> (X)
                  (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="ACL2____MEMBER-EQUAL.html">MEMBER-EQUAL</a> X LST1)
                         (<a href="ACL2____MEMBER-EQUAL.html">MEMBER-EQUAL</a> X LST2)))
          :QUANT-OK T)</pre> 
 
 <p>Unlike <span class="tt"><a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a></span>, <span class="v">simplify-defun-sk</span> does not support 
 keywords <span class="v">:assumption-disable</span>, <span class="v">:assumption-enable</span>, and 
 <span class="v">:assumption-theory</span>, and <span class="v">:hyp-fn</span>, since there is no need, as <span class="tt"><a href="ACL2____DEFUN-SK.html">defun-sk</a></span> does not support recursion.</p> 
 
 <h3>Example Set 3: Guard Verification</h3> 
 
 <p>Consider the preceding example, but where we verify guards before 
 attempting simplification, as follows.</p> 
 
 <pre class="code">(<a href="ACL2____VERIFY-GUARDS.html">verify-guards</a> foo)
(<a href="APT____SIMPLIFY-DEFUN-SK.html">simplify-defun-sk</a> foo :assumptions :guard)</pre> 
 
 <p>The new <span class="tt"><a href="ACL2____DEFUN-SK.html">defun-sk</a></span> form is the same as before.  However, this time 
 the new function symbol is guard-verified.  If we use 
 <span class="v">show-simplify-defun-sk</span> in place of <span class="v">simplify-defun-sk</span> just above, we 
 can see that the following <span class="tt"><a href="ACL2____VERIFY-GUARDS.html">verify-guards</a></span> event is generated for the 
 new function symbol.</p> 
 
 <pre class="code">(<a href="ACL2____VERIFY-GUARDS.html">VERIFY-GUARDS</a> FOO$1
               :HINTS (("Goal" :USE (:GUARD-THEOREM FOO))))</pre> 
 
 <p>This illustrates that by default, guard verification will be attempted for 
 the new function symbol exactly when the original function symbol is 
 guard-verified.  However, that default behavior can be overridden by using the 
 <span class="v">:verify-guards</span> keyword.  For example, suppose that the preceding call of 
 <span class="v">simplify-defun-sk</span> displayed above is replaced by the following.</p> 
 
 <pre class="code">(<a href="APT____SIMPLIFY-DEFUN-SK.html">simplify-defun-sk</a> foo
                   :assumptions :guard
                   :verify-guards nil)</pre> 
 
 <p>In this case, guard verification will not be attempted for the new function 
 symbol.</p> 
 
 <p><span class="v">Simplify-defun-sk</span> provides the keyword <span class="v">:guard-hints</span> for the 
 simplified function's guard verification proofs.  For example, suppose that 
 instead of the <span class="v">simplify-defun-sk</span> forms above we evaluate this (rather 
 silly) form.</p> 
 
 <pre class="code">(<a href="APT____SIMPLIFY-DEFUN-SK.html">simplify-defun-sk</a> foo
                   :assumptions :guard
                   :guard-hints (("Goal" :in-theory (<a href="ACL2____ENABLE.html">enable</a> append))))</pre> 
 
 <p>Then in place of the default <span class="v">:hints</span> supplied to the call of <span class="tt"><a href="ACL2____VERIFY-GUARDS.html">verify-guards</a></span>, as displayed above, the guard hints supplied in our 
 <span class="v">simplify-defun-sk</span> are used.</p> 
 
 <pre class="code">(<a href="ACL2____VERIFY-GUARDS.html">VERIFY-GUARDS</a> FOO$1
               :HINTS (("Goal" :IN-THEORY (<a href="ACL2____ENABLE.html">ENABLE</a> APPEND))))</pre> 
 
 <h3>Example Set 4: <span class="v">Defun-sk</span> specific: <span class="v">defun-sk2</span> and 
 <span class="v">:rewrite</span>
</h3> 
 
 <p>Next, we discuss two features of <span class="v">simplify-defun-sk</span> that do not 
 correspond to features of <span class="tt"><a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a></span>.</p> 
 
 <p>The macro <span class="v">defun-sk2</span> is part of the SOFT tool suite (see <a href="SOFT____SOFT.html">soft::soft</a>).  It is a wrapper for <span class="v">defun-sk</span>.  When <span class="v">simplify-defun-sk</span> 
 is called on a function that was introduced with <span class="v">defun-sk2</span>, the new 
 function is also introduced with <span class="v">defun-sk2</span>.  Here is an example.</p> 
 
 <pre class="code">(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "simplify-defun-sk")
(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "kestrel/soft/top" :dir :system)
(defunvar ?foo (<a href="COMMON-LISP_____A2.html">*</a>) =&gt; *)
(defun-sk2 spec[?foo] (?foo) ()
  (<a href="ACL2____FORALL.html">forall</a> (x) (<a href="COMMON-LISP____EQUAL.html">equal</a> (?foo x) (<a href="COMMON-LISP_____A2.html">*</a> x 2))))
(<a href="APT____SIMPLIFY-DEFUN-SK.html">simplify-defun-sk</a> spec[?foo])</pre> 
 
 <p>The resulting definition benefits from simplification of <span class="v">(<a href="COMMON-LISP_____A2.html">*</a> x 2)</span> to 
 <span class="v">(<a href="COMMON-LISP_____A2.html">*</a> 2 x)</span>.  More interesting: it too is a call of <span class="v">defun-sk2</span>.</p> 
 
 <pre class="code">(DEFUN-SK2 SPEC[?FOO]$1 (?FOO)
           NIL
           (<a href="ACL2____FORALL.html">FORALL</a> (X) (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (?FOO X) (<a href="COMMON-LISP_____A2.html">*</a> 2 X)))
           :QUANT-OK T)</pre> 
 
 <p>A second capability offered by <span class="v">simplify-defun-sk</span> is the <span class="v">:rewrite</span> 
 keyword.  By default, the <span class="v">:rewrite</span> field of the generated <span class="v">defun-sk</span> 
 form (or <span class="v">defun-sk2</span> form) corresponds to that of the corresponding form 
 for the input function symbol.  (Exception: currently, custom <span class="v">:rewrite</span> 
 fields are dropped.  A comment about a proposed <span class="v">simplify-defthm</span> in source 
 file <span class="v">simplify-defun-sk.lisp</span> discusses this issue.)  Here is an example 
 showing a new <span class="v">:rewrite</span> field, based closedly on the first example in this 
 topic.</p> 
 
 <pre class="code">; Start a fresh ACL2 session.
(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "simplify-defun-sk")
(<a href="ACL2____DEFTHM.html">defthm</a> member-equal-fix-true-list
  (<a href="ACL2____IFF.html">iff</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> a (<a href="ACL2____FIX-TRUE-LIST.html">fix-true-list</a> lst))
       (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> a lst)))
(<a href="ACL2____DEFUN-SK.html">defun-sk</a> foo (lst)
  (<a href="ACL2____FORALL.html">forall</a> x (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> x (<a href="ACL2____FIX-TRUE-LIST.html">fix-true-list</a> lst)))))
(<a href="APT____SIMPLIFY-DEFUN-SK.html">simplify-defun-sk</a> foo :rewrite :direct)</pre> 
 
 <p>As a result of the <span class="v">:rewrite</span> argument above, the resulting 
 <span class="v">defun-sk</span> form includes <span class="v">:rewrite :direct</span>.</p> 
 
 <pre class="code">(<a href="ACL2____DEFUN-SK.html">DEFUN-SK</a> FOO$1 (LST)
          (<a href="ACL2____FORALL.html">FORALL</a> (X) (<a href="COMMON-LISP____NOT.html">NOT</a> (<a href="ACL2____MEMBER-EQUAL.html">MEMBER-EQUAL</a> X LST)))
          :QUANT-OK T
          :REWRITE :DIRECT)</pre> 
 
 <p>As for <span class="v">defun-sk</span>, the value of the <span class="v">:rewrite</span> option of 
 <span class="v">simplify-defun-sk</span> can ony be <span class="v">:direct</span> if the quantifier is <span class="tt"><a href="ACL2____FORALL.html">forall</a></span>.</p> 
 
 <h3>Example Set 5: Controlling the Theory for Simplification</h3> 
 
 <p>By default, simplification done on behalf of <span class="v">simplify-defun-sk</span> is 
 carried out in the current theory (see <a href="ACL2____CURRENT-THEORY.html">current-theory</a>).  However, the 
 <span class="v">:theory</span> keyword allows control over that theory without changing the 
 current theory globally.  Let us return to our original example, without extra 
 keywords this time; but this time, let's introduce the key lemma with <span class="tt"><a href="ACL2____DEFTHMD.html">defthmd</a></span> 
 (not because it helps our proofs to disable it, but because that will help us 
 to illustrate the <span class="v">:theory</span> keyword).</p> 
 
 <pre class="code">; Start a fresh ACL2 session.
(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "simplify-defun-sk")
(<a href="ACL2____DEFTHMD.html">defthmd</a> member-equal-fix-true-list
  (<a href="ACL2____IFF.html">iff</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> a (<a href="ACL2____FIX-TRUE-LIST.html">fix-true-list</a> lst))
       (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> a lst)))
(<a href="ACL2____DEFUN-SK.html">defun-sk</a> foo (lst)
  (<a href="ACL2____EXISTS.html">exists</a> x (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> x (<a href="ACL2____FIX-TRUE-LIST.html">fix-true-list</a> lst))))
(<a href="APT____SIMPLIFY-DEFUN-SK.html">simplify-defun-sk</a> foo :theory (<a href="ACL2____ENABLE.html">enable</a> member-equal-fix-true-list))</pre> 
 
 <p>If we omit the <span class="v">:theory</span> value above, the call of <span class="v">simplify-defun-sk</span> 
 fails because <span class="v">member-equal-fix-true-list</span> is <a href="ACL2____DISABLE.html">disable</a>d.  The 
 <span class="v">:theory</span> keyword value causes simplification (and some subsequent 
 reasoning) to be done in the indicated theory.</p> 
 
 <p>For convenience, <span class="v">:enable</span> and/or <span class="v">:disable</span> keywords are available, 
 provided that they are not used when <span class="v">:theory</span> is used.  For example, the 
 following form is treated equivaletly to the <span class="v">simplify-defun-sk</span> call 
 displayed just above.</p> 
 
 <pre class="code">(<a href="APT____SIMPLIFY-DEFUN-SK.html">simplify-defun-sk</a> foo :enable (member-equal-fix-true-list))</pre> 
 
 <h3>Example Set 6: Simplifying Subterms</h3> 
 
 <p>Like <span class="tt"><a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a></span>, value of the <span class="v">:simplify-body</span> keyword of 
 <span class="v">simplify-defun-sk</span> can be <span class="v">t</span>, <span class="v">nil</span>, or a pattern.  It may be 
 surprising that <span class="v">nil</span> is allowed, since (unlike <span class="v">simplify-defun</span>) the 
 body is the only piece of the definition that is simplified (not the guard or 
 measure).  However, it is anticipated that sometimes <span class="v">simplify-defun-sk</span> 
 may be called without knowing if simplification will succeed, but nevertheless 
 wanting a new function symbol to be defined.  (If that same functionality is 
 desired for <span class="v">simplify-defun</span> then it could be changed as well.)</p> 
 
 <p>The handling of patterns is the same as for <span class="v">simplify-defun</span>; see <a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> for further discussion of ``Simplifying a Subterm''.  Here we 
 present a simple example with a single subterm simplified, but as with 
 <span class="v">simplify-defun</span>, it is legal to specify more than one such subterm.</p> 
 
 <pre class="code">; Start a fresh ACL2 session.
(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "simplify-defun-sk")
; Books included above define set-equiv as an equivalence relation,
; and provide some nice congruence rules.
(<a href="ACL2____DEFTHM.html">defthm</a> set-equiv-fix-true-list
  (<a href="ACL2____SET-EQUIV.html">set-equiv</a> (<a href="ACL2____FIX-TRUE-LIST.html">fix-true-list</a> lst)
             lst))
(<a href="ACL2____DEFUN-SK.html">defun-sk</a> foo (lst1 lst2)
  (<a href="ACL2____EXISTS.html">exists</a> x (<a href="ACL2____IFF.html">iff</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> x (<a href="ACL2____FIX-TRUE-LIST.html">fix-true-list</a> lst1))
                      (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> x (<a href="ACL2____FIX-TRUE-LIST.html">fix-true-list</a> lst2)))
                 t)))
(<a href="APT____SIMPLIFY-DEFUN-SK.html">simplify-defun-sk</a> foo
                   :simplify-body
                   (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> x @)
                        (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> x (<a href="ACL2____FIX-TRUE-LIST.html">fix-true-list</a> lst2))))</pre> 
 
 <p>The result is below.  Notice that simplification has taken place at the 
 subterm labeled with <span class="v">@</span>, and nowhere else.</p> 
 
 <pre class="code">(<a href="ACL2____DEFUN-SK.html">DEFUN-SK</a> FOO$1 (LST1 LST2)
          (<a href="ACL2____EXISTS.html">EXISTS</a> (X)
                  (<a href="ACL2____IFF.html">IFF</a> (<a href="COMMON-LISP____AND.html">AND</a> (<a href="ACL2____MEMBER-EQUAL.html">MEMBER-EQUAL</a> X LST1)
                            (<a href="ACL2____MEMBER-EQUAL.html">MEMBER-EQUAL</a> X (<a href="ACL2____FIX-TRUE-LIST.html">FIX-TRUE-LIST</a> LST2)))
                       T))
          :QUANT-OK T)</pre> 
 
 <p>It is interesting to note that our original lemma, 
 <span class="v">member-equal-fix-true-list</span>, is not sufficient for the simplification. 
 That is because it is a rule to rewrite calls of <span class="v">member-equal</span>, but the 
 subterm in question has no such calls.</p> 
 
 <pre class="code">; Start a fresh ACL2 session.
(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "simplify-defun-sk")
(<a href="ACL2____DEFTHM.html">defthm</a> member-equal-fix-true-list
  (<a href="ACL2____IFF.html">iff</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> a (<a href="ACL2____FIX-TRUE-LIST.html">fix-true-list</a> lst))
       (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> a lst)))
(<a href="ACL2____DEFUN-SK.html">defun-sk</a> foo (lst1 lst2)
  (<a href="ACL2____EXISTS.html">exists</a> x (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> x (<a href="ACL2____FIX-TRUE-LIST.html">fix-true-list</a> lst1))
                 (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> x (<a href="ACL2____FIX-TRUE-LIST.html">fix-true-list</a> lst2)))))
(<a href="APT____SIMPLIFY-DEFUN-SK.html">simplify-defun-sk</a> foo
                   :simplify-body
                   (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> x @)
                        (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> x (<a href="ACL2____FIX-TRUE-LIST.html">fix-true-list</a> lst2))))</pre> 
 

</body>
</html>
