<html>
<head>
<meta charset="UTF-8">
<title>Use-termhint</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____USE-TERMHINT">Click for Use-termhint in the Full Manual</a></h3>

<p>Compute hints based on a term that gets simplified along with the rest of the goal.</p><p>When a theory doesn't lend itself well to rewriting, you might just 
use a lot of hints to get through a proof.  But this can become brittle and 
unwieldy: you might get through the proof by piling on :use hints, but if that 
proof later fails it can be very difficult to debug.  An unstructured pile of 
hints doesn't give many clues for how the proof is supposed to work and how to 
fix it if it breaks.  Use-termhint provides a different way to structure proofs 
that require a lot of hints.  Also see <a href="ACL2____TERMHINT-SEQ.html">termhint-seq</a> for a way to give 
hints in sequence throughout a termhint term.</p> 
 
<h2>Demo</h2> 
 
<p>As a very simple example, suppose that we have axioms ax1 through ax3, and 
we want to prove th:</p> 
 
<pre class="code">(<a href="ACL2____DEFSTUB.html">defstub</a> p1 (x) t)
(<a href="ACL2____DEFSTUB.html">defstub</a> p2 (x y z) t)
(<a href="ACL2____DEFSTUB.html">defstub</a> p3 (x y) t)
(<a href="ACL2____DEFSTUB.html">defstub</a> p4 (x) t)
(<a href="ACL2____DEFSTUB.html">defstub</a> b (x) t)
(<a href="ACL2____DEFSTUB.html">defstub</a> c (x) t)
(<a href="ACL2____DEFSTUB.html">defstub</a> d (x) t)

(<a href="ACL2____DEFAXIOM.html">defaxiom</a> t1
  (<a href="ACL2____IMPLIES.html">implies</a> (p1 a)
           (p2 a (b a) (c a))))

(<a href="ACL2____DEFAXIOM.html">defaxiom</a> t2
  (<a href="ACL2____IMPLIES.html">implies</a> (p2 a b c)
           (p3 a (d c))))

(<a href="ACL2____DEFAXIOM.html">defaxiom</a> t3
  (<a href="ACL2____IMPLIES.html">implies</a> (p3 a d)
           (p4 a)))

(<a href="ACL2____DEFTHM.html">defthm</a> th
  (<a href="ACL2____IMPLIES.html">implies</a> (p1 a)
           (p4 a)))</pre> 
 
<p>We could do this using some unstructured :use hints (in this case perhaps 
only one would suffice).  But we can be more explicit about how the proof 
precedes by using use-termhint, as follows.</p> 
 
<p>First, we write a function that follows the process of the proof and 
provides hints at certain endpoints:</p> 
 
<pre class="code">;; A computed hint to use later -- see below.
(<a href="COMMON-LISP____DEFUN.html">defun</a> my-use-t3-inst-hint (d)
   `(:use ((:instance t3 (d ,d)))))

(<a href="COMMON-LISP____DEFUN.html">defun</a> hint-for-th (a)
  (<a href="ACL2____B_A2.html">b*</a> ((b (b a))
       (c (c a))
       ;; The first thing that we want to conclude is (p2 a b c) for some b, c,
       ;; namely, the ones given by t1.
       ((unless (p2 a b c))
        ;; The unless here causes a case split.  In one case, we assume (p2 a
        ;; b c).  In the other case, we arrive here, and we return a hint that
        ;; proves the subgoal by proving (p2 a b c).  This hint is
        ;; double-quoted because in general we return the quotation of a
        ;; computed hint expression; in this case, the computed hint we want
        ;; is '(:use t1).
        ''(:use t1))
       ;; Now we can assume (p2 a b c).  Next we want to show (p3 a d) for some d,
       ;; by t2.
       (d (d c))
       ((unless (p3 a d))
        ;; In the case where we're assuming (<a href="COMMON-LISP____NOT.html">not</a> (p3 a d)), prove it by using t2.
        ;; Notice the uses of (<a href="ACL2____HQ.html">hq</a> ...) below: these are specially processed by
        ;; use-termhint, so that (<a href="ACL2____HQ.html">hq</a> b) will be replaced by whatever the term
        ;; bound to b has been rewritten to.  This will produce the hint:
        ;;    :use ((:instance t2
        ;;           (b (b a))
        ;;           (c (c a))))
        ;; But notice that we don't have to write out (b a) and (c a); instead we
        ;; use the (<a href="ACL2____HQ.html">hq</a> ...) of variables bound to those terms.
        `'(:use ((:instance t2
                  (b ,(<a href="ACL2____HQ.html">hq</a> b))
                  (c ,(<a href="ACL2____HQ.html">hq</a> c)))))))
    ;; Finally, we have (p3 a d), so we just use t3 to get our conclusion.
    ;; We could use the following:
    ;; `'(:use ((:instance t3 (d ,(<a href="ACL2____HQ.html">hq</a> d)))))
    ;; but instead we'll do this, just to show that you can use arbitrary
    ;; computed hints:
    `(my-use-t3-inst-hint ',(<a href="ACL2____HQ.html">hq</a> d))))</pre> 
 
<p>Now, we submit th with the following hints:</p> 
<pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> th
   (<a href="ACL2____IMPLIES.html">implies</a> (p1 a)
            (p4 a))
   :hints (("goal" :in-theory (<a href="ACL2____DISABLE.html">disable</a> t1 t2 t3))
           (<a href="ACL2____USE-TERMHINT.html">use-termhint</a> (hint-for-th a))))</pre> 
<p>which suffices to prove it.</p> 
 
<h2>Mechanism</h2> 
 
<p>Use-termhint produces a sequence of two computed hints: an initial :use hint 
that adds a <span class="v">use-termhint-hyp</span> hypothesis to the goal, and another computed 
hint evaluated when stable under simplification, which looks for the simplified 
<span class="v">use-termhint-hyp</span> literal and and extracts a hint from that term.</p> 
 
<p>In the above example, the hypothesis added to the goal is 
<span class="v">(use-termhint-hyp (hint-for-th a))</span>. 
This term is processed and simplified like any other. 
In particular, the hint-for-th function is opened (because it is an 
enabled, non-recursive function) and, because it contains IFs, causes some case 
splits.  In each of the three cases, once everything settles down, the 
use-termhint-hyp literal remains and contains a term specifying the hint to 
give for that case.  This hint is taken care of by the later computed hint, 
which strips that hypothesis from the clause and then gives a hint 
corresponding to what was in the use-termhint-hyp hypothesis.</p> 
 
<h2>Details</h2> 
 
<p>The <span class="v">hq</span> trick, or something like it, is necessary to allow the hint 
object to contain terms that are simplified and beta-reduced by the prover as 
well as hint boilerplate that is not.  The function <a href="ACL2____PROCESS-TERMHINT.html">process-termhint</a> is 
used to produce normal hint objects from these; it interprets calls of 
<span class="v">cons</span> and <span class="v">append</span> and treats calls of <span class="v">hq</span> like <span class="v">quote</span>.</p> 
 
<p>Other quote-like symbols can be added to this list.  In particular, it may 
be useful to add symbols that have certain congruences or rewriting properties. 
For example, if you want to expand a certain function call and that function 
has a congruence on its first argument, you may want to introduce an HQ-like 
symbol that has the same congruence:</p> 
 
<pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> my-hq (x) (my-fix x))
(<a href="ACL2____DEFCONG.html">defcong</a> my-equiv equal (my-hq x) 1)
(<a href="ACL2____IN-THEORY.html">in-theory</a> (<a href="ACL2____DISABLE.html">disable</a> my-hq (my-hq) (:t my-hq)))
(termhint-add-quotesym my-hq)

(<a href="ACL2____DEFTHM.html">defthm</a> ...
  :hints ((<a href="ACL2____USE-TERMHINT.html">use-termhint</a>
           (<a href="COMMON-LISP____LET.html">let</a> ((arg ...))
              `(:expand ((my-fn ,(my-hq arg))))))))</pre> 

</body>
</html>
