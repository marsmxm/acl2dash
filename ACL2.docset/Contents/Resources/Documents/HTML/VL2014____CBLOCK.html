<html>
<head>
<meta charset="UTF-8">
<title>Cblock</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=VL2014____CBLOCK">Click for Cblock in the Full Manual</a></h3>

<p>Transform simple, purely combinational <span class="v">always</span> and 
<span class="v">always_comb</span> blocks into corresponding <span class="v">assign</span> statements, replacing 
registers with wiring.</p><p>Some basic criteria for treating an always block as 
combinational:</p> 
 
<ul> 
 
<li>Expressions must be sized.</li> 
 
<li>It must be a plain <span class="v">always</span> block or an <span class="v">always_comb</span> block.</li> 
 
<li>Plain <span class="v">always</span> blocks must be a sensitivity list.  This sensitivity list 
may not mention any edge-triggered components (since if it does, this block 
isn't combinational).  Moreover, the sensitivity list needs to be "correct": 
either it may be <span class="v">always @(<a href="COMMON-LISP_____A2.html">*</a>)</span>, or else it must correctly mention every 
net/reg that is used in an rvalue context, including <span class="v">if</span> conditions and 
right-hand sides of assignments.</li> 
 
<li>For simplicity, we don't try to handle sensitivity lists that include part- 
or bit-selects.  That is, we support things like <span class="v">always @(a or b)</span>, but not 
<span class="v">always @(a[3] or b[17:0])</span>.</li> 
 
<li>We don't support assignments to variables in the sensitivity list (by which 
we really mean the set of right-hand side variables).  This isn't necessarily 
<i>wrong</i>, but it is kind of weird because it means that evaluating the 
block will potentially trigger another evaluation of the block.  This could 
perhaps lead to loops, and is generally confusing.  For instance, consider: 
 
<pre class="code">always @@(a or c)
begin
   a = 1;
   a = c;
end</pre> 
 
If <span class="v">c</span> transitions to 0, then this block can start looping with itself, 
forever setting A to 1 and then back to 0.  It might be possible to relax this 
restriction if it proves problematic, but this all gets very subtle.</li> 
 
<li>The module may not have initial statements.  We're going to want to convert 
each each lvalue <span class="v">reg</span> into a <span class="v">wire</span>, so if <span class="v">initial</span> statements could 
be writing to these <span class="v">reg</span>s, then this conversion would produce a malformed 
module.  Prohibiting initial statements is an easy way to avoid this.</li> 
 
<li>All assignments must be delay-free, blocking assignments.  Non-blocking 
assignments are appropriate for edge-triggered logic, not for combinational 
logic.  Delays are not supported for simplicity.</li> 
 
<li>The lvalue registers must never be assigned to by other <span class="v">always</span> blocks. 
Having multiple <span class="v">always</span> statements updating the same register is way too 
hard to think about.  See <a href="VL2014____VL-ALWAYS-SCARY-REGS.html">vl-always-scary-regs</a>.</li> 
 
<li>Always blocks that update only a portion of a register (even if the 
specified range is the entire register) are not currently supported, since this 
leaves us without an easy way to convert the <span class="v">reg</span> into a <span class="v">wire</span>.</li> 
 
<li>Each lvalue register must be assigned to in every branch.  Otherwise we 
need to infer a latch, e.g., the following can't be turned into ordinary 
<span class="v">assign</span> statements: 
 
 
<pre class="code">always @@(v1 or v2)
  if (v1)
     r = v2;</pre> 
 
because <span class="v">r</span> needs to keep its value when <span class="v">v1</span> is false.  It wouldn't be 
correct to replace this block with <span class="v">assign r = v1 ? v2 : r</span>, because that's 
a combinational loop.</li> 
 
</ul>
</body>
</html>
