<html>
<head>
<meta charset="UTF-8">
<title>ACL2-pc::equiv</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2-PC____EQUIV">Click for ACL2-pc::equiv in the Full Manual</a></h3>

<p>(primitive) 
attempt an equality (or congruence-based) substitution</p><pre class="code">Examples:
(equiv (<a href="COMMON-LISP_____A2.html">*</a> x y) 3) -- replace (<a href="COMMON-LISP_____A2.html">*</a> x y) by 3 everywhere inside the
                     current subterm, if their equality is among the
                     top-level hypotheses or the governors
(equiv x t iff)   -- replace x by t everywhere inside the current
                     subterm, where only propositional equivalence
                     needs to be maintained at each occurrence of x

General form:
(equiv old new &amp;optional relation)</pre> 
 
 <p>Substitute <span class="v">new</span> for <span class="v">old</span> everywhere inside the current subterm, 
 provided that either <span class="v">(relation old new)</span> or <span class="v">(relation new old)</span> is 
 among the top-level hypotheses or the governors (possibly by way of 
 backchaining and/or refinement; see below).  If <span class="v">relation</span> is <span class="v">nil</span> or 
 is not supplied, then it defaults to <span class="v">equal</span>.  If <span class="v">relation</span> is not 
 <span class="v">equal</span> (either explicitly or by default), then substitution of <span class="v">new</span> 
 for <span class="v">old</span> will only take place at occurrences for which <span class="v">relation</span> is 
 among the <a href="ACL2____EQUIVALENCE.html">equivalence</a> relations being maintained without the use of 
 <a href="ACL2____PATTERNED-CONGRUENCE.html">patterned-congruence</a>s.  Also see <span class="v">acl2-pc::=</span> for a much more 
 flexible command.  Note that the <span class="v">equiv</span> command fails if no substitution 
 is actually made.</p> 
 
 <p><b>Remark:</b> No substitution takes place inside explicit values.  So for 
 example, the instruction <span class="v">(equiv 3 x)</span> will cause <span class="v">3</span> to be replaced by 
 <span class="v">x</span> if the current subterm is, say, <span class="v">(<a href="COMMON-LISP_____A2.html">*</a> 3 y)</span>, but not if the current 
 subterm is <span class="v">(<a href="COMMON-LISP_____A2.html">*</a> 4 y)</span> even though <span class="v">4 = (<a href="COMMON-LISP____1_B2.html">1+</a> 3)</span>.</p> 
 
 <p>The following remarks are quite technical and mostly describe a certain 
 weak form of ``backchaining'' that has been implemented for <span class="v">equiv</span> in 
 order to support the <span class="v">=</span> command.  In fact neither the term <span class="v">(relation
 old new)</span> nor the term <span class="v">(relation new old)</span> needs to be <b>explicitly</b> 
 among the current ``assumptions'', i.e., the top-level hypothesis or the 
 governors.  Rather, there need only be such an assumption that ``tells us'' 
 <span class="v">(r old new)</span> or <span class="v">(r new old)</span>, for <b>some</b> equivalence relation 
 <span class="v">r</span> that <b>refines</b> <span class="v">relation</span>.  Here, ``tells us'' means that 
 either one of the indicated terms is among those assumptions, or else there is 
 an assumption that is an implication whose conclusion is one of the indicated 
 terms and whose hypotheses (gathered up by appropriately flattening the first 
 argument of the <span class="v">implies</span> term) are all among the current 
 assumptions.</p>
</body>
</html>
