<html>
<head>
<meta charset="UTF-8">
<title>3. Computing with Symbolic Objects</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=GL____3._02Computing_02with_02Symbolic_02Objects">Click for 3. Computing with Symbolic Objects in the Full Manual</a></h3>

<p></p> 
 
<p>Once we have a representation for symbolic objects, we can perform symbolic 
executions on those objects.  For instance, recall the symbolic number <span class="v">p</span> 
which can have value 1 or 5,</p> 
 
<pre class="code">p = (:g-integer  true   false   A &amp; B   false)</pre> 
 
<p>We might symbolically add 1 to <span class="v">p</span> to obtain a new symbolic number, say 
<span class="v">q</span>,</p> 
 
<pre class="code">q = (:g-integer  false   true    A &amp; B   false)</pre> 
 
<p>which represents either 2 or 6.  Suppose <span class="v">r</span> is another symbolic number,</p> 
 
<pre class="code">r = (:g-integer  A   false   true   false)</pre> 
 
<p>which represents either 4 or 5.  We might add <span class="v">q</span> and <span class="v">r</span> to obtain 
<span class="v">s</span>,</p> 
 
<pre class="code">s = (:g-integer  A    true    ~(A &amp; B)    (A &amp; B)    false)</pre> 
 
<p>whose value can be 6, 7, or 11.</p> 
 
<p>Why can't <span class="v">s</span> be 10 if <span class="v">q</span> can be 6 and <span class="v">r</span> can be 4?  This 
combination isn't possible because <span class="v">q</span> and <span class="v">r</span> involve the same 
expression, <span class="v">A</span>.  The only way for <span class="v">r</span> to be 4 is for <span class="v">A</span> to be false, 
but then <span class="v">q</span> must be 2.</p> 
 
<p>The underlying algorithm GL uses for symbolic additions is just a 
ripple-carry addition on the Boolean expressions making up the bits of the two 
numbers.  Performing a symbolic addition, then, means constructing new <a href="ACL2____UBDDS.html">ubdds</a> or <a href="ACL2____AIG.html">aig</a>s, depending on which mode is being used.</p> 
 
<p>GL has built-in support for symbolically executing most ACL2 primitives. 
Generally, this is done by cases on the types of the symbolic objects being 
passed in as arguments.  For instance, if we want to symbolically execute <a href="COMMON-LISP____CONSP.html">consp</a> on <span class="v">s</span>, then we are asking whether a <span class="v">:g-integer</span> may ever 
represent a cons, so the answer is simply <span class="v">nil</span>.  Similarly, if we ever try 
to add a <span class="v">:g-boolean</span> to a <span class="v">:g-integer</span>, by the ACL2 axioms the 
<span class="v">:g-boolean</span> is simply treated as 0.</p> 
 
<p>Beyond these primitives, GL provides what is essentially a <a href="http://www-formal.stanford.edu/jmc/recursive.pdf" target="_blank"><nobr>McCarthy-style 
interpreter<img src="../Icon_External_Link.png" title="External link to http://www-formal.stanford.edu/jmc/recursive.pdf"></nobr></a> for symbolically executing terms.  By default, it expands 
function definitions until it reaches primitives, with some special handling 
for <a href="COMMON-LISP____IF.html">if</a>.  For better performance, its interpretation scheme can be 
customized with more efficient definitions and other <a href="GL____OPTIMIZATION.html">optimization</a>s.</p> 

</body>
</html>
