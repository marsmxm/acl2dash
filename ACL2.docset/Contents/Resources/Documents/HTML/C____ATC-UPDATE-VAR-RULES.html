<html>
<head>
<meta charset="UTF-8">
<title>Atc-update-var-rules</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=C____ATC-UPDATE-VAR-RULES">Click for Atc-update-var-rules in the Full Manual</a></h3>

<p>Rules about <span class="tt"><a href="C____UPDATE-VAR.html">update-var</a></span>.</p><p>The theorems about <span class="tt"><a href="C____UPDATE-VAR.html">update-var</a></span> push them into the states, 
     sometimes combining them into <span class="tt"><a href="C____ADD-VAR.html">add-var</a></span>s. 
     The first theorem pushes <span class="tt"><a href="C____UPDATE-VAR.html">update-var</a></span> into <span class="tt"><a href="C____ENTER-SCOPE.html">enter-scope</a></span>. 
     The second theorem combines <span class="tt"><a href="C____UPDATE-VAR.html">update-var</a></span> with <span class="tt"><a href="C____ADD-VAR.html">add-var</a></span> 
     if the variable is the same, otherwise it pushes <span class="tt"><a href="C____UPDATE-VAR.html">update-var</a></span> in. 
     There is no rule for <span class="tt"><a href="C____ADD-FRAME.html">add-frame</a></span> because that does not happen. 
     The third theorem overwrites an <span class="tt"><a href="C____UPDATE-VAR.html">update-var</a></span> 
     with an <span class="tt"><a href="C____UPDATE-VAR.html">update-var</a></span> for the same variable. 
     The fourth theorem is used to arrange a nest of <span class="tt"><a href="C____UPDATE-VAR.html">update-var</a></span>s 
     in alphabetical order of the variable names: 
     it swaps two <span class="tt"><a href="C____UPDATE-VAR.html">update-var</a></span>s when the outer one 
     has an larger variable than the inner one. 
     Note that we need to disable loop stoppers for this rule, 
     otherwise ACL2 may not apply it based on the written value terms, 
     which are irrelevant to this normalization 
     based on alphabetical order. 
     Note the <span class="tt"><a href="ACL2____SYNTAXP.html">syntaxp</a></span> hypotheses 
     that require the identifiers (i.e. variable names) 
     to have the form described in <a href="C____ATC-IDENTIFIER-RULES.html">atc-identifier-rules</a>. 
     Finally, the fifth theorem serves to simplify the case in which 
     a variable is written with its current value; 
     this case may occur when proving the base case of a loop. 
     This theorem is phrased perhaps more generally than expected, 
     with two different computation state variables, 
     instead of the simpler form in <span class="v">update-var-of-read-var-same-lemma</span>: 
     the reason is that sometimes during symbolic execution 
     a pattern arises of the form 
     <span class="v">(<a href="C____UPDATE-VAR.html">update-var</a> var (<a href="C____READ-VAR.html">read-var</a> var compst) &lt;other-compst&gt;)</span>, 
     where <span class="v">&lt;other-compst&gt;</span> is a term 
     that is not just the <span class="v">compst</span> variable: 
     the rule binds <span class="v">compst1</span> to that. 
     This fifth theorem has a <span class="tt"><a href="ACL2____SYNTAXP.html">syntaxp</a></span> hypothesis 
     requiring the computation state argument of <span class="tt"><a href="C____READ-VAR.html">read-var</a></span> 
     to be a variable; 
     this may not be actually necessary, 
     but for now we include it just to make sure.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Theorem: </b>update-var-of-enter-scope</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> update-var-of-enter-scope
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____UPDATE-VAR.html">update-var</a> var val (<a href="C____ENTER-SCOPE.html">enter-scope</a> compst))
               (<a href="C____ENTER-SCOPE.html">enter-scope</a> (<a href="C____UPDATE-VAR.html">update-var</a> var val compst))))</pre> 
<p><b>Theorem: </b>update-var-of-add-var</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> update-var-of-add-var
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____UPDATE-VAR.html">update-var</a> var val (<a href="C____ADD-VAR.html">add-var</a> var2 val2 compst))
               (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____IDENT-FIX.html">ident-fix</a> var) (<a href="C____IDENT-FIX.html">ident-fix</a> var2))
                   (<a href="C____ADD-VAR.html">add-var</a> var2 val compst)
                   (<a href="C____ADD-VAR.html">add-var</a> var2
                            val2 (<a href="C____UPDATE-VAR.html">update-var</a> var val compst)))))</pre> 
<p><b>Theorem: </b>update-var-of-update-var-same</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> update-var-of-update-var-same
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____UPDATE-VAR.html">update-var</a> var val (<a href="C____UPDATE-VAR.html">update-var</a> var val2 compst))
               (<a href="C____UPDATE-VAR.html">update-var</a> var val compst)))</pre> 
<p><b>Theorem: </b>update-var-of-update-var-less</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    update-var-of-update-var-less
    (<a href="ACL2____IMPLIES.html">implies</a>
         (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SYNTAXP.html">syntaxp</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> var2)
                            (<a href="COMMON-LISP____EQ.html">eq</a> (<a href="COMMON-LISP____CAR.html">car</a> var2) 'ident)
                            (<a href="ACL2____QUOTEP.html">quotep</a> (<a href="COMMON-LISP____CADR.html">cadr</a> var2))))
              (<a href="ACL2____SYNTAXP.html">syntaxp</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> var)
                            (<a href="COMMON-LISP____EQ.html">eq</a> (<a href="COMMON-LISP____CAR.html">car</a> var) 'ident)
                            (<a href="ACL2____QUOTEP.html">quotep</a> (<a href="COMMON-LISP____CADR.html">cadr</a> var))))
              (<a href="ACL2_____C3_C3.html">&lt;&lt;</a> (<a href="C____IDENT-FIX.html">ident-fix</a> var2) (<a href="C____IDENT-FIX.html">ident-fix</a> var))
              (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____COMPUSTATE-FRAMES-NUMBER.html">compustate-frames-number</a> compst)
                          0)))
         (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____UPDATE-VAR.html">update-var</a> var val (<a href="C____UPDATE-VAR.html">update-var</a> var2 val2 compst))
                (<a href="C____UPDATE-VAR.html">update-var</a> var2 val2 (<a href="C____UPDATE-VAR.html">update-var</a> var val compst))))
    :rule-classes ((:rewrite :loop-stopper nil)))</pre> 
<p><b>Theorem: </b>update-var-of-read-var-same</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> update-var-of-read-var-same
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SYNTAXP.html">syntaxp</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> compst))
                      (<a href="C____COMPUSTATEP.html">compustatep</a> compst1)
                      (<a href="C____VALUEP.html">valuep</a> (<a href="C____READ-VAR.html">read-var</a> var compst))
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____READ-VAR.html">read-var</a> var compst)
                             (<a href="C____READ-VAR.html">read-var</a> var compst1)))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____UPDATE-VAR.html">update-var</a> var (<a href="C____READ-VAR.html">read-var</a> var compst)
                                    compst1)
                        compst1)))</pre> 

</body>
</html>
