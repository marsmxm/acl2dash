<html>
<head>
<meta charset="UTF-8">
<title>Multiplier-verification-demo-1</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=RP____MULTIPLIER-VERIFICATION-DEMO-1">Click for Multiplier-verification-demo-1 in the Full Manual</a></h3>

<p>First demo for <a href="RP____MULTIPLIER-VERIFICATION.html">Multiplier-Verification</a> showing how an isolated 
 integer multiplier is verified.</p> <p> Below is a demo that  shows how to input a multiplier design coded 
in (System) Verilog into ACL2, and verify it efficiently. We choose a 64x64-bit 
Booth Encoded Dadda Tree multiplier with  Han-Carlson adder as our example.  If 
you  wish, you  can skip  to <a href="RP____MULTIPLIER-VERIFICATION-DEMO-2.html">Multiplier-Verification-demo-2</a> for  a more 
complex arithmetic module.  </p> 
 
 
<p>   The   exact   events   given   in   this   page   are   also   given   in 
<span class="v">&lt;your-acl2-directory&gt;/books/projects/rp-rewriter/lib/mult3/demo/demo-1.lisp</span> 
</p> 
 
<p> 
1. Include the books to convert Verilog designs to SVL format. 
</p> 
<pre class="code">(include-book "centaur/sv/top" :dir :system) ;; a big book; takes around 30 seconds 
(include-book "centaur/vl/loader/top" :dir :system) ;; takes around 10 seconds 
(include-book "oslib/ls" :dir :system) 
(include-book "centaur/svl/top" :dir :system) 
</pre> 
<p> 
<a href="ACL2____SVL.html">svl</a> system uses <a href="ACL2____SV.html">sv</a> and <a href="ACL2____VL.html">vl</a> packages. 
</p> 
 
<p> 2. Load VL design for  the modules in DT_SB4_HC_64_64_multgen.sv. This file 
is                                 located                                under 
<span class="v">&lt;your-acl2-directory&gt;/books/projects/rp-rewriter/lib/mult3/demo</span>.   This is 
a 64x64 Signed,  Booth radix-4 encoded, Dadda Tree  integer multiplier.  <pre class="code"><span class="v">
(<a href="ACL2____DEFCONSTS.html">acl2::defconsts</a>
 (*vl-design* state)
 (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> loadresult state)
       (<a href="VL____VL-LOAD.html">vl::vl-load</a> (<a href="VL____MAKE-VL-LOADCONFIG.html">vl::make-vl-loadconfig</a>
                     :start-files '("DT_SB4_HC_64_64_multgen.sv")))))
   (<a href="ACL2____MV.html">mv</a> ({vl::vl-loadresult-&gt;design loadresult) state)))
</span> 
</pre> 
</p> 
 
<p> 
3. Load SV design: 
<pre class="code"><span class="v">
(<a href="ACL2____DEFCONSTS.html">acl2::defconsts</a>
 (*sv-design*
  *simplified-good*
  *simplified-bad*)
 (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> errmsg sv-design good bad)
       (<a href="VL____VL-DESIGN-_E3SV-DESIGN.html">vl::vl-design-&gt;sv-design</a> "DT_SB4_HC_64_64"
                                 *vl-design* (<a href="VL____MAKE-VL-SIMPCONFIG.html">vl::make-vl-simpconfig</a>))))
   (<a href="COMMON-LISP____AND.html">and</a> errmsg
        (<a href="ACL2____RAISE.html">acl2::raise</a> "~@0~%" errmsg))
   (<a href="ACL2____MV.html">mv</a> sv-design good bad)))
</span> 
</pre> 
</p> 
 
 
<p> 
4. Load SVL Design: 
<pre class="code"><span class="v">(<a href="ACL2____DEFCONSTS.html">acl2::defconsts</a> (*svl-design* rp::rp-state)
                 (<a href="ACL2____SVL-FLATTEN-DESIGN.html">svl-flatten-design</a> *sv-design*
                                     *vl-design*
                                     :dont-flatten :all))
</span> 
</pre> 
 
</p> 
 
<p>  SVL  design is  a  simulation-ready  version  of  SV design  with  circuit 
hierarchy maintained. Note  that we are telling the program  not to flatten all 
the modules (with the ':dont-flatten :all' argument), which will reserve design 
hierarchy, which  we will  use while  verifying the module.   If users  wish to 
flatten some modules, they should at  least have the adder module names instead 
of ':all'. See <a href="ACL2____SVL-FLATTEN-DESIGN.html">svl-flatten-design</a>.  </p> 
 
 
 
<p> 
5. Include the book that has the rewrite and meta rules 
for multiplier proofs: 
<pre class="code">(include-book "projects/rp-rewriter/lib/mult3/svl-top" :dir :system) 
</pre> 
</p> 
 
 
<p> 
6. Rewrite the adder modules with our specification: 
 
</p> 
 
<pre class="code">(def-rp-rule svl-run-phase-of-FullAdder 
  (implies (and (bitp x) 
                (bitp y) 
                (bitp z)) 
           (equal (svl::svl-run-phase-wog "fa" 
                                          (list x y z) 
                                          svl::*empty-state* 
                                          *svl-design*) 
                  (mv (s-c-spec (list x y z)) 
                      svl::*empty-state*))) 
  :hints (("Goal" 
           :do-not-induct t 
           :in-theory (e/d (bitp) 
                           ())))) 
</pre> 
<pre class="code">(def-rp-rule svl-run-phase-of-HalfAdder 
  (implies (and (bitp x) 
                (bitp y)) 
           (equal (svl::svl-run-phase-wog "ha" 
                                          (list x y) 
                                          svl::*empty-state* 
                                          *svl-design*) 
                  (mv (s-c-spec (list x y)) 
                      svl::*empty-state*))) 
  :hints (("Goal" 
           :do-not-induct t 
           :in-theory (e/d (bitp) 
                           ())))) 
</pre> 
 
<p> 
The multiplier we are working on uses two types of bit-level adders: a 
full-adder with module name "fa", and a half-adder with module name 
"ha". We rewrite them with the lemmas given above. We use <a href="RP____DEF-RP-RULE.html">def-rp-rule</a> 
to save these in the <a href="ACL2____RP-REWRITER.html">rp-rewriter</a>'s rule-set. ACL2 can prove these lemmas 
easily by case-splitting with <span class="v">bitp</span> and trying all the combinations. 
</p> 
 
<pre class="code">(defthmrp final-stage-adder-correct 
  (implies (and (integerp in1) 
                (integerp in2)) 
           (equal (svl::svl-run-phase-wog "HC_128" 
                                          (list in1 in2) 
                                          svl::*empty-state* 
                                          *svl-design*) 
                  (mv (list (loghead 129 (+ (loghead 128 in1) 
                                            (loghead 128 in2))) 
                      svl::*empty-state*))) 
  :disable-meta-rules (s-c-spec-meta) 
  :enable-rules rp::*adder-rules*) 
</pre> 
 
<p> 
This multiplier  module uses  a Han-Carlson parallel  prefix adder  with module 
name "HC_128".   We use our  suggested rewriting  scheme to prove  this adder 
equivalent  to   our  specification.   The  macro   <a href="RP____DEFTHMRP.html">defthmrp</a>  calls 
RP-Rewriter as a  clause processor. In proofs for adder  modules, the arguments 
':disable-meta-rules (s-c-spec-meta)' and ':enable-rules rp::*adder-rules*' are 
standard. These arguments disable the  rules specific to multiplier modules and 
enable the ones for adders. 
 
</p> 
 
<p> 
Rewriting all the adder logic in terms of their specification as given above is 
a crucial step for multiplier correctness proofs. The adder proofs are usually 
very fast and takes a split second.  
</p> 
 
<p> 
7. Finally, prove the multiplier correct: 
<pre class="code">(defthmrp multiplier-correct-v1 
  (implies (and (integerp in1) 
                (integerp in2)) 
           (equal (svl::svl-run-phase-wog "DT_SB4_HC_64_64" 
                                          (list in1 in2) 
                                          svl::*empty-state* 
                                          *svl-design*) 
                  (mv  (list (loghead 128 (* (sign-ext in1 64) 
                                             (sign-ext in2 64)))) 
                       svl::*empty-state*)))) 
</pre> 
 
This proof takes about 1.5 seconds to finish. Alternatively, users can run 
a similar proof as follows with a simulation pattern instead: 
 
<pre class="code">(progn 
  (defconst *input-bindings* 
    '(("IN1" a) 
      ("IN2" b))) 
 
  (defconst *output-bindings* 
    '(("result" out))) 
 
  ;; Another way to state correctness proof for the multiplier. 
  ;; Similar to SVTV-run 
  ;; takes around 1.5 seconds 
  (defthmrp multiplier-correct-v1 
    (implies (and (integerp in1) 
                  (integerp in2)) 
             (equal (svl-run "DT_SB4_HC_64_64" 
                             `((a . ,in1) 
                               (b . ,in2)) 
                             *input-bindings* 
                             *output-bindings* 
                             *svl-design*) 
                    `((out . ,(loghead 128 (* (sign-ext in1 64) 
                                              (sign-ext in2 64))))))))) 
</pre> 
 
 
Once we can successfully submit one of these events, we can conclude that the 
given design is functionally correct. 
 
</p> 
 
<p> This program  is tested for multipliers up to  1024x1024; and they each finished 
in at most 5 minutes on our machines.  </p> 
 
<p> 
For large multipliers, users may need to increase the stack size in ACL2 image 
(e.g., saved_acl2 under you ACL2 directory) and run the proofs again. In our 
tests, we have observed SBCL to be faster than CCL; however, for large 
multipliers garbage collector of CCL does a better job with <a href="ACL2____SET-MAX-MEM.html">ACL2::set-max-mem</a> and it can finish large proofs when SBCL terminates with memory 
errors.  
</p> 
 
 
<p> 
You may continue to <a href="RP____MULTIPLIER-VERIFICATION-DEMO-2.html">Multiplier-Verification-demo-2</a>. 
</p> 
 

</body>
</html>
