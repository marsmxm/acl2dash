<html>
<head>
<meta charset="UTF-8">
<title>Tutorial2-eights-problem</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____TUTORIAL2-EIGHTS-PROBLEM">Click for Tutorial2-eights-problem in the Full Manual</a></h3>

<p>The Eights Problem Example</p><p>This example was written almost entirely by Bill Young of 
 Computational Logic, Inc.</p> 
 
 <p>This simple example was brought to our attention as one that Paul Jackson 
 has solved using the NuPrl system.  The challenge is to prove the theorem:</p> 
 
 <pre class="code">for all n &gt; 7, there exist naturals i and j such that: n = 3i + 5j.</pre> 
 
 <p>In ACL2, we could phrase this theorem using quantification.  However we 
 will start with a constructive approach, i.e., we will show that values of 
 <span class="v">i</span> and <span class="v">j</span> exist by writing a function that will construct such values 
 for given <span class="v">n</span>.  Suppose we had a function <span class="v">(split n)</span> that returns an 
 appropriate pair <span class="v">(i . j)</span>.  Our theorem would be as follows:</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> split-splits
  (<a href="COMMON-LISP____LET.html">let</a> ((i (<a href="COMMON-LISP____CAR.html">car</a> (split n)))
        (j (<a href="COMMON-LISP____CDR.html">cdr</a> (split n))))
    (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)
                  (<a href="COMMON-LISP_____C3.html">&lt;</a> 7 n))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> i)
                  (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 0 i)
                  (<a href="COMMON-LISP____INTEGERP.html">integerp</a> j)
                  (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 0 j)
                  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP_____A2.html">*</a> 3 i) (<a href="COMMON-LISP_____A2.html">*</a> 5 j))
                         n)))))</pre> 
 
 <p>That is, assuming that <span class="v">n</span> is a natural number greater than 7, <span class="v">(split
 n)</span> returns values <span class="v">i</span> and <span class="v">j</span> that are in the appropriate relation to 
 <span class="v">n</span>.</p> 
 
 <p>Let's look at a few cases:</p> 
 
 <pre class="code"> 8 = 3x1 + 5x1;    11 = 3x2 + 5x1;     14 = 3x3 + 5x1;   ...
 9 = 3x3 + 5x0;    12 = 3x4 + 5x0;     15 = 3x5 + 5x0;   ...
10 = 3x0 + 5x2;    13 = 3x1 + 5x2;     16 = 3x2 + 5x2;   ...</pre> 
 
 <p>Maybe you will have observed a pattern here; any natural number larger than 
 10 can be obtained by adding some multiple of 3 to 8, 9, or 10.  This gives us 
 the clue to constructing a proof.  It is clear that we can write split as 
 follows:</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> bump-i (x)
  ;; Bump the i component of the pair
  ;; (i . j) by 1.
  (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____1_B2.html">1+</a> (<a href="COMMON-LISP____CAR.html">car</a> x)) (<a href="COMMON-LISP____CDR.html">cdr</a> x)))

(<a href="COMMON-LISP____DEFUN.html">defun</a> split (n)
  ;; Find a pair (i . j) such that
  ;; n = 3i + 5j.
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____OR.html">or</a> (<a href="ACL2____ZP.html">zp</a> n) (<a href="COMMON-LISP_____C3.html">&lt;</a> n 8))
      nil ;; any value is really reasonable here
    (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> n 8)
        (<a href="COMMON-LISP____CONS.html">cons</a> 1 1)
      (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> n 9)
          (<a href="COMMON-LISP____CONS.html">cons</a> 3 0)
        (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> n 10)
            (<a href="COMMON-LISP____CONS.html">cons</a> 0 2)
          (bump-i (split (<a href="COMMON-LISP____-.html">-</a> n 3))))))))</pre> 
 
 <p>Notice that we explicitly compute the values of <span class="v">i</span> and <span class="v">j</span> for the 
 cases of 8, 9, and 10, and for the degenerate case when <span class="v">n</span> is not a 
 natural or is less than 8.  For all naturals greater than <span class="v">n</span>, we decrement 
 <span class="v">n</span> by 3 and bump the number of 3's (the value of i) by 1.  We know that 
 the recursion must terminate because any integer value greater than 10 can 
 eventually be reduced to 8, 9, or 10 by successively subtracting 3.</p> 
 
 <p>Let's try it on some examples:</p> 
 
 <pre class="code">ACL2 !&gt;(split 28)
(6 . 2)

ACL2 !&gt;(split 45)
(15 . 0)

ACL2 !&gt;(split 335)
(110 . 1)</pre> 
 
 <p>Finally, we submit our theorem <span class="v">split-splits</span>, and the proof succeeds. 
 In this case, the prover is ``smart'' enough to induct according to the 
 pattern indicated by the function split.</p> 
 
 <p>For completeness, we'll note that we can state and prove a quantified 
 version of this theorem.  We introduce the notion <span class="v">split-able</span> to mean that 
 appropriate <span class="v">i</span> and <span class="v">j</span> exist for <span class="v">n</span>.</p> 
 
 <pre class="code">(<a href="ACL2____DEFUN-SK.html">defun-sk</a> split-able (n)
  (<a href="ACL2____EXISTS.html">exists</a> (i j)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> n (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP_____A2.html">*</a> 3 i) (<a href="COMMON-LISP_____A2.html">*</a> 5 j)))))</pre> 
 
 <p>Then our theorem is given below.  Notice that we prove it by observing that 
 our previous function <span class="v">split</span> delivers just such an <span class="v">i</span> and <span class="v">j</span> (as 
 we proved above).</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> split-splits2
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)
                (<a href="COMMON-LISP_____C3.html">&lt;</a> 7 n))
           (split-able n))
  :hints (("Goal" :use (:instance split-able-suff
                                  (i (<a href="COMMON-LISP____CAR.html">car</a> (split n)))
                                  (j (<a href="COMMON-LISP____CDR.html">cdr</a> (split n)))))))</pre> 
 
 <p>Unfortunately, understanding the mechanics of the proof requires knowing 
 something about the way <span class="tt"><a href="ACL2____DEFUN-SK.html">defun-sk</a></span> works.  See <a href="ACL2____DEFUN-SK.html">defun-sk</a> or see 
 <a href="ACL2____TUTORIAL4-DEFUN-SK-EXAMPLE.html">Tutorial4-Defun-Sk-Example</a> for more on that subject.</p>
</body>
</html>
