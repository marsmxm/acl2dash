<html>
<head>
<meta charset="UTF-8">
<title>Base58-decode</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=BITCOIN____BASE58-DECODE">Click for Base58-decode in the Full Manual</a></h3>

<p>Turn a list of Base58 characters 
          into the corresponding list of bytes.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(base58-decode chars) → bytes</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">chars</span> — <font color="#606060">Guard <span class="v">(<a href="BITCOIN____BASE58-CHARACTER-LISTP.html">base58-character-listp</a> chars)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">bytes</span> — <font color="#606060">Type <span class="v">(<a href="ACL2____BYTE-LISTP.html">byte-listp</a> bytes)</span>.</font>
</dd> 
 
</dl></div> 
<p>This is not explicitly described in [Wiki] or [MB], 
     but is, implicitly, the inverse of encoding.</p><p>From a formal specification perspective, 
     we could define this function as the inverse of <span class="tt"><a href="BITCOIN____BASE58-ENCODE.html">base58-encode</a></span>. 
     But since decoding is quite analogous to encoding, 
     and not more complicated than encoding, 
     instead we define it in an executable way, 
     and prove that it is indeed the inverse of encoding. 
     This way, the formal specification of decoding is executable.</p><p>This executable formal specification of decoding essentially runs 
     the encoding steps ``in reverse''. 
     Instead of counting 
     the number of leading ``zero'' (i.e. <span class="v">1</span>) characters 
     in the input characters, 
     we count the number of leading zeros in their corresponding values, 
     via <span class="tt"><a href="ACL2____TRIM-BENDIAN_A2.html">trim-bendian*</a></span>. 
     Unlike in <span class="tt"><a href="BITCOIN____BASE58-ENCODE.html">base58-encode</a></span>, 
     there is no need here for an <span class="tt"><a href="ACL2____MBE.html">mbe</a></span> 
     to fix the argument of <span class="tt"><a href="ACL2____TRIM-BENDIAN_A2.html">trim-bendian*</a></span>.</p><p>The addition of the zero bytes does not affect the denoted natural number, 
     which is the same denoted by 
     (the corresponding values of) the input characters.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>base58-decode</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> base58-decode (chars)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="BITCOIN____BASE58-CHARACTER-LISTP.html">base58-character-listp</a> chars)))
       (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'base58-decode))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
            (<a href="ACL2____B_A2.html">b*</a> ((vals (<a href="BITCOIN____BASE58-CHARS_D3_E3VALS.html">base58-chars=&gt;vals</a> chars))
                 (nat (<a href="ACL2____BENDIAN_D3_E3NAT.html">bendian=&gt;nat</a> 58 vals))
                 (number-of-zeros (<a href="COMMON-LISP____-.html">-</a> (<a href="ACL2____LEN.html">len</a> vals)
                                     (<a href="ACL2____LEN.html">len</a> (<a href="ACL2____TRIM-BENDIAN_A2.html">trim-bendian*</a> vals))))
                 (<a href="BITCOIN____BYTES.html">bytes</a> (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="ACL2____REPEAT.html">repeat</a> number-of-zeros 0)
                                (<a href="ACL2____NAT_D3_E3BEBYTES_A2.html">nat=&gt;bebytes*</a> nat))))
                bytes)))</pre> 
<p><b>Theorem: </b>byte-listp-of-base58-decode</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> byte-listp-of-base58-decode
        (<a href="ACL2____B_A2.html">b*</a> ((<a href="BITCOIN____BYTES.html">bytes</a> (<a href="BITCOIN____BASE58-DECODE.html">base58-decode</a> chars)))
            (<a href="ACL2____BYTE-LISTP.html">byte-listp</a> bytes))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>base58-decode-same-natural-number</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> base58-decode-same-natural-number
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____BEBYTES_D3_E3NAT.html">bebytes=&gt;nat</a> (<a href="BITCOIN____BASE58-DECODE.html">base58-decode</a> chars))
               (<a href="ACL2____BENDIAN_D3_E3NAT.html">bendian=&gt;nat</a> 58 (<a href="BITCOIN____BASE58-CHARS_D3_E3VALS.html">base58-chars=&gt;vals</a> chars))))</pre> 
<p><b>Theorem: </b>base58-decode-of-base58-character-list-fix-chars</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> base58-decode-of-base58-character-list-fix-chars
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="BITCOIN____BASE58-DECODE.html">base58-decode</a> (<a href="BITCOIN____BASE58-CHARACTER-LIST-FIX.html">base58-character-list-fix</a> chars))
               (<a href="BITCOIN____BASE58-DECODE.html">base58-decode</a> chars)))</pre> 
<p><b>Theorem: </b>base58-decode-base58-character-list-equiv-congruence-on-chars</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     base58-decode-base58-character-list-equiv-congruence-on-chars
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="BITCOIN____BASE58-CHARACTER-LIST-EQUIV.html">base58-character-list-equiv</a> chars chars-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="BITCOIN____BASE58-DECODE.html">base58-decode</a> chars)
                     (<a href="BITCOIN____BASE58-DECODE.html">base58-decode</a> chars-equiv)))
     :rule-classes :congruence)</pre> 

</body>
</html>
