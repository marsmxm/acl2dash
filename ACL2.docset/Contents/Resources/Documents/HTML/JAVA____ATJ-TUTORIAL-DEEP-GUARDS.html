<html>
<head>
<meta charset="UTF-8">
<title>Atj-tutorial-deep-guards</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=JAVA____ATJ-TUTORIAL-DEEP-GUARDS">Click for Atj-tutorial-deep-guards in the Full Manual</a></h3>

<p>ATJ tutorial: Guards in the Deep Embedding Approach.</p><p>This tutorial page describes the effect of ATJ's <span class="v">:guards</span> option 
    when <span class="v">:deep</span> is <span class="v">t</span>, i.e. in the <a href="JAVA____ATJ-TUTORIAL-DEEP.html">deep embedding approach</a>. The effect of <span class="v">:guards</span> in the shallow embedding approach 
    is described in later tutorial pages. 
    Even though, as noted in <a href="JAVA____ATJ-TUTORIAL-DEEP-SHALLOW.html">atj-tutorial-deep-shallow</a>, 
    the shallow embedding approach is generally preferred over the deep one, 
    some of the concepts common to the two approaches are discussed here. 
    So, if this tutorial page is skipped at first reading, 
    it may be necessary to come back to it 
    while reading the pages on the shallow embedding approach.</p><h5>Ignoring Guards</h5><p>As briefly noted in the factorial example in <a href="JAVA____ATJ-TUTORIAL-DEEP.html">atj-tutorial-deep</a>, 
    the option <span class="v">:guards nil</span> specifies 
    not to assume the satisfaction of guards. 
    More precisely, this option tells ATJ that the generated Java code 
    must mimic ACL2's execution in the logic, i.e. ignoring guards completely. 
    (Indeed, <a href="JAVA____ATJ-TUTORIAL-ACL2-ENVIRONMENT.html">AIJ's representation of the ACL2 function definitions</a> currently does not even include the functions' guards.)</p><p>ACL2's execution in the logic is described <a href="ACL2____EVALUATION.html">in the manual page on ACL2 evaluation</a>. It means that ACL2 functions, which are total in the logic, 
    may be called on any argument values (inside or outside the guards), 
    and functions will return the corresponding results. 
    For instance, one can call <span class="tt"><a href="COMMON-LISP____CAR.html">car</a></span> on a number and obtain <span class="v">nil</span>, 
    or call <span class="tt"><a href="ACL2____BINARY-_B2.html">binary-+</a></span> on a symbol and a string and obtain 0.</p><p>Accordingly, the <span class="v">call(Acl2Symbol, Acl2Value[])</span> method 
    generated by ATJ (see <a href="JAVA____ATJ-TUTORIAL-DEEP.html">atj-tutorial-deep</a>) 
    accepts any array of <span class="v">Acl2Value</span>s, 
    independently from the guard of the function named by the <span class="v">Acl2Symbol</span>, 
    and returns the resulting <span class="v">Acl2Value</span>.</p><p>When ACL2 executes in the logic, 
    calls of the form <span class="v">(<a href="ACL2____MBE.html">mbe</a> :logic a :exec b)</span> 
    are executed as just <span class="v">a</span>, ignoring <span class="v">b</span>. 
    Untranslated ACL2 terms of the form <span class="v">(<a href="ACL2____MBE.html">mbe</a> :logic a :exec b)</span> 
    are translated to the form <span class="v">(<a href="ACL2____RETURN-LAST.html">return-last</a> 'acl2::mbe1-raw b a)</span>. 
    Therefore, with the option <span class="v">:guards nil</span>, 
    ATJ treats terms <span class="v">(<a href="ACL2____RETURN-LAST.html">return-last</a> 'acl2::mbe1-raw b a)</span> 
    as if they were just <span class="v">a</span>, 
    for the purpose of generating Java code: 
    that is, ATJ generates Java code for <span class="v">a</span>, ignoring <span class="v">b</span>. 
    This is also discussed in <a href="JAVA____ATJ-TUTORIAL-TRANSLATED.html">atj-tutorial-translated</a>.</p><h5>Assuming Guards</h5><p>The <span class="v">:guards t</span> option tells ATJ to assume that all guards are satisfied. 
    This assumption is not checked by ATJ. 
    Ideally, it should be only used when 
    the ACL2 functions that ATJ translates to Java are all guard-verified, 
    or at least when the user is confident that 
    guards should be always satisfied. 
    Furthermore, external Java code that calls ATJ-generated code 
    must do so with values that satisfy the guards of the called functions. 
    If any of these assumption of guard satisfaction is violated 
    (whether due to internal calls if guards are not verified, 
    or to external calls even if guards are verified), 
    the Java code generated by ATJ may behave in unpredictable ways.</p><p>It should be possible to extend the code generated by ATJ 
    to check guards under suitable conditions, 
    in particular at the top level (i.e. for calls from external Java code), 
    as ACL2 does by default even for guard-verified code. 
    In fact, it should be possible to mimic <a href="ACL2____SET-GUARD-CHECKING.html">ACL2's various guard checking modes</a> in ATJ-generated Java code. 
    This is future work.</p><p>Currently, in the deep embedding approach, 
    the only effect of assuming guard satisfaction is that 
    for terms <span class="v">(<a href="ACL2____RETURN-LAST.html">return-last</a> 'acl2::mbe1-raw b a)</span>, 
    which result from translating <span class="v">(<a href="ACL2____MBE.html">mbe</a> :logic a :exec b)</span>, 
    ATJ generates Java code for <span class="v">b</span>, ignoring <span class="v">a</span>. 
    Compare this with the description above for <span class="v">:guards nil</span>.</p><p>When ACL2 executes in raw Lisp (i.e. not in the logic), 
    calls of the form <span class="v">(<a href="ACL2____MBE.html">mbe</a> :logic a :exec b)</span> 
    are executed as just <span class="v">b</span>, ignoring <span class="v">a</span>. 
    Compare this with the description above for execution in the logic.</p><p>Even with <span class="v">:guards t</span>, the <span class="v">call(Acl2Symbol, Acl2Value[])</span> method 
    generated by ATJ (see <a href="JAVA____ATJ-TUTORIAL-DEEP.html">atj-tutorial-deep</a>) 
    accepts any array of <span class="v">Acl2Value</span>s, 
    whether they satisfy the guard of the function named by the <span class="v">Acl2Symbol</span> 
    or not. 
    If they do not, unpredictable behavior may occur. 
    Given that, in the deep embedding approach, 
    the ACL2 functions are executed via <a href="JAVA____ATJ-TUTORIAL-EVALUATOR.html">AIJ's Java interpreter</a>, it is natural for all the ACL2 values manipulated by the interpreter 
    to have the same Java type (i.e. <span class="v">Acl2Value</span>), 
    rather than using narrower types derived from the guards.</p><p>Executing the <span class="v">:exec</span> portion of <span class="tt"><a href="ACL2____MBE.html">mbe</a></span>s 
    may be much faster than executing the <span class="v">:logic</span> portion. 
    For example, some fixing functions use <span class="tt"><a href="ACL2____MBE.html">mbe</a></span> 
    to logically fix values without any run-time penalty: 
    the <span class="v">:exec</span> part does nothing, 
    while the <span class="v">:logic</span> part may perform expensive computations, 
    e.g. fix every element of a long list. 
    As another examples, <span class="tt"><a href="ACL2____MBT.html">mbt</a></span>s are really <span class="tt"><a href="ACL2____MBE.html">mbe</a></span>s 
    that do nothing in the <span class="v">:exec</span> part 
    but may perform expensive tests in the <span class="v">:logic</span> part. 
    Thus, if the assumption of guard satisfaction can be supported, 
    it may be advantageous to use <span class="v">:guards t</span> 
    in the deep embedding approach, 
    even if the difference with <span class="v">:guards nil</span> 
    is just the treatment of (translated) <span class="tt"><a href="ACL2____MBE.html">mbe</a></span>s.</p><p>The difference between <span class="v">:guards nil</span> and <span class="v">:guards t</span> 
    is much more significant in the shallow embedding approach. 
    This is described in detail in later tutorial pages.</p><div class="box"></div><p><b>Previous:</b> <a href="JAVA____ATJ-TUTORIAL-TRANSLATED.html">ACL2 Functions Translated To Java</a></p><p><b>Next:</b> <a href="JAVA____ATJ-TUTORIAL-TESTS.html">Generation of Tests</a></p>
</body>
</html>
