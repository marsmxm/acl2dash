<html>
<head>
<meta charset="UTF-8">
<title>Sal/shl-spec</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=X86ISA____SAL_F2SHL-SPEC">Click for Sal/shl-spec in the Full Manual</a></h3>

<p>Specification for the <span class="v">SAL/SHL</span> instruction</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(sal/shl-spec size dst src input-rflags)  (mv * * *)</pre></dt> 
</dl></div> 
<p>Source: Intel Manual, Volume 2B, Instruction Set Reference 
(N-Z).</p> 
 
<p>The shift arithmetic left (SAL) and shift logical left (SHL) 
instructions perform the same operation; they shift the bits in the 
destination operand to the left (toward more significant bit 
locations). For each shift count, the most significant bit of the 
destination operand is shifted into the CF flag, and the least 
significant bit is cleared.  The OF flag is affected only on 1-bit 
shifts. For left shifts, the OF flag is set to 0 if the 
most-significant bit of the result is the same as the CF flag (that 
is, the top two bits of the original operand were the same); 
otherwise, it is set to 1.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>sal/shl-spec$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> sal/shl-spec$inline
       (size dst src input-rflags)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (<a href="COMMON-LISP____MEMBER.html">member</a> 1 2 4 8) size)
                (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 32) input-rflags))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="X86ISA____N06P.html">n06p</a> src)
                                   (<a href="COMMON-LISP____CASE.html">case</a> size (1 (<a href="X86ISA____N08P.html">n08p</a> dst))
                                         (2 (<a href="X86ISA____N16P.html">n16p</a> dst))
                                         (4 (<a href="X86ISA____N32P.html">n32p</a> dst))
                                         (8 (<a href="X86ISA____N64P.html">n64p</a> dst))
                                         (otherwise nil)))))
       (<a href="COMMON-LISP____CASE.html">case</a> size
             (1 (<a href="X86ISA____SAL_F2SHL-SPEC-8.html">sal/shl-spec-8</a> dst src input-rflags))
             (2 (<a href="X86ISA____SAL_F2SHL-SPEC-16.html">sal/shl-spec-16</a> dst src input-rflags))
             (4 (<a href="X86ISA____SAL_F2SHL-SPEC-32.html">sal/shl-spec-32</a> dst src input-rflags))
             (8 (<a href="X86ISA____SAL_F2SHL-SPEC-64.html">sal/shl-spec-64</a> dst src input-rflags))
             (otherwise (<a href="ACL2____MV.html">mv</a> 0 0 0))))</pre> 
<p><b>Theorem: </b>natp-mv-nth-0-sal/shl-spec</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> natp-mv-nth-0-sal/shl-spec
        (<a href="ACL2____NATP.html">natp</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> 0
                      (<a href="X86ISA____SAL_F2SHL-SPEC.html">sal/shl-spec</a> size dst src input-rflags)))
        :rule-classes :type-prescription)</pre> 
<p><b>Theorem: </b>n32p-mv-nth-1-sal/shl-spec</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 n32p-mv-nth-1-sal/shl-spec
 (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> 32
                  (<a href="ACL2____MV-NTH.html">mv-nth</a> 1
                          (<a href="X86ISA____SAL_F2SHL-SPEC.html">sal/shl-spec</a> size dst src input-rflags)))
 :rule-classes
 (:rewrite
  (:type-prescription
      :corollary
      (<a href="ACL2____NATP.html">natp</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> 1
                    (<a href="X86ISA____SAL_F2SHL-SPEC.html">sal/shl-spec</a> size dst src input-rflags)))
      :hints
      (("Goal" :in-theory '(<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> integer-range-p natp))))
  (:linear
   :corollary
   (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 0
            (<a href="ACL2____MV-NTH.html">mv-nth</a> 1
                    (<a href="X86ISA____SAL_F2SHL-SPEC.html">sal/shl-spec</a> size dst src input-rflags)))
        (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> 1
                   (<a href="X86ISA____SAL_F2SHL-SPEC.html">sal/shl-spec</a> size dst src input-rflags))
           4294967296))
   :hints
   (("Goal"
        :in-theory '(<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> integer-range-p (:e expt)))))))</pre> 
<p><b>Theorem: </b>n32p-mv-nth-2-sal/shl-spec</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 n32p-mv-nth-2-sal/shl-spec
 (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> 32
                  (<a href="ACL2____MV-NTH.html">mv-nth</a> 2
                          (<a href="X86ISA____SAL_F2SHL-SPEC.html">sal/shl-spec</a> size dst src input-rflags)))
 :rule-classes
 (:rewrite
  (:type-prescription
      :corollary
      (<a href="ACL2____NATP.html">natp</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> 2
                    (<a href="X86ISA____SAL_F2SHL-SPEC.html">sal/shl-spec</a> size dst src input-rflags)))
      :hints
      (("Goal" :in-theory '(<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> integer-range-p natp))))
  (:linear
   :corollary
   (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 0
            (<a href="ACL2____MV-NTH.html">mv-nth</a> 2
                    (<a href="X86ISA____SAL_F2SHL-SPEC.html">sal/shl-spec</a> size dst src input-rflags)))
        (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> 2
                   (<a href="X86ISA____SAL_F2SHL-SPEC.html">sal/shl-spec</a> size dst src input-rflags))
           4294967296))
   :hints
   (("Goal"
        :in-theory '(<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> integer-range-p (:e expt)))))))</pre> 

</body>
</html>
