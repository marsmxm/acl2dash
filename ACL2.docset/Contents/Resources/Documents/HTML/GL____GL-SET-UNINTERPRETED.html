<html>
<head>
<meta charset="UTF-8">
<title>Gl-set-uninterpreted</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=GL____GL-SET-UNINTERPRETED">Click for Gl-set-uninterpreted in the Full Manual</a></h3>

<p>Prevent GL from interpreting a function's definition or concretely executing it.</p><p>Usage:</p> 
<pre class="code">;; disallow definition expansion and concrete execution
(<a href="GL____GL-SET-UNINTERPRETED.html">gl::gl-set-uninterpreted</a> fnname)
(<a href="GL____GL-SET-UNINTERPRETED.html">gl::gl-set-uninterpreted</a> fnname t) ;; same as above

;; disallow definition expansion but allow concrete execution
(<a href="GL____GL-SET-UNINTERPRETED.html">gl::gl-set-uninterpreted</a> fnname :concrete-only)

;; disallow concrete execution but allow definition expansion
(<a href="GL____GL-SET-UNINTERPRETED.html">gl::gl-set-uninterpreted</a> fnname :no-concrete)

;; remove restrictions
(<a href="GL____GL-SET-UNINTERPRETED.html">gl::gl-set-uninterpreted</a> fnname nil)
(gl::gl-unset-uninterpreted fnname) ;; same</pre> 
<p>prevents GL from opening the definition of fnname and/or concretely executing 
it.  GL will still apply rewrite rules to a call of <span class="v">fnname</span>.  If the 
call is not rewritten away, symbolic execution of a <span class="v">fnname</span> call will 
simply produce an object (of the :g-apply type) representing a call of 
<span class="v">fnname</span> on the given arguments.</p> 
 
<p><span class="v">gl::gl-unset-uninterpreted</span> undoes the effect of <span class="v">gl::gl-set-uninterpreted</span>.</p> 
 
<p>Note that <span class="v">gl::gl-set-uninterpreted</span> has virtually no effect when 
applied to a GL primitive: a function that has its ``symbolic 
counterpart'' built into the GL clause processor you're using.  (It 
actually does do a little â€” it can prevent the function from being 
applied to concrete values before rewrite rules are applied.  But that 
could change in the future.)  But what is a GL primitive?  That 
depends on the current GL clause processor, and can only be determined 
reliably by looking at the definition of the following function 
symbol:</p> 
 
<pre class="code">(<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="ACL2____ASSOC-EQ.html">assoc-eq</a> 'gl::run-gified
               (<a href="ACL2____TABLE-ALIST.html">table-alist</a> 'gl::latest-greatest-gl-clause-proc (<a href="ACL2____W.html">w</a> state))))</pre> 
 
<p>For example, this function symbol is 'gl::glcp-run-gified immediately after 
including the community-book <span class="v">"centaur/gl/gl"</span>.  Now use <span class="v">:</span><span class="tt"><a href="ACL2____PE.html">pe</a></span> 
on this function symbol.  The body of that definition should be of the form 
<span class="v">(<a href="COMMON-LISP____CASE.html">case</a> fn ...)</span>, which matches <span class="v">fn</span> against all the GL primitives for the 
current GL clause processor.</p> 
 
 
 

</body>
</html>
