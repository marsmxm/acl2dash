<html>
<head>
<meta charset="UTF-8">
<title>Atc-arrays</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=C____ATC-ARRAYS">Click for Atc-arrays in the Full Manual</a></h3>

<p>A model of C arrays for ATC.</p><p>At this time, we represent arrays as 
     sequences of values that can be read and written. 
     These array representations can be passed around, and manipulated by, 
     ACL2 functions that represent C functions, 
     and ATC translates those to corresponding array manipulations.</p><p>We represent arrays as values of fixtypes that wrap lists of C values. 
     We provide operations to read and write elements, 
     essentially wrappers of <span class="tt"><a href="COMMON-LISP____NTH.html">nth</a></span> and <span class="tt"><a href="ACL2____UPDATE-NTH.html">update-nth</a></span>.</p><p>This fairly simple model should suffice to generate C code 
     that manipulates arrays in some interesting ways. 
     It should suffice to represent C functions 
     that receive arrays from external callers, 
     and possibly update them. 
     However, we may need to extend the model in the future; 
     in particular, we may provide operations to create arrays.</p><p>This array model is similar to <a href="JAVA____ATJ-JAVA-PRIMITIVE-ARRAY-MODEL.html">ATJ's model of Java primitive arrays</a>. But C arrays differ from Java arrays: 
     in particular, Java arrays are self-contained objects, 
     whose length and other attributes can be programmatically queried; 
     in contrast, C arrays are more of a ``view'' of certain memory regions. 
     Nonetheless, at the level of ACL2 manipulations, 
     the two kinds of arrays differ less (at least for certain mundane uses), 
     because, even though C does not provide ``direct access'' to 
     an array's length and other attributes, 
     there is nonetheless an implicit notion of array, 
     with its length and other attributes, 
     that is conceptually created and passed around and manipulated.</p><p>Similarly to the use of the Java array model in ATJ, 
     the C arrays modeled here have to be treated in a stobj-like manner 
     by the ACL2 functions to be translated to C. 
     In general, each of these ACL2 functions 
     takes zero or more arrays as inputs (possibly among other inputs), 
     and must return, in an <span class="tt"><a href="ACL2____MV.html">mv</a></span>, 
     all the arrays that it possibly modifies, 
     along with the regular return result of the function (if any); 
     the arrays that are only read by the function do not have to be returned. 
     Inside the function, the arrays must be updated (if at all) 
     in a single-threaded way, analogously to stobjs. 
     Upcoming extensions of ATC will ensure that this discipline is followed, 
     analogously to what ATJ does.</p><p>Our initial model of arrays assumes that different arrays do not overlap. 
     That is, 
     either two arrays are the same array (when they have the same pointer), 
     or they are completely disjoint. 
     The model does not capture 
     the situation of an array being a subarray of another one. 
     We may extend the model in the future.</p><p>We provide a model of arrays of all the integer types 
     supported in ATC's model of C, 
     i.e. arrays of <span class="v">unsigned chars</span>s, arrays of <span class="v">int</span>s, etc. 
     [C:6.5.2.1/2] explains that array indexing <span class="v">a[i]</span> boils down to 
     addition between the pointer <span class="v">a</span> and the integer <span class="v">i</span>, 
     and [C:6.5.6/2] allows the integer to have any integer type. 
     This means that, for each possible array type, 
     there are versions of the read and write operations (which use indices) 
     for all the integer types supported in ATC's model of C. 
     Since all these functions follow a common pattern, 
     we generate arary types and functions programmatically, 
     as done for the <a href="C____ATC-INTEGERS.html">integers</a>.</p><p>[C:6.2.5/20] requires arrays to be non-empty, 
     i.e. to contain at least one element, 
     i.e. to have positive length. 
     As noted in <a href="C____ATC-ARRAYS.html">atc-arrays</a>, arrays are indexed via integers. 
     [C] only provides minimum requirements for the sizes of integer types, 
     not maximum requirements: 
     other than practical considerations, 
     nothing, mathematically, prevents some integer types 
     to consists of thousands or millions of bits. 
     So our model of arrays requires them to be non-empty 
     but puts no maximum limits on their length.</p><p>For each integer type <span class="v">&lt;type&gt;</span>, 
     besides the fixtype of arrays of that type, 
     we generate functions 
     <span class="v">&lt;type&gt;-array-read</span> and <span class="v">&lt;type&gt;-array-write</span> 
     that take ACL2 integers as indices; 
     these functions do not directly represent C constructs, 
     but are useful to make the definition of the ones that do more concise. 
     We generate functions 
     <span class="v">&lt;type&gt;-array-read-&lt;type1&gt;</span> and <span class="v">&lt;type&gt;-array-write-&lt;type1&gt;</span>, 
     which represent C constructs: 
     that convert the index to an ACL2 integer 
     and then call the two functions above. 
     We also generate convenience functions 
     to test whether indices are in range 
     and to return the length of the arrays: 
     these do not represent C constructs, 
     but are useful in guards for example.</p>
</body>
</html>
