<html>
<head>
<meta charset="UTF-8">
<title>Smt-translator</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=SMT____SMT-TRANSLATOR">Click for Smt-translator in the Full Manual</a></h3>

<p>SMT-translator does the LISP to Python translation.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>smt-numberp</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> smt-numberp (sym)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'smt-numberp))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> sym)
                    (<a href="COMMON-LISP____INTEGERP.html">integerp</a> sym)
                    (<a href="ACL2____REAL_F2RATIONALP.html">real/rationalp</a> sym))
                t nil)))</pre> 
<p><b>Theorem: </b>booleanp-of-smt-numberp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> booleanp-of-smt-numberp
        (<a href="ACL2____B_A2.html">b*</a> ((is? (smt-numberp sym)))
            (<a href="ACL2____BOOLEANP.html">booleanp</a> is?))
        :rule-classes :rewrite)</pre> 
<p><b>Function: </b>smt-number-fix</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> smt-number-fix (num)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (smt-numberp num)))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'smt-number-fix))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="COMMON-LISP____IF.html">if</a> (smt-numberp num) num 0)
                 :exec num)))</pre> 
<p><b>Theorem: </b>smt-numberp-of-smt-number-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> smt-numberp-of-smt-number-fix
        (<a href="ACL2____B_A2.html">b*</a> ((fixed (smt-number-fix num)))
            (smt-numberp fixed))
        :rule-classes :rewrite)</pre> 
<p><b>Function: </b>smt-number-equiv$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> smt-number-equiv$inline
       (acl2::x acl2::y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (smt-numberp acl2::x)
                                   (smt-numberp acl2::y))))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (smt-number-fix acl2::x)
              (smt-number-fix acl2::y)))</pre> 
<p><b>Theorem: </b>smt-number-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> smt-number-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (smt-number-equiv x y))
             (smt-number-equiv x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (smt-number-equiv x y)
                      (smt-number-equiv y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (smt-number-equiv x y)
                           (smt-number-equiv y z))
                      (smt-number-equiv x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>smt-number-equiv-implies-equal-smt-number-fix-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> smt-number-equiv-implies-equal-smt-number-fix-1
        (<a href="ACL2____IMPLIES.html">implies</a> (smt-number-equiv acl2::x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (smt-number-fix acl2::x)
                        (smt-number-fix x-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>smt-number-fix-under-smt-number-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> smt-number-fix-under-smt-number-equiv
        (smt-number-equiv (smt-number-fix acl2::x)
                          acl2::x)
        :rule-classes (:rewrite :rewrite-quoted-constant))</pre> 
<p><b>Function: </b>translate-function</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> translate-function (opr)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> opr)))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'translate-function))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____B_A2.html">b*</a> ((fn-sig (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> opr *smt-functions*)))
                 ((<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> fn-sig nil))
                  (<a href="ACL2____PROG2_42.html">prog2$</a> (<a href="ACL2____ER.html">er</a> hard?
                              'smt-translator=&gt;translate-function
                              "Not a basic SMT function: ~q0" opr)
                          (<a href="ACL2____MV.html">mv</a> "" 0)))
                 ((<a href="COMMON-LISP____CONS.html">cons</a> translated-fn nargs) fn-sig))
                (<a href="ACL2____MV.html">mv</a> translated-fn nargs))))</pre> 
<p><b>Theorem: </b>stringp-of-translate-function.translated</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> stringp-of-translate-function.translated
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?translated ?nargs)
              (translate-function opr)))
            (<a href="COMMON-LISP____STRINGP.html">stringp</a> translated))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>natp-of-translate-function.nargs</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> natp-of-translate-function.nargs
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?translated ?nargs)
              (translate-function opr)))
            (<a href="ACL2____NATP.html">natp</a> nargs))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>wordp-of-translate-function</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> wordp-of-translate-function
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> fn &amp;) (translate-function x)))
            (wordp fn)))</pre> 
<p><b>Function: </b>translate-number</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
   translate-number (num)
   (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (smt-numberp num)))
   (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'translate-number))
        (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
        (<a href="ACL2____B_A2.html">b*</a> ((num (smt-number-fix num))
             ((<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> num)
                       (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> num))))
              (<a href="COMMON-LISP____CONS.html">cons</a> '"_SMT_.Qx("
                    (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____NUMERATOR.html">numerator</a> num)
                          (<a href="COMMON-LISP____CONS.html">cons</a> '","
                                (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____DENOMINATOR.html">denominator</a> num) '(")")))))))
            (<a href="COMMON-LISP____LIST.html">list</a> num))))</pre> 
<p><b>Theorem: </b>paragraphp-of-translate-number</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> paragraphp-of-translate-number
        (<a href="ACL2____B_A2.html">b*</a> ((translated (translate-number num)))
            (<a href="SMT____PARAGRAPHP.html">paragraphp</a> translated))
        :rule-classes :rewrite)</pre> 
<p><b>Function: </b>symbol-string-alistp</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> symbol-string-alistp (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'symbol-string-alistp))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)
                (<a href="COMMON-LISP____EQ.html">eq</a> x nil)
                (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CAR.html">car</a> x))
                     (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAAR.html">caar</a> x))
                     (<a href="COMMON-LISP____STRINGP.html">stringp</a> (<a href="COMMON-LISP____CDAR.html">cdar</a> x))
                     (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x))))))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-revappend</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-string-alistp-of-revappend
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="COMMON-LISP____REVAPPEND.html">revappend</a> acl2::x acl2::y))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x))
                    (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-remove</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-string-alistp-of-remove
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x)
                 (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="COMMON-LISP____REMOVE.html">remove</a> acl2::a acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-last</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-string-alistp-of-last
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="COMMON-LISP____LAST.html">last</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-nthcdr</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-string-alistp-of-nthcdr
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> acl2::n acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-butlast</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-string-alistp-of-butlast
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="COMMON-LISP____BUTLAST.html">butlast</a> acl2::x acl2::n)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-update-nth</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 symbol-string-alistp-of-update-nth
 (<a href="ACL2____IMPLIES.html">implies</a>
    (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
    (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="ACL2____UPDATE-NTH.html">update-nth</a> acl2::n acl2::y acl2::x))
         (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::y)
                   (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::y))
                   (<a href="COMMON-LISP____STRINGP.html">stringp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::y)))
              (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____NFIX.html">nfix</a> acl2::n) (<a href="ACL2____LEN.html">len</a> acl2::x))
                  (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> nil)
                       (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> nil))
                       (<a href="COMMON-LISP____STRINGP.html">stringp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> nil)))))))
 :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-repeat</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-string-alistp-of-repeat
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="ACL2____REPEAT.html">acl2::repeat</a> acl2::n acl2::x))
             (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x)
                      (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::x))
                      (<a href="COMMON-LISP____STRINGP.html">stringp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::x)))
                 (<a href="ACL2____ZP.html">zp</a> acl2::n)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-take</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-string-alistp-of-take
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="ACL2____TAKE.html">take</a> acl2::n acl2::x))
                      (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> nil)
                               (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> nil))
                               (<a href="COMMON-LISP____STRINGP.html">stringp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> nil)))
                          (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____NFIX.html">nfix</a> acl2::n) (<a href="ACL2____LEN.html">len</a> acl2::x)))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-union-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     symbol-string-alistp-of-union-equal
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="ACL2____UNION-EQUAL.html">union-equal</a> acl2::x acl2::y))
            (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x))
                 (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::y))))
     :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-intersection-equal-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   symbol-string-alistp-of-intersection-equal-2
   (<a href="ACL2____IMPLIES.html">implies</a>
        (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::y))
        (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="ACL2____INTERSECTION-EQUAL.html">intersection-equal</a> acl2::x acl2::y)))
   :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-intersection-equal-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   symbol-string-alistp-of-intersection-equal-1
   (<a href="ACL2____IMPLIES.html">implies</a>
        (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
        (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="ACL2____INTERSECTION-EQUAL.html">intersection-equal</a> acl2::x acl2::y)))
   :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-set-difference-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 symbol-string-alistp-of-set-difference-equal
 (<a href="ACL2____IMPLIES.html">implies</a>
      (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x)
      (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="ACL2____SET-DIFFERENCE-EQUAL.html">set-difference-equal</a> acl2::x acl2::y)))
 :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-when-subsetp-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-string-alistp-when-subsetp-equal
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SUBSETP-EQUAL.html">subsetp-equal</a> acl2::x acl2::y)
                           (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::y))
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x)
                             (<a href="ACL2____TRUE-LISTP.html">true-listp</a> acl2::x)))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::y)
                           (<a href="ACL2____SUBSETP-EQUAL.html">subsetp-equal</a> acl2::x acl2::y))
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x)
                             (<a href="ACL2____TRUE-LISTP.html">true-listp</a> acl2::x))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-rcons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-string-alistp-of-rcons
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="ACL2____RCONS.html">acl2::rcons</a> acl2::a acl2::x))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::a)
                       (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::a))
                       (<a href="COMMON-LISP____STRINGP.html">stringp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::a)))
                  (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-append</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-string-alistp-of-append
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="COMMON-LISP____APPEND.html">append</a> acl2::a acl2::b))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::a))
                    (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::b)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-rev</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-string-alistp-of-rev
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="ACL2____REV.html">acl2::rev</a> acl2::x))
               (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-duplicated-members</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 symbol-string-alistp-of-duplicated-members
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x)
          (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (acl2::duplicated-members acl2::x)))
 :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-difference</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  symbol-string-alistp-of-difference
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x)
           (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="SET____DIFFERENCE.html">set::difference</a> acl2::x acl2::y)))
  :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-intersect-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   symbol-string-alistp-of-intersect-2
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::y)
            (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="SET____INTERSECT.html">set::intersect</a> acl2::x acl2::y)))
   :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-intersect-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   symbol-string-alistp-of-intersect-1
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x)
            (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="SET____INTERSECT.html">set::intersect</a> acl2::x acl2::y)))
   :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-union</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-string-alistp-of-union
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="SET____UNION.html">set::union</a> acl2::x acl2::y))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::x))
                  (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::y))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-mergesort</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-string-alistp-of-mergesort
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="SET____MERGESORT.html">set::mergesort</a> acl2::x))
             (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-delete</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     symbol-string-alistp-of-delete
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x)
              (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="SET____DELETE.html">set::delete</a> acl2::k acl2::x)))
     :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-insert</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-string-alistp-of-insert
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="SET____INSERT.html">set::insert</a> acl2::a acl2::x))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::x))
                  (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::a)
                       (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::a))
                       (<a href="COMMON-LISP____STRINGP.html">stringp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::a)))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-sfix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-string-alistp-of-sfix
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::x))
             (<a href="COMMON-LISP____OR.html">or</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x)
                 (<a href="COMMON-LISP____NOT.html">not</a> (<a href="SET____SETP.html">set::setp</a> acl2::x))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-string-alistp-of-list-fix
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x)
                 (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>true-listp-when-symbol-string-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> true-listp-when-symbol-string-alistp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x)
                 (<a href="ACL2____TRUE-LISTP.html">true-listp</a> acl2::x))
        :rule-classes :compound-recognizer)</pre> 
<p><b>Theorem: </b>symbol-string-alistp-when-not-consp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-string-alistp-when-not-consp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x)
                        (<a href="COMMON-LISP____NOT.html">not</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-cdr-when-symbol-string-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-string-alistp-of-cdr-when-symbol-string-alistp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-cons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-string-alistp-of-cons
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::a acl2::x))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::a)
                         (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::a))
                         (<a href="COMMON-LISP____STRINGP.html">stringp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::a)))
                    (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-make-fal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   symbol-string-alistp-of-make-fal
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x)
                 (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::y))
            (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="ACL2____MAKE-FAL.html">acl2::make-fal</a> acl2::x acl2::y)))
   :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>stringp-of-cdr-when-member-equal-of-symbol-string-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> stringp-of-cdr-when-member-equal-of-symbol-string-alistp
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x)
                           (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> acl2::a acl2::x))
                      (<a href="COMMON-LISP____STRINGP.html">stringp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::a)))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> acl2::a acl2::x)
                           (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x))
                      (<a href="COMMON-LISP____STRINGP.html">stringp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::a))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbolp-of-car-when-member-equal-of-symbol-string-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbolp-of-car-when-member-equal-of-symbol-string-alistp
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x)
                           (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> acl2::a acl2::x))
                      (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::a)))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> acl2::a acl2::x)
                           (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x))
                      (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::a))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>consp-when-member-equal-of-symbol-string-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   consp-when-member-equal-of-symbol-string-alistp
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x)
                 (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> acl2::a acl2::x))
            (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::a))
   :rule-classes
   ((:rewrite :backchain-limit-lst (0 0))
    (:rewrite :backchain-limit-lst (0 0)
              :corollary (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> acl2::a acl2::x)
                                      (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x)
                                      'nil)
                                  (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::a)))))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-remove-assoc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 symbol-string-alistp-of-remove-assoc
 (<a href="ACL2____IMPLIES.html">implies</a>
     (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x)
     (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="ACL2____REMOVE-ASSOC-EQUAL.html">remove-assoc-equal</a> acl2::name acl2::x)))
 :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-put-assoc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  symbol-string-alistp-of-put-assoc
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x))
           (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a>
                     (<a href="ACL2____PUT-ASSOC-EQUAL.html">put-assoc-equal</a> acl2::name acl2::val acl2::x))
                (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> acl2::name)
                     (<a href="COMMON-LISP____STRINGP.html">stringp</a> acl2::val))))
  :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-hons-shrink-alist</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    symbol-string-alistp-of-hons-shrink-alist
    (<a href="ACL2____IMPLIES.html">implies</a>
         (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x)
              (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::y))
         (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="ACL2____HONS-SHRINK-ALIST.html">hons-shrink-alist</a> acl2::x acl2::y)))
    :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-hons-acons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  symbol-string-alistp-of-hons-acons
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> (<a href="ACL2____HONS-ACONS.html">hons-acons</a> acl2::a acl2::n acl2::x))
         (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> acl2::a)
              (<a href="COMMON-LISP____STRINGP.html">stringp</a> acl2::n)
              (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x)))
  :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>stringp-of-cdr-of-hons-assoc-equal-when-symbol-string-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    stringp-of-cdr-of-hons-assoc-equal-when-symbol-string-alistp
    (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x)
             (<a href="ACL2____IFF.html">iff</a> (<a href="COMMON-LISP____STRINGP.html">stringp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="ACL2____HONS-ASSOC-EQUAL.html">hons-assoc-equal</a> acl2::k acl2::x)))
                  (<a href="COMMON-LISP____OR.html">or</a> (<a href="ACL2____HONS-ASSOC-EQUAL.html">hons-assoc-equal</a> acl2::k acl2::x)
                      (<a href="COMMON-LISP____STRINGP.html">stringp</a> nil))))
    :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>alistp-when-symbol-string-alistp-rewrite</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> alistp-when-symbol-string-alistp-rewrite
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x)
                 (<a href="ACL2____ALISTP.html">alistp</a> acl2::x))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>alistp-when-symbol-string-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> alistp-when-symbol-string-alistp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x)
                 (<a href="ACL2____ALISTP.html">alistp</a> acl2::x))
        :rule-classes :tau-system)</pre> 
<p><b>Theorem: </b>stringp-of-cdar-when-symbol-string-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> stringp-of-cdar-when-symbol-string-alistp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x)
                 (<a href="ACL2____IFF.html">iff</a> (<a href="COMMON-LISP____STRINGP.html">stringp</a> (<a href="COMMON-LISP____CDAR.html">cdar</a> acl2::x))
                      (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x) (<a href="COMMON-LISP____STRINGP.html">stringp</a> nil))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbolp-of-caar-when-symbol-string-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbolp-of-caar-when-symbol-string-alistp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x)
                 (<a href="ACL2____IFF.html">iff</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAAR.html">caar</a> acl2::x))
                      (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x) (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> nil))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Function: </b>symbol-string-alist-fix$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
   symbol-string-alist-fix$inline (x)
   (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> x)))
   (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'symbol-string-alist-fix))
        (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
        (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)
                        nil
                        (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CAR.html">car</a> x))
                            (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> (<a href="COMMON-LISP____CAAR.html">caar</a> x))
                                        (<a href="ACL2____STR-FIX.html">str-fix</a> (<a href="COMMON-LISP____CDAR.html">cdar</a> x)))
                                  (<a href="SMT____SYMBOL-STRING-ALIST-FIX.html">symbol-string-alist-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x)))
                            (<a href="SMT____SYMBOL-STRING-ALIST-FIX.html">symbol-string-alist-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x))))
             :exec x)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-symbol-string-alist-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-string-alistp-of-symbol-string-alist-fix
        (<a href="ACL2____B_A2.html">b*</a> ((fty::newx (symbol-string-alist-fix$inline x)))
            (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> fty::newx))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>symbol-string-alist-fix-when-symbol-string-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-string-alist-fix-when-symbol-string-alistp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYMBOL-STRING-ALIST-FIX.html">symbol-string-alist-fix</a> x) x)))</pre> 
<p><b>Function: </b>symbol-string-alist-equiv$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> symbol-string-alist-equiv$inline
       (acl2::x acl2::y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::x)
                                   (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> acl2::y))))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYMBOL-STRING-ALIST-FIX.html">symbol-string-alist-fix</a> acl2::x)
              (<a href="SMT____SYMBOL-STRING-ALIST-FIX.html">symbol-string-alist-fix</a> acl2::y)))</pre> 
<p><b>Theorem: </b>symbol-string-alist-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-string-alist-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="SMT____SYMBOL-STRING-ALIST-EQUIV.html">symbol-string-alist-equiv</a> x y))
             (<a href="SMT____SYMBOL-STRING-ALIST-EQUIV.html">symbol-string-alist-equiv</a> x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYMBOL-STRING-ALIST-EQUIV.html">symbol-string-alist-equiv</a> x y)
                      (<a href="SMT____SYMBOL-STRING-ALIST-EQUIV.html">symbol-string-alist-equiv</a> y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYMBOL-STRING-ALIST-EQUIV.html">symbol-string-alist-equiv</a> x y)
                           (<a href="SMT____SYMBOL-STRING-ALIST-EQUIV.html">symbol-string-alist-equiv</a> y z))
                      (<a href="SMT____SYMBOL-STRING-ALIST-EQUIV.html">symbol-string-alist-equiv</a> x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>symbol-string-alist-equiv-implies-equal-symbol-string-alist-fix-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   symbol-string-alist-equiv-implies-equal-symbol-string-alist-fix-1
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYMBOL-STRING-ALIST-EQUIV.html">symbol-string-alist-equiv</a> acl2::x x-equiv)
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYMBOL-STRING-ALIST-FIX.html">symbol-string-alist-fix</a> acl2::x)
                   (<a href="SMT____SYMBOL-STRING-ALIST-FIX.html">symbol-string-alist-fix</a> x-equiv)))
   :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>symbol-string-alist-fix-under-symbol-string-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-string-alist-fix-under-symbol-string-alist-equiv
        (<a href="SMT____SYMBOL-STRING-ALIST-EQUIV.html">symbol-string-alist-equiv</a> (<a href="SMT____SYMBOL-STRING-ALIST-FIX.html">symbol-string-alist-fix</a> acl2::x)
                                   acl2::x)
        :rule-classes (:rewrite :rewrite-quoted-constant))</pre> 
<p><b>Theorem: </b>equal-of-symbol-string-alist-fix-1-forward-to-symbol-string-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 equal-of-symbol-string-alist-fix-1-forward-to-symbol-string-alist-equiv
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYMBOL-STRING-ALIST-FIX.html">symbol-string-alist-fix</a> acl2::x)
                 acl2::y)
          (<a href="SMT____SYMBOL-STRING-ALIST-EQUIV.html">symbol-string-alist-equiv</a> acl2::x acl2::y))
 :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>equal-of-symbol-string-alist-fix-2-forward-to-symbol-string-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 equal-of-symbol-string-alist-fix-2-forward-to-symbol-string-alist-equiv
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> acl2::x
                 (<a href="SMT____SYMBOL-STRING-ALIST-FIX.html">symbol-string-alist-fix</a> acl2::y))
          (<a href="SMT____SYMBOL-STRING-ALIST-EQUIV.html">symbol-string-alist-equiv</a> acl2::x acl2::y))
 :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>symbol-string-alist-equiv-of-symbol-string-alist-fix-1-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   symbol-string-alist-equiv-of-symbol-string-alist-fix-1-forward
   (<a href="ACL2____IMPLIES.html">implies</a>
        (<a href="SMT____SYMBOL-STRING-ALIST-EQUIV.html">symbol-string-alist-equiv</a> (<a href="SMT____SYMBOL-STRING-ALIST-FIX.html">symbol-string-alist-fix</a> acl2::x)
                                   acl2::y)
        (<a href="SMT____SYMBOL-STRING-ALIST-EQUIV.html">symbol-string-alist-equiv</a> acl2::x acl2::y))
   :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>symbol-string-alist-equiv-of-symbol-string-alist-fix-2-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  symbol-string-alist-equiv-of-symbol-string-alist-fix-2-forward
  (<a href="ACL2____IMPLIES.html">implies</a>
       (<a href="SMT____SYMBOL-STRING-ALIST-EQUIV.html">symbol-string-alist-equiv</a> acl2::x
                                  (<a href="SMT____SYMBOL-STRING-ALIST-FIX.html">symbol-string-alist-fix</a> acl2::y))
       (<a href="SMT____SYMBOL-STRING-ALIST-EQUIV.html">symbol-string-alist-equiv</a> acl2::x acl2::y))
  :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>cons-of-symbol-fix-k-under-symbol-string-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> cons-of-symbol-fix-k-under-symbol-string-alist-equiv
        (<a href="SMT____SYMBOL-STRING-ALIST-EQUIV.html">symbol-string-alist-equiv</a>
             (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> acl2::k) acl2::v)
                   acl2::x)
             (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::k acl2::v) acl2::x)))</pre> 
<p><b>Theorem: </b>cons-symbol-equiv-congruence-on-k-under-symbol-string-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 cons-symbol-equiv-congruence-on-k-under-symbol-string-alist-equiv
 (<a href="ACL2____IMPLIES.html">implies</a>
  (<a href="ACL2____SYMBOL-EQUIV.html">acl2::symbol-equiv</a> acl2::k k-equiv)
  (<a href="SMT____SYMBOL-STRING-ALIST-EQUIV.html">symbol-string-alist-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::k acl2::v) acl2::x)
                             (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> k-equiv acl2::v) acl2::x)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>cons-of-str-fix-v-under-symbol-string-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  cons-of-str-fix-v-under-symbol-string-alist-equiv
  (<a href="SMT____SYMBOL-STRING-ALIST-EQUIV.html">symbol-string-alist-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::k (<a href="ACL2____STR-FIX.html">str-fix</a> acl2::v))
                                   acl2::x)
                             (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::k acl2::v) acl2::x)))</pre> 
<p><b>Theorem: </b>cons-streqv-congruence-on-v-under-symbol-string-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 cons-streqv-congruence-on-v-under-symbol-string-alist-equiv
 (<a href="ACL2____IMPLIES.html">implies</a>
  (<a href="ACL2____STREQV.html">acl2::streqv</a> acl2::v v-equiv)
  (<a href="SMT____SYMBOL-STRING-ALIST-EQUIV.html">symbol-string-alist-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::k acl2::v) acl2::x)
                             (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::k v-equiv) acl2::x)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>cons-of-symbol-string-alist-fix-y-under-symbol-string-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 cons-of-symbol-string-alist-fix-y-under-symbol-string-alist-equiv
 (<a href="SMT____SYMBOL-STRING-ALIST-EQUIV.html">symbol-string-alist-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x
                                  (<a href="SMT____SYMBOL-STRING-ALIST-FIX.html">symbol-string-alist-fix</a> acl2::y))
                            (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y)))</pre> 
<p><b>Theorem: </b>cons-symbol-string-alist-equiv-congruence-on-y-under-symbol-string-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 cons-symbol-string-alist-equiv-congruence-on-y-under-symbol-string-alist-equiv
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYMBOL-STRING-ALIST-EQUIV.html">symbol-string-alist-equiv</a> acl2::y y-equiv)
          (<a href="SMT____SYMBOL-STRING-ALIST-EQUIV.html">symbol-string-alist-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y)
                                     (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x y-equiv)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>symbol-string-alist-fix-of-acons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    symbol-string-alist-fix-of-acons
    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYMBOL-STRING-ALIST-FIX.html">symbol-string-alist-fix</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::a acl2::b) x))
           (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> acl2::a)
                       (<a href="ACL2____STR-FIX.html">str-fix</a> acl2::b))
                 (<a href="SMT____SYMBOL-STRING-ALIST-FIX.html">symbol-string-alist-fix</a> x))))</pre> 
<p><b>Theorem: </b>symbol-string-alist-fix-of-append</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-string-alist-fix-of-append
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYMBOL-STRING-ALIST-FIX.html">symbol-string-alist-fix</a> (<a href="COMMON-LISP____APPEND.html">append</a> std::a std::b))
               (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="SMT____SYMBOL-STRING-ALIST-FIX.html">symbol-string-alist-fix</a> std::a)
                       (<a href="SMT____SYMBOL-STRING-ALIST-FIX.html">symbol-string-alist-fix</a> std::b))))</pre> 
<p><b>Theorem: </b>consp-car-of-symbol-string-alist-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> consp-car-of-symbol-string-alist-fix
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____SYMBOL-STRING-ALIST-FIX.html">symbol-string-alist-fix</a> x)))
               (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____SYMBOL-STRING-ALIST-FIX.html">symbol-string-alist-fix</a> x))))</pre> 
<p><b>Function: </b>te-args-p</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 te-args-p (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'te-args-p))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="COMMON-LISP____AND.html">and</a>
    (<a href="ACL2____MBE.html">mbe</a> :logic
         (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____ALISTP.html">alistp</a> x)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____STRIP-CARS.html">strip-cars</a> x)
                     '(expr-lst fn-lst fty-info symbol-index
                                symbol-list avoid-list symbol-map)))
         :exec (fty::alist-with-carsp
                    x
                    '(expr-lst fn-lst fty-info symbol-index
                               symbol-list avoid-list symbol-map)))
    (<a href="ACL2____B_A2.html">b*</a> ((expr-lst (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x)))
         (fn-lst (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x)))
         (<a href="SMT____FTY-INFO.html">fty-info</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 2 x)))
         (symbol-index (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 3 x)))
         (symbol-list (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 4 x)))
         (avoid-list (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 5 x)))
         (symbol-map (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 6 x))))
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> expr-lst)
             (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> fn-lst)
             (<a href="SMT____FTY-INFO-ALIST-P.html">fty-info-alist-p</a> fty-info)
             (<a href="ACL2____NATP.html">natp</a> symbol-index)
             (<a href="ACL2____STRING-LISTP.html">string-listp</a> symbol-list)
             (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> avoid-list)
             (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> symbol-map))))))</pre> 
<p><b>Theorem: </b>consp-when-te-args-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> consp-when-te-args-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____TE-ARGS-P.html">te-args-p</a> x) (<a href="COMMON-LISP____CONSP.html">consp</a> x))
        :rule-classes :compound-recognizer)</pre> 
<p><b>Function: </b>te-args-fix$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 te-args-fix$inline (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____TE-ARGS-P.html">te-args-p</a> x)))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'te-args-fix))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____MBE.html">mbe</a>
   :logic
   (<a href="ACL2____B_A2.html">b*</a>
    ((expr-lst (pseudo-term-list-fix (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x))))
     (fn-lst (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x))))
     (<a href="SMT____FTY-INFO.html">fty-info</a> (<a href="SMT____FTY-INFO-ALIST-FIX.html">fty-info-alist-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 2 x))))
     (symbol-index (<a href="ACL2____NFIX.html">nfix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 3 x))))
     (symbol-list (str::string-list-fix (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 4 x))))
     (avoid-list (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 5 x))))
     (symbol-map (<a href="SMT____SYMBOL-STRING-ALIST-FIX.html">symbol-string-alist-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 6 x)))))
    (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'expr-lst expr-lst)
          (<a href="COMMON-LISP____CONS.html">cons</a> 'fn-lst fn-lst)
          (<a href="COMMON-LISP____CONS.html">cons</a> 'fty-info fty-info)
          (<a href="COMMON-LISP____CONS.html">cons</a> 'symbol-index symbol-index)
          (<a href="COMMON-LISP____CONS.html">cons</a> 'symbol-list symbol-list)
          (<a href="COMMON-LISP____CONS.html">cons</a> 'avoid-list avoid-list)
          (<a href="COMMON-LISP____CONS.html">cons</a> 'symbol-map symbol-map)))
   :exec x)))</pre> 
<p><b>Theorem: </b>te-args-p-of-te-args-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-p-of-te-args-fix
        (<a href="ACL2____B_A2.html">b*</a> ((new-x (te-args-fix$inline x)))
            (<a href="SMT____TE-ARGS-P.html">te-args-p</a> new-x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>te-args-fix-when-te-args-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-fix-when-te-args-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____TE-ARGS-P.html">te-args-p</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS-FIX.html">te-args-fix</a> x) x)))</pre> 
<p><b>Function: </b>te-args-equiv$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> te-args-equiv$inline (acl2::x acl2::y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____TE-ARGS-P.html">te-args-p</a> acl2::x)
                                   (<a href="SMT____TE-ARGS-P.html">te-args-p</a> acl2::y))))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS-FIX.html">te-args-fix</a> acl2::x)
              (<a href="SMT____TE-ARGS-FIX.html">te-args-fix</a> acl2::y)))</pre> 
<p><b>Theorem: </b>te-args-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="SMT____TE-ARGS-EQUIV.html">te-args-equiv</a> x y))
             (<a href="SMT____TE-ARGS-EQUIV.html">te-args-equiv</a> x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____TE-ARGS-EQUIV.html">te-args-equiv</a> x y)
                      (<a href="SMT____TE-ARGS-EQUIV.html">te-args-equiv</a> y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____TE-ARGS-EQUIV.html">te-args-equiv</a> x y)
                           (<a href="SMT____TE-ARGS-EQUIV.html">te-args-equiv</a> y z))
                      (<a href="SMT____TE-ARGS-EQUIV.html">te-args-equiv</a> x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>te-args-equiv-implies-equal-te-args-fix-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-equiv-implies-equal-te-args-fix-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____TE-ARGS-EQUIV.html">te-args-equiv</a> acl2::x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS-FIX.html">te-args-fix</a> acl2::x)
                        (<a href="SMT____TE-ARGS-FIX.html">te-args-fix</a> x-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>te-args-fix-under-te-args-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-fix-under-te-args-equiv
        (<a href="SMT____TE-ARGS-EQUIV.html">te-args-equiv</a> (<a href="SMT____TE-ARGS-FIX.html">te-args-fix</a> acl2::x)
                       acl2::x)
        :rule-classes (:rewrite :rewrite-quoted-constant))</pre> 
<p><b>Theorem: </b>equal-of-te-args-fix-1-forward-to-te-args-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-te-args-fix-1-forward-to-te-args-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS-FIX.html">te-args-fix</a> acl2::x) acl2::y)
                 (<a href="SMT____TE-ARGS-EQUIV.html">te-args-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>equal-of-te-args-fix-2-forward-to-te-args-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-te-args-fix-2-forward-to-te-args-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> acl2::x (<a href="SMT____TE-ARGS-FIX.html">te-args-fix</a> acl2::y))
                 (<a href="SMT____TE-ARGS-EQUIV.html">te-args-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>te-args-equiv-of-te-args-fix-1-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-equiv-of-te-args-fix-1-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____TE-ARGS-EQUIV.html">te-args-equiv</a> (<a href="SMT____TE-ARGS-FIX.html">te-args-fix</a> acl2::x)
                                acl2::y)
                 (<a href="SMT____TE-ARGS-EQUIV.html">te-args-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>te-args-equiv-of-te-args-fix-2-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-equiv-of-te-args-fix-2-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____TE-ARGS-EQUIV.html">te-args-equiv</a> acl2::x (<a href="SMT____TE-ARGS-FIX.html">te-args-fix</a> acl2::y))
                 (<a href="SMT____TE-ARGS-EQUIV.html">te-args-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Function: </b>te-args-&gt;expr-lst$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 te-args-&gt;expr-lst$inline (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____TE-ARGS-P.html">te-args-p</a> x)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
     ((acl2::__function__ 'te-args-&gt;expr-lst))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
     (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                     (pseudo-term-list-fix (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x))))
          :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x)))))</pre> 
<p><b>Theorem: </b>pseudo-term-listp-of-te-args-&gt;expr-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-listp-of-te-args-&gt;expr-lst
        (<a href="ACL2____B_A2.html">b*</a> ((expr-lst (te-args-&gt;expr-lst$inline x)))
            (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> expr-lst))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>te-args-&gt;expr-lst$inline-of-te-args-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-&gt;expr-lst$inline-of-te-args-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (te-args-&gt;expr-lst$inline (<a href="SMT____TE-ARGS-FIX.html">te-args-fix</a> x))
               (te-args-&gt;expr-lst$inline x)))</pre> 
<p><b>Theorem: </b>te-args-&gt;expr-lst$inline-te-args-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-&gt;expr-lst$inline-te-args-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____TE-ARGS-EQUIV.html">te-args-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (te-args-&gt;expr-lst$inline x)
                        (te-args-&gt;expr-lst$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>te-args-&gt;fn-lst$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     te-args-&gt;fn-lst$inline (x)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____TE-ARGS-P.html">te-args-p</a> x)))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
     (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'te-args-&gt;fn-lst))
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
          (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                          (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x))))
               :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x)))))</pre> 
<p><b>Theorem: </b>func-alistp-of-te-args-&gt;fn-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-te-args-&gt;fn-lst
        (<a href="ACL2____B_A2.html">b*</a> ((fn-lst (te-args-&gt;fn-lst$inline x)))
            (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> fn-lst))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>te-args-&gt;fn-lst$inline-of-te-args-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-&gt;fn-lst$inline-of-te-args-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (te-args-&gt;fn-lst$inline (<a href="SMT____TE-ARGS-FIX.html">te-args-fix</a> x))
               (te-args-&gt;fn-lst$inline x)))</pre> 
<p><b>Theorem: </b>te-args-&gt;fn-lst$inline-te-args-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-&gt;fn-lst$inline-te-args-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____TE-ARGS-EQUIV.html">te-args-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (te-args-&gt;fn-lst$inline x)
                        (te-args-&gt;fn-lst$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>te-args-&gt;fty-info$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
  te-args-&gt;fty-info$inline (x)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____TE-ARGS-P.html">te-args-p</a> x)))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
  (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'te-args-&gt;fty-info))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
       (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                       (<a href="SMT____FTY-INFO-ALIST-FIX.html">fty-info-alist-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 2 x))))
            :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 2 x)))))</pre> 
<p><b>Theorem: </b>fty-info-alist-p-of-te-args-&gt;fty-info</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fty-info-alist-p-of-te-args-&gt;fty-info
        (<a href="ACL2____B_A2.html">b*</a> ((<a href="SMT____FTY-INFO.html">fty-info</a> (te-args-&gt;fty-info$inline x)))
            (<a href="SMT____FTY-INFO-ALIST-P.html">fty-info-alist-p</a> fty-info))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>te-args-&gt;fty-info$inline-of-te-args-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-&gt;fty-info$inline-of-te-args-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (te-args-&gt;fty-info$inline (<a href="SMT____TE-ARGS-FIX.html">te-args-fix</a> x))
               (te-args-&gt;fty-info$inline x)))</pre> 
<p><b>Theorem: </b>te-args-&gt;fty-info$inline-te-args-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-&gt;fty-info$inline-te-args-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____TE-ARGS-EQUIV.html">te-args-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (te-args-&gt;fty-info$inline x)
                        (te-args-&gt;fty-info$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>te-args-&gt;symbol-index$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> te-args-&gt;symbol-index$inline (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____TE-ARGS-P.html">te-args-p</a> x)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'te-args-&gt;symbol-index))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                            (<a href="ACL2____NFIX.html">nfix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 3 x))))
                 :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 3 x)))))</pre> 
<p><b>Theorem: </b>natp-of-te-args-&gt;symbol-index</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> natp-of-te-args-&gt;symbol-index
        (<a href="ACL2____B_A2.html">b*</a> ((symbol-index (te-args-&gt;symbol-index$inline x)))
            (<a href="ACL2____NATP.html">natp</a> symbol-index))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>te-args-&gt;symbol-index$inline-of-te-args-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-&gt;symbol-index$inline-of-te-args-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (te-args-&gt;symbol-index$inline (<a href="SMT____TE-ARGS-FIX.html">te-args-fix</a> x))
               (te-args-&gt;symbol-index$inline x)))</pre> 
<p><b>Theorem: </b>te-args-&gt;symbol-index$inline-te-args-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-&gt;symbol-index$inline-te-args-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____TE-ARGS-EQUIV.html">te-args-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (te-args-&gt;symbol-index$inline x)
                        (te-args-&gt;symbol-index$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>te-args-&gt;symbol-list$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 te-args-&gt;symbol-list$inline (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____TE-ARGS-P.html">te-args-p</a> x)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
     ((acl2::__function__ 'te-args-&gt;symbol-list))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
     (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                     (str::string-list-fix (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 4 x))))
          :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 4 x)))))</pre> 
<p><b>Theorem: </b>string-listp-of-te-args-&gt;symbol-list</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> string-listp-of-te-args-&gt;symbol-list
        (<a href="ACL2____B_A2.html">b*</a> ((symbol-list (te-args-&gt;symbol-list$inline x)))
            (<a href="ACL2____STRING-LISTP.html">string-listp</a> symbol-list))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>te-args-&gt;symbol-list$inline-of-te-args-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-&gt;symbol-list$inline-of-te-args-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (te-args-&gt;symbol-list$inline (<a href="SMT____TE-ARGS-FIX.html">te-args-fix</a> x))
               (te-args-&gt;symbol-list$inline x)))</pre> 
<p><b>Theorem: </b>te-args-&gt;symbol-list$inline-te-args-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-&gt;symbol-list$inline-te-args-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____TE-ARGS-EQUIV.html">te-args-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (te-args-&gt;symbol-list$inline x)
                        (te-args-&gt;symbol-list$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>te-args-&gt;avoid-list$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     te-args-&gt;avoid-list$inline (x)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____TE-ARGS-P.html">te-args-p</a> x)))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
     (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'te-args-&gt;avoid-list))
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
          (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                          (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 5 x))))
               :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 5 x)))))</pre> 
<p><b>Theorem: </b>symbol-listp-of-te-args-&gt;avoid-list</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-listp-of-te-args-&gt;avoid-list
        (<a href="ACL2____B_A2.html">b*</a> ((avoid-list (te-args-&gt;avoid-list$inline x)))
            (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> avoid-list))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>te-args-&gt;avoid-list$inline-of-te-args-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-&gt;avoid-list$inline-of-te-args-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (te-args-&gt;avoid-list$inline (<a href="SMT____TE-ARGS-FIX.html">te-args-fix</a> x))
               (te-args-&gt;avoid-list$inline x)))</pre> 
<p><b>Theorem: </b>te-args-&gt;avoid-list$inline-te-args-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-&gt;avoid-list$inline-te-args-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____TE-ARGS-EQUIV.html">te-args-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (te-args-&gt;avoid-list$inline x)
                        (te-args-&gt;avoid-list$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>te-args-&gt;symbol-map$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 te-args-&gt;symbol-map$inline (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____TE-ARGS-P.html">te-args-p</a> x)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'te-args-&gt;symbol-map))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                  (<a href="SMT____SYMBOL-STRING-ALIST-FIX.html">symbol-string-alist-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 6 x))))
       :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 6 x)))))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-te-args-&gt;symbol-map</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-string-alistp-of-te-args-&gt;symbol-map
        (<a href="ACL2____B_A2.html">b*</a> ((symbol-map (te-args-&gt;symbol-map$inline x)))
            (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> symbol-map))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>te-args-&gt;symbol-map$inline-of-te-args-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-&gt;symbol-map$inline-of-te-args-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (te-args-&gt;symbol-map$inline (<a href="SMT____TE-ARGS-FIX.html">te-args-fix</a> x))
               (te-args-&gt;symbol-map$inline x)))</pre> 
<p><b>Theorem: </b>te-args-&gt;symbol-map$inline-te-args-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-&gt;symbol-map$inline-te-args-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____TE-ARGS-EQUIV.html">te-args-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (te-args-&gt;symbol-map$inline x)
                        (te-args-&gt;symbol-map$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>te-args</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 te-args
 (expr-lst fn-lst fty-info symbol-index
           symbol-list avoid-list symbol-map)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> expr-lst)
                             (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> fn-lst)
                             (<a href="SMT____FTY-INFO-ALIST-P.html">fty-info-alist-p</a> fty-info)
                             (<a href="ACL2____NATP.html">natp</a> symbol-index)
                             (<a href="ACL2____STRING-LISTP.html">string-listp</a> symbol-list)
                             (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> avoid-list)
                             (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> symbol-map))))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
   ((acl2::__function__ 'te-args))
   (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
   (<a href="ACL2____B_A2.html">b*</a> ((expr-lst (<a href="ACL2____MBE.html">mbe</a> :logic (pseudo-term-list-fix expr-lst)
                       :exec expr-lst))
        (fn-lst (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> fn-lst)
                     :exec fn-lst))
        (<a href="SMT____FTY-INFO.html">fty-info</a> (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____FTY-INFO-ALIST-FIX.html">fty-info-alist-fix</a> fty-info)
                       :exec fty-info))
        (symbol-index (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____NFIX.html">nfix</a> symbol-index)
                           :exec symbol-index))
        (symbol-list (<a href="ACL2____MBE.html">mbe</a> :logic (str::string-list-fix symbol-list)
                          :exec symbol-list))
        (avoid-list (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> avoid-list)
                         :exec avoid-list))
        (symbol-map (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____SYMBOL-STRING-ALIST-FIX.html">symbol-string-alist-fix</a> symbol-map)
                         :exec symbol-map)))
       (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'expr-lst expr-lst)
             (<a href="COMMON-LISP____CONS.html">cons</a> 'fn-lst fn-lst)
             (<a href="COMMON-LISP____CONS.html">cons</a> 'fty-info fty-info)
             (<a href="COMMON-LISP____CONS.html">cons</a> 'symbol-index symbol-index)
             (<a href="COMMON-LISP____CONS.html">cons</a> 'symbol-list symbol-list)
             (<a href="COMMON-LISP____CONS.html">cons</a> 'avoid-list avoid-list)
             (<a href="COMMON-LISP____CONS.html">cons</a> 'symbol-map symbol-map)))))</pre> 
<p><b>Theorem: </b>te-args-p-of-te-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-p-of-te-args
        (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst fn-lst fty-info symbol-index
                         symbol-list avoid-list symbol-map)))
            (<a href="SMT____TE-ARGS-P.html">te-args-p</a> x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>te-args-&gt;expr-lst-of-te-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 te-args-&gt;expr-lst-of-te-args
 (<a href="COMMON-LISP____EQUAL.html">equal</a>
   (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst fn-lst fty-info symbol-index
                               symbol-list avoid-list symbol-map))
   (pseudo-term-list-fix expr-lst)))</pre> 
<p><b>Theorem: </b>te-args-&gt;fn-lst-of-te-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 te-args-&gt;fn-lst-of-te-args
 (<a href="COMMON-LISP____EQUAL.html">equal</a>
     (<a href="SMT____TE-ARGS-_E3FN-LST.html">te-args-&gt;fn-lst</a> (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst fn-lst fty-info symbol-index
                               symbol-list avoid-list symbol-map))
     (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> fn-lst)))</pre> 
<p><b>Theorem: </b>te-args-&gt;fty-info-of-te-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 te-args-&gt;fty-info-of-te-args
 (<a href="COMMON-LISP____EQUAL.html">equal</a>
   (<a href="SMT____TE-ARGS-_E3FTY-INFO.html">te-args-&gt;fty-info</a> (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst fn-lst fty-info symbol-index
                               symbol-list avoid-list symbol-map))
   (<a href="SMT____FTY-INFO-ALIST-FIX.html">fty-info-alist-fix</a> fty-info)))</pre> 
<p><b>Theorem: </b>te-args-&gt;symbol-index-of-te-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-&gt;symbol-index-of-te-args
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS-_E3SYMBOL-INDEX.html">te-args-&gt;symbol-index</a>
                    (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst fn-lst fty-info symbol-index
                             symbol-list avoid-list symbol-map))
               (<a href="ACL2____NFIX.html">nfix</a> symbol-index)))</pre> 
<p><b>Theorem: </b>te-args-&gt;symbol-list-of-te-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-&gt;symbol-list-of-te-args
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS-_E3SYMBOL-LIST.html">te-args-&gt;symbol-list</a>
                    (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst fn-lst fty-info symbol-index
                             symbol-list avoid-list symbol-map))
               (str::string-list-fix symbol-list)))</pre> 
<p><b>Theorem: </b>te-args-&gt;avoid-list-of-te-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-&gt;avoid-list-of-te-args
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS-_E3AVOID-LIST.html">te-args-&gt;avoid-list</a>
                    (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst fn-lst fty-info symbol-index
                             symbol-list avoid-list symbol-map))
               (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> avoid-list)))</pre> 
<p><b>Theorem: </b>te-args-&gt;symbol-map-of-te-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-&gt;symbol-map-of-te-args
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS-_E3SYMBOL-MAP.html">te-args-&gt;symbol-map</a>
                    (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst fn-lst fty-info symbol-index
                             symbol-list avoid-list symbol-map))
               (<a href="SMT____SYMBOL-STRING-ALIST-FIX.html">symbol-string-alist-fix</a> symbol-map)))</pre> 
<p><b>Theorem: </b>te-args-of-fields</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-of-fields
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS.html">te-args</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> x)
                        (<a href="SMT____TE-ARGS-_E3FN-LST.html">te-args-&gt;fn-lst</a> x)
                        (<a href="SMT____TE-ARGS-_E3FTY-INFO.html">te-args-&gt;fty-info</a> x)
                        (<a href="SMT____TE-ARGS-_E3SYMBOL-INDEX.html">te-args-&gt;symbol-index</a> x)
                        (<a href="SMT____TE-ARGS-_E3SYMBOL-LIST.html">te-args-&gt;symbol-list</a> x)
                        (<a href="SMT____TE-ARGS-_E3AVOID-LIST.html">te-args-&gt;avoid-list</a> x)
                        (<a href="SMT____TE-ARGS-_E3SYMBOL-MAP.html">te-args-&gt;symbol-map</a> x))
               (<a href="SMT____TE-ARGS-FIX.html">te-args-fix</a> x)))</pre> 
<p><b>Theorem: </b>te-args-fix-when-te-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-fix-when-te-args
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS-FIX.html">te-args-fix</a> x)
               (<a href="SMT____TE-ARGS.html">te-args</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> x)
                        (<a href="SMT____TE-ARGS-_E3FN-LST.html">te-args-&gt;fn-lst</a> x)
                        (<a href="SMT____TE-ARGS-_E3FTY-INFO.html">te-args-&gt;fty-info</a> x)
                        (<a href="SMT____TE-ARGS-_E3SYMBOL-INDEX.html">te-args-&gt;symbol-index</a> x)
                        (<a href="SMT____TE-ARGS-_E3SYMBOL-LIST.html">te-args-&gt;symbol-list</a> x)
                        (<a href="SMT____TE-ARGS-_E3AVOID-LIST.html">te-args-&gt;avoid-list</a> x)
                        (<a href="SMT____TE-ARGS-_E3SYMBOL-MAP.html">te-args-&gt;symbol-map</a> x))))</pre> 
<p><b>Theorem: </b>equal-of-te-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-te-args
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst fn-lst fty-info symbol-index
                               symbol-list avoid-list symbol-map)
                      x)
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____TE-ARGS-P.html">te-args-p</a> x)
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> x)
                           (pseudo-term-list-fix expr-lst))
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS-_E3FN-LST.html">te-args-&gt;fn-lst</a> x)
                           (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> fn-lst))
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS-_E3FTY-INFO.html">te-args-&gt;fty-info</a> x)
                           (<a href="SMT____FTY-INFO-ALIST-FIX.html">fty-info-alist-fix</a> fty-info))
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS-_E3SYMBOL-INDEX.html">te-args-&gt;symbol-index</a> x)
                           (<a href="ACL2____NFIX.html">nfix</a> symbol-index))
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS-_E3SYMBOL-LIST.html">te-args-&gt;symbol-list</a> x)
                           (str::string-list-fix symbol-list))
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS-_E3AVOID-LIST.html">te-args-&gt;avoid-list</a> x)
                           (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> avoid-list))
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS-_E3SYMBOL-MAP.html">te-args-&gt;symbol-map</a> x)
                           (<a href="SMT____SYMBOL-STRING-ALIST-FIX.html">symbol-string-alist-fix</a> symbol-map)))))</pre> 
<p><b>Theorem: </b>te-args-of-pseudo-term-list-fix-expr-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-of-pseudo-term-list-fix-expr-lst
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS.html">te-args</a> (pseudo-term-list-fix expr-lst)
                        fn-lst fty-info symbol-index
                        symbol-list avoid-list symbol-map)
               (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst fn-lst fty-info symbol-index
                        symbol-list avoid-list symbol-map)))</pre> 
<p><b>Theorem: </b>te-args-pseudo-term-list-equiv-congruence-on-expr-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     te-args-pseudo-term-list-equiv-congruence-on-expr-lst
     (<a href="ACL2____IMPLIES.html">implies</a> (pseudo-term-list-equiv expr-lst expr-lst-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst fn-lst fty-info symbol-index
                              symbol-list avoid-list symbol-map)
                     (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst-equiv
                              fn-lst fty-info symbol-index
                              symbol-list avoid-list symbol-map)))
     :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>te-args-of-func-alist-fix-fn-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-of-func-alist-fix-fn-lst
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> fn-lst)
                        fty-info symbol-index
                        symbol-list avoid-list symbol-map)
               (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst fn-lst fty-info symbol-index
                        symbol-list avoid-list symbol-map)))</pre> 
<p><b>Theorem: </b>te-args-func-alist-equiv-congruence-on-fn-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     te-args-func-alist-equiv-congruence-on-fn-lst
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALIST-EQUIV.html">func-alist-equiv</a> fn-lst fn-lst-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst fn-lst fty-info symbol-index
                              symbol-list avoid-list symbol-map)
                     (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst
                              fn-lst-equiv fty-info symbol-index
                              symbol-list avoid-list symbol-map)))
     :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>te-args-of-fty-info-alist-fix-fty-info</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-of-fty-info-alist-fix-fty-info
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst
                        fn-lst (<a href="SMT____FTY-INFO-ALIST-FIX.html">fty-info-alist-fix</a> fty-info)
                        symbol-index
                        symbol-list avoid-list symbol-map)
               (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst fn-lst fty-info symbol-index
                        symbol-list avoid-list symbol-map)))</pre> 
<p><b>Theorem: </b>te-args-fty-info-alist-equiv-congruence-on-fty-info</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     te-args-fty-info-alist-equiv-congruence-on-fty-info
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FTY-INFO-ALIST-EQUIV.html">fty-info-alist-equiv</a> fty-info fty-info-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst fn-lst fty-info symbol-index
                              symbol-list avoid-list symbol-map)
                     (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst
                              fn-lst fty-info-equiv symbol-index
                              symbol-list avoid-list symbol-map)))
     :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>te-args-of-nfix-symbol-index</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-of-nfix-symbol-index
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst
                        fn-lst fty-info (<a href="ACL2____NFIX.html">nfix</a> symbol-index)
                        symbol-list avoid-list symbol-map)
               (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst fn-lst fty-info symbol-index
                        symbol-list avoid-list symbol-map)))</pre> 
<p><b>Theorem: </b>te-args-nat-equiv-congruence-on-symbol-index</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     te-args-nat-equiv-congruence-on-symbol-index
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____NAT-EQUIV.html">acl2::nat-equiv</a> symbol-index symbol-index-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst fn-lst fty-info symbol-index
                              symbol-list avoid-list symbol-map)
                     (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst
                              fn-lst fty-info symbol-index-equiv
                              symbol-list avoid-list symbol-map)))
     :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>te-args-of-string-list-fix-symbol-list</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-of-string-list-fix-symbol-list
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst fn-lst fty-info symbol-index
                        (str::string-list-fix symbol-list)
                        avoid-list symbol-map)
               (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst fn-lst fty-info symbol-index
                        symbol-list avoid-list symbol-map)))</pre> 
<p><b>Theorem: </b>te-args-string-list-equiv-congruence-on-symbol-list</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    te-args-string-list-equiv-congruence-on-symbol-list
    (<a href="ACL2____IMPLIES.html">implies</a> (str::string-list-equiv symbol-list symbol-list-equiv)
             (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst fn-lst fty-info symbol-index
                             symbol-list avoid-list symbol-map)
                    (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst fn-lst
                             fty-info symbol-index symbol-list-equiv
                             avoid-list symbol-map)))
    :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>te-args-of-symbol-list-fix-avoid-list</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-of-symbol-list-fix-avoid-list
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst fn-lst fty-info symbol-index
                        symbol-list (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> avoid-list)
                        symbol-map)
               (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst fn-lst fty-info symbol-index
                        symbol-list avoid-list symbol-map)))</pre> 
<p><b>Theorem: </b>te-args-symbol-list-equiv-congruence-on-avoid-list</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   te-args-symbol-list-equiv-congruence-on-avoid-list
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____SYMBOL-LIST-EQUIV.html">acl2::symbol-list-equiv</a> avoid-list avoid-list-equiv)
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst fn-lst fty-info symbol-index
                            symbol-list avoid-list symbol-map)
                   (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst
                            fn-lst fty-info symbol-index symbol-list
                            avoid-list-equiv symbol-map)))
   :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>te-args-of-symbol-string-alist-fix-symbol-map</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-of-symbol-string-alist-fix-symbol-map
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst fn-lst fty-info
                        symbol-index symbol-list avoid-list
                        (<a href="SMT____SYMBOL-STRING-ALIST-FIX.html">symbol-string-alist-fix</a> symbol-map))
               (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst fn-lst fty-info symbol-index
                        symbol-list avoid-list symbol-map)))</pre> 
<p><b>Theorem: </b>te-args-symbol-string-alist-equiv-congruence-on-symbol-map</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   te-args-symbol-string-alist-equiv-congruence-on-symbol-map
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYMBOL-STRING-ALIST-EQUIV.html">symbol-string-alist-equiv</a> symbol-map symbol-map-equiv)
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst fn-lst fty-info symbol-index
                            symbol-list avoid-list symbol-map)
                   (<a href="SMT____TE-ARGS.html">te-args</a> expr-lst
                            fn-lst fty-info symbol-index symbol-list
                            avoid-list symbol-map-equiv)))
   :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>te-args-fix-redef</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> te-args-fix-redef
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TE-ARGS-FIX.html">te-args-fix</a> x)
               (<a href="SMT____TE-ARGS.html">te-args</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> x)
                        (<a href="SMT____TE-ARGS-_E3FN-LST.html">te-args-&gt;fn-lst</a> x)
                        (<a href="SMT____TE-ARGS-_E3FTY-INFO.html">te-args-&gt;fty-info</a> x)
                        (<a href="SMT____TE-ARGS-_E3SYMBOL-INDEX.html">te-args-&gt;symbol-index</a> x)
                        (<a href="SMT____TE-ARGS-_E3SYMBOL-LIST.html">te-args-&gt;symbol-list</a> x)
                        (<a href="SMT____TE-ARGS-_E3AVOID-LIST.html">te-args-&gt;avoid-list</a> x)
                        (<a href="SMT____TE-ARGS-_E3SYMBOL-MAP.html">te-args-&gt;symbol-map</a> x)))
        :rule-classes :definition)</pre> 
<p><b>Function: </b>map-translated-actuals</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> map-translated-actuals (actuals)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____PARAGRAPHP.html">paragraphp</a> actuals)))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'map-translated-actuals))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____B_A2.html">b*</a> ((actuals (paragraph-fix actuals))
                 ((unless (<a href="COMMON-LISP____CONSP.html">consp</a> actuals)) actuals)
                 ((unless (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> actuals))) actuals)
                 ((<a href="COMMON-LISP____CONS.html">cons</a> first rest) actuals)
                 (mapped-rest (map-translated-actuals rest)))
                (<a href="COMMON-LISP____CONS.html">cons</a> first (<a href="COMMON-LISP____CONS.html">cons</a> #\, mapped-rest)))))</pre> 
<p><b>Theorem: </b>paragraphp-of-map-translated-actuals</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> paragraphp-of-map-translated-actuals
        (<a href="ACL2____B_A2.html">b*</a> ((mapped (map-translated-actuals actuals)))
            (<a href="SMT____PARAGRAPHP.html">paragraphp</a> mapped))
        :rule-classes :rewrite)</pre> 
<p><b>Function: </b>translate-fty-special</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 translate-fty-special
 (fn-call fn-actuals fty-info)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> fn-call)
                             (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> fn-actuals)
                             (<a href="SMT____FTY-INFO-ALIST-P.html">fty-info-alist-p</a> fty-info))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'translate-fty-special))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____B_A2.html">b*</a>
   ((fn-call (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> fn-call))
    (fn-actuals (pseudo-term-list-fix fn-actuals))
    (<a href="SMT____FTY-INFO.html">fty-info</a> (<a href="SMT____FTY-INFO-ALIST-FIX.html">fty-info-alist-fix</a> fty-info))
    ((<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CAR.html">car</a> fn-actuals)
                   (<a href="COMMON-LISP____NULL.html">null</a> (<a href="COMMON-LISP____CDR.html">cdr</a> fn-actuals)))
              (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CAR.html">car</a> fn-actuals))
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAAR.html">caar</a> fn-actuals) 'magic-fix)
              (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CADAR.html">cadar</a> fn-actuals))
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CADAR.html">cadar</a> fn-actuals)) 'quote)
              (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CADR.html">cadr</a> (<a href="COMMON-LISP____CADAR.html">cadar</a> fn-actuals)))))
     (<a href="COMMON-LISP____IF.html">if</a>
      (<a href="COMMON-LISP____EQUAL.html">equal</a> fn-call 'consp)
      (<a href="ACL2____MV.html">mv</a>
       (<a href="COMMON-LISP____LIST.html">list</a>
          (<a href="STR____DOWNCASE-STRING.html">downcase-string</a>
               (<a href="COMMON-LISP____CONCATENATE.html">concatenate</a>
                    'string
                    (lisp-to-python-names (<a href="COMMON-LISP____CADR.html">cadr</a> (<a href="COMMON-LISP____CADAR.html">cadar</a> fn-actuals)))
                    "_" (translate-symbol fn-call))))
       ''t)
      (<a href="ACL2____MV.html">mv</a>
       (<a href="COMMON-LISP____LIST.html">list</a>
          (<a href="STR____DOWNCASE-STRING.html">downcase-string</a>
               (<a href="COMMON-LISP____CONCATENATE.html">concatenate</a>
                    'string
                    (lisp-to-python-names (<a href="COMMON-LISP____CADR.html">cadr</a> (<a href="COMMON-LISP____CADAR.html">cadar</a> fn-actuals)))
                    "." (translate-symbol fn-call))))
       (<a href="COMMON-LISP____CAR.html">car</a> fn-actuals))))
    (fixed
     (<a href="COMMON-LISP____COND.html">cond</a>
      ((<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> fn-call 'car)
           (<a href="COMMON-LISP____EQUAL.html">equal</a> fn-call 'cdr)
           (<a href="COMMON-LISP____EQUAL.html">equal</a> fn-call 'consp))
       (<a href="ACL2____B_A2.html">b*</a>
         (((unless (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CAR.html">car</a> fn-actuals)
                        (<a href="COMMON-LISP____NULL.html">null</a> (<a href="COMMON-LISP____CDR.html">cdr</a> fn-actuals))))
           (<a href="ACL2____ER.html">er</a> hard?
               'smt-translator=&gt;translate-fty-special
               "Wrong ~
         number of arguments for ~p0: ~p1~%"
               fn-call fn-actuals)))
         (<a href="COMMON-LISP____CAR.html">car</a> fn-actuals)))
      ((<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> fn-call 'cons)
           (<a href="COMMON-LISP____EQUAL.html">equal</a> fn-call 'assoc-equal))
       (<a href="ACL2____B_A2.html">b*</a>
         (((unless (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CADR.html">cadr</a> fn-actuals)
                        (<a href="COMMON-LISP____NULL.html">null</a> (<a href="COMMON-LISP____CDDR.html">cddr</a> fn-actuals))))
           (<a href="ACL2____ER.html">er</a> hard?
               'smt-translator=&gt;translate-fty-special
               "Wrong ~
         number of arguments for ~p0: ~p1~%"
               fn-call fn-actuals)))
         (<a href="COMMON-LISP____CADR.html">cadr</a> fn-actuals)))
      ((<a href="COMMON-LISP____EQUAL.html">equal</a> fn-call 'acons)
       (<a href="ACL2____B_A2.html">b*</a>
         (((unless (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CADDR.html">caddr</a> fn-actuals)
                        (<a href="COMMON-LISP____NULL.html">null</a> (<a href="COMMON-LISP____CDDDR.html">cdddr</a> fn-actuals))))
           (<a href="ACL2____ER.html">er</a> hard?
               'smt-translator=&gt;translate-fty-special
               "Wrong ~
         number of arguments for ~p0: ~p1~%"
               fn-call fn-actuals)))
         (<a href="COMMON-LISP____CADDR.html">caddr</a> fn-actuals)))
      (t (<a href="ACL2____ER.html">er</a> hard?
             'smt-translator=&gt;translate-fty-special
             "Impossible path:
                                 ~q0"
             fn-call))))
    ((unless (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> fixed)
                  (<a href="COMMON-LISP____CAR.html">car</a> fixed)
                  (<a href="COMMON-LISP____CADR.html">cadr</a> fixed)
                  (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> fixed))))
     (<a href="ACL2____PROG2_42.html">prog2$</a> (<a href="ACL2____ER.html">er</a> hard?
                 'smt-translator=&gt;translate-fty-special
                 "Not fixed1:
                                 ~q0"
                 fixed)
             (<a href="ACL2____MV.html">mv</a> nil ''t)))
    ((<a href="ACL2____MV.html">mv</a> fixing? &amp;)
     (fixing-of-flextype (<a href="COMMON-LISP____CAR.html">car</a> fixed)
                         fty-info))
    ((unless fixing?)
     (<a href="ACL2____PROG2_42.html">prog2$</a> (<a href="ACL2____ER.html">er</a> hard?
                 'smt-translator=&gt;translate-fty-special
                 "Not fixed2:
                                 ~q0"
                 (<a href="COMMON-LISP____CAR.html">car</a> fixed))
             (<a href="ACL2____MV.html">mv</a> nil ''t)))
    ((unless (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> (<a href="COMMON-LISP____CADR.html">cadr</a> fixed)))
     (<a href="ACL2____PROG2_42.html">prog2$</a>
        (<a href="ACL2____ER.html">er</a> hard?
            'smt-translator=&gt;translate-fty-special
            "not ~
                               pseudo-termp: ~q0"
            (<a href="COMMON-LISP____CADR.html">cadr</a> fixed))
        (<a href="ACL2____MV.html">mv</a> nil ''t)))
    (smt-precond (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> fn-call 'car)
                     (<a href="COMMON-LISP____CONS.html">cons</a> 'consp (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CADR.html">cadr</a> fixed) 'nil))
                     ''t)))
   (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> fn-call 'acons)
           (<a href="COMMON-LISP____EQUAL.html">equal</a> fn-call 'assoc-equal)
           (<a href="COMMON-LISP____EQUAL.html">equal</a> fn-call 'consp))
       (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____LIST.html">list</a> (<a href="STR____DOWNCASE-STRING.html">downcase-string</a>
                      (<a href="COMMON-LISP____CONCATENATE.html">concatenate</a> 'string
                                   (translate-symbol fixing?)
                                   "_" (translate-symbol fn-call))))
           ''t)
       (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____LIST.html">list</a> (<a href="STR____DOWNCASE-STRING.html">downcase-string</a>
                      (<a href="COMMON-LISP____CONCATENATE.html">concatenate</a> 'string
                                   (translate-symbol fixing?)
                                   "." (translate-symbol fn-call))))
           smt-precond)))))</pre> 
<p><b>Theorem: </b>paragraphp-of-translate-fty-special.translated</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> paragraphp-of-translate-fty-special.translated
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?translated ?smt-precond)
              (translate-fty-special fn-call fn-actuals fty-info)))
            (<a href="SMT____PARAGRAPHP.html">paragraphp</a> translated))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>pseudo-termp-of-translate-fty-special.smt-precond</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-termp-of-translate-fty-special.smt-precond
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?translated ?smt-precond)
              (translate-fty-special fn-call fn-actuals fty-info)))
            (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> smt-precond))
        :rule-classes :rewrite)</pre> 
<p><b>Function: </b>translate-field-accessor</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 translate-field-accessor
 (fty-name fn-call)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> fty-name)
                             (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> fn-call))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'translate-field-accessor))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____B_A2.html">b*</a>
    ((fty-name (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> fty-name))
     (fn-call (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> fn-call))
     (fty-name-str (<a href="COMMON-LISP____SYMBOL-NAME.html">symbol-name</a> fty-name))
     (fn-call-str (<a href="COMMON-LISP____SYMBOL-NAME.html">symbol-name</a> fn-call))
     ((unless (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="COMMON-LISP_____B2.html">+</a> 2 (<a href="COMMON-LISP____LENGTH.html">length</a> fty-name-str))
                  (<a href="COMMON-LISP____LENGTH.html">length</a> fn-call-str)))
      (<a href="ACL2____MV.html">mv</a> (<a href="ACL2____ER.html">er</a> hard?
              'smt-translator=&gt;translate-field-accessor
              "Something is ~
             wrong1: ~p0 and ~p1"
              fty-name-str fn-call-str)
          ''t))
     (pos-prefix (<a href="COMMON-LISP____SEARCH.html">search</a> fty-name-str fn-call-str
                         :test 'equal))
     ((unless (<a href="COMMON-LISP____EQUAL.html">equal</a> pos-prefix 0))
      (<a href="ACL2____MV.html">mv</a> (<a href="ACL2____ER.html">er</a> hard?
              'smt-translator=&gt;translate-field-accessor
              "Something is ~
             wrong2: ~p0 and ~p1"
              fty-name-str fn-call-str)
          ''t))
     (pos1 (<a href="COMMON-LISP____LENGTH.html">length</a> fty-name-str))
     (pos-infix (<a href="COMMON-LISP____SEARCH.html">search</a> "-&gt;" fn-call-str :test 'equal))
     ((unless (<a href="COMMON-LISP____EQUAL.html">equal</a> pos1 pos-infix))
      (<a href="ACL2____MV.html">mv</a> (<a href="ACL2____ER.html">er</a> hard?
              'smt-translator=&gt;translate-field-accessor
              "Something is ~
             wrong3: ~p0 and ~p1"
              fty-name-str fn-call-str)
          ''t))
     (pos-suffix (<a href="COMMON-LISP_____B2.html">+</a> 2 pos1))
     (pos2 (<a href="COMMON-LISP____SEARCH.html">search</a> "$INLINE" fn-call-str
                   :from-end t
                   :test 'equal))
     ((unless (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> pos2)
                   (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> pos-suffix pos2)
                   (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> pos2 (<a href="COMMON-LISP____LENGTH.html">length</a> fn-call-str))))
      (<a href="ACL2____MV.html">mv</a> (<a href="ACL2____ER.html">er</a> hard?
              'smt-translator=&gt;translate-field-accessor
              "Something is ~
             wrong4: ~p0 and ~p1"
              fty-name-str fn-call-str)
          ''t))
     (suffix (<a href="COMMON-LISP____SUBSEQ.html">subseq</a> fn-call-str pos-suffix pos2))
     ((unless (<a href="COMMON-LISP____STRINGP.html">stringp</a> suffix))
      (<a href="ACL2____MV.html">mv</a> (<a href="ACL2____ER.html">er</a> hard?
              'smt-translator=&gt;translate-field-accessor
              "Something is ~
             wrong5: ~p0 and ~p1"
              fty-name-str fn-call-str)
          ''t)))
    (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____LIST.html">list</a> (<a href="STR____DOWNCASE-STRING.html">downcase-string</a>
                   (<a href="COMMON-LISP____CONCATENATE.html">concatenate</a> 'string
                                (lisp-to-python-names fty-name-str)
                                "." (lisp-to-python-names suffix))))
        ''t))))</pre> 
<p><b>Theorem: </b>paragraphp-of-translate-field-accessor.translated</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> paragraphp-of-translate-field-accessor.translated
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?translated ?smt-precond)
              (translate-field-accessor fty-name fn-call)))
            (<a href="SMT____PARAGRAPHP.html">paragraphp</a> translated))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>pseudo-termp-of-translate-field-accessor.smt-precond</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-termp-of-translate-field-accessor.smt-precond
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?translated ?smt-precond)
              (translate-field-accessor fty-name fn-call)))
            (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> smt-precond))
        :rule-classes :rewrite)</pre> 
<p><b>Function: </b>translate-fty</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 translate-fty
 (fn-call fn-actuals fty-info)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> fn-call)
                             (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> fn-actuals)
                             (<a href="SMT____FTY-INFO-ALIST-P.html">fty-info-alist-p</a> fty-info))))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____OR.html">or</a> (fncall-of-flextype-special fn-call)
                            (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> fn-call fty-info))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'translate-fty))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____B_A2.html">b*</a>
   ((fn-call (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> fn-call))
    (special? (fncall-of-flextype-special fn-call))
    ((<a href="COMMON-LISP____IF.html">if</a> special?)
     (translate-fty-special fn-call fn-actuals fty-info))
    (item (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> fn-call fty-info))
    (fty-name (<a href="SMT____FTY-INFO-_E3NAME.html">fty-info-&gt;name</a> (<a href="COMMON-LISP____CDR.html">cdr</a> item)))
    (<a href="SMT____FTY-TYPE.html">fty-type</a> (<a href="SMT____FTY-INFO-_E3TYPE.html">fty-info-&gt;type</a> (<a href="COMMON-LISP____CDR.html">cdr</a> item)))
    (option? (fncall-of-flextype-option fn-call fty-info))
    ((<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____AND.html">and</a> option? (<a href="COMMON-LISP____EQUAL.html">equal</a> fty-type :constructor)))
     (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONCATENATE.html">concatenate</a> 'string
                            (translate-symbol fty-name)
                            ".some"))
         ''t))
    ((<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____AND.html">and</a> option? (<a href="COMMON-LISP____EQUAL.html">equal</a> fty-type :field)))
     (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONCATENATE.html">concatenate</a> 'string
                            (translate-symbol fty-name)
                            ".val"))
         ''t))
    ((unless (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> fty-type :field)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> fty-type :constructor)))
     (<a href="ACL2____MV.html">mv</a>
      (<a href="ACL2____ER.html">er</a>
       hard? 'smt-translator=&gt;translate-fty
       "Unexpected fty function ~
                         found: ~p0 of ~p1~%"
       fn-call fty-type)
      ''t))
    ((<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> fty-type :constructor))
     (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONCATENATE.html">concatenate</a> 'string
                            (translate-symbol fty-name)
                            "." (translate-symbol fn-call)))
         ''t)))
   (translate-field-accessor fty-name fn-call))))</pre> 
<p><b>Theorem: </b>paragraphp-of-translate-fty.translated</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> paragraphp-of-translate-fty.translated
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?translated ?smt-precond)
              (translate-fty fn-call fn-actuals fty-info)))
            (<a href="SMT____PARAGRAPHP.html">paragraphp</a> translated))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>pseudo-termp-of-translate-fty.smt-precond</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-termp-of-translate-fty.smt-precond
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?translated ?smt-precond)
              (translate-fty fn-call fn-actuals fty-info)))
            (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> smt-precond))
        :rule-classes :rewrite)</pre> 
<p><b>Function: </b>generate-symbol-enumeration</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 generate-symbol-enumeration
 (symbol-index)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____NATP.html">natp</a> symbol-index)))
 (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'generate-symbol-enumeration))
      (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
      (<a href="ACL2____B_A2.html">b*</a> ((symbol-index (<a href="ACL2____NFIX.html">nfix</a> symbol-index))
           (new-sym (<a href="COMMON-LISP____CONCATENATE.html">concatenate</a> 'string
                                 "gensym_"
                                 (<a href="STR____NAT-TO-DEC-STRING.html">nat-to-dec-string</a> symbol-index))))
          new-sym)))</pre> 
<p><b>Theorem: </b>stringp-of-generate-symbol-enumeration</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> stringp-of-generate-symbol-enumeration
        (<a href="ACL2____B_A2.html">b*</a> ((new-sym (generate-symbol-enumeration symbol-index)))
            (<a href="COMMON-LISP____STRINGP.html">stringp</a> new-sym))
        :rule-classes :rewrite)</pre> 
<p><b>Function: </b>translate-quote</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
   translate-quote (expr)
   (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
   (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'translate-quote))
        (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
        (<a href="ACL2____B_A2.html">b*</a> (((unless (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> expr)
                          (smt-numberp expr)
                          (<a href="ACL2____BOOLEANP.html">booleanp</a> expr)))
              (<a href="ACL2____ER.html">er</a> hard? 'smt-translator=&gt;translate-quote
                  "Atom not ~
                       supported: ~q0"
                  expr)))
            (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="ACL2____BOOLEANP.html">booleanp</a> expr)
                   (translate-bool expr nil))
                  ((smt-numberp expr)
                   (translate-number expr))
                  (t (translate-symbol expr))))))</pre> 
<p><b>Theorem: </b>paragraphp-of-translate-quote</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> paragraphp-of-translate-quote
        (<a href="ACL2____B_A2.html">b*</a> ((translated-quote (translate-quote expr)))
            (<a href="SMT____PARAGRAPHP.html">paragraphp</a> translated-quote))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>stringp-of-translated-quote-when-symbolp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> stringp-of-translated-quote-when-symbolp
        (<a href="ACL2____B_A2.html">b*</a> ((translated-quote (translate-quote expr)))
            (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> expr)
                          (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> expr)))
                     (<a href="COMMON-LISP____STRINGP.html">stringp</a> translated-quote)))
        :rule-classes :rewrite)</pre> 
<p><b>Function: </b>translate-expression</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 translate-expression (<a href="ACL2____ARGS.html">args</a>)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____TE-ARGS-P.html">te-args-p</a> args)))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'translate-expression))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____B_A2.html">b*</a>
   ((<a href="ACL2____ARGS.html">args</a> (<a href="SMT____TE-ARGS-FIX.html">te-args-fix</a> args))
    ((<a href="SMT____TE-ARGS.html">te-args</a> a) args)
    ((unless (<a href="COMMON-LISP____CONSP.html">consp</a> a.expr-lst))
     (<a href="ACL2____MV.html">mv</a> nil ''t
         a.symbol-list
         a.symbol-index a.symbol-map))
    ((<a href="COMMON-LISP____CONS.html">cons</a> expr rest) a.expr-lst)
    ((<a href="ACL2____MV.html">mv</a> translated-rest
         smt-precond-rest symbols-rest
         symbol-index-rest symbol-map-rest)
     (translate-expression (<a href="SMT____CHANGE-TE-ARGS.html">change-te-args</a> a :expr-lst rest)))
    ((<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> expr))
     (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____CONS.html">cons</a> (translate-symbol expr)
               translated-rest)
         smt-precond-rest symbols-rest
         symbol-index-rest symbol-map-rest))
    ((<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> expr) 'quote))
     (<a href="ACL2____B_A2.html">b*</a>
      ((the-sym (<a href="COMMON-LISP____CADR.html">cadr</a> expr))
       ((unless (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> the-sym)
                     (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> the-sym))))
        (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____CONS.html">cons</a> (translate-quote the-sym)
                  translated-rest)
            smt-precond-rest symbols-rest
            symbol-index-rest symbol-map-rest))
       ((unless (<a href="ACL2____MBT.html">mbt</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> symbol-map-rest)))
        (<a href="ACL2____MV.html">mv</a> (<a href="ACL2____ER.html">er</a> hard?
                'smt-translator=&gt;translate-expression
                "Can't reach ~
                      this branch~%")
            nil nil 0 nil))
       (exist-map? (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> the-sym symbol-map-rest)))
       ((<a href="COMMON-LISP____IF.html">if</a> exist-map?)
        (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____CONS.html">cons</a> exist-map? translated-rest)
            smt-precond-rest
            (<a href="COMMON-LISP____CONS.html">cons</a> exist-map? symbols-rest)
            symbol-index-rest symbol-map-rest))
       (exist-sym? (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> the-sym a.avoid-list))
       (gen-sym (<a href="COMMON-LISP____IF.html">if</a> exist-sym?
                    (generate-symbol-enumeration a.symbol-index)
                    (translate-symbol the-sym))))
      (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____CONS.html">cons</a> gen-sym translated-rest)
          smt-precond-rest
          (<a href="COMMON-LISP____CONS.html">cons</a> gen-sym symbols-rest)
          (<a href="COMMON-LISP____IF.html">if</a> exist-sym? (<a href="COMMON-LISP____1_B2.html">1+</a> symbol-index-rest)
              symbol-index-rest)
          (<a href="COMMON-LISP____IF.html">if</a> exist-map? symbol-map-rest
              (<a href="COMMON-LISP____ACONS.html">acons</a> the-sym gen-sym symbol-map-rest)))))
    ((<a href="COMMON-LISP____CONS.html">cons</a> fn-call fn-actuals) expr)
    ((<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____PSEUDO-LAMBDAP.html">pseudo-lambdap</a> fn-call))
     (<a href="ACL2____B_A2.html">b*</a>
      ((<a href="ACL2____FORMALS.html">formals</a> (<a href="ACL2____LAMBDA-FORMALS.html">lambda-formals</a> fn-call))
       ((unless (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> formals)
                     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> formals) (<a href="ACL2____LEN.html">len</a> fn-actuals))
                     (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> fn-actuals)))
        (<a href="ACL2____MV.html">mv</a> (<a href="ACL2____ER.html">er</a> hard?
                'smt-translator=&gt;translate-expression
                "bad lambda: ~q0" fn-call)
            nil nil 0 nil))
       (<a href="ACL2____BODY.html">body</a> (<a href="ACL2____LAMBDA-BODY.html">lambda-body</a> fn-call))
       (lambda-sym (<a href="COMMON-LISP____CAR.html">car</a> fn-call))
       ((<a href="ACL2____MV.html">mv</a> translated-lambda &amp;)
        (translate-function lambda-sym))
       (translated-formals (translate-symbol-lst formals))
       ((<a href="ACL2____MV.html">mv</a> translated-body
            smt-precond-1 symbol-list-1
            symbol-index-1 symbol-map-1)
        (translate-expression
             (<a href="SMT____CHANGE-TE-ARGS.html">change-te-args</a> a
                             :expr-lst (<a href="COMMON-LISP____LIST.html">list</a> body)
                             :symbol-list symbols-rest
                             :symbol-index symbol-index-rest
                             :symbol-map symbol-map-rest)))
       ((<a href="ACL2____MV.html">mv</a> translated-actuals
            smt-precond-2 symbol-list-2
            symbol-index-2 symbol-map-2)
        (translate-expression
             (<a href="SMT____CHANGE-TE-ARGS.html">change-te-args</a> a
                             :expr-lst fn-actuals
                             :symbol-list symbol-list-1
                             :symbol-index symbol-index-1
                             :symbol-map symbol-map-1)))
       (translated-lambda-whole
        (<a href="COMMON-LISP____CONS.html">cons</a>
         '#\(
         (<a href="COMMON-LISP____CONS.html">cons</a>
          translated-lambda
          (<a href="COMMON-LISP____CONS.html">cons</a>
           '#\Space
           (<a href="COMMON-LISP____CONS.html">cons</a>
            translated-formals
            (<a href="COMMON-LISP____CONS.html">cons</a>
             '#\:
             (<a href="COMMON-LISP____CONS.html">cons</a>
              translated-body
              (<a href="COMMON-LISP____CONS.html">cons</a>
               '#\)
               (<a href="COMMON-LISP____CONS.html">cons</a>
                   '#\(
                   (<a href="COMMON-LISP____CONS.html">cons</a> (map-translated-actuals translated-actuals)
                         '(#\)))))))))))))
      (<a href="ACL2____MV.html">mv</a>
       (<a href="COMMON-LISP____CONS.html">cons</a> translated-lambda-whole translated-rest)
       (<a href="COMMON-LISP____CONS.html">cons</a>
        'if
        (<a href="COMMON-LISP____CONS.html">cons</a>
         (<a href="COMMON-LISP____CONS.html">cons</a>
          'if
          (<a href="COMMON-LISP____CONS.html">cons</a>
               (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'lambda
                           (<a href="COMMON-LISP____CONS.html">cons</a> formals (<a href="COMMON-LISP____CONS.html">cons</a> smt-precond-1 'nil)))
                     fn-actuals)
               (<a href="COMMON-LISP____CONS.html">cons</a> smt-precond-2 '('nil))))
         (<a href="COMMON-LISP____CONS.html">cons</a> smt-precond-rest '('nil))))
       symbol-list-2
       symbol-index-2 symbol-map-2)))
    ((<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> fn-call 'magic-fix))
     (<a href="ACL2____B_A2.html">b*</a>
      (((unless (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> fn-actuals)
                     (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> fn-actuals))
                     (<a href="COMMON-LISP____NULL.html">null</a> (<a href="COMMON-LISP____CDDR.html">cddr</a> fn-actuals))))
        (<a href="ACL2____MV.html">mv</a>
         (<a href="ACL2____ER.html">er</a>
          hard?
          'smt-translator=&gt;translate-expression
          "Wrong ~
         number of arguments for magic-fix function: ~q0"
          expr)
         nil nil 0 nil))
       (the-type (<a href="COMMON-LISP____CAR.html">car</a> fn-actuals))
       (the-nil (<a href="COMMON-LISP____CADR.html">cadr</a> fn-actuals))
       ((<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> the-nil)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> the-nil) 'quote)
                 (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> the-nil))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CADR.html">cadr</a> the-nil) nil)
                 (<a href="COMMON-LISP____CONSP.html">consp</a> the-type)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> the-type) 'quote)
                 (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> the-type))
                 (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CADR.html">cadr</a> the-type))))
        (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____CONS.html">cons</a> (translate-bool nil (<a href="COMMON-LISP____CADR.html">cadr</a> the-type))
                  translated-rest)
            smt-precond-rest symbols-rest
            symbol-index-rest symbol-map-rest))
       ((<a href="ACL2____MV.html">mv</a> translated-actuals
            smt-precond-1 symbol-list-1
            symbol-index-1 symbol-map-1)
        (translate-expression
             (<a href="SMT____CHANGE-TE-ARGS.html">change-te-args</a> a
                             :expr-lst (<a href="COMMON-LISP____CDR.html">cdr</a> fn-actuals)
                             :symbol-list symbols-rest
                             :symbol-index symbol-index-rest
                             :symbol-map symbol-map-rest))))
      (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____CONS.html">cons</a> translated-actuals translated-rest)
          (<a href="COMMON-LISP____CONS.html">cons</a> 'if
                (<a href="COMMON-LISP____CONS.html">cons</a> smt-precond-1
                      (<a href="COMMON-LISP____CONS.html">cons</a> smt-precond-rest '('nil))))
          symbol-list-1
          symbol-index-1 symbol-map-1)))
    ((<a href="ACL2____MV.html">mv</a> fixing? guards)
     (fixing-of-flextype fn-call a.fty-info))
    ((<a href="COMMON-LISP____IF.html">if</a> fixing?)
     (<a href="ACL2____B_A2.html">b*</a>
      (((unless (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> fn-actuals)
                     (<a href="COMMON-LISP____CAR.html">car</a> fn-actuals)
                     (<a href="COMMON-LISP____NULL.html">null</a> (<a href="COMMON-LISP____CDR.html">cdr</a> fn-actuals))))
        (<a href="ACL2____MV.html">mv</a>
         (<a href="ACL2____ER.html">er</a>
          hard?
          'smt-translator=&gt;translate-expression
          "Wrong ~
         number of arguments for a fixing function: ~q0"
          expr)
         nil nil 0 nil))
       (fixed (<a href="COMMON-LISP____CAR.html">car</a> fn-actuals))
       ((unless (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> guards)
                     (<a href="COMMON-LISP____CAR.html">car</a> guards)
                     (<a href="COMMON-LISP____NULL.html">null</a> (<a href="COMMON-LISP____CDR.html">cdr</a> guards))
                     (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> guards) 'quote))))
        (<a href="ACL2____MV.html">mv</a> (<a href="ACL2____ER.html">er</a> hard?
                'smt-translator=&gt;translate-expression
                "bad guards :
       ~q0" guards)
            nil nil 0 nil))
       ((<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> fixed)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> fixed) 'quote)
                 (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> fixed))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CADR.html">cadr</a> fixed) nil)))
        (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____CONS.html">cons</a> (translate-bool nil fixing?)
                  translated-rest)
            (<a href="COMMON-LISP____CONS.html">cons</a> 'if
                  (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> guards) (<a href="COMMON-LISP____CONS.html">cons</a> fixed 'nil))
                        (<a href="COMMON-LISP____CONS.html">cons</a> smt-precond-rest '('nil))))
            symbols-rest
            symbol-index-rest symbol-map-rest))
       ((<a href="ACL2____MV.html">mv</a> translated-actuals
            smt-precond-1 symbol-list-1
            symbol-index-1 symbol-map-1)
        (translate-expression
             (<a href="SMT____CHANGE-TE-ARGS.html">change-te-args</a> a
                             :expr-lst fn-actuals
                             :symbol-list symbols-rest
                             :symbol-index symbol-index-rest
                             :symbol-map symbol-map-rest))))
      (<a href="ACL2____MV.html">mv</a>
       (<a href="COMMON-LISP____CONS.html">cons</a> translated-actuals translated-rest)
       (<a href="COMMON-LISP____CONS.html">cons</a> 'if
             (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'if
                         (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> guards) (<a href="COMMON-LISP____CONS.html">cons</a> fixed 'nil))
                               (<a href="COMMON-LISP____CONS.html">cons</a> smt-precond-1 '('nil))))
                   (<a href="COMMON-LISP____CONS.html">cons</a> smt-precond-rest '('nil))))
       symbol-list-1
       symbol-index-1 symbol-map-1)))
    (fty? (<a href="SMT____FNCALL-OF-FLEXTYPE.html">fncall-of-flextype</a> fn-call a.fty-info))
    ((<a href="COMMON-LISP____IF.html">if</a> fty?)
     (<a href="ACL2____B_A2.html">b*</a>
      (((<a href="ACL2____MV.html">mv</a> translated-fn-call fty-smt-precond)
        (translate-fty fn-call fn-actuals a.fty-info))
       ((<a href="ACL2____MV.html">mv</a> translated-actuals
            smt-precond-1 symbol-list-1
            symbol-index-1 symbol-map-1)
        (translate-expression
             (<a href="SMT____CHANGE-TE-ARGS.html">change-te-args</a> a
                             :expr-lst fn-actuals
                             :symbol-list symbols-rest
                             :symbol-index symbol-index-rest
                             :symbol-map symbol-map-rest)))
       (translated-expr
        (<a href="COMMON-LISP____CONS.html">cons</a>
             translated-fn-call
             (<a href="COMMON-LISP____CONS.html">cons</a> '#\(
                   (<a href="COMMON-LISP____CONS.html">cons</a> (map-translated-actuals translated-actuals)
                         '(#\)))))))
      (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____CONS.html">cons</a> translated-expr translated-rest)
          (<a href="COMMON-LISP____CONS.html">cons</a> 'if
                (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'if
                            (<a href="COMMON-LISP____CONS.html">cons</a> fty-smt-precond
                                  (<a href="COMMON-LISP____CONS.html">cons</a> smt-precond-1 '('nil))))
                      (<a href="COMMON-LISP____CONS.html">cons</a> smt-precond-rest '('nil))))
          symbol-list-1
          symbol-index-1 symbol-map-1)))
    ((unless (<a href="ACL2____MBT.html">mbt</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> fn-call)))
     (<a href="ACL2____MV.html">mv</a> nil ''t nil 0 nil))
    (fn (<a href="ACL2____HONS-GET.html">hons-get</a> fn-call a.fn-lst))
    ((<a href="COMMON-LISP____IF.html">if</a> fn)
     (<a href="ACL2____B_A2.html">b*</a>
      (((<a href="ACL2____MV.html">mv</a> translated-actuals
            smt-precond-1 symbol-list-1
            symbol-index-1 symbol-map-1)
        (translate-expression
             (<a href="SMT____CHANGE-TE-ARGS.html">change-te-args</a> a
                             :expr-lst fn-actuals
                             :symbol-list symbols-rest
                             :symbol-index symbol-index-rest
                             :symbol-map symbol-map-rest)))
       (translated-fn-call
        (<a href="COMMON-LISP____CONS.html">cons</a>
             (translate-symbol fn-call)
             (<a href="COMMON-LISP____CONS.html">cons</a> '#\(
                   (<a href="COMMON-LISP____CONS.html">cons</a> (map-translated-actuals translated-actuals)
                         '(#\)))))))
      (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____CONS.html">cons</a> translated-fn-call translated-rest)
          (<a href="COMMON-LISP____CONS.html">cons</a> 'if
                (<a href="COMMON-LISP____CONS.html">cons</a> smt-precond-1
                      (<a href="COMMON-LISP____CONS.html">cons</a> smt-precond-rest '('nil))))
          symbol-list-1
          symbol-index-1 symbol-map-1)))
    ((<a href="ACL2____MV.html">mv</a> fn nargs)
     (translate-function fn-call))
    ((<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> nargs))
     (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> fn '(#\( #\)))
               translated-rest)
         smt-precond-rest symbols-rest
         symbol-index-rest symbol-map-rest))
    ((<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> fn-call 'if))
     (<a href="ACL2____B_A2.html">b*</a>
      (((unless (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> fn-actuals)
                     (<a href="COMMON-LISP____CAR.html">car</a> fn-actuals)
                     (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> fn-actuals))
                     (<a href="COMMON-LISP____CADR.html">cadr</a> fn-actuals)
                     (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CDDR.html">cddr</a> fn-actuals))
                     (<a href="COMMON-LISP____CADDR.html">caddr</a> fn-actuals)
                     (<a href="COMMON-LISP____NULL.html">null</a> (<a href="COMMON-LISP____CDDDR.html">cdddr</a> fn-actuals))))
        (<a href="ACL2____MV.html">mv</a>
         (<a href="ACL2____ER.html">er</a> hard?
             'smt-translator=&gt;translate-expression
             "fn-actuals ~
       for if should be of length 3: ~q0"
             fn-actuals)
         nil nil 0 nil))
       ((<a href="ACL2____MV.html">mv</a> translated-car-actual
            smt-precond-if symbol-list-1
            symbol-index-1 symbol-map-1)
        (translate-expression
             (<a href="SMT____CHANGE-TE-ARGS.html">change-te-args</a> a
                             :expr-lst (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CAR.html">car</a> fn-actuals))
                             :symbol-list symbols-rest
                             :symbol-index symbol-index-rest
                             :symbol-map symbol-map-rest)))
       ((<a href="ACL2____MV.html">mv</a> translated-cadr-actual
            smt-precond-then symbol-list-2
            symbol-index-2 symbol-map-2)
        (translate-expression
             (<a href="SMT____CHANGE-TE-ARGS.html">change-te-args</a> a
                             :expr-lst (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CADR.html">cadr</a> fn-actuals))
                             :symbol-list symbol-list-1
                             :symbol-index symbol-index-1
                             :symbol-map symbol-map-1)))
       ((<a href="ACL2____MV.html">mv</a> translated-caddr-actual
            smt-precond-else symbol-list-3
            symbol-index-3 symbol-map-3)
        (translate-expression
             (<a href="SMT____CHANGE-TE-ARGS.html">change-te-args</a> a
                             :expr-lst (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CADDR.html">caddr</a> fn-actuals))
                             :symbol-list symbol-list-2
                             :symbol-index symbol-index-2
                             :symbol-map symbol-map-2)))
       (translated-actuals
            (<a href="COMMON-LISP____CONS.html">cons</a> translated-car-actual
                  (<a href="COMMON-LISP____CONS.html">cons</a> translated-cadr-actual
                        (<a href="COMMON-LISP____CONS.html">cons</a> translated-caddr-actual 'nil))))
       ((unless (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> (<a href="COMMON-LISP____CAR.html">car</a> fn-actuals))
                     (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> (<a href="COMMON-LISP____CADR.html">cadr</a> fn-actuals))
                     (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> (<a href="COMMON-LISP____CADDR.html">caddr</a> fn-actuals))))
        (<a href="ACL2____MV.html">mv</a> (<a href="ACL2____ER.html">er</a> hard?
                'smt-translator=&gt;translate-expression
                "pseudo-termp
       ensured: ~q0"
                fn-actuals)
            nil nil 0 nil))
       (smt-precond
        (<a href="COMMON-LISP____CONS.html">cons</a>
         'if
         (<a href="COMMON-LISP____CONS.html">cons</a>
             smt-precond-if
             (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'if
                         (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> fn-actuals)
                               (<a href="COMMON-LISP____CONS.html">cons</a> smt-precond-then
                                     (<a href="COMMON-LISP____CONS.html">cons</a> smt-precond-else 'nil))))
                   '('nil))))))
      (<a href="ACL2____MV.html">mv</a>
       (<a href="COMMON-LISP____CONS.html">cons</a>
        (<a href="COMMON-LISP____CONS.html">cons</a>
             fn
             (<a href="COMMON-LISP____CONS.html">cons</a> '#\(
                   (<a href="COMMON-LISP____CONS.html">cons</a> (map-translated-actuals translated-actuals)
                         '(#\)))))
        translated-rest)
       (<a href="COMMON-LISP____CONS.html">cons</a> 'if
             (<a href="COMMON-LISP____CONS.html">cons</a> smt-precond
                   (<a href="COMMON-LISP____CONS.html">cons</a> smt-precond-rest '('nil))))
       symbol-list-3
       symbol-index-3 symbol-map-3)))
    ((<a href="ACL2____MV.html">mv</a> translated-actuals
         smt-precond-1 symbol-list-1
         symbol-index-1 symbol-map-1)
     (translate-expression
          (<a href="SMT____CHANGE-TE-ARGS.html">change-te-args</a> a
                          :expr-lst fn-actuals
                          :symbol-list symbols-rest
                          :symbol-index symbol-index-rest
                          :symbol-map symbol-map-rest))))
   (<a href="ACL2____MV.html">mv</a>
    (<a href="COMMON-LISP____CONS.html">cons</a>
       (<a href="COMMON-LISP____CONS.html">cons</a> fn
             (<a href="COMMON-LISP____CONS.html">cons</a> '#\(
                   (<a href="COMMON-LISP____CONS.html">cons</a> (map-translated-actuals translated-actuals)
                         '(#\)))))
       translated-rest)
    (<a href="COMMON-LISP____CONS.html">cons</a> 'if
          (<a href="COMMON-LISP____CONS.html">cons</a> smt-precond-1
                (<a href="COMMON-LISP____CONS.html">cons</a> smt-precond-rest '('nil))))
    symbol-list-1
    symbol-index-1 symbol-map-1))))</pre> 
<p><b>Theorem: </b>paragraphp-of-translate-expression.translated</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> paragraphp-of-translate-expression.translated
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?translated ?smt-precond
                  ?symbols ?symbol-index ?symbol-map)
              (translate-expression args)))
            (<a href="SMT____PARAGRAPHP.html">paragraphp</a> translated))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>pseudo-termp-of-translate-expression.smt-precond</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-termp-of-translate-expression.smt-precond
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?translated ?smt-precond
                  ?symbols ?symbol-index ?symbol-map)
              (translate-expression args)))
            (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> smt-precond))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>string-listp-of-translate-expression.symbols</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> string-listp-of-translate-expression.symbols
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?translated ?smt-precond
                  ?symbols ?symbol-index ?symbol-map)
              (translate-expression args)))
            (<a href="ACL2____STRING-LISTP.html">string-listp</a> symbols))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>natp-of-translate-expression.symbol-index</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> natp-of-translate-expression.symbol-index
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?translated ?smt-precond
                  ?symbols ?symbol-index ?symbol-map)
              (translate-expression args)))
            (<a href="ACL2____NATP.html">natp</a> symbol-index))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>symbol-string-alistp-of-translate-expression.symbol-map</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-string-alistp-of-translate-expression.symbol-map
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?translated ?smt-precond
                  ?symbols ?symbol-index ?symbol-map)
              (translate-expression args)))
            (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> symbol-map))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>pseudo-term-listp-of-cdr-of-te-args-&gt;expr-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-listp-of-cdr-of-te-args-&gt;expr-lst
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____TE-ARGS-P.html">te-args-p</a> x)
                      (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> x)))
                 (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> x)))))</pre> 
<p><b>Theorem: </b>consp-of-car-of-te-args-&gt;expr-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     consp-of-car-of-te-args-&gt;expr-lst
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____TE-ARGS-P.html">te-args-p</a> args)
                   (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))
                   (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args)))))
              (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args)))))</pre> 
<p><b>Theorem: </b>not-cdr-of-car-of-quote-ex-args-&gt;expr-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   not-cdr-of-car-of-quote-ex-args-&gt;expr-lst
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____TE-ARGS-P.html">te-args-p</a> args)
                 (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))
                 (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args)))
                        'quote)
                 (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))))))
            (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))))))</pre> 
<p><b>Theorem: </b>symbolp-of-caaar-of-te-args-&gt;expr-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    symbolp-of-caaar-of-te-args-&gt;expr-lst
    (<a href="ACL2____IMPLIES.html">implies</a>
         (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____TE-ARGS-P.html">te-args-p</a> args)
              (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))
              (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))))
              (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args)))
                          'quote))
              (<a href="ACL2____PSEUDO-LAMBDAP.html">pseudo-lambdap</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args)))))
         (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args)))))))</pre> 
<p><b>Theorem: </b>symbolp-of-caar-te-args-&gt;expr-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 symbolp-of-caar-te-args-&gt;expr-lst
 (<a href="ACL2____IMPLIES.html">implies</a>
   (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____TE-ARGS-P.html">te-args-p</a> args)
        (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))
        (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))))
        (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____PSEUDO-LAMBDAP.html">pseudo-lambdap</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))))))
   (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))))))</pre> 
<p><b>Theorem: </b>symbol-listp-of-cadaar-of-te-args-&gt;expr-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   symbol-listp-of-cadaar-of-te-args-&gt;expr-lst
   (<a href="ACL2____IMPLIES.html">implies</a>
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____TE-ARGS-P.html">te-args-p</a> args)
             (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))
             (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))))
             (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args)))
                         'quote))
             (<a href="ACL2____PSEUDO-LAMBDAP.html">pseudo-lambdap</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args)))))
        (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> (<a href="COMMON-LISP____CADR.html">cadr</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args)))))))</pre> 
<p><b>Theorem: </b>pseudo-termp-of-caddaar-of-te-args-&gt;expr-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  pseudo-termp-of-caddaar-of-te-args-&gt;expr-lst
  (<a href="ACL2____IMPLIES.html">implies</a>
       (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____TE-ARGS-P.html">te-args-p</a> args)
            (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))
            (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))))
            (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args)))
                        'quote))
            (<a href="ACL2____PSEUDO-LAMBDAP.html">pseudo-lambdap</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args)))))
       (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> (<a href="COMMON-LISP____CADDR.html">caddr</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args)))))))</pre> 
<p><b>Theorem: </b>pseudo-term-listp-of-cdar-te-args-&gt;expr-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    pseudo-term-listp-of-cdar-te-args-&gt;expr-lst
    (<a href="ACL2____IMPLIES.html">implies</a>
         (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____TE-ARGS-P.html">te-args-p</a> args)
              (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))
              (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))))
              (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args)))
                          'quote))
              (<a href="ACL2____PSEUDO-LAMBDAP.html">pseudo-lambdap</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args)))))
         (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))))))</pre> 
<p><b>Theorem: </b>pseudo-term-listp-of-cdar-of-te-args-&gt;expr-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 pseudo-term-listp-of-cdar-of-te-args-&gt;expr-lst
 (<a href="ACL2____IMPLIES.html">implies</a>
   (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____TE-ARGS-P.html">te-args-p</a> args)
        (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))
        (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))))
        (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args)))
                    'quote))
        (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____PSEUDO-LAMBDAP.html">pseudo-lambdap</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))))))
   (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))))))</pre> 
<p><b>Theorem: </b>crock-pseudo-term-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    crock-pseudo-term-listp
    (<a href="ACL2____IMPLIES.html">implies</a>
         (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))))
         (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> (<a href="COMMON-LISP____CDDR.html">cddr</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))))))</pre> 
<p><b>Theorem: </b>pseudo-term-listp-of-cddar-of-te-args-&gt;expr-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 pseudo-term-listp-of-cddar-of-te-args-&gt;expr-lst
 (<a href="ACL2____IMPLIES.html">implies</a>
   (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____TE-ARGS-P.html">te-args-p</a> args)
        (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))
        (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))))
        (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args)))
                    'quote))
        (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____PSEUDO-LAMBDAP.html">pseudo-lambdap</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))))))
   (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> (<a href="COMMON-LISP____CDDR.html">cddr</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))))))</pre> 
<p><b>Theorem: </b>not-cdaar-te-args-&gt;expr-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 not-cdaar-te-args-&gt;expr-lst
 (<a href="ACL2____IMPLIES.html">implies</a>
      (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____TE-ARGS-P.html">te-args-p</a> args)
           (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))
           (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))))
           (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args)))
                       'quote))
           (<a href="ACL2____PSEUDO-LAMBDAP.html">pseudo-lambdap</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))))
           (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args)))))))
      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args)))))))</pre> 
<p><b>Theorem: </b>not-cddaar-of-te-args-&gt;expr-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 not-cddaar-of-te-args-&gt;expr-lst
 (<a href="ACL2____IMPLIES.html">implies</a>
     (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____TE-ARGS-P.html">te-args-p</a> args)
          (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))
          (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))))
          (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args)))
                      'quote))
          (<a href="ACL2____PSEUDO-LAMBDAP.html">pseudo-lambdap</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))))
          (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CDDR.html">cddr</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args)))))))
     (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CDDR.html">cddr</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args)))))))</pre> 
<p><b>Theorem: </b>not-caar-of-te-args-&gt;expr-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 not-caar-of-te-args-&gt;expr-lst
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____TE-ARGS-P.html">te-args-p</a> args)
               (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))
               (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))))
               (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args)))
                           'quote))
               (<a href="ACL2____PSEUDO-LAMBDAP.html">pseudo-lambdap</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))))
               (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))))))
          (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____TE-ARGS-_E3EXPR-LST.html">te-args-&gt;expr-lst</a> args))))))</pre> 
<p><b>Theorem: </b>consp-of-pseudo-lambdap</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> consp-of-pseudo-lambdap
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____PSEUDO-LAMBDAP.html">pseudo-lambdap</a> x) (<a href="COMMON-LISP____CONSP.html">consp</a> x)))</pre> 
<p><b>Theorem: </b>symbol-string-alistp-is-true-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-string-alistp-is-true-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYMBOL-STRING-ALISTP.html">symbol-string-alistp</a> alist)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> key alist))))
                 (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> key alist))))</pre> 
<p><b>Function: </b>translate-declaration</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 translate-declaration
 (name type fty-info int-to-rat)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> name)
                             (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> type)
                             (<a href="SMT____FTY-INFO-ALIST-P.html">fty-info-alist-p</a> fty-info)
                             (<a href="ACL2____BOOLEANP.html">booleanp</a> int-to-rat))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'translate-declaration))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____B_A2.html">b*</a>
   ((name (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> name))
    (<a href="COMMON-LISP____TYPE.html">type</a> (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> type))
    (translated-name (translate-symbol name))
    (fty-item (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> type fty-info))
    (<a href="COMMON-LISP____TYPE.html">type</a> (<a href="COMMON-LISP____IF.html">if</a> fty-item (<a href="SMT____FTY-INFO-_E3NAME.html">fty-info-&gt;name</a> (<a href="COMMON-LISP____CDR.html">cdr</a> fty-item))
              type))
    (translated-type (translate-type type int-to-rat 'common-type)))
   (<a href="COMMON-LISP____CONS.html">cons</a>
    translated-name
    (<a href="COMMON-LISP____CONS.html">cons</a>
     '=
     (<a href="COMMON-LISP____CONS.html">cons</a>
      '"z3.Const"
      (<a href="COMMON-LISP____CONS.html">cons</a>
       '#\(
       (<a href="COMMON-LISP____CONS.html">cons</a>
         '#\'
         (<a href="COMMON-LISP____CONS.html">cons</a> translated-name
               (<a href="COMMON-LISP____CONS.html">cons</a> '#\'
                     (<a href="COMMON-LISP____CONS.html">cons</a> '#\,
                           (<a href="COMMON-LISP____CONS.html">cons</a> '#\Space
                                 (<a href="COMMON-LISP____CONS.html">cons</a> translated-type
                                       '(#\) #\Newline))))))))))))))</pre> 
<p><b>Theorem: </b>paragraphp-of-translate-declaration</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   paragraphp-of-translate-declaration
   (<a href="ACL2____B_A2.html">b*</a> ((translated
             (translate-declaration name type fty-info int-to-rat)))
       (<a href="SMT____PARAGRAPHP.html">paragraphp</a> translated))
   :rule-classes :rewrite)</pre> 
<p><b>Function: </b>translate-type-decl-list</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 translate-type-decl-list
 (type-decl-lst fty-info acc int-to-rat)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> type-decl-lst)
                             (<a href="SMT____FTY-INFO-ALIST-P.html">fty-info-alist-p</a> fty-info)
                             (<a href="SMT____PARAGRAPHP.html">paragraphp</a> acc)
                             (<a href="ACL2____BOOLEANP.html">booleanp</a> int-to-rat))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'translate-type-decl-list))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____B_A2.html">b*</a>
    ((type-decl-lst (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> type-decl-lst))
     (acc (paragraph-fix acc))
     ((unless (<a href="COMMON-LISP____CONSP.html">consp</a> type-decl-lst)) acc)
     ((<a href="COMMON-LISP____CONS.html">cons</a> first rest) type-decl-lst)
     ((<a href="SMT____DECL.html">decl</a> d) first)
     ((<a href="SMT____HINT-PAIR.html">hint-pair</a> h) d.type)
     (translated-type-decl
          (translate-declaration d.name h.thm fty-info int-to-rat)))
    (translate-type-decl-list
         rest
         fty-info (<a href="COMMON-LISP____CONS.html">cons</a> translated-type-decl acc)
         int-to-rat))))</pre> 
<p><b>Theorem: </b>paragraphp-of-translate-type-decl-list</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     paragraphp-of-translate-type-decl-list
     (<a href="ACL2____B_A2.html">b*</a> ((translated (translate-type-decl-list
                           type-decl-lst fty-info acc int-to-rat)))
         (<a href="SMT____PARAGRAPHP.html">paragraphp</a> translated))
     :rule-classes :rewrite)</pre> 
<p><b>Function: </b>translate-theorem</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 translate-theorem
 (theorem fn-lst fty-info acc)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> theorem)
                             (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> fn-lst)
                             (<a href="SMT____FTY-INFO-ALIST-P.html">fty-info-alist-p</a> fty-info)
                             (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> acc))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'translate-theorem))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____B_A2.html">b*</a>
   ((theorem (pseudo-term-fix theorem))
    ((<a href="ACL2____MV.html">mv</a> translated-theorem-body
         smt-precond symbols &amp; &amp;)
     (<a href="ACL2____WITH-FAST-ALISTS.html">with-fast-alists</a>
        (fn-lst)
        (translate-expression (<a href="SMT____MAKE-TE-ARGS.html">make-te-args</a> :expr-lst (<a href="COMMON-LISP____LIST.html">list</a> theorem)
                                            :fn-lst fn-lst
                                            :fty-info fty-info
                                            :symbol-index 0
                                            :symbol-list nil
                                            :avoid-list acc))))
    (theorem-assign
         (<a href="COMMON-LISP____CONS.html">cons</a> '"theorem = "
               (<a href="COMMON-LISP____CONS.html">cons</a> translated-theorem-body '(#\Newline))))
    (prove-theorem '("_SMT_.prove(theorem)" #\Newline)))
   (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____CONS.html">cons</a> theorem-assign
             (<a href="COMMON-LISP____CONS.html">cons</a> prove-theorem 'nil))
       smt-precond symbols))))</pre> 
<p><b>Theorem: </b>paragraphp-of-translate-theorem.translated</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> paragraphp-of-translate-theorem.translated
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?translated ?smt-precond ?symbols)
              (translate-theorem theorem fn-lst fty-info acc)))
            (<a href="SMT____PARAGRAPHP.html">paragraphp</a> translated))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>pseudo-termp-of-translate-theorem.smt-precond</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-termp-of-translate-theorem.smt-precond
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?translated ?smt-precond ?symbols)
              (translate-theorem theorem fn-lst fty-info acc)))
            (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> smt-precond))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>string-listp-of-translate-theorem.symbols</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> string-listp-of-translate-theorem.symbols
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?translated ?smt-precond ?symbols)
              (translate-theorem theorem fn-lst fty-info acc)))
            (<a href="ACL2____STRING-LISTP.html">string-listp</a> symbols))
        :rule-classes :rewrite)</pre> 
<p><b>Function: </b>translate-uninterpreted-arguments</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 translate-uninterpreted-arguments
 (<a href="COMMON-LISP____TYPE.html">type</a> args fty-info int-to-rat)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> type)
                             (<a href="SMT____DECL-LISTP.html">decl-listp</a> args)
                             (<a href="SMT____FTY-INFO-ALIST-P.html">fty-info-alist-p</a> fty-info)
                             (<a href="ACL2____BOOLEANP.html">booleanp</a> int-to-rat))))
 (<a href="COMMON-LISP____LET.html">let</a>
    ((acl2::__function__ 'translate-uninterpreted-arguments))
    (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
    (<a href="ACL2____B_A2.html">b*</a> ((<a href="COMMON-LISP____TYPE.html">type</a> (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> type))
         (<a href="ACL2____ARGS.html">args</a> (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> args))
         ((unless (<a href="COMMON-LISP____CONSP.html">consp</a> args)) nil)
         ((<a href="COMMON-LISP____CONS.html">cons</a> first rest) args)
         ((<a href="SMT____DECL.html">decl</a> d) first)
         ((<a href="SMT____HINT-PAIR.html">hint-pair</a> h) d.type)
         (fty-item (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> h.thm fty-info))
         (type-name (<a href="COMMON-LISP____IF.html">if</a> fty-item (<a href="SMT____FTY-INFO-_E3NAME.html">fty-info-&gt;name</a> (<a href="COMMON-LISP____CDR.html">cdr</a> fty-item))
                        h.thm))
         (translated-type
              (translate-type type-name int-to-rat 'uninterpreted)))
        (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> '#\,
                    (<a href="COMMON-LISP____CONS.html">cons</a> '#\Space
                          (<a href="COMMON-LISP____CONS.html">cons</a> translated-type 'nil)))
              (translate-uninterpreted-arguments
                   type rest fty-info int-to-rat)))))</pre> 
<p><b>Theorem: </b>paragraphp-of-translate-uninterpreted-arguments</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> paragraphp-of-translate-uninterpreted-arguments
        (<a href="ACL2____B_A2.html">b*</a> ((translated (translate-uninterpreted-arguments
                              type args fty-info int-to-rat)))
            (<a href="SMT____PARAGRAPHP.html">paragraphp</a> translated))
        :rule-classes :rewrite)</pre> 
<p><b>Function: </b>translate-uninterpreted-decl</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 translate-uninterpreted-decl
 (fn fty-info int-to-rat)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-P.html">func-p</a> fn)
                             (<a href="SMT____FTY-INFO-ALIST-P.html">fty-info-alist-p</a> fty-info)
                             (<a href="ACL2____BOOLEANP.html">booleanp</a> int-to-rat))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'translate-uninterpreted-decl))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____B_A2.html">b*</a>
   ((fn (<a href="SMT____FUNC-FIX.html">func-fix</a> fn))
    ((<a href="SMT____FUNC.html">func</a> f) fn)
    (name f.name)
    (translated-formals (translate-uninterpreted-arguments
                             'formals
                             f.formals fty-info int-to-rat))
    ((<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____E3.html">&gt;</a> (<a href="ACL2____LEN.html">len</a> f.returns) 1))
     (<a href="ACL2____ER.html">er</a> hard?
         'smt-translator=&gt;translate-uninterpreted-decl
         "Currently, ~
            mv returns are not supported."))
    (translated-returns (translate-uninterpreted-arguments
                             'returns
                             f.returns fty-info int-to-rat)))
   (<a href="COMMON-LISP____CONS.html">cons</a>
      (translate-symbol name)
      (<a href="COMMON-LISP____CONS.html">cons</a> '"= z3.Function("
            (<a href="COMMON-LISP____CONS.html">cons</a> '#\'
                  (<a href="COMMON-LISP____CONS.html">cons</a> name
                        (<a href="COMMON-LISP____CONS.html">cons</a> '#\'
                              (<a href="COMMON-LISP____CONS.html">cons</a> translated-formals
                                    (<a href="COMMON-LISP____CONS.html">cons</a> translated-returns
                                          '(")" #\Newline)))))))))))</pre> 
<p><b>Theorem: </b>paragraphp-of-translate-uninterpreted-decl</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   paragraphp-of-translate-uninterpreted-decl
   (<a href="ACL2____B_A2.html">b*</a> ((translated
             (translate-uninterpreted-decl fn fty-info int-to-rat)))
       (<a href="SMT____PARAGRAPHP.html">paragraphp</a> translated))
   :rule-classes :rewrite)</pre> 
<p><b>Function: </b>translate-uninterpreted-decl-lst</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 translate-uninterpreted-decl-lst
 (fn-lst fty-info acc int-to-rat)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> fn-lst)
                             (<a href="SMT____FTY-INFO-ALIST-P.html">fty-info-alist-p</a> fty-info)
                             (<a href="SMT____PARAGRAPHP.html">paragraphp</a> acc)
                             (<a href="ACL2____BOOLEANP.html">booleanp</a> int-to-rat))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'translate-uninterpreted-decl-lst))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____B_A2.html">b*</a>
   ((fn-lst (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> fn-lst))
    (acc (paragraph-fix acc))
    ((unless (<a href="COMMON-LISP____CONSP.html">consp</a> fn-lst)) acc)
    ((<a href="COMMON-LISP____CONS.html">cons</a> first rest) fn-lst)
    (first-decl (translate-uninterpreted-decl (<a href="COMMON-LISP____CDR.html">cdr</a> first)
                                              fty-info int-to-rat)))
   (translate-uninterpreted-decl-lst
        rest fty-info (<a href="COMMON-LISP____CONS.html">cons</a> first-decl acc)
        int-to-rat))))</pre> 
<p><b>Theorem: </b>paragraphp-of-translate-uninterpreted-decl-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> paragraphp-of-translate-uninterpreted-decl-lst
        (<a href="ACL2____B_A2.html">b*</a> ((translated (translate-uninterpreted-decl-lst
                              fn-lst fty-info acc int-to-rat)))
            (<a href="SMT____PARAGRAPHP.html">paragraphp</a> translated))
        :rule-classes :rewrite)</pre> 
<p><b>Function: </b>translate-symbol-declare</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> translate-symbol-declare (symbols)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____STRING-LISTP.html">string-listp</a> symbols)))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'translate-symbol-declare))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____B_A2.html">b*</a> ((symbols (str::string-list-fix symbols))
                 ((unless (<a href="COMMON-LISP____CONSP.html">consp</a> symbols)) nil)
                 ((<a href="COMMON-LISP____CONS.html">cons</a> first rest) symbols))
                (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> first
                            (<a href="COMMON-LISP____CONS.html">cons</a> '" = Symbol_z3.intern('"
                                  (<a href="COMMON-LISP____CONS.html">cons</a> first '("')" #\Newline))))
                      (translate-symbol-declare rest)))))</pre> 
<p><b>Theorem: </b>paragraphp-of-translate-symbol-declare</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> paragraphp-of-translate-symbol-declare
        (<a href="ACL2____B_A2.html">b*</a> ((translated (translate-symbol-declare symbols)))
            (<a href="SMT____PARAGRAPHP.html">paragraphp</a> translated))
        :rule-classes :rewrite)</pre> 
<p><b>Function: </b>translate-symbol-enumeration</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 translate-symbol-enumeration (symbols)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____STRING-LISTP.html">string-listp</a> symbols)))
 (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'translate-symbol-enumeration))
      (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
      (<a href="ACL2____B_A2.html">b*</a> ((datatype-line '("Symbol_z3 = _SMT_.Symbol()" #\Newline))
           (declarations (translate-symbol-declare symbols)))
          (<a href="COMMON-LISP____CONS.html">cons</a> datatype-line declarations))))</pre> 
<p><b>Theorem: </b>paragraphp-of-translate-symbol-enumeration</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> paragraphp-of-translate-symbol-enumeration
        (<a href="ACL2____B_A2.html">b*</a> ((translated (translate-symbol-enumeration symbols)))
            (<a href="SMT____PARAGRAPHP.html">paragraphp</a> translated))
        :rule-classes :rewrite)</pre> 
<p><b>Function: </b>smt-translation</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 smt-translation
 (term smtlink-hint state)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (<a href="ACL2____STATE.html">state</a>)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> term)
                             (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> smtlink-hint))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'smt-translation))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____B_A2.html">b*</a>
   ((term (pseudo-term-fix term))
    (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> smtlink-hint))
    ((<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> h) smtlink-hint)
    (fn-alst (<a href="SMT____MAKE-ALIST-FN-LST.html">make-alist-fn-lst</a> h.functions))
    ((<a href="ACL2____MV.html">mv</a> decl-list theorem)
     (<a href="SMT____SMT-EXTRACT.html">smt-extract</a> term h.fty-info h.abs))
    ((<a href="ACL2____MV.html">mv</a> fn-decl-list type-decl-list)
     (recover-type-hyp decl-list
                       fn-alst h.fty-info h.abs nil state))
    ((unless (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> fn-decl-list)
                  (<a href="SMT____DECL-LISTP.html">decl-listp</a> type-decl-list)))
     (<a href="ACL2____MV.html">mv</a>
      (<a href="ACL2____ER.html">er</a>
       hard? 'translator=&gt;smt-translation
       "returned values from ~
    recover-type-hyp is not of the right type!~%")
      nil))
    (acc (all-vars1 term nil))
    ((unless (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> acc))
     (<a href="ACL2____MV.html">mv</a>
      (<a href="ACL2____ER.html">er</a>
       hard? 'translator=&gt;smt-translation
       "returned values from ~
    acl2::all-vars1 is not of type symbol-listp!~%")
      nil))
    ((<a href="ACL2____MV.html">mv</a> translated-theorem smt-precond symbols)
     (translate-theorem theorem fn-decl-list h.fty-info acc))
    (pretty-translated-theorem
         (pretty-print-theorem translated-theorem 160))
    (symbols (<a href="ACL2____REMOVE-DUPLICATES-EQUAL.html">remove-duplicates-equal</a> symbols))
    (translated-uninterpreted-decls
         (<a href="ACL2____WITH-FAST-ALIST.html">with-fast-alist</a> fn-decl-list
                          (translate-uninterpreted-decl-lst
                               fn-decl-list
                               h.fty-info pretty-translated-theorem
                               h.int-to-rat)))
    (translated-theorem-with-type-decls
         (translate-type-decl-list type-decl-list h.fty-info
                                   translated-uninterpreted-decls
                                   h.int-to-rat))
    (translated-abs-types (translate-abstract-types h.abs))
    (translated-fty-types
         (translate-fty-types h.fty-types h.int-to-rat))
    (translated-theorem-with-fty-type-decls
         (<a href="COMMON-LISP____APPEND.html">append</a> translated-abs-types
                 (<a href="COMMON-LISP____APPEND.html">append</a> translated-fty-types
                         translated-theorem-with-type-decls)))
    (translated-symbol (translate-symbol-enumeration symbols)))
   (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____CONS.html">cons</a> translated-symbol
             translated-theorem-with-fty-type-decls)
       smt-precond))))</pre> 

</body>
</html>
