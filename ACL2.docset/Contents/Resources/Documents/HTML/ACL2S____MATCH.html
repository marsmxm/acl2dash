<html>
<head>
<meta charset="UTF-8">
<title>Match</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2S____MATCH">Click for Match in the Full Manual</a></h3>

<p>Pattern matching supporting recognizers, e.g., those 
  automatically generated by <a href="ACL2____DEFDATA.html">defdata</a>, and <a href="ACL2____CASE-MATCH.html">case-match</a>, with support for specifying type recognizers  
  similar to that provided by <a href="ACL2S____DEFINEC.html">definec</a>.</p> 
<h3>Examples</h3> 
 
<pre class="code">(<a href="ACL2S____DEFINEC.html">definec</a> fact (n :nat) :pos
  (<a href="ACL2S____MATCH.html">match</a> n
    (0 1)
    (&amp; (<a href="COMMON-LISP_____A2.html">*</a> n (fact (<a href="COMMON-LISP____1-.html">1-</a> n))))))

(<a href="ACL2S____DEFINEC.html">definec</a> acl2-count2 (x :all) :nat
  (<a href="ACL2S____MATCH.html">match</a> x
    ((a . b) (<a href="COMMON-LISP_____B2.html">+</a> 1 (acl2-count2 a) (acl2-count2 b)))
    (:rational
     (:integer (integer-abs x))
     (&amp; (<a href="COMMON-LISP_____B2.html">+</a> (integer-abs (<a href="COMMON-LISP____NUMERATOR.html">numerator</a> x))
           (<a href="COMMON-LISP____DENOMINATOR.html">denominator</a> x))))
    ((:r complex/complex-rationalp)
     (<a href="COMMON-LISP_____B2.html">+</a> 1 (acl2-count2 (<a href="COMMON-LISP____REALPART.html">realpart</a> x))
        (acl2-count2 (<a href="COMMON-LISP____IMAGPART.html">imagpart</a> x))))
    (:string (<a href="COMMON-LISP____LENGTH.html">length</a> x))
    (&amp; 0)))

;; Compare with the definition of acl2-count

(<a href="COMMON-LISP____DEFUN.html">defun</a> acl2-count (x)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t :mode :program))
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x)
      (<a href="COMMON-LISP_____B2.html">+</a> 1 (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> (<a href="COMMON-LISP____CAR.html">car</a> x))
         (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x)))
    (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x)
        (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x)
            (integer-abs x)
          (<a href="COMMON-LISP_____B2.html">+</a> (integer-abs (<a href="COMMON-LISP____NUMERATOR.html">numerator</a> x))
             (<a href="COMMON-LISP____DENOMINATOR.html">denominator</a> x)))
      (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____COMPLEX_F2COMPLEX-RATIONALP.html">complex/complex-rationalp</a> x)
          (<a href="COMMON-LISP_____B2.html">+</a> 1 (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> (<a href="COMMON-LISP____REALPART.html">realpart</a> x))
             (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> (<a href="COMMON-LISP____IMAGPART.html">imagpart</a> x)))
        (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____STRINGP.html">stringp</a> x)
            (<a href="COMMON-LISP____LENGTH.html">length</a> x)
          0)))))

;; Note that the two definitions are equivalent, 
;; as the following is a theorem. 

(<a href="ACL2____THM.html">thm</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (acl2-count2 x) (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> x)))</pre> 
 
<h3>Purpose</h3> 
 
<p> The macro <a href="ACL2S____MATCH.html">match</a> provides pattern matching.  It includes the 
functionality provided by <a href="ACL2____CASE-MATCH.html">case-match</a> and also supports 
recognizers in a style similar to how <a href="ACL2S____DEFINEC.html">definec</a> allows you to 
specify <a href="ACL2____DEFDATA.html">defdata</a> types. 
</p> 
 
<p> There are two ways to specify recognizers. One is to use a 
keyword, such as :rational, in the above examples. Such keywords are 
turned into recognizers by creating a regular symbol with a "p" at 
the end, e.g, :rational gets turned into rationalp (but :atom gets 
turned into atom). The generated symbols are in the ACL2s package. The 
more general mechanism is to specicy a recognizer using the (:r 
recognizer) form; an example is (:r complex/complex-rationalp) in the 
acl2-count2 definition above. In this way, you can also specify the 
package of the recognizer.  </p> 
 
<p>If you want to match a keyword, you can do that by quoting it. 
So <span class="tt">':rational</span> matches the keyword, not the type.</p> 
 
<p> If you are matching a recognizer, you can either have a single 
form after that, in which case, that form is an ACL2 expression that 
gets associated with the recognizer, or you can have a list of forms, 
in which case they are treated as nested matching forms.  An example 
of such nesting is shown in the :rational case of the match in the 
definition of acl2-count2, above.  </p> 
 
<p> 
If you are not matching a recognizer, then match behaves like  
<a href="ACL2____CASE-MATCH.html">case-match</a>. 
</p> 
 
<p>  
One important difference with <a href="ACL2____CASE-MATCH.html">case-match</a> is that match 
requires that the cases are complete. It does this by returning  
the following if there are no matches. 
</p> 
 
<pre class="code">(<a href="ACL2____ILLEGAL.html">illegal</a> 'match "match is not exhaustive" ())</pre> 
 

</body>
</html>
