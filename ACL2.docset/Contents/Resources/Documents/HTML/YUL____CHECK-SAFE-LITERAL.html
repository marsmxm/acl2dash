<html>
<head>
<meta charset="UTF-8">
<title>Check-safe-literal</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=YUL____CHECK-SAFE-LITERAL">Click for Check-safe-literal in the Full Manual</a></h3>

<p>Check if a literal is safe.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(check-safe-literal lit) → _</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">lit</span> — <font color="#606060">Guard <span class="v">(<a href="YUL____LITERALP.html">literalp</a> lit)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">_</span> — <font color="#606060">Type <span class="v">(<a href="FTY____RESULTERR-OPTIONP.html">resulterr-optionp</a> _)</span>.</font>
</dd> 
 
</dl></div> 
<p>According to [Yul: Specification of Yul: Restrictions on the Grammar], 
     literals cannot be larger than their types, 
     and the largest type is that of 256-bit words. 
     For now we do not model types (i.e. we assume one type), 
     so we limit the size to 256 bits. 
     To check this constraint, 
     we just evaluate the literal 
     and ensure that the evaluation does not return an error: 
     this captures exactly the static constraints on literals.</p><p>We do not impose other restrictions on plain strings here, 
     such as that a string surrounded by double quotes 
     cannot contain (unescaped) double quotes. 
     Those are simply syntactic restrictions.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>check-safe-literal</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> check-safe-literal (lit)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="YUL____LITERALP.html">literalp</a> lit)))
       (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'check-safe-literal))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
            (<a href="ACL2____B_A2.html">b*</a> (((ok &amp;) (<a href="YUL____EVAL-LITERAL.html">eval-literal</a> lit))) nil)))</pre> 
<p><b>Theorem: </b>resulterr-optionp-of-check-safe-literal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> resulterr-optionp-of-check-safe-literal
        (<a href="ACL2____B_A2.html">b*</a> ((_ (<a href="YUL____CHECK-SAFE-LITERAL.html">check-safe-literal</a> lit)))
            (<a href="FTY____RESULTERR-OPTIONP.html">resulterr-optionp</a> _))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>check-safe-literal-of-literal-fix-lit</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> check-safe-literal-of-literal-fix-lit
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="YUL____CHECK-SAFE-LITERAL.html">check-safe-literal</a> (<a href="YUL____LITERAL-FIX.html">literal-fix</a> lit))
               (<a href="YUL____CHECK-SAFE-LITERAL.html">check-safe-literal</a> lit)))</pre> 
<p><b>Theorem: </b>check-safe-literal-literal-equiv-congruence-on-lit</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> check-safe-literal-literal-equiv-congruence-on-lit
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="YUL____LITERAL-EQUIV.html">literal-equiv</a> lit lit-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="YUL____CHECK-SAFE-LITERAL.html">check-safe-literal</a> lit)
                        (<a href="YUL____CHECK-SAFE-LITERAL.html">check-safe-literal</a> lit-equiv)))
        :rule-classes :congruence)</pre> 

</body>
</html>
