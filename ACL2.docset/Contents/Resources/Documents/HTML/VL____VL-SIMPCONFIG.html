<html>
<head>
<meta charset="UTF-8">
<title>Vl-simpconfig</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=VL____VL-SIMPCONFIG">Click for Vl-simpconfig in the Full Manual</a></h3>

<p>Options for how to simplify Verilog modules.</p><p>This is a product type introduced by <a href="FTY____DEFPROD.html">defprod</a>.</p> 
<h5>Fields</h5> 
<dl>
<dt>compress-p — <a href="ACL2____BOOLEANP.html">booleanp</a>
</dt> 
<dd>Hons the modules at various points.  This takes some time, but can produce 
     smaller translation files.</dd> 
 
<dt>problem-mods — <a href="ACL2____STRING-LISTP.html">string-listp</a>
</dt> 
<dd>Names of modules that should thrown out, perhaps because they cause some kind 
     of problems.</dd> 
 
<dt>already-annotated — <a href="ACL2____BOOLEANP.html">booleanp</a>
</dt> 
<dd>Denotes that we've already annotated the design and shouldn't do it 
     again.</dd> 
 
<dt>unroll-limit — <a href="ACL2____NATP.html">natp</a>
</dt> 
<dd>Maximum number of iterations to unroll for loops, etc., when rewriting statements. 
      This is just a safety valve.</dd> 
 
<dt>sc-limit — <a href="ACL2____NATP.html">natp</a>
</dt> 
<dd>Recursion limit for compiling statements, e.g., unrolling loops and 
     figuring out when they terminate.  You might hit this if loops have 
     non-trivial finishing conditions.  Small limits may be preferable for 
     applications like linting where you don't want a single troublesome loop 
     to waste inordinate amounts of time.  Larger limits may be needed if 
     you're trying to model a design that has long-running loops.</dd> 
 
<dt>elab-limit — <a href="ACL2____NATP.html">natp</a>
</dt> 
<dd>Recursion limit for elaboration.  This usually shouldn't matter or need tinkering. 
     It's a safety valve against possible loops in elaboration, e.g., to 
     resolve parameter P you need to evaluate parameter Q, which might require 
     you to resolve R, which might depend hierarchically on P, and so on. So if 
     you hit this there's probably something wrong with your design.</dd> 
 
<dt>uniquecase-conservative — <a href="ACL2____NATP.html">natp</a>
</dt> 
<dd>For <span class="v">unique case</span> and <span class="v">unique0 case</span> statements, a synthesis tool is 
     allowed to assume that the cases are mutually exclusive and simplify the logic 
     accordingly. For <span class="v">unique</span> they can assume that exactly one of the tests 
     will be true.  This configuration flag is a natural number that sets the degree 
     of conservativity, as follows: When 0 (the default), the logic we generate 
     emulates a simulator, which always executes the first matching case.  When 
     1, if uniqueness is violated, then we pretend that all tests that were 1 instead 
     evaluated to X, or if all tests were 0 then we pretend all instead evaluated 
     to X.  When 2 or greater, when the condition is violated we pretend all tests 
     evaluated to X.  When 3 or greater, we additionally pretend that all assignments 
     within the case statement write X instead of the given value.  The intention 
     behind this is to make it likely that our logic is conservative with respect 
     to anything a synthesis tool might produce.</dd> 
 
<dt>uniquecase-constraints — <a href="ACL2____BOOLEANP.html">booleanp</a>
</dt> 
<dd>Generate constraints for <span class="v">unique case</span> and <span class="v">unique0 case</span> statements. 
      Likely you do not want both this and <span class="v">uniquecase-conservative</span> to be set, 
     because they are two different approaches for dealing with a synthesis tool's 
     flexibility in dealing with unique and unique0 case statements.  When this 
     is set, we separately store a constraint saying that the cases are one-hot 
     or one/zero-hot, respectively.  This constraint is stored in the SV modules 
     when they are generated by <a href="VL____VL-DESIGN-_E3SV-DESIGN.html">vl-design-&gt;sv-design</a>.</dd> 
 
<dt>enum-constraints</dt> 
<dd>Generate constraints for variables of <span class="v">enum</span> datatypes, or compound datatypes 
     that have <span class="v">enum</span> subfields. These constraints are saved in the SV modules 
     when they are generated by <a href="VL____VL-DESIGN-_E3SV-DESIGN.html">vl-design-&gt;sv-design</a>.  Each constraint 
     says that an enum field's value is one of the proper values of an enum type. 
      If NIL (the default), these constraints are not generated. If T or any nonnil 
     object other than the keyword :ALL, then the constraints are generated except 
     for port variables. If :ALL, then these are generated for ports as well.</dd> 
 
<dt>enum-fixups</dt> 
<dd>Generate fixups for variables of <span class="v">enum</span> datatypes, or compound datatypes 
     that have <span class="v">enum</span> subfields. These cause svex compilation to fix up enum 
     values to be X if not one of the allowed values. If NIL (the default), this 
     fixing will not be done.  Similar to the <span class="v">enum-constraints</span> option, fixups 
     are only done for non-port variables unless this option is set to the keyword 
     :ALL.</dd> 
 
<dt>sv-simplify — <a href="ACL2____BOOLEANP.html">booleanp</a>
</dt> 
<dd>Apply svex rewriting to the results of compiling procedural blocks.</dd> 
 
<dt>sv-simplify-verbosep — <a href="ACL2____BOOLEANP.html">booleanp</a>
</dt> 
<dd>Verbosely report svex rewriting statistics.</dd> 
 
<dt>sv-include-atts — <a href="ACL2____STRING-LISTP.html">string-listp</a>
</dt> 
<dd>Translate SystemVerilog attributes on variable declarations into sv modules.</dd> 
 
<dt>nb-latch-delay-hack — <a href="ACL2____BOOLEANP.html">booleanp</a>
</dt> 
<dd>Artificially add a delay to nonblocking assignments in latch-like contexts.</dd> 
 
<dt>name-without-default-params — <a href="ACL2____BOOLEANP.html">booleanp</a>
</dt> 
<dd>Omit non-overridden parameters from module names generated by unparameterization.</dd> 
 
<dt>unparam-bad-instance-fatalp — <a href="ACL2____BOOLEANP.html">booleanp</a>
</dt> 
<dd>Make a fatal warning when a nonexistent parameter is overridden by a module instance.</dd> 
 
<dt>defer-argresolve — <a href="ACL2____BOOLEANP.html">booleanp</a>
</dt> 
<dd>Don't run the argresolve transform before elaborate; instead, do it once 
      the parameters for the given module are resolved.  This may avoid errors 
      when a module conditionally instantiates another module that hasn't been 
      found, but the condition under which it instantiates that module is never 
      satisfied.</dd> 
 
<dt>suppress-fatal-warning-types — <a href="ACL2____SYMBOL-LIST.html">ACL2::symbol-list</a>
</dt> 
<dd>Treat the listed warnings as non-fatal during vl-design-propagate-errors. 
     Such warnings will still show up as fatal, but the modules in which they exist 
     will not be labeled "bad".</dd> 
 
</dl>
</body>
</html>
