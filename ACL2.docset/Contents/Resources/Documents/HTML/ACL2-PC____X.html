<html>
<head>
<meta charset="UTF-8">
<title>ACL2-pc::x</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2-PC____X">Click for ACL2-pc::x in the Full Manual</a></h3>

<p>(atomic macro) 
expand and (maybe) simplify function call at the current subterm</p><pre class="code">Examples:
x --  expand and simplify.</pre> 
 
 <p>Also see <a href="ACL2-PC____EXPAND.html">ACL2-pc::expand</a> and see <a href="ACL2-PC____X-DUMB.html">ACL2-pc::x-dumb</a>, which do 
 not perform simplification.</p> 
 
 <p>For example, if the current subterm is (append a b), then after <span class="v">x</span> the 
 current subterm will probably be (cons (car a) (append (cdr a) b)) if (consp 
 a) is among the top-level hypotheses and governors.  If there are no top-level 
 hypotheses and governors, then after <span class="v">x</span> the current subterm will probably 
 be:</p> 
 
 <pre class="code">(<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> a)
    (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> a) (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="COMMON-LISP____CDR.html">cdr</a> a) b))
    b).</pre> 
 
 <pre class="code">General Form:
(X &amp;key
   rewrite normalize backchain-limit in-theory hands-off expand)</pre> 
 
 <p>Expand the function call at the current subterm, and simplify using the 
 same conventions as with the <span class="v">s</span> command (see <a href="ACL2-PC____S.html">ACL2-pc::s</a>).</p> 
 
 <p>Unlike <span class="v">s</span>, it is permitted to set both <span class="v">:rewrite</span> and 
 <span class="v">:normalize</span> to <span class="v">nil</span>, which will result in no simplification; see 
 <a href="ACL2-PC____X-DUMB.html">ACL2-pc::x-dumb</a>.</p> 
 
 <p><b>Remark</b> (obscure): On rare occasions the current address may be 
 affected by the use of <span class="v">x</span>.  For example, suppose we have the 
 definition</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> g (x) (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x) x 3))</pre> 
 
 <p>and then we enter the interactive proof-builder with</p> 
 
 <pre class="code">(<a href="ACL2____VERIFY.html">verify</a> (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x) (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____G.html">g</a> x) 3) t)) .</pre> 
 
 <p>Then after invoking the instruction <span class="v">(dive 2 1)</span>, so that the current 
 subterm is <span class="v">(<a href="ACL2____G.html">g</a> x)</span>, followed by the instruction <span class="v">x</span>, we would expect the 
 conclusion to be <span class="v">(<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x) (<a href="COMMON-LISP____EQUAL.html">equal</a> 3 3) t)</span>.  However, the system 
 actually replaces <span class="v">(<a href="COMMON-LISP____EQUAL.html">equal</a> 3 3)</span> with <span class="v">t</span> (because we use the ACL2 
 term-forming primitives), and hence the conclusion is actually <span class="v">(<a href="COMMON-LISP____IF.html">if</a>
 (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x) t t)</span>.  Therefore, the current address is put at <span class="v">(2)</span> rather 
 than <span class="v">(2 1)</span>.  In such cases, a warning ``<span class="v">NOTE</span>'' will be printed to 
 the terminal.</p> 
 
 <p>The other primitive commands to which the above ``truncation'' note applies 
 are <span class="v">equiv</span>, <span class="v">rewrite</span>, and <span class="v">s</span>.</p>
</body>
</html>
