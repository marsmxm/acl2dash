<html>
<head>
<meta charset="UTF-8">
<title>Defprod</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=FTY____DEFPROD">Click for Defprod in the Full Manual</a></h3>

<p>Define a new product type, like a <span class="v">struct</span> in C, following the 
<a href="ACL2____FTY-DISCIPLINE.html">fty-discipline</a>.</p><p><span class="v">Defprod</span> is a macro for introducing <span class="v">struct</span>-like types.  It 
can be used to conveniently define a recognizer, constructor, accessors, fixing 
function, and equivalence relation, and other supporting macros and 
documentation for a new struct-like type.  It automatically arranges so that 
these new definitions follow the <a href="ACL2____FTY-DISCIPLINE.html">fty-discipline</a>.</p> 
 
<p><span class="v">Defprod</span> can be used in a standalone fashion to introduce simple (non 
mutually-recursive) product types.  But it is also compatible with <a href="FTY____DEFTYPES.html">deftypes</a>, so it can be used to create products that are mutually-recursive 
with other <span class="v">deftypes</span> compatible type generators.</p> 
 
<p>As with all <a href="FTY____DEFTYPES.html">deftypes</a>-compatible type generators, its field types must 
be types that are ``known'' to FTY.  That is, they must either refer to types 
that have been introduced with <a href="FTY____DEFFIXTYPE.html">deffixtype</a> or that have been produced by 
other FTY type generating macros.  (Fields can also be completely untyped.) 
See also <a href="FTY____BASETYPES.html">basetypes</a> for some base types with fixing functions.</p> 
 
 
<h3>Basic Example</h3> 
 
<pre class="code">(<a href="FTY____DEFPROD.html">defprod</a> sandwich
  ((bread   symbolp :default 'sourdough)
   (coldcut meatp)
   (spread  condimentp)))</pre> 
 
<p>This example would produce:</p> 
 
<ul> 
<li>A recognizer <span class="v">sandwich-p</span>.</li> 
<li>A fixing function <span class="v">sandwich-fix</span>.</li> 
<li>An equivalence relation <span class="v">sandwich-equiv</span>.</li> 
<li>A constructor <span class="v">(sandwich bread coldcut spread)</span>.</li> 
<li>A constructor macro <span class="v">(make-sandwich :bread bread ...)</span>, which simply 
expands to a constructor call but uses the given defaults.</li> 
<li>A changer macro <span class="v">(change-sandwich x :bread bread ...)</span>.</li> 
<li>An accessor for each field, e.g., <span class="v">sandwich-&gt;bread</span>.</li> 
<li>A <a href="ACL2____B_A2.html">b*</a> binder <span class="v">sandwich</span>, like those in <a href="STD____DEFAGGREGATE.html">std::defaggregate</a>.</li> 
</ul> 
 
<p>Much of this—the make/change macros, accessor names, b* 
binders—is nearly identical to <a href="STD____DEFAGGREGATE.html">std::defaggregate</a>.  If you have 
used <span class="v">defaggregate</span>, switching to <span class="v">defprod</span> should be very 
comfortable.</p> 
 
 
<p>General Syntax:</p> 
 
<pre class="code">(<a href="FTY____DEFPROD.html">defprod</a> prodname
   (list-of-fields)
   keyword-options)</pre> 
 
<p>The fields are <a href="STD____EXTENDED-FORMALS.html">std::extended-formals</a>, except that the guard must be 
either simply a predicate or the call of a unary predicate on the field name. 
Acceptable keyword arguments for each field are:</p> 
 
<ul> 
 
<li>
<span class="v">:default</span>: default value of the field in its constructor macro</li> 
 
<li>
<span class="v">:rule-classes</span>: rule-classes for the return type theorem of the 
accessor.</li> 
 
</ul> 
 
 
<h3>Name/Documentation Options</h3> 
 
<dl> 
 
<dt><span class="v">:pred</span></dt> 
<dt><span class="v">:fix</span></dt> 
<dt><span class="v">:equiv</span></dt> 
<dt><span class="v">:count</span></dt> 
 
<dd>These allow you to override the default function names, which 
are (respectively) <span class="v">name-p</span>, <span class="v">name-fix</span>, <span class="v">name-equiv</span>, and 
<span class="v">name-count</span>.</dd> 
 
<dd>As a special case, <span class="v">:count</span> may be nil, meaning no count function is 
produced.  (A count function is only produced when this is mutually-recursive 
with other type generators.)</dd> 
 
 
<dt><span class="v">:parents</span></dt> 
<dt><span class="v">:short</span></dt> 
<dt><span class="v">:long</span></dt> 
 
<dd>These let you customize the <a href="ACL2____XDOC.html">xdoc</a> documentation produced for this 
type.  The documentation generated for products will automatically list the 
fields and link to their types; it's often convenient to put additional notes 
directly in the fields, e.g., 
 
<pre class="code">(<a href="FTY____DEFPROD.html">defprod</a> monster
  :parents (game)
  :short "A monster to fight."
  ((name   stringp "Name of the monster")
   (health natp    "How many hit points does the monster have?")
   ...)
  :long "&lt;p&gt;More details about monsters could go here.&lt;/p&gt;")</pre>
</dd> 
 
</dl> 
 
 
<h3>Performance/Efficiency Options</h3> 
 
<dl> 
 
<dt><span class="v">:tag</span></dt> 
 
<dd>Defaults to <span class="v">nil</span>, meaning that the product is untagged.  Otherwise it 
must be a keyword symbol and this symbol will be consed onto every occurrence 
of the object.</dd> 
 
<dd>Having tags on your objects adds some execution/memory overhead, but 
provides a reasonably nice way to distinguish different kinds of objects from 
one another at runtime.</dd> 
 
 
<dt><span class="v">:layout</span></dt> 
 
<dd>Defaults to <span class="v">:alist</span>, but might instead be set to <span class="v">:tree</span>, 
<span class="v">:fulltree</span> or <span class="v">:list</span>.  This determines how the fields are laid out in 
the object's representation.</dd> 
 
<dd>The <span class="v">:alist</span> format provides the best readability/debuggability but is 
the worst layout for execution/memory efficiency.  This layout represents 
instances of your product type using an alist-like format where the name of 
each field is next to its value.  When printing such an object you can easily 
see the fields and their values, but creating these objects requires additional 
consing to put the field names on, etc.</dd> 
 
<dd>The <span class="v">:tree</span> or <span class="v">:fulltree</span> layouts provides the best efficiency and 
worst readability.  They pack the fields into a compact tree structure, without 
their names.  In <span class="v">:tree</span> mode, any <span class="v">(nil . nil)</span> pairs are compressed 
into just <span class="v">nil</span>.  In <span class="v">:fulltree</span> mode this compression doesn't happen, 
which might marginally save time if you know your fields will never be in pairs 
of <span class="v">nil</span>s.  Tree-based structures require minimal consing, and each accessor 
simply follows some minimal, fixed car/cdr path into the object.  The objects 
print as horrible blobs of conses that can be hard to inspect.</dd> 
 
<dd>The <span class="v">:list</span> layout strikes a middle ground, with the fields of the 
object laid out as a plain list.  Accessing the fields of such a structure may 
require more <span class="v">cdr</span> operations than for a <span class="v">:tree</span> layout, but at least 
when you print them it is still pretty easy to tell what the fields are.</dd> 
 
<dd>Example: a tagless product with 5 fields could be laid out as follows: 
 
<pre class="code">`((,a . ,b) . (,c . (,d . ,e)))                  ;; :tree
`(,a ,b ,c ,d ,e)                                ;; :list
`((a . ,a) (b . ,b) (c . ,c) (d . ,d) (e . ,e))  ;; :alist</pre>
</dd> 
 
 
<dt>:hons</dt> 
 
<dd>NIL by default.  When T, the constructor is defined using <a href="ACL2____HONS.html">hons</a> 
rather than <a href="COMMON-LISP____CONS.html">cons</a>, so your structures will always be structure shared. 
This may improve memory efficiency in certain cases but is probably not a good 
idea for most structures.</dd> 
 
<dt>:inline</dt> 
 
<dd>Default: <span class="v">(:acc :fix)</span>, meaning that the accessors and fixing function, 
which for execution purposes is just the identity, will be defined as an <a href="COMMON-LISP____INLINE.html">inline</a> function.  This argument may also contain <span class="v">:xtor</span>, which causes the 
constructor to be inlined as well, but this is typically less useful as the 
constructor requires some amount of consing.  The option <span class="v">:all</span> (not in a 
list) is also possible.</dd> 
 
</dl> 
 
 
<h3>Other Options</h3> 
 
<dl> 
 
<dt><span class="v">:measure</span></dt> 
 
<dd>A measure is only necessary in the mutually-recursive case, but is probably 
necessary then.  The default measure is <span class="v">(<a href="ACL2____ACL2-COUNT.html">acl2-count</a> x)</span>, but this may not 
work in the mutually-recursive case because of the possibility that <span class="v">x</span> 
could be (say) an atom, in which case the <span class="v">acl2-count</span> of <span class="v">x</span> will be no 
greater than the <span class="v">acl2-count</span> of a field.  Often something like 
<span class="v">(<a href="ACL2____TWO-NATS-MEASURE.html">two-nats-measure</a> (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> x) 5)</span> is a good measure for the product, 
where the other mutually-recursive types have a similar measure with smaller 
second component.</dd> 
 
 
<dt><span class="v">:require</span></dt> 
<dt><span class="v">:reqfix</span></dt> 
 
<dd>This adds a dependent type requirement; see the section on this feature 
below.</dd> 
 
</dl> 
 
 
<h4>Experimental Dependent Type Option</h4> 
 
<p>The top-level keyword <span class="v">:require</span> can add a requirement that the fields 
satisfy some relation.  Using this option requires that one or more fields be 
given a <span class="v">:reqfix</span> option; it must be a theorem that applying the regular 
fixing functions followed by the <span class="v">:reqfix</span> of each field independently 
yields fields that satisfy the requirement.  It should also be the case that 
applying the reqfixes to fields already satisfying the requirement leaves them 
unchanged.  For example:</p> 
 
<pre class="code">(<a href="FTY____DEFPROD.html">defprod</a> sizednum
  ((size natp)
   (bits natp :reqfix (<a href="ACL2____LOGHEAD.html">loghead</a> size bits)))
  :require (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> size bits))</pre> 
 
<p>If there is more than one field with a <span class="v">:reqfix</span> option, these reqfixes 
are applied to each field independently, after applying all of their types' 
fixing functions.  For example, for the following to succeed:</p> 
 
<pre class="code">(<a href="FTY____DEFPROD.html">defprod</a> foo
  ((a atype :reqfix (afix a b c))
   (b btype :reqfix (<a href="ACL2____BFIX.html">bfix</a> a b c))
   (c       :reqfix (cfix a b c)))
  :require (foo-req a b c))</pre> 
 
<p>the following must be a theorem (assuming <span class="v">afix</span> and <span class="v">bfix</span> are the 
fixing functions for <span class="v">atype</span> and <span class="v">btype</span>, respectively):</p> 
 
<pre class="code">(<a href="COMMON-LISP____LET.html">let</a> ((a (afix a))
      (b (<a href="ACL2____BFIX.html">bfix</a> b)))
  (<a href="COMMON-LISP____LET.html">let</a> ((a (afix a b c))
        (b (<a href="ACL2____BFIX.html">bfix</a> a b c))
        (c (cfix a b c)))
    (foo-req a b c)))</pre> 
 
<p>Notice the LET, rather than LET*, binding the fields to their reqfixes.  It 
would NOT be sufficient for this to be true with a LET*.</p>
</body>
</html>
