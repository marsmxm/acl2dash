<html>
<head>
<meta charset="UTF-8">
<title>Primitives</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=VL2014____PRIMITIVES">Click for Primitives in the Full Manual</a></h3>

<p>The primitive modules targetted by VL.</p><p>The modules here can sort of be thought of as the target language 
for VL's simplification scheme.  That is, the sequence of <a href="VL2014____TRANSFORMS.html">transforms</a> 
applied by <a href="VL2014____VL-SIMPLIFY.html">vl-simplify</a> tries to convert rich Verilog modules that 
include expressions, gates, parameters, etc., into simple, hierarchical modules 
that do nothing more than instantiate other modules, with these primitive 
modules at the tips.</p> 
 
<p>This set of primitives modules could be simplified.  For instance we could 
rewrite all of the basic gate modules into <span class="v">nand</span> or some other basic form. 
We haven't done this yet, under the (probably misguided) theory that having a 
richer set of primitives might somehow be more efficient for our symbolic 
simulator.</p> 
 
<p>Note that the list below is somewhat <b>incomplete</b>.  For instance, in 
the final <a href="VL2014____E-CONVERSION.html">e-conversion</a> step, we can generate "resolution" modules for 
resolving multiple drivers.  These resolution modules are essentially 
primitives.  But there isn't a fixed set of resolution primitives, instead we 
generate the primitives we need on the fly; see <a href="VL2014____VL-MAKE-N-BIT-RES-MODULE.html">vl-make-n-bit-res-module</a>, for instance.</p> 
 
<p>Similarly, historically VL had a single <span class="v">VL_1_BIT_FLOP</span> primitive, but 
when we added support for <span class="v">always</span> blocks with multiple edge triggers, we 
did away with this.  Instead, VL can now generate many kinds of primitive 
flops, each with a supporting E module.  See, e.g., <a href="VL2014____VL-MAKE-1-BIT-N-EDGE-FLOP.html">vl-make-1-bit-n-edge-flop</a>.</p>
</body>
</html>
