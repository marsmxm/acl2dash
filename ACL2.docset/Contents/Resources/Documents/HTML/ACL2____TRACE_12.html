<html>
<head>
<meta charset="UTF-8">
<title>Trace!</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____TRACE_12">Click for Trace! in the Full Manual</a></h3>

<p>Trace the indicated functions after creating an active trust tag</p><pre class="code">Example:
(<a href="ACL2____TRACE_12.html">trace!</a> (fact :native t :entry *foo*))

General Form:
(<a href="ACL2____TRACE_12.html">trace!</a> spec1 ... specn)</pre> 
 
 <p>where the <span class="v">speci</span> are suitable arguments to <span class="tt"><a href="ACL2____TRACE_42.html">trace$</a></span>.</p> 
 
 <p>See <a href="ACL2____TRACE_42.html">trace$</a> for a way to trace function calls.  Some calls of 
 <span class="v">trace$</span> are potentially dangerous and thus require a trust tag (see <a href="ACL2____DEFTTAG.html">defttag</a>).  But it can be a nuisance to call <span class="v">defttag</span> explicitly, so the 
 <span class="v">trace!</span> macro is provided in order to avoid the need to do that: 
 <span class="v">trace!</span> automatically defines a (temporary) trust tag.</p> 
 
 <p>See <a href="ACL2____UNTRACE_42.html">untrace$</a> for how to undo the effect of <span class="tt"><a href="ACL2____TRACE_12.html">trace!</a></span>.</p> 
 
 <p>The evaluation of a <span class="v">trace!</span> form causes temporary creation of an active 
 trust tag, <span class="v">:trace!</span>, followed by the corresponding <span class="v">trace$</span> form.  The 
 trust tag will disappear when the call to <span class="v">trace!</span> completes.  Even though 
 <span class="v">trace!</span> will remove its temporary ttag, it will still print a ``<span class="v">TTAG
 NOTE</span>'', which indicates that the session is suspect.  See <a href="ACL2____DEFTTAG.html">defttag</a> and 
 see <a href="ACL2____TTAGS-SEEN.html">ttags-seen</a> for further remarks on this issue.</p> 
 
 <p>Because of the active trust tag, it is possible to do things with 
 <span class="v">trace!</span>  that are useful but without logical justification.  Below is an 
 example of how to use <span class="v">trace!</span> to cause a function call to change <a href="ACL2____STATE.html">state</a>, even though the function does not take <span class="tt"><a href="ACL2____STATE.html">state</a></span> as a 
 parameter.  Note: It may be helpful to see <a href="ACL2____EVALUATION.html">evaluation</a> in order to 
 understand the package prefix <span class="v">"ACL2_*1*_ACL2"</span> displayed below.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="COMMON-LISP____DEFUN.html">defun</a> fact (n)
         (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____NATP.html">natp</a> n) :verify-guards nil))
         (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> n)
             1
           (<a href="COMMON-LISP_____A2.html">*</a> n (fact (<a href="COMMON-LISP____1-.html">1-</a> n)))))

The admission of FACT is trivial, using the relation O&lt; (which is known
to be well-founded on the domain recognized by O-P) and the measure
(<a href="ACL2____ACL2-COUNT.html">ACL2-COUNT</a> N).  We observe that the type of FACT is described by the
theorem (<a href="COMMON-LISP____AND.html">AND</a> (<a href="COMMON-LISP____INTEGERP.html">INTEGERP</a> (FACT N)) (<a href="COMMON-LISP_____C3.html">&lt;</a> 0 (FACT N))).  We used the :compound-
recognizer rule ZP-COMPOUND-RECOGNIZER and primitive type reasoning.

Summary
Form:  ( DEFUN FACT ...)
Rules: ((:COMPOUND-RECOGNIZER ZP-COMPOUND-RECOGNIZER)
        (:FAKE-RUNE-FOR-TYPE-SET NIL))
Warnings:  None
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 FACT
ACL2 !&gt;(<a href="COMMON-LISP____DEFUN.html">defun</a> update-foo (n value state)
         (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs state :verify-guards nil))
         (<a href="ACL2____ASSIGN.html">assign</a> foo (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> n value) (<a href="ACL2_____04.html">@</a> foo))))

Since UPDATE-FOO is non-recursive, its admission is trivial.  We observe
that the type of UPDATE-FOO is described by the theorem
(<a href="COMMON-LISP____AND.html">AND</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> (UPDATE-FOO N VALUE STATE))
     (<a href="ACL2____TRUE-LISTP.html">TRUE-LISTP</a> (UPDATE-FOO N VALUE STATE))).
We used primitive type reasoning.

(UPDATE-FOO * * STATE) =&gt; (<a href="ACL2____MV.html">MV</a> * * STATE).

Summary
Form:  ( DEFUN UPDATE-FOO ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
Warnings:  None
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 UPDATE-FOO
ACL2 !&gt;(<a href="ACL2____TRACE_12.html">trace!</a> (fact :exit (update-foo n value state)))

TTAG NOTE: Adding ttag :TRACE! from the top level loop.
 ((FACT :EXIT (UPDATE-FOO N VALUE STATE)))
ACL2 !&gt;(<a href="ACL2____ASSIGN.html">assign</a> foo nil)
 NIL
ACL2 !&gt;(fact 7)
1&gt; (ACL2_*1*_ACL2::FACT 7)
  2&gt; (ACL2_*1*_ACL2::FACT 6)
    3&gt; (ACL2_*1*_ACL2::FACT 5)
      4&gt; (ACL2_*1*_ACL2::FACT 4)
        5&gt; (ACL2_*1*_ACL2::FACT 3)
          6&gt; (ACL2_*1*_ACL2::FACT 2)
            7&gt; (ACL2_*1*_ACL2::FACT 1)
              8&gt; (ACL2_*1*_ACL2::FACT 0)
              &lt;8 NIL
            &lt;7 NIL
          &lt;6 NIL
        &lt;5 NIL
      &lt;4 NIL
    &lt;3 NIL
  &lt;2 NIL
&lt;1 NIL
5040
ACL2 !&gt;(<a href="ACL2_____04.html">@</a> foo)
((7 . 5040)
 (6 . 720)
 (5 . 120)
 (4 . 24)
 (3 . 6)
 (2 . 2)
 (1 . 1)
 (0 . 1))
ACL2 !&gt;(<a href="ACL2____VERIFY-GUARDS.html">verify-guards</a> fact)

Computing the guard conjecture for FACT....

The guard conjecture for FACT is trivial to prove, given the :compound-
recognizer rules NATP-COMPOUND-RECOGNIZER and ZP-COMPOUND-RECOGNIZER,
primitive type reasoning and the :type-prescription rule FACT.  FACT
is compliant with Common Lisp.

Summary
Form:  ( VERIFY-GUARDS FACT)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER ZP-COMPOUND-RECOGNIZER)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:TYPE-PRESCRIPTION FACT))
Warnings:  None
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 FACT
ACL2 !&gt;(<a href="ACL2____ASSIGN.html">assign</a> foo nil)
 NIL
ACL2 !&gt;(fact 7)
1&gt; (ACL2_*1*_ACL2::FACT 7)
  2&gt; (FACT 7)
    3&gt; (FACT 6)
      4&gt; (FACT 5)
        5&gt; (FACT 4)
          6&gt; (FACT 3)
            7&gt; (FACT 2)
              8&gt; (FACT 1)
                9&gt; (FACT 0)
                &lt;9 NIL
              &lt;8 NIL
            &lt;7 NIL
          &lt;6 NIL
        &lt;5 NIL
      &lt;4 NIL
    &lt;3 NIL
  &lt;2 NIL
&lt;1 NIL
5040
ACL2 !&gt;(<a href="ACL2_____04.html">@</a> foo)
((7 . 5040)
 (7 . 5040)
 (6 . 720)
 (5 . 120)
 (4 . 24)
 (3 . 6)
 (2 . 2)
 (1 . 1)
 (0 . 1))
ACL2 !&gt;(<a href="ACL2____TRACE_12.html">trace!</a> (fact :exit (<a href="COMMON-LISP____PROGN.html">progn</a> (update-foo n value state)
                                  (<a href="COMMON-LISP____CONS.html">cons</a> traced-fn values))))

TTAG NOTE: Adding ttag :TRACE! from the top level loop.
 ((FACT :EXIT (<a href="COMMON-LISP____PROGN.html">PROGN</a> (UPDATE-FOO N VALUE STATE)
                     (<a href="COMMON-LISP____CONS.html">CONS</a> TRACED-FN VALUES))))
ACL2 !&gt;(<a href="ACL2____ASSIGN.html">assign</a> foo nil)
 NIL
ACL2 !&gt;(fact 7)
1&gt; (ACL2_*1*_ACL2::FACT 7)
  2&gt; (FACT 7)
    3&gt; (FACT 6)
      4&gt; (FACT 5)
        5&gt; (FACT 4)
          6&gt; (FACT 3)
            7&gt; (FACT 2)
              8&gt; (FACT 1)
                9&gt; (FACT 0)
                &lt;9 (FACT 1)
              &lt;8 (FACT 1)
            &lt;7 (FACT 2)
          &lt;6 (FACT 6)
        &lt;5 (FACT 24)
      &lt;4 (FACT 120)
    &lt;3 (FACT 720)
  &lt;2 (FACT 5040)
&lt;1 (ACL2_*1*_ACL2::FACT 5040)
5040
ACL2 !&gt;(<a href="ACL2_____04.html">@</a> foo)
((7 . 5040)
 (7 . 5040)
 (6 . 720)
 (5 . 120)
 (4 . 24)
 (3 . 6)
 (2 . 2)
 (1 . 1)
 (0 . 1))
ACL2 !&gt;</pre> 
 
 <p>Finally, we remark that using <span class="v">trace!</span> can cause errors in situations 
 where tracing is automatically suspended and re-introduced.  This is likely to 
 be a rare occurrence, but consider the following example.</p> 
 
 <pre class="code">(<a href="ACL2____TRACE_12.html">trace!</a> (<a href="ACL2____LEXORDER.html">lexorder</a> :native t :multiplicity 1))
(<a href="ACL2____CERTIFY-BOOK.html">certify-book</a> "foo" 0 t)</pre> 
 
 <p>If the certify-book causes compilation, you may see an error such as the 
 following.</p> 
 
 <pre class="code">ACL2 Error in (<a href="ACL2____CERTIFY-BOOK.html">CERTIFY-BOOK</a> "foo" ...):  The keyword :NATIVE cannot
be used in a trace spec unless there is an active trust tag.  The trace
spec (<a href="ACL2____LEXORDER.html">LEXORDER</a> :NATIVE T :MULTIPLICITY 1) is thus illegal.  Consider
using trace! instead.  The complete list of keywords that require a
trust tag for use in a trace spec is: (:NATIVE :DEF :MULTIPLICITY).</pre> 
 
 <p>This error is harmless.  The function will appear, when calling 
 <span class="v">(<a href="ACL2____TRACE_42.html">trace$</a>)</span>, to remain traced, but in fact there will be no tracing 
 behavior, so you may want to call <span class="tt"><a href="ACL2____UNTRACE_42.html">untrace$</a></span> on the function symbol in 
 question.</p>
</body>
</html>
