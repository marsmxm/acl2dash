<html>
<head>
<meta charset="UTF-8">
<title>Pointer</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=C____POINTER">Click for Pointer in the Full Manual</a></h3>

<p>Fixtype of pointers.</p><p>This is a product type introduced by <a href="FTY____DEFPROD.html">fty::defprod</a>.</p> 
<h5>Fields</h5> 
<dl>
<dt>address? — <a href="C____ADDRESS-OPTION.html">address-option</a>
</dt> 
 
<dt>reftype — <a href="C____TYPE.html">type</a>
</dt> 
 
</dl><p>Pointers are mentioned in several places in [C], 
     but there seems to be no specific place in [C] that defines them. 
     Nonetheless, we can get a precise picture from various places. 
     [C:6.2.5/20] says that pointer types describe objects 
     whose values provide references to entities. 
     [C:6.3.2.3] specifies several thingss about pointers; 
     in particular, it talks about null pointers. 
     Thus, the picture is the following: 
     a pointer is either an address or a null pointer. 
     In our defensive dynamic semantics, where values are tagged by their types, 
     we also include in a pointer the type of its referenced value.</p><p>Thus, we define a pointer as consisting of an optional address and a type. 
     The address is absent for a null pointer; 
     note that [C] does not prescribe 0 to represent a null pointer, 
     even though 0 is used in null pointer constants [C:6.3.2.3/3]. 
     The type is not the pointer type, but the referenced type; 
     this way, we avoid having to constrain the type to be a pointer type. 
     The type of the pointer is the type of pointer to the referenced type.</p>
</body>
</html>
