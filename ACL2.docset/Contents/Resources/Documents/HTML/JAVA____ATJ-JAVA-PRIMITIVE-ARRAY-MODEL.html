<html>
<head>
<meta charset="UTF-8">
<title>Atj-java-primitive-array-model</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=JAVA____ATJ-JAVA-PRIMITIVE-ARRAY-MODEL">Click for Atj-java-primitive-array-model in the Full Manual</a></h3>

<p>ATJ's model of Java primitive arrays.</p><p>For the purpose of generating Java code 
     that manipulates Java primitive arrays, 
     we introduce an ACL2 representation of Java primitive arrays 
     and of operations on such arrays. 
     This is currently not part of our Java language formalization, 
     but it may eventually be replaced with 
     a perhaps more general model from the Java language formalization. 
     The current model only serves ATJ's needs; 
     it is not meant to model all aspects of Java primitive arrays. 
     ATJ's use of this model of Java primitive arrays 
     is described in <a href="JAVA____ATJ-JAVA-PRIMITIVE-ARRAYS.html">atj-java-primitive-arrays</a>.</p><p>We model a Java primitive array essentially as 
     a list of Java primitive values whose length is below 2^{31}. 
     This length limit is derived from the fact that 
     the <span class="v">length</span> field of an array has type <span class="v">int</span> [JLS:10.7], 
     and the maximum integer representable with <span class="v">int</span> is 2^{31}-1. 
     We tag the list, via <span class="tt"><a href="FTY____DEFPROD.html">fty::defprod</a></span>, 
     with an indication of the primitive types.</p><p>We introduce the following functions, 
     eight of each kind, for the eight Java primitive types:</p><ul>
<li>Operations to read components of Java primitive arrays: 
      these model array accesses whose results are used as values. 
      The index is (our ACL2 model of) a Java <span class="v">int</span>, 
      and the result is (our ACL2 model of) the array component type.</li>
<li>Operations to obtain the lengths of Java primitive arrays: 
      these model accesses of the <span class="v">length</span> field of arrays. 
      The result is (our ACL2 model of) a Java <span class="v">int</span>.</li>
<li>Operations to write components of Java primitive arrays: 
      these model the assignment of values 
      to array access expressions whose results are used as variables 
      (these operations functionally return updated arrays). 
      The index is (our ACL2 model of) a Java <span class="v">int</span>, 
      the new component value is (our ACL2 model of) the array component type, 
      and the result is the new Java primitive array.</li>
<li>Operations to create new Java primitive arrays of given lengths 
      (and with every component the default value for the component type, 
      i.e. <span class="v">false</span> for <span class="v">boolean</span> and 0 for the integral types 
      [JLS:4.12.5]): 
      these model array creation expressions 
      with lengths and without initializers. 
      The size is (our ACL2 model of) a Java <span class="v">int</span>, 
      and the result is the newly created Java primitive array.</li>
<li>Operations to create new Java primitive arrays with given components: 
      these model array creation expressions 
      without lengths and with initializers. 
      The inputs are lists of (our ACL2 models of) Java primitive values 
      (of the arrays' component types), 
      and the outputs are the newly created Java primitive arrays. 
      These operations are the same as the constructors of the array fixtypes, 
      but introducing them provides future flexibility, 
      should the definition of the fixtype change in some way.</li>
<li>Operations to convert from Java primitive arrays to ACL2 lists, 
      component-wise: 
      a Java <span class="v">boolean</span> array is converted to 
      the list of corresponding ACL2 <span class="tt"><a href="ACL2____BOOLEANP.html">booleanp</a></span> values; 
      a Java <span class="v">char</span> array is converted to 
      the list of corresponding ACL2 <span class="tt"><a href="ACL2____UBYTE16P.html">ubyte16p</a></span> values; 
      a Java <span class="v">byte</span> array is converted to 
      the list of corresponding ACL2 <span class="tt"><a href="ACL2____SBYTE8P.html">sbyte8p</a></span> values; 
      a Java <span class="v">short</span> array is converted to 
      the list of corresponding ACL2 <span class="tt"><a href="ACL2____SBYTE16P.html">sbyte16p</a></span> values; 
      a Java <span class="v">int</span> array is converted to 
      the list of corresponding ACL2 <span class="tt"><a href="ACL2____SBYTE32P.html">sbyte32p</a></span> values; and 
      a Java <span class="v">long</span> array is converted to 
      the list of corresponding ACL2 <span class="tt"><a href="ACL2____SBYTE64P.html">sbyte64p</a></span> values. 
      No conversion operations for <span class="v">float</span> and <span class="v">double</span> arrays 
      are defined here, 
      because we have an abstract model of those two primitive types.</li>
<li>Operations to convert to Java primitive arrays from ACL2 lists, 
      component-wise; these are the inverse conversions of 
      those described just above.</li>
</ul><p>Note that the conversions between Java arrays and ACL2 lists 
     involve lists of ACL2 values, not of Java primitive values. 
     The reason is that ACL2 lists of (our model of) Java primitive values 
     do not really have a place in the generated Java code, 
     which separates Java primitive values and arrays from built-in ACL2 values, 
     through the ATJ types.</p>
</body>
</html>
