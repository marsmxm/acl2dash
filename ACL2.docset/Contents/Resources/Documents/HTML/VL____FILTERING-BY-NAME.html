<html>
<head>
<meta charset="UTF-8">
<title>Filtering-by-name</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=VL____FILTERING-BY-NAME">Click for Filtering-by-name in the Full Manual</a></h3>

<p>Functions for filtering lists of parsed objects by their names.</p><p>We implement functions for keeping and deleting objects by their 
names, and also for partitioning lists of objects into named and unnamed 
sub-lists.</p> 
 
<p>These functions are logically simple, but we use MBE to make them fairly 
efficient.  In particular, suppose we want to keep, delete, or filter the list 
<span class="v">x</span> using some list of <span class="v">names</span>.</p> 
 
<ul> 
 
<li>If there are only a few names, we use naive algorithm that calls <a href="ACL2____MEMBER-EQUAL.html">member-equal</a> repeatedly, and this is effectively <span class="v">O(|x|)</span>.</li> 
 
<li>When there are many names, we use <a href="VL____MAKE-LOOKUP-ALIST.html">make-lookup-alist</a> to construct a 
temporary, fast alist, and use <a href="VL____FAST-MEMBERP.html">fast-memberp</a> to perform the lookups. 
Assuming that hashing operations are constant time, constructing this table is 
<span class="v">O(|names|)</span>, and the subsequent processing of <span class="v">x</span> is <span class="v">O(|x|)</span>.</li> 
 
</ul> 
 
<p>These functions <b>preserve the order</b> of the initial list.  The order of 
<span class="v">names</span> is irrelevant, and any spurious <span class="v">names</span> that aren't among the 
names of <span class="v">x</span> are simply ignored.</p> 
 
<p>See also <a href="VL____FINDING-BY-NAME.html">finding-by-name</a> for related functions that can also be used 
to look up objects by their names and to rearrange objects by their 
names.</p>
</body>
</html>
