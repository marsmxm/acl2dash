<html>
<head>
<meta charset="UTF-8">
<title>Tyspecseq</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=C____TYSPECSEQ">Click for Tyspecseq in the Full Manual</a></h3>

<p>Fixtype of sequences of type specifiers [C:6.7.2].</p><p>This is a tagged union type, introduced by <a href="FTY____DEFTAGSUM.html">fty::deftagsum</a>.</p> 
<h5>Member Tags → Types</h5><dl>
<dt>
<span class="tt">:void</span> → <a href="C____TYSPECSEQ-VOID.html">tyspecseq-void</a>
</dt> 
<dt>
<span class="tt">:char</span> → <a href="C____TYSPECSEQ-CHAR.html">tyspecseq-char</a>
</dt> 
<dt>
<span class="tt">:schar</span> → <a href="C____TYSPECSEQ-SCHAR.html">tyspecseq-schar</a>
</dt> 
<dt>
<span class="tt">:uchar</span> → <a href="C____TYSPECSEQ-UCHAR.html">tyspecseq-uchar</a>
</dt> 
<dt>
<span class="tt">:sshort</span> → <a href="C____TYSPECSEQ-SSHORT.html">tyspecseq-sshort</a>
</dt> 
<dt>
<span class="tt">:ushort</span> → <a href="C____TYSPECSEQ-USHORT.html">tyspecseq-ushort</a>
</dt> 
<dt>
<span class="tt">:sint</span> → <a href="C____TYSPECSEQ-SINT.html">tyspecseq-sint</a>
</dt> 
<dt>
<span class="tt">:uint</span> → <a href="C____TYSPECSEQ-UINT.html">tyspecseq-uint</a>
</dt> 
<dt>
<span class="tt">:slong</span> → <a href="C____TYSPECSEQ-SLONG.html">tyspecseq-slong</a>
</dt> 
<dt>
<span class="tt">:ulong</span> → <a href="C____TYSPECSEQ-ULONG.html">tyspecseq-ulong</a>
</dt> 
<dt>
<span class="tt">:sllong</span> → <a href="C____TYSPECSEQ-SLLONG.html">tyspecseq-sllong</a>
</dt> 
<dt>
<span class="tt">:ullong</span> → <a href="C____TYSPECSEQ-ULLONG.html">tyspecseq-ullong</a>
</dt> 
<dt>
<span class="tt">:bool</span> → <a href="C____TYSPECSEQ-BOOL.html">tyspecseq-bool</a>
</dt> 
<dt>
<span class="tt">:float</span> → <a href="C____TYSPECSEQ-FLOAT.html">tyspecseq-float</a>
</dt> 
<dt>
<span class="tt">:double</span> → <a href="C____TYSPECSEQ-DOUBLE.html">tyspecseq-double</a>
</dt> 
<dt>
<span class="tt">:ldouble</span> → <a href="C____TYSPECSEQ-LDOUBLE.html">tyspecseq-ldouble</a>
</dt> 
<dt>
<span class="tt">:struct</span> → <a href="C____TYSPECSEQ-STRUCT.html">tyspecseq-struct</a>
</dt> 
<dt>
<span class="tt">:union</span> → <a href="C____TYSPECSEQ-UNION.html">tyspecseq-union</a>
</dt> 
<dt>
<span class="tt">:enum</span> → <a href="C____TYSPECSEQ-ENUM.html">tyspecseq-enum</a>
</dt> 
<dt>
<span class="tt">:typedef</span> → <a href="C____TYSPECSEQ-TYPEDEF.html">tyspecseq-typedef</a>
</dt> 
</dl> 
<p>A sequence of one or more type specifiers in a declaration 
     specifies a type. 
     The allowed sequences are described in [C:6.7.2]. 
     This fixtype captures (some of) these sequences.</p><p>We capture type specifier sequences for 
     the <span class="v">void</span> type, 
     the plain <span class="v">char</span> type, 
     the standard signed and unsigned integer types (which include <span class="v">_Bool</span>), 
     the (real and complex) floating types, 
     limited forms of structure, union, and enumeration types, 
     and type definition names. 
     Complex floating types are not supported by all implementations; 
     we include them in the abstract syntax, 
     because it must suffice to represent all implementations, 
     but they can be used only if supported.</p><p>The form of structure, union, and enumeration types is limited 
     to the case of a single identifier (i.e. tag) [C:6.7.2.1] [C:6.7.2.2], 
     without members or enumerators. 
     Syntactically, declarations that define 
     (members of) structure and union types 
     and (enumerators) of enumeration types 
     are also type specifiers. 
     But we capture them elsewhere in our abstract syntax. 
     We use <span class="v">tyspecseq</span> only for parts of the code 
     that reference existing types, 
     not that introduce them. 
     In that context, there is a distinction between 
     defining a structure type and merely referencing it.</p><p>We do not capture atomic type specifiers for now. 
     These involve additional syntactic complexities, 
     as they contain type names, 
     which are defined below to depend on type specifier sequences; 
     so adding atomic type specifiers would introduce a mutual recursion 
     in the definition of these fixtypes, 
     which is doable but can perhaps be avoided for a while, 
     until we actually need atomic type specifiers.</p><p>This <span class="v">tyspecseq</span> fixtype has one constructor 
     for each item in the list in [C:6.7.2/2], 
     where different items are different types 
     (syntactically speaking, 
     as type definition names may be equal to other types). 
     Each item in that list lists one of more sequences, 
     meant to represent multisets, i.e. where order does not matter. 
     We capture all the possible multisets for each item, 
     via boolean fields that say whether 
     elements of a sequence are present or absent: 
     for example, <span class="v">(<a href="C____MAKE-TYSPECSEQ-SSHORT.html">make-tyspecseq-sshort</a> :signed t :int nil)</span> 
     represents <span class="v">signed short</span>; 
     see the pretty-printer for details. 
     However, we do not capture 
     different sequentializations of the same multiset, 
     e.g. we capture <span class="v">signed short</span> but not <span class="v">short signed</span>. 
     We capture the sequences listed in [C:6.7.2/2] 
     that represent the multiset. 
     Arguably, those are the sequences that should always be used, 
     despite other equivalent sequences being allowed.</p><p>The type specifiers in a declaration 
     may be intermixed with other declaration specifiers [C:6.7/1] [C:6.7.2/2] 
     (e.g. one could write <span class="v">unsigned auto int x = 1;</span>), 
     so long as their sequence (ignoring any intermixed non-type specifiers) 
     is valid according to [C:6.7.2/2]. 
     This intermixing is probably best avoided, 
     so our abstract syntax does not allow it: 
     our type specifier sequences are meant to be contiguous.</p>
</body>
</html>
