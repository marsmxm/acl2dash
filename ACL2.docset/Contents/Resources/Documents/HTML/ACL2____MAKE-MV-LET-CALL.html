<html>
<head>
<meta charset="UTF-8">
<title>Make-mv-let-call</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____MAKE-MV-LET-CALL">Click for Make-mv-let-call in the Full Manual</a></h3>

<p>Build a translated call of <span class="tt"><a href="ACL2____MV-LET.html">mv-let</a></span>.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(make-mv-let-call mv-var vars indices mv-term body-term) 
   
term</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">mv-var</span>  <font color="#606060">Guard <span class="v">(<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> mv-var)</span>.</font>
</dd> 
  <dd>
<span class="tt">vars</span>  <font color="#606060">Guard <span class="v">(<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> vars)</span>.</font>
</dd> 
  <dd>
<span class="tt">indices</span>  <font color="#606060">Guard <span class="v">(<a href="COMMON-LISP____OR.html">or</a> (<a href="ACL2____NAT-LISTP.html">nat-listp</a> indices) (<a href="COMMON-LISP____EQ.html">eq</a> indices :all))</span>.</font>
</dd> 
  <dd>
<span class="tt">mv-term</span>  <font color="#606060">Guard <span class="v">(<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> mv-term)</span>.</font>
</dd> 
  <dd>
<span class="tt">body-term</span>  <font color="#606060">Guard <span class="v">(<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> body-term)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">term</span>  <font color="#606060">Type <span class="v">(<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> term)</span>, given the <a href="ACL2____GUARD.html">guard</a>.</font>
</dd> 
 
</dl></div> 
<p>In translated form, <span class="v">(<a href="ACL2____MV-LET.html">mv-let</a> (var1 ... varn) mv-term body-term)</span> is</p><pre class="code">((<a href="COMMON-LISP____LAMBDA.html">lambda</a> (<a href="ACL2____MV.html">mv</a>)
         ((<a href="COMMON-LISP____LAMBDA.html">lambda</a> (var1 ... varn) body-term-trans)
          (<a href="ACL2____MV-NTH.html">mv-nth</a> '0 mv)
          ...
          (<a href="ACL2____MV-NTH.html">mv-nth</a> 'n-1 mv)))
 mv-term-trans)</pre><p>where <span class="v">mv-term-trans</span> and <span class="v">body-term-trans</span> are 
     the translations of <span class="v">mv-term</span> and <span class="v">body-term</span>.</p><p>This utility creates a translated term of the form above 
     from its constituents.</p><p>For greater flexibility, 
     we allow the <span class="v">mv</span> variable to be 
     a symbol different from the symbol `<span class="v">mv</span>': 
     as explained in <span class="tt"><a href="ACL2____CHECK-MV-LET-CALL.html">check-mv-let-call</a></span>, 
     a translated <span class="tt"><a href="ACL2____MV-LET.html">mv-let</a></span> may have a different symbol from `<span class="v">mv</span>', 
     and so this flexibility is useful, for example, 
     to reconstruct an <span class="tt"><a href="ACL2____MV-LET.html">mv-let</a></span> call, 
     possibly with some modification, 
     from another one whose <span class="v">mv</span> variable is another symbol. 
     The parameter <span class="v">mv-var</span> of this utility is the symbol to use.</p><p>Also for greater flexibilty, 
     we allow some <span class="tt"><a href="ACL2____MV-NTH.html">mv-nth</a></span> calls to be missing. 
     As explained in <span class="tt"><a href="ACL2____CHECK-MV-LET-CALL.html">check-mv-let-call</a></span>, 
     while translated terms obtained directly from <span class="tt"><a href="ACL2____MV-LET.html">mv-let</a></span> calls 
     always have all the <span class="tt"><a href="ACL2____MV-NTH.html">mv-nth</a></span> calls, 
     a term subjected to some transformations may not. 
     To use this utility to reconstruct this kind of transformed term, 
     the <span class="v">indices</span> parameter lets the caller specify 
     which indices should be present. 
     As a convenience, <span class="v">:all</span> stands for 
     all contiguous indices from 0 to the number of bound variables minus 1. 
     If a list of indices is supplied, 
     it must consist of strictly increasing natural numbers, 
     and its length must match the number of bound variables. 
     The second condition is expressed by the guard, 
     but the first condition is checked at run time, 
     causing an error if not satisfied.</p><p>This utility is essentially the inverse of <span class="tt"><a href="ACL2____CHECK-MV-LET-CALL.html">check-mv-let-call</a></span>.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>make-mv-let-call-aux1</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> make-mv-let-call-aux1 (index n mv-var)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> index)
                                   (<a href="ACL2____NATP.html">natp</a> n)
                                   (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> mv-var))))
       (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'make-mv-let-call-aux1))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
            (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____MBT.html">mbt</a> (<a href="ACL2____NATP.html">natp</a> index)))
                    (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____MBT.html">mbt</a> (<a href="ACL2____NATP.html">natp</a> n)))
                    (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> index n))
                nil
                (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'mv-nth
                            (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'quote (<a href="COMMON-LISP____CONS.html">cons</a> index 'nil))
                                  (<a href="COMMON-LISP____CONS.html">cons</a> mv-var 'nil)))
                      (make-mv-let-call-aux1 (<a href="COMMON-LISP____1_B2.html">1+</a> index)
                                             n mv-var)))))</pre> 
<p><b>Theorem: </b>pseudo-term-listp-of-make-mv-let-call-aux1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     pseudo-term-listp-of-make-mv-let-call-aux1
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> mv-var)
              (<a href="ACL2____B_A2.html">b*</a> ((terms (make-mv-let-call-aux1 index n mv-var)))
                  (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> terms)))
     :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>len-of-make-mv-let-call-aux1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> len-of-make-mv-let-call-aux1
        (<a href="ACL2____B_A2.html">b*</a> ((?terms (make-mv-let-call-aux1 index n mv-var)))
            (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> index) (<a href="ACL2____NATP.html">natp</a> n))
                     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> terms)
                            (<a href="ACL2____NFIX.html">nfix</a> (<a href="COMMON-LISP____-.html">-</a> n index))))))</pre> 
<p><b>Function: </b>make-mv-let-call-aux2</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 make-mv-let-call-aux2 (indices mv-var)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NAT-LISTP.html">nat-listp</a> indices)
                             (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> mv-var))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((__function__ 'make-mv-let-call-aux2))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
  (<a href="COMMON-LISP____COND.html">cond</a>
   ((<a href="COMMON-LISP____ENDP.html">endp</a> indices) nil)
   ((<a href="COMMON-LISP____ENDP.html">endp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> indices))
    (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'mv-nth
                (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'quote (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> indices) 'nil))
                      (<a href="COMMON-LISP____CONS.html">cons</a> mv-var 'nil)))))
   (t
    (<a href="COMMON-LISP____IF.html">if</a>
     (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="COMMON-LISP____CAR.html">car</a> indices) (<a href="COMMON-LISP____CADR.html">cadr</a> indices))
     (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'mv-nth
                 (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'quote (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> indices) 'nil))
                       (<a href="COMMON-LISP____CONS.html">cons</a> mv-var 'nil)))
           (make-mv-let-call-aux2 (<a href="COMMON-LISP____CDR.html">cdr</a> indices)
                                  mv-var))
     (<a href="ACL2____PROG2_42.html">prog2$</a>
      (<a href="ACL2____RAISE.html">raise</a>
       "The list of indices ~x0 ~
                                is not strictly increasing."
       indices)
      (<a href="COMMON-LISP____MAKE-LIST.html">make-list</a> (<a href="ACL2____LEN.html">len</a> indices)
                 :initial-element nil)))))))</pre> 
<p><b>Theorem: </b>pseudo-term-listp-of-make-mv-let-call-aux2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     pseudo-term-listp-of-make-mv-let-call-aux2
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> mv-var)
              (<a href="ACL2____B_A2.html">b*</a> ((terms (make-mv-let-call-aux2 indices mv-var)))
                  (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> terms)))
     :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>len-of-mv-let-call-aux2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> len-of-mv-let-call-aux2
        (<a href="ACL2____B_A2.html">b*</a> ((?terms (make-mv-let-call-aux2 indices mv-var)))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> terms) (<a href="ACL2____LEN.html">len</a> indices))))</pre> 
<p><b>Function: </b>make-mv-let-call</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 make-mv-let-call
 (mv-var vars indices mv-term body-term)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> mv-var)
                             (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> vars)
                             (<a href="COMMON-LISP____OR.html">or</a> (<a href="ACL2____NAT-LISTP.html">nat-listp</a> indices)
                                 (<a href="COMMON-LISP____EQ.html">eq</a> indices :all))
                             (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> mv-term)
                             (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> body-term))))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> indices :all)
                            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> indices) (<a href="ACL2____LEN.html">len</a> vars)))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((__function__ 'make-mv-let-call))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
  (<a href="COMMON-LISP____CONS.html">cons</a>
   (<a href="COMMON-LISP____CONS.html">cons</a>
      'lambda
      (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> mv-var 'nil)
            (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'lambda
                              (<a href="COMMON-LISP____CONS.html">cons</a> vars (<a href="COMMON-LISP____CONS.html">cons</a> body-term 'nil)))
                        (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQ.html">eq</a> indices :all)
                            (make-mv-let-call-aux1 0 (<a href="ACL2____LEN.html">len</a> vars)
                                                   mv-var)
                            (make-mv-let-call-aux2 indices mv-var)))
                  'nil)))
   (<a href="COMMON-LISP____CONS.html">cons</a> mv-term 'nil))))</pre> 
<p><b>Theorem: </b>pseudo-termp-of-make-mv-let-call</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 pseudo-termp-of-make-mv-let-call
 (<a href="ACL2____IMPLIES.html">implies</a>
  (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> mv-var)
       (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> vars)
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____NAT-LISTP.html">nat-listp</a> indices)
           (<a href="ACL2____NAT-LISTP.html">nat-listp</a> indices)
           (<a href="COMMON-LISP____EQ.html">eq</a> indices ':all))
       (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> mv-term)
       (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> body-term)
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> indices ':all)
           (<a href="COMMON-LISP____EQUAL.html">equal</a> indices ':all)
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> indices) (<a href="ACL2____LEN.html">len</a> vars))))
  (<a href="ACL2____B_A2.html">b*</a>
   ((<a href="ACL2____TERM.html">term</a> (<a href="ACL2____MAKE-MV-LET-CALL.html">make-mv-let-call</a> mv-var vars indices mv-term body-term)))
   (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> term)))
 :rule-classes :rewrite)</pre> 

</body>
</html>
