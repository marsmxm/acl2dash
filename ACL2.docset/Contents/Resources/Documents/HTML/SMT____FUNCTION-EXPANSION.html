<html>
<head>
<meta charset="UTF-8">
<title>Function-expansion</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=SMT____FUNCTION-EXPANSION">Click for Function-expansion in the Full Manual</a></h3>

<p>Function expansion</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>sym-nat-alistp</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> sym-nat-alistp (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'sym-nat-alistp))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)
                (<a href="COMMON-LISP____EQ.html">eq</a> x nil)
                (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CAR.html">car</a> x))
                     (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAAR.html">caar</a> x))
                     (<a href="ACL2____NATP.html">natp</a> (<a href="COMMON-LISP____CDAR.html">cdar</a> x))
                     (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x))))))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-revappend</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alistp-of-revappend
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="COMMON-LISP____REVAPPEND.html">revappend</a> acl2::x acl2::y))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x))
                    (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-remove</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alistp-of-remove
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x)
                 (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="COMMON-LISP____REMOVE.html">remove</a> acl2::a acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-last</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alistp-of-last
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="COMMON-LISP____LAST.html">last</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-nthcdr</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alistp-of-nthcdr
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> acl2::n acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-butlast</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alistp-of-butlast
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="COMMON-LISP____BUTLAST.html">butlast</a> acl2::x acl2::n)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-update-nth</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 sym-nat-alistp-of-update-nth
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
          (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____UPDATE-NTH.html">update-nth</a> acl2::n acl2::y acl2::x))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::y)
                         (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::y))
                         (<a href="ACL2____NATP.html">natp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::y)))
                    (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____NFIX.html">nfix</a> acl2::n) (<a href="ACL2____LEN.html">len</a> acl2::x))
                        (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> nil)
                             (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> nil))
                             (<a href="ACL2____NATP.html">natp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> nil)))))))
 :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-repeat</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alistp-of-repeat
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____REPEAT.html">acl2::repeat</a> acl2::n acl2::x))
             (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x)
                      (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::x))
                      (<a href="ACL2____NATP.html">natp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::x)))
                 (<a href="ACL2____ZP.html">zp</a> acl2::n)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-take</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alistp-of-take
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____TAKE.html">take</a> acl2::n acl2::x))
                      (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> nil)
                               (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> nil))
                               (<a href="ACL2____NATP.html">natp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> nil)))
                          (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____NFIX.html">nfix</a> acl2::n) (<a href="ACL2____LEN.html">len</a> acl2::x)))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-union-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alistp-of-union-equal
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____UNION-EQUAL.html">union-equal</a> acl2::x acl2::y))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x))
                    (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::y))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-intersection-equal-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     sym-nat-alistp-of-intersection-equal-2
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::y))
              (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____INTERSECTION-EQUAL.html">intersection-equal</a> acl2::x acl2::y)))
     :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-intersection-equal-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     sym-nat-alistp-of-intersection-equal-1
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
              (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____INTERSECTION-EQUAL.html">intersection-equal</a> acl2::x acl2::y)))
     :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-set-difference-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   sym-nat-alistp-of-set-difference-equal
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x)
            (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____SET-DIFFERENCE-EQUAL.html">set-difference-equal</a> acl2::x acl2::y)))
   :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-when-subsetp-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alistp-when-subsetp-equal
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SUBSETP-EQUAL.html">subsetp-equal</a> acl2::x acl2::y)
                           (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::y))
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x)
                             (<a href="ACL2____TRUE-LISTP.html">true-listp</a> acl2::x)))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::y)
                           (<a href="ACL2____SUBSETP-EQUAL.html">subsetp-equal</a> acl2::x acl2::y))
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x)
                             (<a href="ACL2____TRUE-LISTP.html">true-listp</a> acl2::x))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-rcons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alistp-of-rcons
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____RCONS.html">acl2::rcons</a> acl2::a acl2::x))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::a)
                       (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::a))
                       (<a href="ACL2____NATP.html">natp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::a)))
                  (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-append</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alistp-of-append
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="COMMON-LISP____APPEND.html">append</a> acl2::a acl2::b))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::a))
                    (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::b)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-rev</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alistp-of-rev
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____REV.html">acl2::rev</a> acl2::x))
               (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-duplicated-members</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     sym-nat-alistp-of-duplicated-members
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x)
              (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (acl2::duplicated-members acl2::x)))
     :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-difference</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alistp-of-difference
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x)
                 (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="SET____DIFFERENCE.html">set::difference</a> acl2::x acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-intersect-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alistp-of-intersect-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::y)
                 (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="SET____INTERSECT.html">set::intersect</a> acl2::x acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-intersect-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alistp-of-intersect-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x)
                 (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="SET____INTERSECT.html">set::intersect</a> acl2::x acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-union</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alistp-of-union
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="SET____UNION.html">set::union</a> acl2::x acl2::y))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::x))
                  (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::y))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-mergesort</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alistp-of-mergesort
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="SET____MERGESORT.html">set::mergesort</a> acl2::x))
             (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-delete</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alistp-of-delete
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x)
                 (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="SET____DELETE.html">set::delete</a> acl2::k acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-insert</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alistp-of-insert
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="SET____INSERT.html">set::insert</a> acl2::a acl2::x))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::x))
                  (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::a)
                       (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::a))
                       (<a href="ACL2____NATP.html">natp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::a)))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-sfix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alistp-of-sfix
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::x))
             (<a href="COMMON-LISP____OR.html">or</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x)
                 (<a href="COMMON-LISP____NOT.html">not</a> (<a href="SET____SETP.html">set::setp</a> acl2::x))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alistp-of-list-fix
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x)
                 (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>true-listp-when-sym-nat-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> true-listp-when-sym-nat-alistp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x)
                 (<a href="ACL2____TRUE-LISTP.html">true-listp</a> acl2::x))
        :rule-classes :compound-recognizer)</pre> 
<p><b>Theorem: </b>sym-nat-alistp-when-not-consp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alistp-when-not-consp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x)
                        (<a href="COMMON-LISP____NOT.html">not</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-cdr-when-sym-nat-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alistp-of-cdr-when-sym-nat-alistp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-cons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alistp-of-cons
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::a acl2::x))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::a)
                         (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::a))
                         (<a href="ACL2____NATP.html">natp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::a)))
                    (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-make-fal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alistp-of-make-fal
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x)
                      (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::y))
                 (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____MAKE-FAL.html">acl2::make-fal</a> acl2::x acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>natp-of-cdr-when-member-equal-of-sym-nat-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> natp-of-cdr-when-member-equal-of-sym-nat-alistp
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x)
                           (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> acl2::a acl2::x))
                      (<a href="ACL2____NATP.html">natp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::a)))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> acl2::a acl2::x)
                           (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x))
                      (<a href="ACL2____NATP.html">natp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::a))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbolp-of-car-when-member-equal-of-sym-nat-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbolp-of-car-when-member-equal-of-sym-nat-alistp
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x)
                           (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> acl2::a acl2::x))
                      (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::a)))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> acl2::a acl2::x)
                           (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x))
                      (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::a))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>consp-when-member-equal-of-sym-nat-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   consp-when-member-equal-of-sym-nat-alistp
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x)
                 (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> acl2::a acl2::x))
            (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::a))
   :rule-classes
   ((:rewrite :backchain-limit-lst (0 0))
    (:rewrite :backchain-limit-lst (0 0)
              :corollary (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> acl2::a acl2::x)
                                      (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x)
                                      'nil)
                                  (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::a)))))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-remove-assoc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  sym-nat-alistp-of-remove-assoc
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x)
           (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____REMOVE-ASSOC-EQUAL.html">remove-assoc-equal</a> acl2::name acl2::x)))
  :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-put-assoc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 sym-nat-alistp-of-put-assoc
 (<a href="ACL2____IMPLIES.html">implies</a>
  (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x))
  (<a href="ACL2____IFF.html">iff</a>
     (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____PUT-ASSOC-EQUAL.html">put-assoc-equal</a> acl2::name acl2::val acl2::x))
     (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> acl2::name)
          (<a href="ACL2____NATP.html">natp</a> acl2::val))))
 :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-hons-shrink-alist</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     sym-nat-alistp-of-hons-shrink-alist
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x)
                   (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::y))
              (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____HONS-SHRINK-ALIST.html">hons-shrink-alist</a> acl2::x acl2::y)))
     :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-hons-acons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alistp-of-hons-acons
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> (<a href="ACL2____HONS-ACONS.html">hons-acons</a> acl2::a acl2::n acl2::x))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> acl2::a)
                    (<a href="ACL2____NATP.html">natp</a> acl2::n)
                    (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>natp-of-cdr-of-hons-assoc-equal-when-sym-nat-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     natp-of-cdr-of-hons-assoc-equal-when-sym-nat-alistp
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x)
              (<a href="ACL2____IFF.html">iff</a> (<a href="ACL2____NATP.html">natp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="ACL2____HONS-ASSOC-EQUAL.html">hons-assoc-equal</a> acl2::k acl2::x)))
                   (<a href="COMMON-LISP____OR.html">or</a> (<a href="ACL2____HONS-ASSOC-EQUAL.html">hons-assoc-equal</a> acl2::k acl2::x)
                       (<a href="ACL2____NATP.html">natp</a> nil))))
     :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>alistp-when-sym-nat-alistp-rewrite</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> alistp-when-sym-nat-alistp-rewrite
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x)
                 (<a href="ACL2____ALISTP.html">alistp</a> acl2::x))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>alistp-when-sym-nat-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> alistp-when-sym-nat-alistp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x)
                 (<a href="ACL2____ALISTP.html">alistp</a> acl2::x))
        :rule-classes :tau-system)</pre> 
<p><b>Theorem: </b>natp-of-cdar-when-sym-nat-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> natp-of-cdar-when-sym-nat-alistp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x)
                 (<a href="ACL2____IFF.html">iff</a> (<a href="ACL2____NATP.html">natp</a> (<a href="COMMON-LISP____CDAR.html">cdar</a> acl2::x))
                      (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x) (<a href="ACL2____NATP.html">natp</a> nil))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbolp-of-caar-when-sym-nat-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbolp-of-caar-when-sym-nat-alistp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x)
                 (<a href="ACL2____IFF.html">iff</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAAR.html">caar</a> acl2::x))
                      (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x) (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> nil))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Function: </b>sym-nat-alist-fix$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> sym-nat-alist-fix$inline (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> x)))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'sym-nat-alist-fix))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)
                            nil
                            (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CAR.html">car</a> x))
                                (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> (<a href="COMMON-LISP____CAAR.html">caar</a> x))
                                            (<a href="ACL2____NFIX.html">nfix</a> (<a href="COMMON-LISP____CDAR.html">cdar</a> x)))
                                      (<a href="SMT____SYM-NAT-ALIST-FIX.html">sym-nat-alist-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x)))
                                (<a href="SMT____SYM-NAT-ALIST-FIX.html">sym-nat-alist-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x))))
                 :exec x)))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-sym-nat-alist-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alistp-of-sym-nat-alist-fix
        (<a href="ACL2____B_A2.html">b*</a> ((fty::newx (sym-nat-alist-fix$inline x)))
            (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> fty::newx))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>sym-nat-alist-fix-when-sym-nat-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alist-fix-when-sym-nat-alistp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYM-NAT-ALIST-FIX.html">sym-nat-alist-fix</a> x) x)))</pre> 
<p><b>Function: </b>sym-nat-alist-equiv$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> sym-nat-alist-equiv$inline
       (acl2::x acl2::y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::x)
                                   (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> acl2::y))))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYM-NAT-ALIST-FIX.html">sym-nat-alist-fix</a> acl2::x)
              (<a href="SMT____SYM-NAT-ALIST-FIX.html">sym-nat-alist-fix</a> acl2::y)))</pre> 
<p><b>Theorem: </b>sym-nat-alist-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alist-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="SMT____SYM-NAT-ALIST-EQUIV.html">sym-nat-alist-equiv</a> x y))
             (<a href="SMT____SYM-NAT-ALIST-EQUIV.html">sym-nat-alist-equiv</a> x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALIST-EQUIV.html">sym-nat-alist-equiv</a> x y)
                      (<a href="SMT____SYM-NAT-ALIST-EQUIV.html">sym-nat-alist-equiv</a> y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYM-NAT-ALIST-EQUIV.html">sym-nat-alist-equiv</a> x y)
                           (<a href="SMT____SYM-NAT-ALIST-EQUIV.html">sym-nat-alist-equiv</a> y z))
                      (<a href="SMT____SYM-NAT-ALIST-EQUIV.html">sym-nat-alist-equiv</a> x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>sym-nat-alist-equiv-implies-equal-sym-nat-alist-fix-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alist-equiv-implies-equal-sym-nat-alist-fix-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALIST-EQUIV.html">sym-nat-alist-equiv</a> acl2::x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYM-NAT-ALIST-FIX.html">sym-nat-alist-fix</a> acl2::x)
                        (<a href="SMT____SYM-NAT-ALIST-FIX.html">sym-nat-alist-fix</a> x-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>sym-nat-alist-fix-under-sym-nat-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alist-fix-under-sym-nat-alist-equiv
        (<a href="SMT____SYM-NAT-ALIST-EQUIV.html">sym-nat-alist-equiv</a> (<a href="SMT____SYM-NAT-ALIST-FIX.html">sym-nat-alist-fix</a> acl2::x)
                             acl2::x)
        :rule-classes (:rewrite :rewrite-quoted-constant))</pre> 
<p><b>Theorem: </b>equal-of-sym-nat-alist-fix-1-forward-to-sym-nat-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-sym-nat-alist-fix-1-forward-to-sym-nat-alist-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYM-NAT-ALIST-FIX.html">sym-nat-alist-fix</a> acl2::x)
                        acl2::y)
                 (<a href="SMT____SYM-NAT-ALIST-EQUIV.html">sym-nat-alist-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>equal-of-sym-nat-alist-fix-2-forward-to-sym-nat-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-sym-nat-alist-fix-2-forward-to-sym-nat-alist-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> acl2::x (<a href="SMT____SYM-NAT-ALIST-FIX.html">sym-nat-alist-fix</a> acl2::y))
                 (<a href="SMT____SYM-NAT-ALIST-EQUIV.html">sym-nat-alist-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>sym-nat-alist-equiv-of-sym-nat-alist-fix-1-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alist-equiv-of-sym-nat-alist-fix-1-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALIST-EQUIV.html">sym-nat-alist-equiv</a> (<a href="SMT____SYM-NAT-ALIST-FIX.html">sym-nat-alist-fix</a> acl2::x)
                                      acl2::y)
                 (<a href="SMT____SYM-NAT-ALIST-EQUIV.html">sym-nat-alist-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>sym-nat-alist-equiv-of-sym-nat-alist-fix-2-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  sym-nat-alist-equiv-of-sym-nat-alist-fix-2-forward
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALIST-EQUIV.html">sym-nat-alist-equiv</a> acl2::x (<a href="SMT____SYM-NAT-ALIST-FIX.html">sym-nat-alist-fix</a> acl2::y))
           (<a href="SMT____SYM-NAT-ALIST-EQUIV.html">sym-nat-alist-equiv</a> acl2::x acl2::y))
  :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>cons-of-symbol-fix-k-under-sym-nat-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     cons-of-symbol-fix-k-under-sym-nat-alist-equiv
     (<a href="SMT____SYM-NAT-ALIST-EQUIV.html">sym-nat-alist-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> acl2::k) acl2::v)
                                acl2::x)
                          (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::k acl2::v) acl2::x)))</pre> 
<p><b>Theorem: </b>cons-symbol-equiv-congruence-on-k-under-sym-nat-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   cons-symbol-equiv-congruence-on-k-under-sym-nat-alist-equiv
   (<a href="ACL2____IMPLIES.html">implies</a>
        (<a href="ACL2____SYMBOL-EQUIV.html">acl2::symbol-equiv</a> acl2::k k-equiv)
        (<a href="SMT____SYM-NAT-ALIST-EQUIV.html">sym-nat-alist-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::k acl2::v) acl2::x)
                             (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> k-equiv acl2::v) acl2::x)))
   :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>cons-of-nfix-v-under-sym-nat-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> cons-of-nfix-v-under-sym-nat-alist-equiv
        (<a href="SMT____SYM-NAT-ALIST-EQUIV.html">sym-nat-alist-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::k (<a href="ACL2____NFIX.html">nfix</a> acl2::v))
                                   acl2::x)
                             (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::k acl2::v) acl2::x)))</pre> 
<p><b>Theorem: </b>cons-nat-equiv-congruence-on-v-under-sym-nat-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   cons-nat-equiv-congruence-on-v-under-sym-nat-alist-equiv
   (<a href="ACL2____IMPLIES.html">implies</a>
        (<a href="ACL2____NAT-EQUIV.html">acl2::nat-equiv</a> acl2::v v-equiv)
        (<a href="SMT____SYM-NAT-ALIST-EQUIV.html">sym-nat-alist-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::k acl2::v) acl2::x)
                             (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::k v-equiv) acl2::x)))
   :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>cons-of-sym-nat-alist-fix-y-under-sym-nat-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     cons-of-sym-nat-alist-fix-y-under-sym-nat-alist-equiv
     (<a href="SMT____SYM-NAT-ALIST-EQUIV.html">sym-nat-alist-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x (<a href="SMT____SYM-NAT-ALIST-FIX.html">sym-nat-alist-fix</a> acl2::y))
                          (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y)))</pre> 
<p><b>Theorem: </b>cons-sym-nat-alist-equiv-congruence-on-y-under-sym-nat-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  cons-sym-nat-alist-equiv-congruence-on-y-under-sym-nat-alist-equiv
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALIST-EQUIV.html">sym-nat-alist-equiv</a> acl2::y y-equiv)
           (<a href="SMT____SYM-NAT-ALIST-EQUIV.html">sym-nat-alist-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y)
                                (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x y-equiv)))
  :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>sym-nat-alist-fix-of-acons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alist-fix-of-acons
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYM-NAT-ALIST-FIX.html">sym-nat-alist-fix</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::a acl2::b) x))
               (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> acl2::a)
                           (<a href="ACL2____NFIX.html">nfix</a> acl2::b))
                     (<a href="SMT____SYM-NAT-ALIST-FIX.html">sym-nat-alist-fix</a> x))))</pre> 
<p><b>Theorem: </b>sym-nat-alist-fix-of-append</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alist-fix-of-append
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SYM-NAT-ALIST-FIX.html">sym-nat-alist-fix</a> (<a href="COMMON-LISP____APPEND.html">append</a> std::a std::b))
               (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="SMT____SYM-NAT-ALIST-FIX.html">sym-nat-alist-fix</a> std::a)
                       (<a href="SMT____SYM-NAT-ALIST-FIX.html">sym-nat-alist-fix</a> std::b))))</pre> 
<p><b>Theorem: </b>consp-car-of-sym-nat-alist-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> consp-car-of-sym-nat-alist-fix
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____SYM-NAT-ALIST-FIX.html">sym-nat-alist-fix</a> x)))
               (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____SYM-NAT-ALIST-FIX.html">sym-nat-alist-fix</a> x))))</pre> 
<p><b>Function: </b>update-fn-lvls</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> update-fn-lvls (fn fn-lvls)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> fn)
                                   (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> fn-lvls))))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'update-fn-lvls))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____B_A2.html">b*</a> ((fn (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> fn))
                 (fn-lvls (<a href="SMT____SYM-NAT-ALIST-FIX.html">sym-nat-alist-fix</a> fn-lvls))
                 ((unless (<a href="COMMON-LISP____CONSP.html">consp</a> fn-lvls)) nil)
                 ((<a href="COMMON-LISP____CONS.html">cons</a> first rest) fn-lvls)
                 ((<a href="COMMON-LISP____CONS.html">cons</a> this-fn this-lvl) first)
                 ((unless (<a href="COMMON-LISP____EQUAL.html">equal</a> fn this-fn))
                  (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> this-fn this-lvl)
                        (update-fn-lvls fn rest))))
                (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> this-lvl)
                    (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> this-fn 0) rest)
                    (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> this-fn (<a href="COMMON-LISP____1-.html">1-</a> this-lvl))
                          rest)))))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-update-fn-lvls</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alistp-of-update-fn-lvls
        (<a href="ACL2____B_A2.html">b*</a> ((updated-fn-lvls (update-fn-lvls fn fn-lvls)))
            (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> updated-fn-lvls))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>updated-fn-lvls-decrease</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> updated-fn-lvls-decrease
        (<a href="ACL2____B_A2.html">b*</a> ((updated-fn-lvls (update-fn-lvls fn fn-lvls)))
            (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> fn)
                          (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> fn-lvls)
                          (<a href="COMMON-LISP____CONSP.html">consp</a> fn-lvls)
                          (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> fn fn-lvls)
                          (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> fn fn-lvls))
                                      0)))
                     (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="COMMON-LISP____ASSOC.html">assoc</a> fn updated-fn-lvls))
                        (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="COMMON-LISP____ASSOC.html">assoc</a> fn fn-lvls)))))
        :rule-classes :rewrite)</pre> 
<p><b>Function: </b>ex-args-p</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 ex-args-p (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'ex-args-p))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="COMMON-LISP____AND.html">and</a>
   (<a href="ACL2____MBE.html">mbe</a>
     :logic
     (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____ALISTP.html">alistp</a> x)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____STRIP-CARS.html">strip-cars</a> x)
                 '(term-lst fn-lst fn-lvls wrld-fn-len expand-lst)))
     :exec (fty::alist-with-carsp
                x
                '(term-lst fn-lst fn-lvls wrld-fn-len expand-lst)))
   (<a href="ACL2____B_A2.html">b*</a> ((term-lst (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x)))
        (fn-lst (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x)))
        (fn-lvls (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 2 x)))
        (<a href="SMT____WRLD-FN-LEN.html">wrld-fn-len</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 3 x)))
        (expand-lst (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 4 x))))
       (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> term-lst)
            (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> fn-lst)
            (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> fn-lvls)
            (<a href="ACL2____NATP.html">natp</a> wrld-fn-len)
            (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> expand-lst))))))</pre> 
<p><b>Theorem: </b>consp-when-ex-args-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> consp-when-ex-args-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____EX-ARGS-P.html">ex-args-p</a> x) (<a href="COMMON-LISP____CONSP.html">consp</a> x))
        :rule-classes :compound-recognizer)</pre> 
<p><b>Function: </b>ex-args-fix$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 ex-args-fix$inline (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____EX-ARGS-P.html">ex-args-p</a> x)))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'ex-args-fix))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____MBE.html">mbe</a>
   :logic
   (<a href="ACL2____B_A2.html">b*</a>
      ((term-lst (pseudo-term-list-fix (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x))))
       (fn-lst (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x))))
       (fn-lvls (<a href="SMT____SYM-NAT-ALIST-FIX.html">sym-nat-alist-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 2 x))))
       (<a href="SMT____WRLD-FN-LEN.html">wrld-fn-len</a> (<a href="ACL2____NFIX.html">nfix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 3 x))))
       (expand-lst (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 4 x)))))
      (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'term-lst term-lst)
            (<a href="COMMON-LISP____CONS.html">cons</a> 'fn-lst fn-lst)
            (<a href="COMMON-LISP____CONS.html">cons</a> 'fn-lvls fn-lvls)
            (<a href="COMMON-LISP____CONS.html">cons</a> 'wrld-fn-len wrld-fn-len)
            (<a href="COMMON-LISP____CONS.html">cons</a> 'expand-lst expand-lst)))
   :exec x)))</pre> 
<p><b>Theorem: </b>ex-args-p-of-ex-args-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-args-p-of-ex-args-fix
        (<a href="ACL2____B_A2.html">b*</a> ((new-x (ex-args-fix$inline x)))
            (<a href="SMT____EX-ARGS-P.html">ex-args-p</a> new-x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>ex-args-fix-when-ex-args-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-args-fix-when-ex-args-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____EX-ARGS-P.html">ex-args-p</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-ARGS-FIX.html">ex-args-fix</a> x) x)))</pre> 
<p><b>Function: </b>ex-args-equiv$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> ex-args-equiv$inline (acl2::x acl2::y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____EX-ARGS-P.html">ex-args-p</a> acl2::x)
                                   (<a href="SMT____EX-ARGS-P.html">ex-args-p</a> acl2::y))))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-ARGS-FIX.html">ex-args-fix</a> acl2::x)
              (<a href="SMT____EX-ARGS-FIX.html">ex-args-fix</a> acl2::y)))</pre> 
<p><b>Theorem: </b>ex-args-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-args-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="SMT____EX-ARGS-EQUIV.html">ex-args-equiv</a> x y))
             (<a href="SMT____EX-ARGS-EQUIV.html">ex-args-equiv</a> x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____EX-ARGS-EQUIV.html">ex-args-equiv</a> x y)
                      (<a href="SMT____EX-ARGS-EQUIV.html">ex-args-equiv</a> y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____EX-ARGS-EQUIV.html">ex-args-equiv</a> x y)
                           (<a href="SMT____EX-ARGS-EQUIV.html">ex-args-equiv</a> y z))
                      (<a href="SMT____EX-ARGS-EQUIV.html">ex-args-equiv</a> x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>ex-args-equiv-implies-equal-ex-args-fix-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-args-equiv-implies-equal-ex-args-fix-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____EX-ARGS-EQUIV.html">ex-args-equiv</a> acl2::x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-ARGS-FIX.html">ex-args-fix</a> acl2::x)
                        (<a href="SMT____EX-ARGS-FIX.html">ex-args-fix</a> x-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>ex-args-fix-under-ex-args-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-args-fix-under-ex-args-equiv
        (<a href="SMT____EX-ARGS-EQUIV.html">ex-args-equiv</a> (<a href="SMT____EX-ARGS-FIX.html">ex-args-fix</a> acl2::x)
                       acl2::x)
        :rule-classes (:rewrite :rewrite-quoted-constant))</pre> 
<p><b>Theorem: </b>equal-of-ex-args-fix-1-forward-to-ex-args-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-ex-args-fix-1-forward-to-ex-args-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-ARGS-FIX.html">ex-args-fix</a> acl2::x) acl2::y)
                 (<a href="SMT____EX-ARGS-EQUIV.html">ex-args-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>equal-of-ex-args-fix-2-forward-to-ex-args-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-ex-args-fix-2-forward-to-ex-args-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> acl2::x (<a href="SMT____EX-ARGS-FIX.html">ex-args-fix</a> acl2::y))
                 (<a href="SMT____EX-ARGS-EQUIV.html">ex-args-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>ex-args-equiv-of-ex-args-fix-1-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-args-equiv-of-ex-args-fix-1-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____EX-ARGS-EQUIV.html">ex-args-equiv</a> (<a href="SMT____EX-ARGS-FIX.html">ex-args-fix</a> acl2::x)
                                acl2::y)
                 (<a href="SMT____EX-ARGS-EQUIV.html">ex-args-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>ex-args-equiv-of-ex-args-fix-2-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-args-equiv-of-ex-args-fix-2-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____EX-ARGS-EQUIV.html">ex-args-equiv</a> acl2::x (<a href="SMT____EX-ARGS-FIX.html">ex-args-fix</a> acl2::y))
                 (<a href="SMT____EX-ARGS-EQUIV.html">ex-args-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Function: </b>ex-args-&gt;term-lst$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 ex-args-&gt;term-lst$inline (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____EX-ARGS-P.html">ex-args-p</a> x)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
     ((acl2::__function__ 'ex-args-&gt;term-lst))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
     (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                     (pseudo-term-list-fix (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x))))
          :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x)))))</pre> 
<p><b>Theorem: </b>pseudo-term-listp-of-ex-args-&gt;term-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-listp-of-ex-args-&gt;term-lst
        (<a href="ACL2____B_A2.html">b*</a> ((term-lst (ex-args-&gt;term-lst$inline x)))
            (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> term-lst))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>ex-args-&gt;term-lst$inline-of-ex-args-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-args-&gt;term-lst$inline-of-ex-args-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (ex-args-&gt;term-lst$inline (<a href="SMT____EX-ARGS-FIX.html">ex-args-fix</a> x))
               (ex-args-&gt;term-lst$inline x)))</pre> 
<p><b>Theorem: </b>ex-args-&gt;term-lst$inline-ex-args-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-args-&gt;term-lst$inline-ex-args-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____EX-ARGS-EQUIV.html">ex-args-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (ex-args-&gt;term-lst$inline x)
                        (ex-args-&gt;term-lst$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>ex-args-&gt;fn-lst$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     ex-args-&gt;fn-lst$inline (x)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____EX-ARGS-P.html">ex-args-p</a> x)))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
     (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'ex-args-&gt;fn-lst))
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
          (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                          (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x))))
               :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x)))))</pre> 
<p><b>Theorem: </b>func-alistp-of-ex-args-&gt;fn-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-ex-args-&gt;fn-lst
        (<a href="ACL2____B_A2.html">b*</a> ((fn-lst (ex-args-&gt;fn-lst$inline x)))
            (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> fn-lst))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>ex-args-&gt;fn-lst$inline-of-ex-args-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-args-&gt;fn-lst$inline-of-ex-args-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (ex-args-&gt;fn-lst$inline (<a href="SMT____EX-ARGS-FIX.html">ex-args-fix</a> x))
               (ex-args-&gt;fn-lst$inline x)))</pre> 
<p><b>Theorem: </b>ex-args-&gt;fn-lst$inline-ex-args-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-args-&gt;fn-lst$inline-ex-args-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____EX-ARGS-EQUIV.html">ex-args-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (ex-args-&gt;fn-lst$inline x)
                        (ex-args-&gt;fn-lst$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>ex-args-&gt;fn-lvls$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
   ex-args-&gt;fn-lvls$inline (x)
   (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____EX-ARGS-P.html">ex-args-p</a> x)))
   (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
   (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'ex-args-&gt;fn-lvls))
        (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
        (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                        (<a href="SMT____SYM-NAT-ALIST-FIX.html">sym-nat-alist-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 2 x))))
             :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 2 x)))))</pre> 
<p><b>Theorem: </b>sym-nat-alistp-of-ex-args-&gt;fn-lvls</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sym-nat-alistp-of-ex-args-&gt;fn-lvls
        (<a href="ACL2____B_A2.html">b*</a> ((fn-lvls (ex-args-&gt;fn-lvls$inline x)))
            (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> fn-lvls))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>ex-args-&gt;fn-lvls$inline-of-ex-args-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-args-&gt;fn-lvls$inline-of-ex-args-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (ex-args-&gt;fn-lvls$inline (<a href="SMT____EX-ARGS-FIX.html">ex-args-fix</a> x))
               (ex-args-&gt;fn-lvls$inline x)))</pre> 
<p><b>Theorem: </b>ex-args-&gt;fn-lvls$inline-ex-args-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-args-&gt;fn-lvls$inline-ex-args-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____EX-ARGS-EQUIV.html">ex-args-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (ex-args-&gt;fn-lvls$inline x)
                        (ex-args-&gt;fn-lvls$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>ex-args-&gt;wrld-fn-len$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> ex-args-&gt;wrld-fn-len$inline (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____EX-ARGS-P.html">ex-args-p</a> x)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'ex-args-&gt;wrld-fn-len))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                            (<a href="ACL2____NFIX.html">nfix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 3 x))))
                 :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 3 x)))))</pre> 
<p><b>Theorem: </b>natp-of-ex-args-&gt;wrld-fn-len</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> natp-of-ex-args-&gt;wrld-fn-len
        (<a href="ACL2____B_A2.html">b*</a> ((<a href="SMT____WRLD-FN-LEN.html">wrld-fn-len</a> (ex-args-&gt;wrld-fn-len$inline x)))
            (<a href="ACL2____NATP.html">natp</a> wrld-fn-len))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>ex-args-&gt;wrld-fn-len$inline-of-ex-args-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-args-&gt;wrld-fn-len$inline-of-ex-args-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (ex-args-&gt;wrld-fn-len$inline (<a href="SMT____EX-ARGS-FIX.html">ex-args-fix</a> x))
               (ex-args-&gt;wrld-fn-len$inline x)))</pre> 
<p><b>Theorem: </b>ex-args-&gt;wrld-fn-len$inline-ex-args-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-args-&gt;wrld-fn-len$inline-ex-args-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____EX-ARGS-EQUIV.html">ex-args-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (ex-args-&gt;wrld-fn-len$inline x)
                        (ex-args-&gt;wrld-fn-len$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>ex-args-&gt;expand-lst$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 ex-args-&gt;expand-lst$inline (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____EX-ARGS-P.html">ex-args-p</a> x)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
    ((acl2::__function__ 'ex-args-&gt;expand-lst))
    (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
    (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                    (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 4 x))))
         :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 4 x)))))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-ex-args-&gt;expand-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-alistp-of-ex-args-&gt;expand-lst
        (<a href="ACL2____B_A2.html">b*</a> ((expand-lst (ex-args-&gt;expand-lst$inline x)))
            (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> expand-lst))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>ex-args-&gt;expand-lst$inline-of-ex-args-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-args-&gt;expand-lst$inline-of-ex-args-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (ex-args-&gt;expand-lst$inline (<a href="SMT____EX-ARGS-FIX.html">ex-args-fix</a> x))
               (ex-args-&gt;expand-lst$inline x)))</pre> 
<p><b>Theorem: </b>ex-args-&gt;expand-lst$inline-ex-args-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-args-&gt;expand-lst$inline-ex-args-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____EX-ARGS-EQUIV.html">ex-args-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (ex-args-&gt;expand-lst$inline x)
                        (ex-args-&gt;expand-lst$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>ex-args</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 ex-args
 (term-lst fn-lst fn-lvls wrld-fn-len expand-lst)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> term-lst)
                             (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> fn-lst)
                             (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> fn-lvls)
                             (<a href="ACL2____NATP.html">natp</a> wrld-fn-len)
                             (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> expand-lst))))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
     ((acl2::__function__ 'ex-args))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
     (<a href="ACL2____B_A2.html">b*</a> ((term-lst (<a href="ACL2____MBE.html">mbe</a> :logic (pseudo-term-list-fix term-lst)
                         :exec term-lst))
          (fn-lst (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> fn-lst)
                       :exec fn-lst))
          (fn-lvls (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____SYM-NAT-ALIST-FIX.html">sym-nat-alist-fix</a> fn-lvls)
                        :exec fn-lvls))
          (<a href="SMT____WRLD-FN-LEN.html">wrld-fn-len</a> (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____NFIX.html">nfix</a> wrld-fn-len)
                            :exec wrld-fn-len))
          (expand-lst (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> expand-lst)
                           :exec expand-lst)))
         (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'term-lst term-lst)
               (<a href="COMMON-LISP____CONS.html">cons</a> 'fn-lst fn-lst)
               (<a href="COMMON-LISP____CONS.html">cons</a> 'fn-lvls fn-lvls)
               (<a href="COMMON-LISP____CONS.html">cons</a> 'wrld-fn-len wrld-fn-len)
               (<a href="COMMON-LISP____CONS.html">cons</a> 'expand-lst expand-lst)))))</pre> 
<p><b>Theorem: </b>ex-args-p-of-ex-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-args-p-of-ex-args
        (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="SMT____EX-ARGS.html">ex-args</a> term-lst
                         fn-lst fn-lvls wrld-fn-len expand-lst)))
            (<a href="SMT____EX-ARGS-P.html">ex-args-p</a> x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>ex-args-&gt;term-lst-of-ex-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-args-&gt;term-lst-of-ex-args
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a>
                    (<a href="SMT____EX-ARGS.html">ex-args</a> term-lst
                             fn-lst fn-lvls wrld-fn-len expand-lst))
               (pseudo-term-list-fix term-lst)))</pre> 
<p><b>Theorem: </b>ex-args-&gt;fn-lst-of-ex-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 ex-args-&gt;fn-lst-of-ex-args
 (<a href="COMMON-LISP____EQUAL.html">equal</a>
   (<a href="SMT____EX-ARGS-_E3FN-LST.html">ex-args-&gt;fn-lst</a> (<a href="SMT____EX-ARGS.html">ex-args</a> term-lst
                             fn-lst fn-lvls wrld-fn-len expand-lst))
   (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> fn-lst)))</pre> 
<p><b>Theorem: </b>ex-args-&gt;fn-lvls-of-ex-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 ex-args-&gt;fn-lvls-of-ex-args
 (<a href="COMMON-LISP____EQUAL.html">equal</a>
  (<a href="SMT____EX-ARGS-_E3FN-LVLS.html">ex-args-&gt;fn-lvls</a> (<a href="SMT____EX-ARGS.html">ex-args</a> term-lst
                             fn-lst fn-lvls wrld-fn-len expand-lst))
  (<a href="SMT____SYM-NAT-ALIST-FIX.html">sym-nat-alist-fix</a> fn-lvls)))</pre> 
<p><b>Theorem: </b>ex-args-&gt;wrld-fn-len-of-ex-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-args-&gt;wrld-fn-len-of-ex-args
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-ARGS-_E3WRLD-FN-LEN.html">ex-args-&gt;wrld-fn-len</a>
                    (<a href="SMT____EX-ARGS.html">ex-args</a> term-lst
                             fn-lst fn-lvls wrld-fn-len expand-lst))
               (<a href="ACL2____NFIX.html">nfix</a> wrld-fn-len)))</pre> 
<p><b>Theorem: </b>ex-args-&gt;expand-lst-of-ex-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-args-&gt;expand-lst-of-ex-args
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-ARGS-_E3EXPAND-LST.html">ex-args-&gt;expand-lst</a>
                    (<a href="SMT____EX-ARGS.html">ex-args</a> term-lst
                             fn-lst fn-lvls wrld-fn-len expand-lst))
               (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> expand-lst)))</pre> 
<p><b>Theorem: </b>ex-args-of-fields</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-args-of-fields
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-ARGS.html">ex-args</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> x)
                        (<a href="SMT____EX-ARGS-_E3FN-LST.html">ex-args-&gt;fn-lst</a> x)
                        (<a href="SMT____EX-ARGS-_E3FN-LVLS.html">ex-args-&gt;fn-lvls</a> x)
                        (<a href="SMT____EX-ARGS-_E3WRLD-FN-LEN.html">ex-args-&gt;wrld-fn-len</a> x)
                        (<a href="SMT____EX-ARGS-_E3EXPAND-LST.html">ex-args-&gt;expand-lst</a> x))
               (<a href="SMT____EX-ARGS-FIX.html">ex-args-fix</a> x)))</pre> 
<p><b>Theorem: </b>ex-args-fix-when-ex-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-args-fix-when-ex-args
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-ARGS-FIX.html">ex-args-fix</a> x)
               (<a href="SMT____EX-ARGS.html">ex-args</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> x)
                        (<a href="SMT____EX-ARGS-_E3FN-LST.html">ex-args-&gt;fn-lst</a> x)
                        (<a href="SMT____EX-ARGS-_E3FN-LVLS.html">ex-args-&gt;fn-lvls</a> x)
                        (<a href="SMT____EX-ARGS-_E3WRLD-FN-LEN.html">ex-args-&gt;wrld-fn-len</a> x)
                        (<a href="SMT____EX-ARGS-_E3EXPAND-LST.html">ex-args-&gt;expand-lst</a> x))))</pre> 
<p><b>Theorem: </b>equal-of-ex-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     equal-of-ex-args
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-ARGS.html">ex-args</a> term-lst
                            fn-lst fn-lvls wrld-fn-len expand-lst)
                   x)
            (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____EX-ARGS-P.html">ex-args-p</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> x)
                        (pseudo-term-list-fix term-lst))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-ARGS-_E3FN-LST.html">ex-args-&gt;fn-lst</a> x)
                        (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> fn-lst))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-ARGS-_E3FN-LVLS.html">ex-args-&gt;fn-lvls</a> x)
                        (<a href="SMT____SYM-NAT-ALIST-FIX.html">sym-nat-alist-fix</a> fn-lvls))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-ARGS-_E3WRLD-FN-LEN.html">ex-args-&gt;wrld-fn-len</a> x)
                        (<a href="ACL2____NFIX.html">nfix</a> wrld-fn-len))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-ARGS-_E3EXPAND-LST.html">ex-args-&gt;expand-lst</a> x)
                        (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> expand-lst)))))</pre> 
<p><b>Theorem: </b>ex-args-of-pseudo-term-list-fix-term-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-args-of-pseudo-term-list-fix-term-lst
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-ARGS.html">ex-args</a> (pseudo-term-list-fix term-lst)
                        fn-lst fn-lvls wrld-fn-len expand-lst)
               (<a href="SMT____EX-ARGS.html">ex-args</a> term-lst
                        fn-lst fn-lvls wrld-fn-len expand-lst)))</pre> 
<p><b>Theorem: </b>ex-args-pseudo-term-list-equiv-congruence-on-term-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   ex-args-pseudo-term-list-equiv-congruence-on-term-lst
   (<a href="ACL2____IMPLIES.html">implies</a> (pseudo-term-list-equiv term-lst term-lst-equiv)
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-ARGS.html">ex-args</a> term-lst
                            fn-lst fn-lvls wrld-fn-len expand-lst)
                   (<a href="SMT____EX-ARGS.html">ex-args</a> term-lst-equiv
                            fn-lst fn-lvls wrld-fn-len expand-lst)))
   :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>ex-args-of-func-alist-fix-fn-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-args-of-func-alist-fix-fn-lst
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-ARGS.html">ex-args</a> term-lst (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> fn-lst)
                        fn-lvls wrld-fn-len expand-lst)
               (<a href="SMT____EX-ARGS.html">ex-args</a> term-lst
                        fn-lst fn-lvls wrld-fn-len expand-lst)))</pre> 
<p><b>Theorem: </b>ex-args-func-alist-equiv-congruence-on-fn-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     ex-args-func-alist-equiv-congruence-on-fn-lst
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALIST-EQUIV.html">func-alist-equiv</a> fn-lst fn-lst-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-ARGS.html">ex-args</a> term-lst
                              fn-lst fn-lvls wrld-fn-len expand-lst)
                     (<a href="SMT____EX-ARGS.html">ex-args</a> term-lst fn-lst-equiv
                              fn-lvls wrld-fn-len expand-lst)))
     :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>ex-args-of-sym-nat-alist-fix-fn-lvls</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-args-of-sym-nat-alist-fix-fn-lvls
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-ARGS.html">ex-args</a> term-lst
                        fn-lst (<a href="SMT____SYM-NAT-ALIST-FIX.html">sym-nat-alist-fix</a> fn-lvls)
                        wrld-fn-len expand-lst)
               (<a href="SMT____EX-ARGS.html">ex-args</a> term-lst
                        fn-lst fn-lvls wrld-fn-len expand-lst)))</pre> 
<p><b>Theorem: </b>ex-args-sym-nat-alist-equiv-congruence-on-fn-lvls</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    ex-args-sym-nat-alist-equiv-congruence-on-fn-lvls
    (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SYM-NAT-ALIST-EQUIV.html">sym-nat-alist-equiv</a> fn-lvls fn-lvls-equiv)
             (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-ARGS.html">ex-args</a> term-lst
                             fn-lst fn-lvls wrld-fn-len expand-lst)
                    (<a href="SMT____EX-ARGS.html">ex-args</a> term-lst fn-lst
                             fn-lvls-equiv wrld-fn-len expand-lst)))
    :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>ex-args-of-nfix-wrld-fn-len</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-args-of-nfix-wrld-fn-len
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-ARGS.html">ex-args</a> term-lst
                        fn-lst fn-lvls (<a href="ACL2____NFIX.html">nfix</a> wrld-fn-len)
                        expand-lst)
               (<a href="SMT____EX-ARGS.html">ex-args</a> term-lst
                        fn-lst fn-lvls wrld-fn-len expand-lst)))</pre> 
<p><b>Theorem: </b>ex-args-nat-equiv-congruence-on-wrld-fn-len</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    ex-args-nat-equiv-congruence-on-wrld-fn-len
    (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____NAT-EQUIV.html">acl2::nat-equiv</a> wrld-fn-len wrld-fn-len-equiv)
             (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-ARGS.html">ex-args</a> term-lst
                             fn-lst fn-lvls wrld-fn-len expand-lst)
                    (<a href="SMT____EX-ARGS.html">ex-args</a> term-lst fn-lst
                             fn-lvls wrld-fn-len-equiv expand-lst)))
    :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>ex-args-of-pseudo-term-alist-fix-expand-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-args-of-pseudo-term-alist-fix-expand-lst
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-ARGS.html">ex-args</a> term-lst fn-lst fn-lvls wrld-fn-len
                        (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> expand-lst))
               (<a href="SMT____EX-ARGS.html">ex-args</a> term-lst
                        fn-lst fn-lvls wrld-fn-len expand-lst)))</pre> 
<p><b>Theorem: </b>ex-args-pseudo-term-alist-equiv-congruence-on-expand-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    ex-args-pseudo-term-alist-equiv-congruence-on-expand-lst
    (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____PSEUDO-TERM-ALIST-EQUIV.html">pseudo-term-alist-equiv</a> expand-lst expand-lst-equiv)
             (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-ARGS.html">ex-args</a> term-lst
                             fn-lst fn-lvls wrld-fn-len expand-lst)
                    (<a href="SMT____EX-ARGS.html">ex-args</a> term-lst fn-lst
                             fn-lvls wrld-fn-len expand-lst-equiv)))
    :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>ex-args-fix-redef</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-args-fix-redef
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-ARGS-FIX.html">ex-args-fix</a> x)
               (<a href="SMT____EX-ARGS.html">ex-args</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> x)
                        (<a href="SMT____EX-ARGS-_E3FN-LST.html">ex-args-&gt;fn-lst</a> x)
                        (<a href="SMT____EX-ARGS-_E3FN-LVLS.html">ex-args-&gt;fn-lvls</a> x)
                        (<a href="SMT____EX-ARGS-_E3WRLD-FN-LEN.html">ex-args-&gt;wrld-fn-len</a> x)
                        (<a href="SMT____EX-ARGS-_E3EXPAND-LST.html">ex-args-&gt;expand-lst</a> x)))
        :rule-classes :definition)</pre> 
<p><b>Function: </b>ex-outs-p</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 ex-outs-p (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'ex-outs-p))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="COMMON-LISP____AND.html">and</a>
   (<a href="ACL2____MBE.html">mbe</a>
     :logic (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____ALISTP.html">alistp</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____STRIP-CARS.html">strip-cars</a> x)
                        '(expanded-term-lst expanded-fn-lst)))
     :exec
     (fty::alist-with-carsp x '(expanded-term-lst expanded-fn-lst)))
   (<a href="ACL2____B_A2.html">b*</a> ((expanded-term-lst (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x)))
        (expanded-fn-lst (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x))))
       (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> expanded-term-lst)
            (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> expanded-fn-lst))))))</pre> 
<p><b>Theorem: </b>consp-when-ex-outs-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> consp-when-ex-outs-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____EX-OUTS-P.html">ex-outs-p</a> x) (<a href="COMMON-LISP____CONSP.html">consp</a> x))
        :rule-classes :compound-recognizer)</pre> 
<p><b>Function: </b>ex-outs-fix$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 ex-outs-fix$inline (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____EX-OUTS-P.html">ex-outs-p</a> x)))
 (<a href="COMMON-LISP____LET.html">let</a>
    ((acl2::__function__ 'ex-outs-fix))
    (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
    (<a href="ACL2____MBE.html">mbe</a> :logic
         (<a href="ACL2____B_A2.html">b*</a> ((expanded-term-lst
                   (pseudo-term-list-fix (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x))))
              (expanded-fn-lst
                   (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x)))))
             (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'expanded-term-lst
                         expanded-term-lst)
                   (<a href="COMMON-LISP____CONS.html">cons</a> 'expanded-fn-lst
                         expanded-fn-lst)))
         :exec x)))</pre> 
<p><b>Theorem: </b>ex-outs-p-of-ex-outs-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-outs-p-of-ex-outs-fix
        (<a href="ACL2____B_A2.html">b*</a> ((new-x (ex-outs-fix$inline x)))
            (<a href="SMT____EX-OUTS-P.html">ex-outs-p</a> new-x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>ex-outs-fix-when-ex-outs-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-outs-fix-when-ex-outs-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____EX-OUTS-P.html">ex-outs-p</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-OUTS-FIX.html">ex-outs-fix</a> x) x)))</pre> 
<p><b>Function: </b>ex-outs-equiv$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> ex-outs-equiv$inline (acl2::x acl2::y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____EX-OUTS-P.html">ex-outs-p</a> acl2::x)
                                   (<a href="SMT____EX-OUTS-P.html">ex-outs-p</a> acl2::y))))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-OUTS-FIX.html">ex-outs-fix</a> acl2::x)
              (<a href="SMT____EX-OUTS-FIX.html">ex-outs-fix</a> acl2::y)))</pre> 
<p><b>Theorem: </b>ex-outs-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-outs-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="SMT____EX-OUTS-EQUIV.html">ex-outs-equiv</a> x y))
             (<a href="SMT____EX-OUTS-EQUIV.html">ex-outs-equiv</a> x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____EX-OUTS-EQUIV.html">ex-outs-equiv</a> x y)
                      (<a href="SMT____EX-OUTS-EQUIV.html">ex-outs-equiv</a> y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____EX-OUTS-EQUIV.html">ex-outs-equiv</a> x y)
                           (<a href="SMT____EX-OUTS-EQUIV.html">ex-outs-equiv</a> y z))
                      (<a href="SMT____EX-OUTS-EQUIV.html">ex-outs-equiv</a> x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>ex-outs-equiv-implies-equal-ex-outs-fix-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-outs-equiv-implies-equal-ex-outs-fix-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____EX-OUTS-EQUIV.html">ex-outs-equiv</a> acl2::x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-OUTS-FIX.html">ex-outs-fix</a> acl2::x)
                        (<a href="SMT____EX-OUTS-FIX.html">ex-outs-fix</a> x-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>ex-outs-fix-under-ex-outs-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-outs-fix-under-ex-outs-equiv
        (<a href="SMT____EX-OUTS-EQUIV.html">ex-outs-equiv</a> (<a href="SMT____EX-OUTS-FIX.html">ex-outs-fix</a> acl2::x)
                       acl2::x)
        :rule-classes (:rewrite :rewrite-quoted-constant))</pre> 
<p><b>Theorem: </b>equal-of-ex-outs-fix-1-forward-to-ex-outs-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-ex-outs-fix-1-forward-to-ex-outs-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-OUTS-FIX.html">ex-outs-fix</a> acl2::x) acl2::y)
                 (<a href="SMT____EX-OUTS-EQUIV.html">ex-outs-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>equal-of-ex-outs-fix-2-forward-to-ex-outs-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-ex-outs-fix-2-forward-to-ex-outs-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> acl2::x (<a href="SMT____EX-OUTS-FIX.html">ex-outs-fix</a> acl2::y))
                 (<a href="SMT____EX-OUTS-EQUIV.html">ex-outs-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>ex-outs-equiv-of-ex-outs-fix-1-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-outs-equiv-of-ex-outs-fix-1-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____EX-OUTS-EQUIV.html">ex-outs-equiv</a> (<a href="SMT____EX-OUTS-FIX.html">ex-outs-fix</a> acl2::x)
                                acl2::y)
                 (<a href="SMT____EX-OUTS-EQUIV.html">ex-outs-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>ex-outs-equiv-of-ex-outs-fix-2-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-outs-equiv-of-ex-outs-fix-2-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____EX-OUTS-EQUIV.html">ex-outs-equiv</a> acl2::x (<a href="SMT____EX-OUTS-FIX.html">ex-outs-fix</a> acl2::y))
                 (<a href="SMT____EX-OUTS-EQUIV.html">ex-outs-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Function: </b>ex-outs-&gt;expanded-term-lst$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 ex-outs-&gt;expanded-term-lst$inline (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____EX-OUTS-P.html">ex-outs-p</a> x)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
     ((acl2::__function__ 'ex-outs-&gt;expanded-term-lst))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
     (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                     (pseudo-term-list-fix (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x))))
          :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x)))))</pre> 
<p><b>Theorem: </b>pseudo-term-listp-of-ex-outs-&gt;expanded-term-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     pseudo-term-listp-of-ex-outs-&gt;expanded-term-lst
     (<a href="ACL2____B_A2.html">b*</a> ((expanded-term-lst (ex-outs-&gt;expanded-term-lst$inline x)))
         (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> expanded-term-lst))
     :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>ex-outs-&gt;expanded-term-lst$inline-of-ex-outs-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-outs-&gt;expanded-term-lst$inline-of-ex-outs-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (ex-outs-&gt;expanded-term-lst$inline (<a href="SMT____EX-OUTS-FIX.html">ex-outs-fix</a> x))
               (ex-outs-&gt;expanded-term-lst$inline x)))</pre> 
<p><b>Theorem: </b>ex-outs-&gt;expanded-term-lst$inline-ex-outs-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     ex-outs-&gt;expanded-term-lst$inline-ex-outs-equiv-congruence-on-x
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____EX-OUTS-EQUIV.html">ex-outs-equiv</a> x x-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (ex-outs-&gt;expanded-term-lst$inline x)
                     (ex-outs-&gt;expanded-term-lst$inline x-equiv)))
     :rule-classes :congruence)</pre> 
<p><b>Function: </b>ex-outs-&gt;expanded-fn-lst$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 ex-outs-&gt;expanded-fn-lst$inline (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____EX-OUTS-P.html">ex-outs-p</a> x)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
    ((acl2::__function__ 'ex-outs-&gt;expanded-fn-lst))
    (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
    (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                    (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x))))
         :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x)))))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-ex-outs-&gt;expanded-fn-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-alistp-of-ex-outs-&gt;expanded-fn-lst
        (<a href="ACL2____B_A2.html">b*</a> ((expanded-fn-lst (ex-outs-&gt;expanded-fn-lst$inline x)))
            (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> expanded-fn-lst))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>ex-outs-&gt;expanded-fn-lst$inline-of-ex-outs-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-outs-&gt;expanded-fn-lst$inline-of-ex-outs-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (ex-outs-&gt;expanded-fn-lst$inline (<a href="SMT____EX-OUTS-FIX.html">ex-outs-fix</a> x))
               (ex-outs-&gt;expanded-fn-lst$inline x)))</pre> 
<p><b>Theorem: </b>ex-outs-&gt;expanded-fn-lst$inline-ex-outs-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     ex-outs-&gt;expanded-fn-lst$inline-ex-outs-equiv-congruence-on-x
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____EX-OUTS-EQUIV.html">ex-outs-equiv</a> x x-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (ex-outs-&gt;expanded-fn-lst$inline x)
                     (ex-outs-&gt;expanded-fn-lst$inline x-equiv)))
     :rule-classes :congruence)</pre> 
<p><b>Function: </b>ex-outs</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 ex-outs
 (expanded-term-lst expanded-fn-lst)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> expanded-term-lst)
                             (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> expanded-fn-lst))))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'ex-outs))
      (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
      (<a href="ACL2____B_A2.html">b*</a> ((expanded-term-lst
                (<a href="ACL2____MBE.html">mbe</a> :logic (pseudo-term-list-fix expanded-term-lst)
                     :exec expanded-term-lst))
           (expanded-fn-lst
                (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> expanded-fn-lst)
                     :exec expanded-fn-lst)))
          (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'expanded-term-lst
                      expanded-term-lst)
                (<a href="COMMON-LISP____CONS.html">cons</a> 'expanded-fn-lst
                      expanded-fn-lst)))))</pre> 
<p><b>Theorem: </b>ex-outs-p-of-ex-outs</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-outs-p-of-ex-outs
        (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="SMT____EX-OUTS.html">ex-outs</a> expanded-term-lst expanded-fn-lst)))
            (<a href="SMT____EX-OUTS-P.html">ex-outs-p</a> x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>ex-outs-&gt;expanded-term-lst-of-ex-outs</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-outs-&gt;expanded-term-lst-of-ex-outs
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-OUTS-_E3EXPANDED-TERM-LST.html">ex-outs-&gt;expanded-term-lst</a>
                    (<a href="SMT____EX-OUTS.html">ex-outs</a> expanded-term-lst expanded-fn-lst))
               (pseudo-term-list-fix expanded-term-lst)))</pre> 
<p><b>Theorem: </b>ex-outs-&gt;expanded-fn-lst-of-ex-outs</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-outs-&gt;expanded-fn-lst-of-ex-outs
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-OUTS-_E3EXPANDED-FN-LST.html">ex-outs-&gt;expanded-fn-lst</a>
                    (<a href="SMT____EX-OUTS.html">ex-outs</a> expanded-term-lst expanded-fn-lst))
               (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> expanded-fn-lst)))</pre> 
<p><b>Theorem: </b>ex-outs-of-fields</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-outs-of-fields
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-OUTS.html">ex-outs</a> (<a href="SMT____EX-OUTS-_E3EXPANDED-TERM-LST.html">ex-outs-&gt;expanded-term-lst</a> x)
                        (<a href="SMT____EX-OUTS-_E3EXPANDED-FN-LST.html">ex-outs-&gt;expanded-fn-lst</a> x))
               (<a href="SMT____EX-OUTS-FIX.html">ex-outs-fix</a> x)))</pre> 
<p><b>Theorem: </b>ex-outs-fix-when-ex-outs</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-outs-fix-when-ex-outs
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-OUTS-FIX.html">ex-outs-fix</a> x)
               (<a href="SMT____EX-OUTS.html">ex-outs</a> (<a href="SMT____EX-OUTS-_E3EXPANDED-TERM-LST.html">ex-outs-&gt;expanded-term-lst</a> x)
                        (<a href="SMT____EX-OUTS-_E3EXPANDED-FN-LST.html">ex-outs-&gt;expanded-fn-lst</a> x))))</pre> 
<p><b>Theorem: </b>equal-of-ex-outs</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     equal-of-ex-outs
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-OUTS.html">ex-outs</a> expanded-term-lst expanded-fn-lst)
                   x)
            (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____EX-OUTS-P.html">ex-outs-p</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-OUTS-_E3EXPANDED-TERM-LST.html">ex-outs-&gt;expanded-term-lst</a> x)
                        (pseudo-term-list-fix expanded-term-lst))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-OUTS-_E3EXPANDED-FN-LST.html">ex-outs-&gt;expanded-fn-lst</a> x)
                        (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> expanded-fn-lst)))))</pre> 
<p><b>Theorem: </b>ex-outs-of-pseudo-term-list-fix-expanded-term-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-outs-of-pseudo-term-list-fix-expanded-term-lst
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-OUTS.html">ex-outs</a> (pseudo-term-list-fix expanded-term-lst)
                        expanded-fn-lst)
               (<a href="SMT____EX-OUTS.html">ex-outs</a> expanded-term-lst expanded-fn-lst)))</pre> 
<p><b>Theorem: </b>ex-outs-pseudo-term-list-equiv-congruence-on-expanded-term-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     ex-outs-pseudo-term-list-equiv-congruence-on-expanded-term-lst
     (<a href="ACL2____IMPLIES.html">implies</a> (pseudo-term-list-equiv expanded-term-lst
                                      expanded-term-lst-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-OUTS.html">ex-outs</a> expanded-term-lst expanded-fn-lst)
                     (<a href="SMT____EX-OUTS.html">ex-outs</a> expanded-term-lst-equiv
                              expanded-fn-lst)))
     :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>ex-outs-of-pseudo-term-alist-fix-expanded-fn-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-outs-of-pseudo-term-alist-fix-expanded-fn-lst
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-OUTS.html">ex-outs</a> expanded-term-lst
                        (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> expanded-fn-lst))
               (<a href="SMT____EX-OUTS.html">ex-outs</a> expanded-term-lst expanded-fn-lst)))</pre> 
<p><b>Theorem: </b>ex-outs-pseudo-term-alist-equiv-congruence-on-expanded-fn-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 ex-outs-pseudo-term-alist-equiv-congruence-on-expanded-fn-lst
 (<a href="ACL2____IMPLIES.html">implies</a>
     (<a href="SMT____PSEUDO-TERM-ALIST-EQUIV.html">pseudo-term-alist-equiv</a> expanded-fn-lst expanded-fn-lst-equiv)
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-OUTS.html">ex-outs</a> expanded-term-lst expanded-fn-lst)
            (<a href="SMT____EX-OUTS.html">ex-outs</a> expanded-term-lst
                     expanded-fn-lst-equiv)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>ex-outs-fix-redef</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ex-outs-fix-redef
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____EX-OUTS-FIX.html">ex-outs-fix</a> x)
               (<a href="SMT____EX-OUTS.html">ex-outs</a> (<a href="SMT____EX-OUTS-_E3EXPANDED-TERM-LST.html">ex-outs-&gt;expanded-term-lst</a> x)
                        (<a href="SMT____EX-OUTS-_E3EXPANDED-FN-LST.html">ex-outs-&gt;expanded-fn-lst</a> x)))
        :rule-classes :definition)</pre> 
<p><b>Function: </b>sum-lvls</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> sum-lvls (fn-lvls)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> fn-lvls)))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'sum-lvls))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____B_A2.html">b*</a> ((fn-lvls (<a href="SMT____SYM-NAT-ALIST-FIX.html">sym-nat-alist-fix</a> fn-lvls))
                 ((unless (<a href="COMMON-LISP____CONSP.html">consp</a> fn-lvls)) 0)
                 ((<a href="COMMON-LISP____CONS.html">cons</a> first rest) fn-lvls)
                 ((<a href="COMMON-LISP____CONS.html">cons</a> &amp; lvl) first))
                (<a href="COMMON-LISP_____B2.html">+</a> lvl (sum-lvls rest)))))</pre> 
<p><b>Theorem: </b>natp-of-sum-lvls</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> natp-of-sum-lvls
        (<a href="ACL2____B_A2.html">b*</a> ((sum (sum-lvls fn-lvls)))
            (<a href="ACL2____NATP.html">natp</a> sum))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>sum-lvls-decrease-after-update</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sum-lvls-decrease-after-update
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> fn)
                      (<a href="SMT____SYM-NAT-ALISTP.html">sym-nat-alistp</a> fn-lvls)
                      (<a href="COMMON-LISP____CONSP.html">consp</a> fn-lvls)
                      (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> fn fn-lvls)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> fn fn-lvls))
                                  0)))
                 (<a href="COMMON-LISP_____C3.html">&lt;</a> (sum-lvls (update-fn-lvls fn fn-lvls))
                    (sum-lvls fn-lvls))))</pre> 
<p><b>Function: </b>expand-measure</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> expand-measure (expand-args)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____EX-ARGS-P.html">ex-args-p</a> expand-args)))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'expand-measure))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____B_A2.html">b*</a> ((expand-args (<a href="SMT____EX-ARGS-FIX.html">ex-args-fix</a> expand-args))
                 ((<a href="SMT____EX-ARGS.html">ex-args</a> a) expand-args)
                 (lvl-sum (sum-lvls a.fn-lvls)))
                (<a href="COMMON-LISP____LIST.html">list</a> a.wrld-fn-len
                      lvl-sum (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> a.term-lst)))))</pre> 
<p><b>Theorem: </b>nat-listp-of-expand-measure</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nat-listp-of-expand-measure
        (<a href="ACL2____B_A2.html">b*</a> ((m (<a href="SMT____EXPAND-MEASURE.html">expand-measure</a> expand-args)))
            (<a href="ACL2____NAT-LISTP.html">nat-listp</a> m))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>pseudo-term-list-of-cdar-of-ex-args-&gt;term-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   pseudo-term-list-of-cdar-of-ex-args-&gt;term-lst
   (<a href="ACL2____IMPLIES.html">implies</a>
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____EX-ARGS-P.html">ex-args-p</a> expand-args)
             (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args))
             (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args)))
             (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAAR.html">caar</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args))
                         'quote)))
        (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> (<a href="COMMON-LISP____CDAR.html">cdar</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args)))))</pre> 
<p><b>Theorem: </b>pseudo-term-listp-of-cdr-of-ex-args-&gt;term-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    pseudo-term-listp-of-cdr-of-ex-args-&gt;term-lst
    (<a href="ACL2____IMPLIES.html">implies</a>
         (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____EX-ARGS-P.html">ex-args-p</a> expand-args)
              (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args)))
         (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args)))))</pre> 
<p><b>Theorem: </b>symbolp-of-car-of-ex-args-&gt;term-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  symbolp-of-car-of-ex-args-&gt;term-lst
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____EX-ARGS-P.html">ex-args-p</a> expand-args)
                (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args))
                (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args)))))
           (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args)))))</pre> 
<p><b>Theorem: </b>pseudo-termp-of-car-of-ex-args-&gt;term-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     pseudo-termp-of-car-of-ex-args-&gt;term-lst
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____EX-ARGS-P.html">ex-args-p</a> expand-args)
                   (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args)))
              (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args)))))</pre> 
<p><b>Theorem: </b>len-equal-of-formals-of-pseudo-lambdap-and-actuals-of-pseudo-termp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 len-equal-of-formals-of-pseudo-lambdap-and-actuals-of-pseudo-termp
 (<a href="ACL2____IMPLIES.html">implies</a>
  (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____EX-ARGS-P.html">ex-args-p</a> expand-args)
       (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args)))
       (<a href="ACL2____PSEUDO-LAMBDAP.html">pseudo-lambdap</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args)))))
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> (<a href="COMMON-LISP____CADR.html">cadr</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args)))))
         (<a href="ACL2____LEN.html">len</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args)))))))</pre> 
<p><b>Theorem: </b>symbolp-of-caar-of-ex-args-&gt;term-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 symbolp-of-caar-of-ex-args-&gt;term-lst
 (<a href="ACL2____IMPLIES.html">implies</a>
  (<a href="COMMON-LISP____AND.html">and</a>
   (<a href="SMT____EX-ARGS-P.html">ex-args-p</a> expand-args)
   (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args))
   (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args))))
   (<a href="COMMON-LISP____NOT.html">not</a>
      (<a href="ACL2____PSEUDO-LAMBDAP.html">pseudo-lambdap</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args))))))
  (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args))))))</pre> 
<p><b>Theorem: </b>not-cddr-of-car-of-pseudo-term-list-fix-of-expand-args-&gt;term-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 not-cddr-of-car-of-pseudo-term-list-fix-of-expand-args-&gt;term-lst
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args))
               (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args)))
               (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args))))
               (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args)))
                      'quote))
          (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CDDR.html">cddr</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args))))))</pre> 
<p><b>Theorem: </b>consp-cdr-of-car-of-pseudo-term-list-fix-of-expand-args-&gt;term-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 consp-cdr-of-car-of-pseudo-term-list-fix-of-expand-args-&gt;term-lst
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args))
               (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args)))
               (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args))))
               (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args)))
                      'quote))
          (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args))))))</pre> 
<p><b>Theorem: </b>pseudo-term-listp-of-pseudo-lambdap-of-cdar-ex-args-&gt;term-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   pseudo-term-listp-of-pseudo-lambdap-of-cdar-ex-args-&gt;term-lst
   (<a href="ACL2____IMPLIES.html">implies</a>
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____EX-ARGS-P.html">ex-args-p</a> expand-args)
             (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args))
             (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args)))
             (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAAR.html">caar</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args))
                         'quote)))
        (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> (<a href="COMMON-LISP____CDAR.html">cdar</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args)))))</pre> 
<p><b>Theorem: </b>integerp-of-cdr-of-assoc-equal-of-ex-args-&gt;fn-lvls-of-ex-args-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  integerp-of-cdr-of-assoc-equal-of-ex-args-&gt;fn-lvls-of-ex-args-p
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____EX-ARGS-P.html">ex-args-p</a> x)
                (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> foo (<a href="SMT____EX-ARGS-_E3FN-LVLS.html">ex-args-&gt;fn-lvls</a> x)))
           (<a href="COMMON-LISP____INTEGERP.html">integerp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> foo (<a href="SMT____EX-ARGS-_E3FN-LVLS.html">ex-args-&gt;fn-lvls</a> x))))))</pre> 
<p><b>Theorem: </b>non-neg-of-cdr-of-assoc-equal-of-ex-args-&gt;fn-lvls-of-ex-args-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     non-neg-of-cdr-of-assoc-equal-of-ex-args-&gt;fn-lvls-of-ex-args-p
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____EX-ARGS-P.html">ex-args-p</a> x)
                   (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> foo (<a href="SMT____EX-ARGS-_E3FN-LVLS.html">ex-args-&gt;fn-lvls</a> x)))
              (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 0
                  (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> foo (<a href="SMT____EX-ARGS-_E3FN-LVLS.html">ex-args-&gt;fn-lvls</a> x))))))</pre> 
<p><b>Theorem: </b>consp-of-assoc-equal-of-ex-args-&gt;fn-lvls-of-ex-args-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> consp-of-assoc-equal-of-ex-args-&gt;fn-lvls-of-ex-args-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____EX-ARGS-P.html">ex-args-p</a> x)
                      (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> foo (<a href="SMT____EX-ARGS-_E3FN-LVLS.html">ex-args-&gt;fn-lvls</a> x)))
                 (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> foo (<a href="SMT____EX-ARGS-_E3FN-LVLS.html">ex-args-&gt;fn-lvls</a> x)))))</pre> 
<p><b>Theorem: </b>last-&lt;=</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> last-&lt;=
        (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> (<a href="COMMON-LISP____LAST.html">last</a> x))
            (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> x)))</pre> 
<p><b>Theorem: </b>last-pseudo-term-list-is-pseudo-term-list</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> last-pseudo-term-list-is-pseudo-term-list
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> x)
                 (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> (<a href="COMMON-LISP____LAST.html">last</a> x))))</pre> 
<p><b>Function: </b>expand</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 expand (expand-args fty-info abs state)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (<a href="ACL2____STATE.html">state</a>)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____EX-ARGS-P.html">ex-args-p</a> expand-args)
                             (<a href="SMT____FTY-INFO-ALIST-P.html">fty-info-alist-p</a> fty-info)
                             (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> abs))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'expand))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____B_A2.html">b*</a>
   ((expand-args (<a href="SMT____EX-ARGS-FIX.html">ex-args-fix</a> expand-args))
    (<a href="SMT____FTY-INFO.html">fty-info</a> (<a href="SMT____FTY-INFO-ALIST-FIX.html">fty-info-alist-fix</a> fty-info))
    ((<a href="SMT____EX-ARGS.html">ex-args</a> a) expand-args)
    ((unless (<a href="COMMON-LISP____CONSP.html">consp</a> a.term-lst))
     (<a href="SMT____MAKE-EX-OUTS.html">make-ex-outs</a> :expanded-term-lst nil
                   :expanded-fn-lst a.expand-lst))
    ((<a href="COMMON-LISP____CONS.html">cons</a> term rest) a.term-lst)
    ((<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> term))
     (<a href="ACL2____B_A2.html">b*</a> ((rest-res (<a href="SMT____EXPAND.html">expand</a> (<a href="SMT____CHANGE-EX-ARGS.html">change-ex-args</a> a :term-lst rest)
                            fty-info abs state))
          ((<a href="SMT____EX-OUTS.html">ex-outs</a> o) rest-res))
         (<a href="SMT____MAKE-EX-OUTS.html">make-ex-outs</a>
              :expanded-term-lst (<a href="COMMON-LISP____CONS.html">cons</a> term o.expanded-term-lst)
              :expanded-fn-lst o.expanded-fn-lst)))
    ((<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> term) 'quote))
     (<a href="ACL2____B_A2.html">b*</a> ((rest-res (<a href="SMT____EXPAND.html">expand</a> (<a href="SMT____CHANGE-EX-ARGS.html">change-ex-args</a> a :term-lst rest)
                            fty-info abs state))
          ((<a href="SMT____EX-OUTS.html">ex-outs</a> o) rest-res))
         (<a href="SMT____MAKE-EX-OUTS.html">make-ex-outs</a>
              :expanded-term-lst (<a href="COMMON-LISP____CONS.html">cons</a> term o.expanded-term-lst)
              :expanded-fn-lst o.expanded-fn-lst)))
    ((<a href="COMMON-LISP____CONS.html">cons</a> fn-call fn-actuals) term)
    ((<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____PSEUDO-LAMBDAP.html">pseudo-lambdap</a> fn-call))
     (<a href="ACL2____B_A2.html">b*</a>
      ((<a href="ACL2____LAMBDA-FORMALS.html">lambda-formals</a> (<a href="ACL2____LAMBDA-FORMALS.html">lambda-formals</a> fn-call))
       (body-res
        (<a href="SMT____EXPAND.html">expand</a>
             (<a href="SMT____CHANGE-EX-ARGS.html">change-ex-args</a> a
                             :term-lst (<a href="COMMON-LISP____LIST.html">list</a> (<a href="ACL2____LAMBDA-BODY.html">lambda-body</a> fn-call)))
             fty-info abs state))
       ((<a href="SMT____EX-OUTS.html">ex-outs</a> b) body-res)
       (<a href="ACL2____LAMBDA-BODY.html">lambda-body</a> (<a href="COMMON-LISP____CAR.html">car</a> b.expanded-term-lst))
       (actuals-res
            (<a href="SMT____EXPAND.html">expand</a> (<a href="SMT____CHANGE-EX-ARGS.html">change-ex-args</a> a
                                    :term-lst fn-actuals
                                    :expand-lst b.expanded-fn-lst)
                    fty-info abs state))
       ((<a href="SMT____EX-OUTS.html">ex-outs</a> ac) actuals-res)
       (lambda-actuals ac.expanded-term-lst)
       ((unless (<a href="ACL2____MBT.html">mbt</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> lambda-formals)
                            (<a href="ACL2____LEN.html">len</a> lambda-actuals))))
        (<a href="SMT____MAKE-EX-OUTS.html">make-ex-outs</a> :expanded-term-lst a.term-lst
                      :expanded-fn-lst a.expand-lst))
       (lambda-fn
          (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'lambda
                      (<a href="COMMON-LISP____CONS.html">cons</a> lambda-formals (<a href="COMMON-LISP____CONS.html">cons</a> lambda-body 'nil)))
                lambda-actuals))
       (rest-res
            (<a href="SMT____EXPAND.html">expand</a> (<a href="SMT____CHANGE-EX-ARGS.html">change-ex-args</a> a
                                    :term-lst rest
                                    :expand-lst ac.expanded-fn-lst)
                    fty-info abs state))
       ((<a href="SMT____EX-OUTS.html">ex-outs</a> r) rest-res))
      (<a href="SMT____MAKE-EX-OUTS.html">make-ex-outs</a>
           :expanded-term-lst (<a href="COMMON-LISP____CONS.html">cons</a> lambda-fn r.expanded-term-lst)
           :expanded-fn-lst r.expanded-fn-lst)))
    ((unless (<a href="ACL2____MBT.html">mbt</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> fn-call)))
     (<a href="SMT____MAKE-EX-OUTS.html">make-ex-outs</a> :expanded-term-lst a.term-lst
                   :expanded-fn-lst a.expand-lst))
    (fn (<a href="ACL2____HONS-GET.html">hons-get</a> fn-call a.fn-lst))
    ((unless fn)
     (<a href="ACL2____B_A2.html">b*</a>
      (((unless (<a href="ACL2____FUNCTION-SYMBOLP.html">function-symbolp</a> fn-call (<a href="ACL2____W.html">w</a> state)))
        (<a href="ACL2____PROG2_42.html">prog2$</a> (<a href="ACL2____ER.html">er</a> hard? 'smt-goal-generator=&gt;expand
                    "Should be a function call: ~q0"
                    fn-call)
                (<a href="SMT____MAKE-EX-OUTS.html">make-ex-outs</a> :expanded-term-lst a.term-lst
                              :expanded-fn-lst a.expand-lst)))
       (basic-function (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> fn-call *smt-basics*))
       (flex? (<a href="SMT____FNCALL-OF-FLEXTYPE.html">fncall-of-flextype</a> fn-call fty-info))
       (abs? (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> fn-call abs))
       (lvl-item (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> fn-call a.fn-lvls))
       (extract-res (<a href="ACL2____META-EXTRACT-FORMULA.html">meta-extract-formula</a> fn-call state))
       ((<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> fn-call 'return-last))
        (<a href="ACL2____B_A2.html">b*</a>
         ((actuals-res
               (<a href="SMT____EXPAND.html">expand</a> (<a href="SMT____CHANGE-EX-ARGS.html">change-ex-args</a> a
                                       :term-lst (<a href="COMMON-LISP____LAST.html">last</a> fn-actuals))
                       fty-info abs state))
          ((<a href="SMT____EX-OUTS.html">ex-outs</a> ac) actuals-res)
          (rest-res
             (<a href="SMT____EXPAND.html">expand</a> (<a href="SMT____CHANGE-EX-ARGS.html">change-ex-args</a> a
                                     :term-lst rest
                                     :expand-lst ac.expanded-fn-lst)
                     fty-info abs state))
          ((<a href="SMT____EX-OUTS.html">ex-outs</a> r) rest-res))
         (<a href="SMT____MAKE-EX-OUTS.html">make-ex-outs</a>
              :expanded-term-lst (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> ac.expanded-term-lst)
                                       r.expanded-term-lst)
              :expanded-fn-lst r.expanded-fn-lst)))
       ((<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____OR.html">or</a> basic-function
                flex? abs? (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> a.wrld-fn-len 0)
                (<a href="COMMON-LISP____AND.html">and</a> lvl-item (<a href="ACL2____ZP.html">zp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> lvl-item)))
                (<a href="COMMON-LISP____EQUAL.html">equal</a> extract-res ''t)))
        (<a href="ACL2____B_A2.html">b*</a>
         ((actuals-res
               (<a href="SMT____EXPAND.html">expand</a> (<a href="SMT____CHANGE-EX-ARGS.html">change-ex-args</a> a :term-lst fn-actuals)
                       fty-info abs state))
          ((<a href="SMT____EX-OUTS.html">ex-outs</a> ac) actuals-res)
          (rest-res
             (<a href="SMT____EXPAND.html">expand</a> (<a href="SMT____CHANGE-EX-ARGS.html">change-ex-args</a> a
                                     :term-lst rest
                                     :expand-lst ac.expanded-fn-lst)
                     fty-info abs state))
          ((<a href="SMT____EX-OUTS.html">ex-outs</a> r) rest-res))
         (<a href="SMT____MAKE-EX-OUTS.html">make-ex-outs</a> :expanded-term-lst
                       (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> fn-call ac.expanded-term-lst)
                             r.expanded-term-lst)
                       :expanded-fn-lst r.expanded-fn-lst)))
       (<a href="ACL2____FORMALS.html">formals</a> (<a href="ACL2____FORMALS.html">formals</a> fn-call (<a href="ACL2____W.html">w</a> state)))
       ((unless (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> formals))
        (<a href="ACL2____PROG2_42.html">prog2$</a>
         (<a href="ACL2____ER.html">er</a>
          hard? 'smt-goal-generator=&gt;expand
          "formals get a list that's not a symbol-listp for ~q0, the formals are ~q1"
          fn-call formals)
         (<a href="SMT____MAKE-EX-OUTS.html">make-ex-outs</a> :expanded-term-lst a.term-lst
                       :expanded-fn-lst a.expand-lst)))
       ((unless (<a href="ACL2____TRUE-LISTP.html">true-listp</a> extract-res))
        (<a href="ACL2____PROG2_42.html">prog2$</a>
         (<a href="ACL2____ER.html">er</a>
          hard? 'smt-goal-generator=&gt;expand
          "meta-extract-formula returning a non-true-listp for ~q0The extracted result is ~q1"
          fn-call extract-res)
         (<a href="SMT____MAKE-EX-OUTS.html">make-ex-outs</a> :expanded-term-lst a.term-lst
                       :expanded-fn-lst a.expand-lst)))
       (<a href="ACL2____BODY.html">body</a> (<a href="COMMON-LISP____NTH.html">nth</a> 2 extract-res))
       ((unless (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> body))
        (<a href="ACL2____PROG2_42.html">prog2$</a>
         (<a href="ACL2____ER.html">er</a>
          hard? 'smt-goal-generator=&gt;expand
          "meta-extract-formula returning a non-pseudo-term for ~q0The body is ~q1"
          fn-call body)
         (<a href="SMT____MAKE-EX-OUTS.html">make-ex-outs</a> :expanded-term-lst a.term-lst
                       :expanded-fn-lst a.expand-lst)))
       (updated-expand-lst
            (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> term a.expand-lst)
                a.expand-lst
                (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> term term) a.expand-lst)))
       (body-res
        (<a href="SMT____EXPAND.html">expand</a>
         (<a href="SMT____CHANGE-EX-ARGS.html">change-ex-args</a> a
                         :term-lst (<a href="COMMON-LISP____LIST.html">list</a> body)
                         :fn-lvls (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> fn-call '0) a.fn-lvls)
                         :wrld-fn-len (<a href="COMMON-LISP____1-.html">1-</a> a.wrld-fn-len)
                         :expand-lst updated-expand-lst)
         fty-info abs state))
       ((<a href="SMT____EX-OUTS.html">ex-outs</a> b) body-res)
       (expanded-lambda-body (<a href="COMMON-LISP____CAR.html">car</a> b.expanded-term-lst))
       (expanded-lambda
            (<a href="COMMON-LISP____CONS.html">cons</a> 'lambda
                  (<a href="COMMON-LISP____CONS.html">cons</a> formals
                        (<a href="COMMON-LISP____CONS.html">cons</a> expanded-lambda-body 'nil))))
       (actuals-res
            (<a href="SMT____EXPAND.html">expand</a> (<a href="SMT____CHANGE-EX-ARGS.html">change-ex-args</a> a
                                    :term-lst fn-actuals
                                    :expand-lst b.expanded-fn-lst)
                    fty-info abs state))
       ((<a href="SMT____EX-OUTS.html">ex-outs</a> ac) actuals-res)
       (expanded-term-list ac.expanded-term-lst)
       ((unless (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> formals)
                       (<a href="ACL2____LEN.html">len</a> expanded-term-list)))
        (<a href="ACL2____PROG2_42.html">prog2$</a>
         (<a href="ACL2____ER.html">er</a>
          hard? 'smt-goal-generator=&gt;expand
          "You called your function with the wrong number of actuals: ~q0"
          term)
         (<a href="SMT____MAKE-EX-OUTS.html">make-ex-outs</a> :expanded-term-lst a.term-lst
                       :expanded-fn-lst ac.expanded-fn-lst)))
       (rest-res
            (<a href="SMT____EXPAND.html">expand</a> (<a href="SMT____CHANGE-EX-ARGS.html">change-ex-args</a> a
                                    :term-lst rest
                                    :expand-lst ac.expanded-fn-lst)
                    fty-info abs state))
       ((<a href="SMT____EX-OUTS.html">ex-outs</a> r) rest-res))
      (<a href="SMT____MAKE-EX-OUTS.html">make-ex-outs</a> :expanded-term-lst
                    (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> expanded-lambda expanded-term-list)
                          r.expanded-term-lst)
                    :expanded-fn-lst r.expanded-fn-lst)))
    (lvl-item (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> fn-call a.fn-lvls))
    ((unless lvl-item)
     (<a href="ACL2____PROG2_42.html">prog2$</a>
      (<a href="ACL2____ER.html">er</a>
       hard? 'smt-goal-generator=&gt;expand
       "Function ~q0 exists in the definition list but not in the levels list?"
       fn-call)
      (<a href="SMT____MAKE-EX-OUTS.html">make-ex-outs</a> :expanded-term-lst a.term-lst
                    :expanded-fn-lst a.expand-lst)))
    ((<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> lvl-item)))
     (<a href="ACL2____B_A2.html">b*</a>
      ((actuals-res (<a href="SMT____EXPAND.html">expand</a> (<a href="SMT____CHANGE-EX-ARGS.html">change-ex-args</a> a :term-lst fn-actuals)
                            fty-info abs state))
       ((<a href="SMT____EX-OUTS.html">ex-outs</a> ac) actuals-res)
       (rest-res
            (<a href="SMT____EXPAND.html">expand</a> (<a href="SMT____CHANGE-EX-ARGS.html">change-ex-args</a> a
                                    :term-lst rest
                                    :expand-lst ac.expanded-fn-lst)
                    fty-info abs state))
       ((<a href="SMT____EX-OUTS.html">ex-outs</a> r) rest-res))
      (<a href="SMT____MAKE-EX-OUTS.html">make-ex-outs</a>
        :expanded-term-lst (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> fn-call ac.expanded-term-lst)
                                 r.expanded-term-lst)
        :expanded-fn-lst r.expanded-fn-lst)))
    (new-fn-lvls (update-fn-lvls fn-call a.fn-lvls))
    ((<a href="SMT____FUNC.html">func</a> f) (<a href="COMMON-LISP____CDR.html">cdr</a> fn))
    (extract-res (<a href="ACL2____META-EXTRACT-FORMULA.html">meta-extract-formula</a> fn-call state))
    ((unless (<a href="ACL2____TRUE-LISTP.html">true-listp</a> extract-res))
     (<a href="ACL2____PROG2_42.html">prog2$</a>
      (<a href="ACL2____ER.html">er</a>
       hard? 'smt-goal-generator=&gt;expand
       "meta-extract-formula returning a non-true-listp for ~q0The extracted result is ~q1"
       fn-call extract-res)
      (<a href="SMT____MAKE-EX-OUTS.html">make-ex-outs</a> :expanded-term-lst a.term-lst
                    :expanded-fn-lst a.expand-lst)))
    (<a href="ACL2____BODY.html">body</a> (<a href="COMMON-LISP____NTH.html">nth</a> 2 extract-res))
    ((unless (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> body))
     (<a href="ACL2____PROG2_42.html">prog2$</a>
      (<a href="ACL2____ER.html">er</a>
       hard? 'smt-goal-generator=&gt;expand
       "meta-extract-formula returning a non-pseudo-term for ~q0The body is ~q1"
       fn-call body)
      (<a href="SMT____MAKE-EX-OUTS.html">make-ex-outs</a> :expanded-term-lst a.term-lst
                    :expanded-fn-lst a.expand-lst)))
    (updated-expand-lst (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> term a.expand-lst)
                            a.expand-lst
                            (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> term term) a.expand-lst)))
    (<a href="ACL2____FORMALS.html">formals</a> f.flattened-formals)
    (body-res
         (<a href="SMT____EXPAND.html">expand</a> (<a href="SMT____CHANGE-EX-ARGS.html">change-ex-args</a> a
                                 :term-lst (<a href="COMMON-LISP____LIST.html">list</a> body)
                                 :fn-lvls new-fn-lvls
                                 :expand-lst updated-expand-lst)
                 fty-info abs state))
    ((<a href="SMT____EX-OUTS.html">ex-outs</a> b) body-res)
    (expanded-lambda-body (<a href="COMMON-LISP____CAR.html">car</a> b.expanded-term-lst))
    (expanded-lambda (<a href="COMMON-LISP____CONS.html">cons</a> 'lambda
                           (<a href="COMMON-LISP____CONS.html">cons</a> formals
                                 (<a href="COMMON-LISP____CONS.html">cons</a> expanded-lambda-body 'nil))))
    (actuals-res
         (<a href="SMT____EXPAND.html">expand</a> (<a href="SMT____CHANGE-EX-ARGS.html">change-ex-args</a> a
                                 :term-lst fn-actuals
                                 :expand-lst b.expanded-fn-lst)
                 fty-info abs state))
    ((<a href="SMT____EX-OUTS.html">ex-outs</a> ac) actuals-res)
    (expanded-term-list ac.expanded-term-lst)
    ((unless (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> formals)
                    (<a href="ACL2____LEN.html">len</a> expanded-term-list)))
     (<a href="ACL2____PROG2_42.html">prog2$</a>
      (<a href="ACL2____ER.html">er</a>
       hard? 'smt-goal-generator=&gt;expand
       "You called your function with the wrong number of actuals: ~q0"
       term)
      (<a href="SMT____MAKE-EX-OUTS.html">make-ex-outs</a> :expanded-term-lst a.term-lst
                    :expanded-fn-lst ac.expanded-fn-lst)))
    (rest-res
         (<a href="SMT____EXPAND.html">expand</a> (<a href="SMT____CHANGE-EX-ARGS.html">change-ex-args</a> a
                                 :term-lst rest
                                 :expand-lst ac.expanded-fn-lst)
                 fty-info abs state))
    ((<a href="SMT____EX-OUTS.html">ex-outs</a> r) rest-res))
   (<a href="SMT____MAKE-EX-OUTS.html">make-ex-outs</a> :expanded-term-lst
                 (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> expanded-lambda expanded-term-list)
                       r.expanded-term-lst)
                 :expanded-fn-lst r.expanded-fn-lst))))</pre> 
<p><b>Theorem: </b>ex-outs-p-of-expand</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     ex-outs-p-of-expand
     (<a href="ACL2____B_A2.html">b*</a> ((expanded-result (<a href="SMT____EXPAND.html">expand</a> expand-args fty-info abs state)))
         (<a href="SMT____EX-OUTS-P.html">ex-outs-p</a> expanded-result))
     :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-expand</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 pseudo-term-alistp-of-expand
 (<a href="ACL2____B_A2.html">b*</a>
  ((expanded-result (<a href="SMT____EXPAND.html">expand</a> expand-args fty-info abs state)))
  (<a href="ACL2____IMPLIES.html">implies</a>
   (<a href="SMT____EX-ARGS-P.html">ex-args-p</a> expand-args)
   (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="SMT____EX-OUTS-_E3EXPANDED-FN-LST.html">ex-outs-&gt;expanded-fn-lst</a> expanded-result))))
 :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>pseudo-term-listp-of-expand</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   pseudo-term-listp-of-expand
   (<a href="ACL2____B_A2.html">b*</a> ((expanded-result (<a href="SMT____EXPAND.html">expand</a> expand-args fty-info abs state)))
       (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____EX-ARGS-P.html">ex-args-p</a> expand-args)
                (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a>
                     (<a href="SMT____EX-OUTS-_E3EXPANDED-TERM-LST.html">ex-outs-&gt;expanded-term-lst</a> expanded-result))))
   :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>pseudo-termp-of-car-of-expand</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 pseudo-termp-of-car-of-expand
 (<a href="ACL2____B_A2.html">b*</a> ((expanded-result (<a href="SMT____EXPAND.html">expand</a> expand-args fty-info abs state)))
     (<a href="ACL2____IMPLIES.html">implies</a>
          (<a href="SMT____EX-ARGS-P.html">ex-args-p</a> expand-args)
          (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a>
               (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____EX-OUTS-_E3EXPANDED-TERM-LST.html">ex-outs-&gt;expanded-term-lst</a> expanded-result)))))
 :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>len-of-expand</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 len-of-expand
 (<a href="ACL2____B_A2.html">b*</a>
  ((expanded-result (<a href="SMT____EXPAND.html">expand</a> expand-args fty-info abs state)))
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____EX-ARGS-P.html">ex-args-p</a> expand-args)
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> (<a href="SMT____EX-OUTS-_E3EXPANDED-TERM-LST.html">ex-outs-&gt;expanded-term-lst</a> expanded-result))
                  (<a href="ACL2____LEN.html">len</a> (<a href="SMT____EX-ARGS-_E3TERM-LST.html">ex-args-&gt;term-lst</a> expand-args)))))
 :rule-classes :rewrite)</pre> 

</body>
</html>
