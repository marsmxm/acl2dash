<html>
<head>
<meta charset="UTF-8">
<title>Defmax-nat</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____DEFMAX-NAT">Click for Defmax-nat in the Full Manual</a></h3>

<p>Declaratively define the maximum of a set of natural numbers.</p><h3>Introduction</h3><p>This macro captures the mathematical notation 
      \max\: \{y \in \mathbb{N} \mid \psi[x_1,\ldots,x_n,y]\}, 
      where \mathbb{N} is the set of natural numbers, 
      n \geq 0, 
      and \psi[x_1,\ldots,x_n,y] is a formula 
      that depends on x_1,\ldots,x_n and y. 
      Each value of the tuple \langle x_1, \ldots, x_n \rangle 
      defines a set of natural numbers, 
      which may or may not have a maximum; 
      if it does not, we regard \max as returning a special value 
      distinct from all the natural numbers, e.g. \bot. 
      Thus, the mathematical notation above defines a function 
      from n-tuples to natural numbers or \bot.</p><p>This macro introduces such a function, 
      from a user-supplied term that represents \psi[x_1,\ldots,x_n,y]. 
      The user also supplies 
      the variables to use as x_1,\ldots,x_n and y, 
      as well as an optional term over x_1,\ldots,x_n 
      to use as the function's guard.</p><p>Besides the function itself, 
      this macro introduces auxiliary functions and theorems upon which 
      the function definition is based, 
      as well as theorems about the function. 
      It also introduces theorems to help reason about the function, 
      in particular to establish that the maximum exists 
      without having to calculate it explicitly, 
      and to establish that the maximum is a certain value.</p><p>See <span class="tt"><a href="ACL2____DEFMIN-INT.html">defmin-int</a></span> for a related tool.</p><h3>General Form</h3><pre class="code">(<a href="ACL2____DEFMAX-NAT.html">defmax-nat</a> f y (x1 ... xn)
  body
  :guard ...          ; default t
  :verify-guards ...  ; default t
  )</pre><h3>Inputs</h3><p><span class="v">f</span></p><blockquote><p>Name of the function to introduce.</p></blockquote><p><span class="v">y</span></p><blockquote>
<p>Name of the variable to use as y.</p>
<p>This is the variable bound in the set comprehension 
       of the mathematical notation shown above. 
       Note that the syntax of <span class="v">defmax-nat</span> is similar to 
       the syntax of <span class="tt"><a href="ACL2____DEFCHOOSE.html">defchoose</a></span> in this respect.</p>
</blockquote><p><span class="v">(x1 ... xn)</span></p><blockquote>
<p>List of the names of the zero or more variables 
       to use as x_1,\ldots,x_n.</p>
<p>These are the formal parameters of <span class="v">f</span>.</p>
</blockquote><p><span class="v">body</span></p><blockquote>
<p>Term to use as the formula \psi[x_1,\ldots,x_n,y].</p>
<p>Its only free variables must be among 
       <span class="v">x1</span>, ..., <span class="v">xn</span>, and <span class="v">y</span>.</p>
<p>We write this term as <span class="v">body&lt;x1,...,xn,y&gt;</span>, 
       emphasizing its dependence on the variables.</p>
</blockquote><p><span class="v">:guard</span> — default <span class="v">t</span></p><blockquote>
<p>Term to use as the guard of <span class="v">f</span>.</p>
<p>Its only free variables must be among <span class="v">x1</span>, ..., <span class="v">xn</span>.</p>
<p>Let <span class="v">guard&lt;x1,...,xn&gt;</span> be this term, 
       emphasizing its dependence on the variables.</p>
</blockquote><p><span class="v">:verify-guards</span> — default <span class="v">t</span></p><blockquote><p>Determines whether the guards of <span class="v">f</span>, 
       and of the auxiliary functions generated, 
       should be verified or not.</p></blockquote><p>The current implementation of this macro 
      does not thoroughly validate its inputs, 
      but errors caused by the generated functions and theorems 
      should be relatively easy to debug, 
      based on the documentation below, 
      and possibly on the examination of the implementation, 
      which uses a readable backquote notation. 
      Nonetheless, the implementation of this macro 
      may be improved in the future 
      to validate its inputs more thoroughly.</p><h3>Generated Events</h3><p>See the file <span class="v">defmax-nat-template.lisp</span> for more explanations 
      about the generated functions and theorems.</p><p>Except for <span class="v">f</span> itself, 
      the names of the generated functions consist of the name of <span class="v">f</span> 
      followed by <span class="v">.</span> and by the suffixes described below. 
      All the functions are guard-verified iff <span class="v">:verify-guards</span> is <span class="v">t</span>. 
      All the functions are disabled; 
      all the rewrite rules associated with the <span class="tt"><a href="ACL2____DEFUN-SK.html">defun-sk</a></span>s 
      are disabled; 
      if <span class="v">n</span> is 0, i.e. <span class="v">f</span> has no arguments, 
      the executable counterpart of <span class="v">f</span> is disabled as well, 
      to prevent ACL2 from wrapping calls <span class="v">(f)</span> into <span class="tt"><a href="ACL2____HIDE.html">hide</a></span>.</p><p><span class="v">f.elementp</span></p><blockquote>
<p>Auxiliary function to test the membership of <span class="v">y</span> 
       in the set defined by <span class="v">x1</span>, ..., <span class="v">xn</span>.</p>
<pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> f.elementp (x1 ... xn y)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> guard&lt;x1,...,xn&gt; (<a href="ACL2____NATP.html">natp</a> y))))
  body&lt;x1,...,xn,y&gt;)</pre>
</blockquote><p><span class="v">f.uboundp</span></p><blockquote>
<p>Auxiliary predicate asserting that 
       <span class="v">y</span> is an upper bound of the set defined by <span class="v">x1</span>, ..., <span class="v">xn</span>, 
       along with associated theorems.</p>
<pre class="code">(<a href="ACL2____DEFUN-SK.html">defun-sk</a> f.uboundp (x1 ... xn y)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> guard&lt;x1,...,xn&gt; (<a href="ACL2____NATP.html">natp</a> y))))
  (<a href="ACL2____FORALL.html">forall</a> (y1)
          (<a href="ACL2____IMPLIEZ.html">impliez</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> y1)
                        (f.elementp x1 ... xn y1))
                   (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> (<a href="ACL2____NFIX.html">nfix</a> y) y1)))
  :rewrite (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (f.uboundp x1 ... xn y)
                         (<a href="ACL2____NATP.html">natp</a> y1)
                         (f.elementp x1 ... xn y1))
                    (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> (<a href="ACL2____NFIX.html">nfix</a> y) y1)))

(<a href="ACL2____DEFTHM.html">defthm</a> booleanp-of-f.uboundp
  (<a href="ACL2____BOOLEANP.html">booleanp</a> (f.uboundp x1 ... xn y)))</pre>
</blockquote><p><span class="v">f.existsp</span></p><blockquote>
<p>Auxiliary predicate asserting that 
       the set defined by <span class="v">x1</span>, ..., <span class="v">xn</span> has a maximum, 
       along with associated theorems.</p>
<pre class="code">(<a href="ACL2____DEFUN-SK.html">defun-sk</a> f.existsp (x1 ... xn)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard guard&lt;x1,...,xn&gt;))
  (<a href="ACL2____EXISTS.html">exists</a> (y)
          (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> y)
               (f.elementp x1 ... xn y)
               (f.uboundp x1 ... xn y))))

(<a href="ACL2____DEFTHM.html">defthm</a> booleanp-of-f.existsp
  (<a href="ACL2____BOOLEANP.html">booleanp</a> (f.existsp x1 ... xn)))</pre>
</blockquote><p><span class="v">f</span></p><blockquote>
<p>The function that returns the maximum if it exists (otherwise <span class="v">nil</span>), 
       along with associated theorems.</p>
<pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> f (x1 ... xn)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard guard&lt;x1,...,xn&gt;))
  (<a href="COMMON-LISP____IF.html">if</a> (f.existsp x1 ... xn)
      (f.existsp-witness x1 ... xn)
    nil))

(<a href="ACL2____DEFTHM.html">defthm</a> maybe-natp-of-f
  (<a href="ACL2____MAYBE-NATP.html">maybe-natp</a> (f x1 ... xn)))

(<a href="ACL2____DEFTHM.html">defthm</a> natp-of-f-equal-f.existsp
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____NATP.html">natp</a> (f x1 ... xn))
         (f.existsp x1 ... xn)))

(<a href="ACL2____DEFTHM.html">defthm</a> natp-of-f-when-f.existsp
  (<a href="ACL2____IMPLIES.html">implies</a> (f.existsp x1 ... xn)
           (<a href="ACL2____NATP.html">natp</a> (f x1 ... xn)))
  :rule-classes :type-prescription)

(<a href="ACL2____DEFTHM.html">defthm</a> f-iff-f.existsp
  (<a href="ACL2____IFF.html">iff</a> (f x1 ... xn)
       (f.existsp x1 ... xn)))

(<a href="ACL2____DEFTHM.html">defthm</a> not-f-when-not-f.existsp
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (f.existsp x1 ... xn))
           (<a href="COMMON-LISP____NOT.html">not</a> (f x1 ... xn)))
  :rule-classes :type-prescription)

(<a href="ACL2____DEFTHM.html">defthm</a> f.elementp-of-f-when-f.existsp
  (<a href="ACL2____IMPLIES.html">implies</a> (f.existsp x1 ... xn)
           (f.elementp x1 ... xn (f x1 ... xn))))

(<a href="ACL2____DEFTHM.html">defthm</a> f.uboundp-of-f-when-f.existsp
  (<a href="ACL2____IMPLIES.html">implies</a> (f.existsp x1 ... xn)
           (f.uboundp x1 ... xn (f x1 ... xn))))

(<a href="ACL2____DEFTHM.html">defthm</a> f-geq-when-f.existsp-linear
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (f.existsp x1 ... xn)
                (f.elementp x1 ... xn y1) ;; bind free y1
                (<a href="ACL2____NATP.html">natp</a> y1))
           (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> (f x1 ... xn) y1))
  :rule-classes :linear)

(<a href="ACL2____DEFTHM.html">defthm</a> f-geq-when-f.existsp-rewrite
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (f.existsp x1 ... xn)
                (f.elementp x1 ... xn y1)
                (<a href="ACL2____NATP.html">natp</a> y1))
           (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> (f x1 ... xn) y1))

(<a href="ACL2____DEFTHM.html">defthm</a> f-leq-when-f.existsp-linear
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (f.existsp x1 ... xn)
                (f.uboundp x1 ... xn y1) ;; bind free y1
                (<a href="ACL2____NATP.html">natp</a> y1))
           (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (f x1 ... xn) y1))
  :rule-classes :linear)

(<a href="ACL2____DEFTHM.html">defthm</a> f-leq-when-f.existsp-rewrite
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (f.existsp x1 ... xn)
                (f.uboundp x1 ... xn y1)
                (<a href="ACL2____NATP.html">natp</a> y1))
           (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (f x1 ... xn) y1))</pre>
</blockquote><p><span class="v">f.existsp-when-nonempty-and-bounded</span></p><blockquote>
<p>The helper theorem to establish that the maximum exists 
       by exhibiting a member and a bound of the set.</p>
<pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> f.existsp-when-nonempty-and-bounded
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> y0)
                (f.elementp x1 ... xn y0)
                (<a href="ACL2____NATP.html">natp</a> y1)
                (f.uboundp x1 ... xn y1))
           (f.existsp x1 ... xn))
  :rule-classes nil)</pre>
</blockquote><p><span class="v">f.equal-when-member-and-ubound</span></p><blockquote>
<p>The helper theorem to establish that the maximum has a certain value 
       by showing that that value is 
       both a member and an upper bound of the set.</p>
<pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> f.equal-when-member-and-ubound
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> y)
                (f.elementp x1 ... xn y)
                (f.uboundp x1 ... xn y))
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (f x) y))
  :rule-classes nil)</pre>
</blockquote><p>The current implementation of this macro 
      does not attempt to generate robust proofs. 
      The generated proofs may implicitly rely on rules that, 
      if disabled, may cause the proofs to fail. 
      However, the generated theorems should be always provable. 
      The implementation of this macro will be improved in the future 
      to generate more robust proofs.</p><h3>Future Work</h3><p>This macro may be generalized from natural numbers to integer numbers, 
     or to other suitably ordered domains.</p><p>Besides maxima and minima (also see <span class="tt"><a href="ACL2____DEFMIN-INT.html">defmin-int</a></span>), 
     similar macros could be introduced to declaratively define 
     suprema and infima.</p>
</body>
</html>
