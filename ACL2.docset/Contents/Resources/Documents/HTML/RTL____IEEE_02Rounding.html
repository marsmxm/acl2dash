<html>
<head>
<meta charset="UTF-8">
<title>IEEE Rounding</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=RTL____IEEE_02Rounding">Click for IEEE Rounding in the Full Manual</a></h3>

<p>IEEE Rounding</p><h3>Definitions and Theorems</h3><p><b>Function: </b>rup</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     rup (x n)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____REAL_F2RATIONALP.html">real/rationalp</a> x) (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n))))
     (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> x 0) (raz x n) (rtz x n)))</pre><p><b>Function: </b>rdn</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     rdn (x n)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____REAL_F2RATIONALP.html">real/rationalp</a> x) (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n))))
     (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> x 0) (rtz x n) (raz x n)))</pre><p><b>Theorem: </b>rup-lower-bound</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rup-lower-bound
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____CASE-SPLIT.html">case-split</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x))
                      (<a href="ACL2____CASE-SPLIT.html">case-split</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)))
                 (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> (rup x n) x))
        :rule-classes :linear)</pre><p><b>Theorem: </b>rdn-upper-bound</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rdn-upper-bound
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____CASE-SPLIT.html">case-split</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x))
                      (<a href="ACL2____CASE-SPLIT.html">case-split</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)))
                 (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (rdn x n) x))
        :rule-classes :linear)</pre><p><b>Function: </b>ieee-rounding-mode-p</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> ieee-rounding-mode-p (mode)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____MEMBER.html">member</a> mode '(rtz rup rdn rne)))</pre><p><b>Function: </b>common-mode-p</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> common-mode-p (mode)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____OR.html">or</a> (ieee-rounding-mode-p mode)
           (<a href="COMMON-LISP____EQUAL.html">equal</a> mode 'raz)
           (<a href="COMMON-LISP____EQUAL.html">equal</a> mode 'rna)))</pre><p><b>Theorem: </b>ieee-mode-is-common-mode</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ieee-mode-is-common-mode
        (<a href="ACL2____IMPLIES.html">implies</a> (ieee-rounding-mode-p mode)
                 (common-mode-p mode)))</pre><p><b>Function: </b>rnd</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> rnd (x mode n)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____REAL_F2RATIONALP.html">real/rationalp</a> x)
                                   (common-mode-p mode)
                                   (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n))))
       (<a href="COMMON-LISP____CASE.html">case</a> mode (raz (raz x n))
             (rna (rna x n))
             (rtz (rtz x n))
             (rup (rup x n))
             (rdn (rdn x n))
             (rne (rne x n))
             (otherwise 0)))</pre><p><b>Theorem: </b>rationalp-rnd</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rationalp-rnd (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> (rnd x mode n))
        :rule-classes (:type-prescription))</pre><p><b>Theorem: </b>rnd-choice</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rnd-choice
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)
                      (common-mode-p mode))
                 (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP_____D3.html">=</a> (rnd x mode n) (rtz x n))
                     (<a href="COMMON-LISP_____D3.html">=</a> (rnd x mode n) (raz x n))))
        :rule-classes nil)</pre><p><b>Theorem: </b>sgn-rnd</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sgn-rnd
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (common-mode-p mode)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)
                      (<a href="COMMON-LISP_____E3.html">&gt;</a> n 0))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (sgn (rnd x mode n)) (sgn x))))</pre><p><b>Theorem: </b>rnd-positive</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rnd-positive
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> 0 x)
                      (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)
                      (<a href="COMMON-LISP_____E3.html">&gt;</a> n 0)
                      (common-mode-p mode))
                 (<a href="COMMON-LISP_____E3.html">&gt;</a> (rnd x mode n) 0))
        :rule-classes (:type-prescription))</pre><p><b>Theorem: </b>rnd-negative</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rnd-negative
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> x 0)
                      (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)
                      (<a href="COMMON-LISP_____E3.html">&gt;</a> n 0)
                      (common-mode-p mode))
                 (<a href="COMMON-LISP_____C3.html">&lt;</a> (rnd x mode n) 0))
        :rule-classes (:type-prescription))</pre><p><b>Theorem: </b>rnd-0</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rnd-0 (<a href="COMMON-LISP____EQUAL.html">equal</a> (rnd 0 mode n) 0))</pre><p><b>Theorem: </b>rnd-non-pos</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rnd-non-pos
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> x 0) (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (rnd x mode n) 0))
        :rule-classes (:rewrite :type-prescription :linear))</pre><p><b>Theorem: </b>rnd-non-neg</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rnd-non-neg
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 0 x) (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 0 (rnd x mode n)))
        :rule-classes (:rewrite :type-prescription :linear))</pre><p><b>Function: </b>flip-mode</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> flip-mode (m)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (common-mode-p m)))
       (<a href="COMMON-LISP____CASE.html">case</a> m (rup 'rdn) (rdn 'rup) (t m)))</pre><p><b>Theorem: </b>ieee-rounding-mode-p-flip-mode</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ieee-rounding-mode-p-flip-mode
        (<a href="ACL2____IMPLIES.html">implies</a> (ieee-rounding-mode-p m)
                 (ieee-rounding-mode-p (flip-mode m))))</pre><p><b>Theorem: </b>common-mode-p-flip-mode</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> common-mode-p-flip-mode
        (<a href="ACL2____IMPLIES.html">implies</a> (common-mode-p m)
                 (common-mode-p (flip-mode m))))</pre><p><b>Theorem: </b>rnd-minus</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rnd-minus
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (rnd (<a href="COMMON-LISP____-.html">-</a> x) mode n)
               (<a href="COMMON-LISP____-.html">-</a> (rnd x (flip-mode mode) n))))</pre><p><b>Theorem: </b>rnd-exactp-a</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rnd-exactp-a
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> 0 n)
                 (exactp (rnd x mode n) n)))</pre><p><b>Theorem: </b>rnd-exactp-b</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rnd-exactp-b
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x)
                      (common-mode-p mode)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)
                      (<a href="COMMON-LISP_____E3.html">&gt;</a> n 0))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (exactp x n)
                        (<a href="COMMON-LISP____EQUAL.html">equal</a> x (rnd x mode n)))))</pre><p><b>Theorem: </b>rnd-exactp-c</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rnd-exactp-c
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x)
                      (common-mode-p mode)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)
                      (<a href="COMMON-LISP_____E3.html">&gt;</a> n 0)
                      (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> a)
                      (exactp a n)
                      (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> a x))
                 (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> a (rnd x mode n)))
        :rule-classes nil)</pre><p><b>Theorem: </b>rnd-exactp-d</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rnd-exactp-d
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x)
                      (common-mode-p mode)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)
                      (<a href="COMMON-LISP_____E3.html">&gt;</a> n 0)
                      (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> a)
                      (exactp a n)
                      (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> a x))
                 (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> a (rnd x mode n)))
        :rule-classes nil)</pre><p><b>Theorem: </b>rnd&lt;=raz</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rnd&lt;=raz
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x)
                      (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> x 0)
                      (common-mode-p mode)
                      (<a href="ACL2____NATP.html">natp</a> n))
                 (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (rnd x mode n) (raz x n)))
        :rule-classes nil)</pre><p><b>Theorem: </b>rnd&gt;=rtz</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rnd&gt;=rtz
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x)
                      (<a href="COMMON-LISP_____E3.html">&gt;</a> x 0)
                      (common-mode-p mode)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)
                      (<a href="COMMON-LISP_____E3.html">&gt;</a> n 0))
                 (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> (rnd x mode n) (rtz x n)))
        :rule-classes nil)</pre><p><b>Theorem: </b>rnd&lt;equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rnd&lt;equal
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x)
                      (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> y)
                      (<a href="ACL2____NATP.html">natp</a> n)
                      (common-mode-p mode)
                      (<a href="COMMON-LISP_____E3.html">&gt;</a> n 0)
                      (<a href="COMMON-LISP_____E3.html">&gt;</a> x 0)
                      (<a href="COMMON-LISP____NOT.html">not</a> (exactp x (<a href="COMMON-LISP____1_B2.html">1+</a> n)))
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> (rtz x (<a href="COMMON-LISP____1_B2.html">1+</a> n)) y)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> y x))
                 (<a href="COMMON-LISP_____D3.html">=</a> (rnd y mode n) (rnd x mode n)))
        :rule-classes nil)</pre><p><b>Theorem: </b>rnd&gt;equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rnd&gt;equal
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x)
                      (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> y)
                      (<a href="ACL2____NATP.html">natp</a> n)
                      (common-mode-p mode)
                      (<a href="COMMON-LISP_____E3.html">&gt;</a> n 0)
                      (<a href="COMMON-LISP_____E3.html">&gt;</a> x 0)
                      (<a href="COMMON-LISP____NOT.html">not</a> (exactp x (<a href="COMMON-LISP____1_B2.html">1+</a> n)))
                      (<a href="COMMON-LISP_____E3.html">&gt;</a> (raz x (<a href="COMMON-LISP____1_B2.html">1+</a> n)) y)
                      (<a href="COMMON-LISP_____E3.html">&gt;</a> y x))
                 (<a href="COMMON-LISP_____D3.html">=</a> (rnd y mode n) (rnd x mode n)))
        :rule-classes nil)</pre><p><b>Theorem: </b>rnd-near-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   rnd-near-equal
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x)
                 (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> y)
                 (<a href="ACL2____NATP.html">natp</a> n)
                 (common-mode-p mode)
                 (<a href="COMMON-LISP_____E3.html">&gt;</a> n 0)
                 (<a href="COMMON-LISP_____E3.html">&gt;</a> x 0)
                 (<a href="COMMON-LISP____NOT.html">not</a> (exactp x (<a href="COMMON-LISP____1_B2.html">1+</a> n))))
            (<a href="COMMON-LISP____LET.html">let</a> ((d (<a href="COMMON-LISP____MIN.html">min</a> (<a href="COMMON-LISP____-.html">-</a> x (rtz x (<a href="COMMON-LISP____1_B2.html">1+</a> n)))
                          (<a href="COMMON-LISP____-.html">-</a> (raz x (<a href="COMMON-LISP____1_B2.html">1+</a> n)) x))))
                 (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____E3.html">&gt;</a> d 0)
                      (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="COMMON-LISP____ABS.html">abs</a> (<a href="COMMON-LISP____-.html">-</a> x y)) d)
                               (<a href="COMMON-LISP_____D3.html">=</a> (rnd y mode n) (rnd x mode n))))))
   :rule-classes nil)</pre><p><b>Theorem: </b>expo-rnd</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> expo-rnd
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)
                      (<a href="COMMON-LISP_____E3.html">&gt;</a> n 0)
                      (common-mode-p mode)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____ABS.html">abs</a> (rnd x mode n))
                              (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP____1_B2.html">1+</a> (expo x))))))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (expo (rnd x mode n)) (expo x))))</pre><p><b>Theorem: </b>rnd-monotone</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rnd-monotone
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> x y)
                      (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x)
                      (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> y)
                      (common-mode-p mode)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)
                      (<a href="COMMON-LISP_____E3.html">&gt;</a> n 0))
                 (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (rnd x mode n) (rnd y mode n)))
        :rule-classes nil)</pre><p><b>Theorem: </b>rnd-shift</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rnd-shift
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)
                      (common-mode-p mode)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> k))
                 (<a href="COMMON-LISP_____D3.html">=</a> (rnd (<a href="COMMON-LISP_____A2.html">*</a> x (<a href="COMMON-LISP____EXPT.html">expt</a> 2 k)) mode n)
                    (<a href="COMMON-LISP_____A2.html">*</a> (rnd x mode n) (<a href="COMMON-LISP____EXPT.html">expt</a> 2 k))))
        :rule-classes nil)</pre><p><b>Theorem: </b>plus-rnd</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> plus-rnd
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x)
                      (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> x 0)
                      (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> y)
                      (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> y 0)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> k)
                      (exactp x (<a href="COMMON-LISP_____B2.html">+</a> -1 k (<a href="COMMON-LISP____-.html">-</a> (expo x) (expo y))))
                      (common-mode-p mode))
                 (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP_____B2.html">+</a> x (rnd y mode k))
                    (rnd (<a href="COMMON-LISP_____B2.html">+</a> x y)
                         mode
                         (<a href="COMMON-LISP_____B2.html">+</a> k (<a href="COMMON-LISP____-.html">-</a> (expo (<a href="COMMON-LISP_____B2.html">+</a> x y)) (expo y))))))
        :rule-classes nil)</pre><p><b>Theorem: </b>rnd-rto</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rnd-rto
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (common-mode-p mode)
                      (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> m)
                      (<a href="COMMON-LISP_____E3.html">&gt;</a> m 0)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)
                      (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> n (<a href="COMMON-LISP_____B2.html">+</a> m 2)))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (rnd (rto x n) mode m)
                        (rnd x mode m))))</pre><p><b>Theorem: </b>rnd-up</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rnd-up
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> k)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> n))
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> m))
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> m n)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="COMMON-LISP____ABS.html">abs</a> x) (<a href="COMMON-LISP____EXPT.html">expt</a> 2 k))
                      (common-mode-p mode)
                      (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____ABS.html">abs</a> (rnd x mode n)) (<a href="COMMON-LISP____EXPT.html">expt</a> 2 k)))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____ABS.html">abs</a> (rnd x mode m))
                        (<a href="COMMON-LISP____EXPT.html">expt</a> 2 k))))</pre><p><b>Function: </b>rnd-const</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> rnd-const (e mode n)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> e)
                                   (common-mode-p mode)
                                   (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n))))
       (<a href="COMMON-LISP____CASE.html">case</a> mode ((rne rna) (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP____-.html">-</a> e n)))
             ((rup raz) (<a href="COMMON-LISP____1-.html">1-</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP____1_B2.html">1+</a> (<a href="COMMON-LISP____-.html">-</a> e n)))))
             (otherwise 0)))</pre><p><b>Theorem: </b>rnd-const-lemma</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rnd-const-lemma
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (common-mode-p mode)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> n))
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> x))
                      (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP_____D3.html">=</a> mode 'raz) (<a href="COMMON-LISP_____D3.html">=</a> mode 'rup))
                               (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> (expo x) (<a href="COMMON-LISP____1-.html">1-</a> n))))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (rnd x mode n)
                        (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____EQL.html">eql</a> mode 'rne)
                                 (<a href="COMMON-LISP_____E3.html">&gt;</a> n 1)
                                 (exactp x (<a href="COMMON-LISP____1_B2.html">1+</a> n))
                                 (<a href="COMMON-LISP____NOT.html">not</a> (exactp x n)))
                            (rtz (<a href="COMMON-LISP_____B2.html">+</a> x (rnd-const (expo x) mode n))
                                 (<a href="COMMON-LISP____1-.html">1-</a> n))
                            (rtz (<a href="COMMON-LISP_____B2.html">+</a> x (rnd-const (expo x) mode n))
                                 n)))))</pre><p><b>Function: </b>roundup-pos</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> roundup-pos (x e sticky mode n)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x)
                                   (<a href="COMMON-LISP____INTEGERP.html">integerp</a> e)
                                   (<a href="COMMON-LISP____INTEGERP.html">integerp</a> sticky)
                                   (common-mode-p mode)
                                   (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n))))
       (<a href="COMMON-LISP____CASE.html">case</a> mode
             ((rup raz)
              (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP_____D3.html">=</a> (bits x (<a href="COMMON-LISP____-.html">-</a> e n) 0) 0))
                  (<a href="COMMON-LISP_____D3.html">=</a> sticky 1)))
             (rna (<a href="COMMON-LISP_____D3.html">=</a> (bitn x (<a href="COMMON-LISP____-.html">-</a> e n)) 1))
             (rne (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____D3.html">=</a> (bitn x (<a href="COMMON-LISP____-.html">-</a> e n)) 1)
                       (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP_____D3.html">=</a> (bits x (<a href="COMMON-LISP____-.html">-</a> e (<a href="COMMON-LISP____1_B2.html">1+</a> n)) 0) 0))
                           (<a href="COMMON-LISP_____D3.html">=</a> sticky 1)
                           (<a href="COMMON-LISP_____D3.html">=</a> (bitn x (<a href="COMMON-LISP____-.html">-</a> (<a href="COMMON-LISP____1_B2.html">1+</a> e) n)) 1))))
             (otherwise nil)))</pre><p><b>Theorem: </b>rnd-const-cor-a</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  rnd-const-cor-a
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (common-mode-p mode)
                (<a href="ACL2____POSP.html">posp</a> n)
                (<a href="ACL2____POSP.html">posp</a> m)
                (<a href="COMMON-LISP_____E3.html">&gt;</a> (expo m) n))
           (<a href="COMMON-LISP____LET_A2.html">let*</a> ((e (expo m))
                  (sum (<a href="COMMON-LISP_____B2.html">+</a> m (rnd-const e mode n)))
                  (sh (bits sum (<a href="COMMON-LISP____1_B2.html">1+</a> e) (<a href="COMMON-LISP____1_B2.html">1+</a> (<a href="COMMON-LISP____-.html">-</a> e n))))
                  (sl (bits sum (<a href="COMMON-LISP____-.html">-</a> e n) 0)))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (rnd m mode n)
                        (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____D3.html">=</a> mode 'rne) (<a href="COMMON-LISP_____D3.html">=</a> sl 0))
                            (<a href="COMMON-LISP_____A2.html">*</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP_____B2.html">+</a> 2 (<a href="COMMON-LISP____-.html">-</a> e n))) (bits sh n 1))
                            (<a href="COMMON-LISP_____A2.html">*</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP____1_B2.html">1+</a> (<a href="COMMON-LISP____-.html">-</a> e n))) sh))))))</pre><p><b>Theorem: </b>rnd-const-cor-b</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rnd-const-cor-b
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (common-mode-p mode)
                      (<a href="ACL2____POSP.html">posp</a> n)
                      (<a href="ACL2____POSP.html">posp</a> m)
                      (<a href="COMMON-LISP_____E3.html">&gt;</a> (expo m) n))
                 (<a href="COMMON-LISP____LET_A2.html">let*</a> ((e (expo m))
                        (c (rnd-const e mode n))
                        (sum (<a href="COMMON-LISP_____B2.html">+</a> m c))
                        (sl (bits sum (<a href="COMMON-LISP____-.html">-</a> e n) 0)))
                       (<a href="ACL2____IFF.html">iff</a> (<a href="COMMON-LISP_____D3.html">=</a> m (rnd m mode n)) (<a href="COMMON-LISP_____D3.html">=</a> sl c)))))</pre><p><b>Theorem: </b>roundup-pos-thm-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> roundup-pos-thm-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> z)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> n))
                      (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 n) z))
                 (<a href="COMMON-LISP____LET.html">let</a> ((x (fl z)))
                      (<a href="ACL2____IFF.html">iff</a> (exactp z n)
                           (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> z)
                                (<a href="COMMON-LISP_____D3.html">=</a> (bits x (<a href="COMMON-LISP____-.html">-</a> (expo x) n) 0) 0))))))</pre><p><b>Theorem: </b>roundup-pos-thm-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     roundup-pos-thm-2
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (common-mode-p mode)
                   (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> z)
                   (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> n))
                   (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 n) z))
              (<a href="COMMON-LISP____LET.html">let</a> ((x (fl z))
                    (sticky (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> z) 0 1)))
                   (<a href="COMMON-LISP____EQUAL.html">equal</a> (rnd z mode n)
                          (<a href="COMMON-LISP____IF.html">if</a> (roundup-pos x (expo x) sticky mode n)
                              (fp+ (rtz x n) n)
                              (rtz x n))))))</pre><p><b>Theorem: </b>roundup-pos-thm</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    roundup-pos-thm
    (<a href="ACL2____IMPLIES.html">implies</a>
         (<a href="COMMON-LISP____AND.html">and</a> (common-mode-p mode)
              (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> z)
              (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> n))
              (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 n) z))
         (<a href="COMMON-LISP____LET.html">let</a> ((x (fl z))
               (sticky (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> z) 0 1)))
              (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____IFF.html">iff</a> (exactp z n)
                        (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> z)
                             (<a href="COMMON-LISP_____D3.html">=</a> (bits x (<a href="COMMON-LISP____-.html">-</a> (expo x) n) 0) 0)))
                   (<a href="COMMON-LISP____EQUAL.html">equal</a> (rnd z mode n)
                          (<a href="COMMON-LISP____IF.html">if</a> (roundup-pos x (expo x) sticky mode n)
                              (fp+ (rtz x n) n)
                              (rtz x n)))))))</pre><p><b>Function: </b>roundup-neg</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> roundup-neg (x e sticky mode n)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x)
                                   (<a href="COMMON-LISP____INTEGERP.html">integerp</a> e)
                                   (<a href="COMMON-LISP____INTEGERP.html">integerp</a> sticky)
                                   (common-mode-p mode)
                                   (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n))))
       (<a href="COMMON-LISP____CASE.html">case</a> mode ((rdn raz) t)
             ((rup rtz)
              (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____D3.html">=</a> (bits x (<a href="COMMON-LISP____-.html">-</a> e n) 0) 0)
                   (<a href="COMMON-LISP_____D3.html">=</a> sticky 0)))
             (rna (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP_____D3.html">=</a> (bitn x (<a href="COMMON-LISP____-.html">-</a> e n)) 0)
                      (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____D3.html">=</a> (bits x (<a href="COMMON-LISP____-.html">-</a> e (<a href="COMMON-LISP____1_B2.html">1+</a> n)) 0) 0)
                           (<a href="COMMON-LISP_____D3.html">=</a> sticky 0))))
             (rne (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP_____D3.html">=</a> (bitn x (<a href="COMMON-LISP____-.html">-</a> e n)) 0)
                      (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____D3.html">=</a> (bitn x (<a href="COMMON-LISP____-.html">-</a> (<a href="COMMON-LISP____1_B2.html">1+</a> e) n)) 0)
                           (<a href="COMMON-LISP_____D3.html">=</a> (bits x (<a href="COMMON-LISP____-.html">-</a> e (<a href="COMMON-LISP____1_B2.html">1+</a> n)) 0) 0)
                           (<a href="COMMON-LISP_____D3.html">=</a> sticky 0))))
             (otherwise nil)))</pre><p><b>Theorem: </b>roundup-neg-thm</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  roundup-neg-thm
  (<a href="ACL2____IMPLIES.html">implies</a>
       (<a href="COMMON-LISP____AND.html">and</a> (common-mode-p mode)
            (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> z)
            (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> n))
            (<a href="ACL2____NATP.html">natp</a> k)
            (<a href="COMMON-LISP_____C3.html">&lt;</a> n k)
            (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="COMMON-LISP____-.html">-</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 k)) z)
            (<a href="COMMON-LISP_____C3.html">&lt;</a> z (<a href="COMMON-LISP____-.html">-</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 n))))
       (<a href="COMMON-LISP____LET_A2.html">let*</a> ((x (<a href="COMMON-LISP_____B2.html">+</a> (fl z) (<a href="COMMON-LISP____EXPT.html">expt</a> 2 k)))
              (xc (<a href="COMMON-LISP____1-.html">1-</a> (<a href="COMMON-LISP____-.html">-</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 k) x)))
              (e (expo xc))
              (sticky (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> z) 0 1)))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP_____D3.html">=</a> (expo z) e))
                           (<a href="COMMON-LISP_____D3.html">=</a> z (<a href="COMMON-LISP____-.html">-</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP____1_B2.html">1+</a> e)))))
                  (<a href="ACL2____IFF.html">iff</a> (exactp z n)
                       (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> z)
                            (<a href="COMMON-LISP_____D3.html">=</a> (bits x (<a href="COMMON-LISP____-.html">-</a> (expo xc) n) 0) 0)))
                  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____ABS.html">abs</a> (rnd z mode n))
                         (<a href="COMMON-LISP____IF.html">if</a> (roundup-neg x (expo xc) sticky mode n)
                             (fp+ (rtz xc n) n)
                             (rtz xc n))))))
  :rule-classes nil)</pre> 
 

</body>
</html>
