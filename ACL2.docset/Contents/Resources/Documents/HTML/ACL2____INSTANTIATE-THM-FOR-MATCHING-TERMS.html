<html>
<head>
<meta charset="UTF-8">
<title>Instantiate-thm-for-matching-terms</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____INSTANTIATE-THM-FOR-MATCHING-TERMS">Click for Instantiate-thm-for-matching-terms in the Full Manual</a></h3>

<p>A computed hint which produces :use hints of the given theorem, based 
on occurences of a pattern in the current goal clause.</p><p>Syntax: <span class="tt">(instantiate-thm-for-matching-terms thm subst pattern &amp;key restrict)</span>.</p> 
 
<p>Arguments: THM is a theorem/definition name or rune, SUBST is a list of 
pairs such as</p> 
 
<pre class="code">((var1 sub1)
 (var2 sub2) ... )</pre> 
 
<p>where each vari is a variable name and each sub1 is a term, usually 
containing free variables that are also free in PATTERN, and PATTERN is a 
pattern (pseudo-term) to be matched against the clause.</p> 
 
<p>We translate the PATTERN and each term in the SUBST, so it's ok to use 
macros etc. within them.</p> 
 
<p>For each subterm of CLAUSE that matches PATTERN, the unifying substitution 
is computed and applied to each of the subi terms in the SUBST.</p> 
 
<p>For example, if I have some theorem FOO-BOUND, such as:</p> 
 
<pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> foo-bound
  (<a href="COMMON-LISP_____C3.html">&lt;</a> (foo a b) (<a href="COMMON-LISP____MAX.html">max</a> (<a href="ACL2____G.html">g</a> a) (<a href="ACL2____G.html">g</a> b))))</pre> 
 
<p>and I'm proving the goal:</p> 
 
<pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (p (foo (bar z) (baz q)))
              (<a href="ACL2____Q.html">q</a> (bar z) (buz y)))
         (r (foo (baz q) (bar y))))</pre> 
 
<p>and I provide the computed hint</p> 
 
<pre class="code">(<a href="ACL2____INSTANTIATE-THM-FOR-MATCHING-TERMS.html">instantiate-thm-for-matching-terms</a> foo-bound
                                    ((a c) (b d))
                                    (foo c d))</pre> 
 
<p>this produces the hint:</p> 
 
<pre class="code">:use ((:instance foo-bound
       (a (bar z)) (b (baz q)))
      (:instance foo-bound
       (a (baz q)) (b (bar y))))</pre> 
 
<p>The process by which this happens: The provided pattern <span class="v">(foo c d)</span> is 
matched against the clause, which contains two unifying instances,</p> 
 
<pre class="code">c -&gt; (bar z), d -&gt; (baz q)</pre> 
 
<p>and</p> 
 
<pre class="code">c -&gt; (baz q), d -&gt; (bar y).</pre> 
 
<p>These two unifying substitutions are applied to the user-provided 
 substitution <span class="v">((a c) (b d))</span> to obtain the two instantiations.</p> 
 
<p>Note: you may want to qualify this computed hint with 
STABLE-UNDER-SIMPLIFICATIONP or other conditions, and perhaps disable the 
theorem used.  For example:</p> 
 
<pre class="code">:hints ((<a href="COMMON-LISP____AND.html">and</a> stable-under-simplificationp
             (<a href="COMMON-LISP____LET.html">let</a> ((res (<a href="ACL2____INSTANTIATE-THM-FOR-MATCHING-TERMS.html">instantiate-thm-for-matching-terms</a>
                         foo-bound ((a c) (b d)) (foo c d))))
               (<a href="COMMON-LISP____AND.html">and</a> res (<a href="COMMON-LISP____APPEND.html">append</a> res '(:in-theory (<a href="ACL2____DISABLE.html">disable</a> foo-bound)))))))</pre>
</body>
</html>
