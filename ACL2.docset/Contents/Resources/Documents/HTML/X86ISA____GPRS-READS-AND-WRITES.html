<html>
<head>
<meta charset="UTF-8">
<title>Gprs-reads-and-writes</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=X86ISA____GPRS-READS-AND-WRITES">Click for Gprs-reads-and-writes in the Full Manual</a></h3>

<p>Functions to read/write 8/16/32/64 bits into the registers</p><p><a href="X86ISA____RR08.html">rr08</a>, <a href="X86ISA____RR16.html">rr16</a>, <a href="X86ISA____RR32.html">rr32</a>, and <a href="X86ISA____RR64.html">rr64</a> 
will read the contents of the GPRs as natural numbers. Remember that 
<span class="v">rgfi</span> will return an <a href="X86ISA____I64P.html">i64p</a> value.</p> 
 
<p>Here is an example:</p> 
<br> 
<span class="tt"> 
(!rgfi 0 -1 x86) ;; Write -1 to register 0 
</span> 
 
<p><span class="tt">(rr64 0 x86)</span> returns <span class="v">18446744073709551615</span> and 
<span class="tt">(rgfi 0 x86)</span> returns <span class="v">-1</span>.  Note that 
<span class="v">18446744073709551615</span> is a bignum in CCL. This is precisely the 
reason why we declared registers as <span class="v">i64p</span> instead of <span class="v">n64p</span>; 
<span class="v">-1</span> would be stored as a bignum if the registers were 
<span class="v">n64p</span>. </p> 
 
<p>Similarly, <a href="X86ISA____WR08.html">wr08</a>, <a href="X86ISA____WR16.html">wr16</a>, <a href="X86ISA____WR32.html">wr32</a>, and <a href="X86ISA____WR64.html">wr64</a> 
are used to write natural numbers into the GPRs.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>rr08$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 rr08$inline (reg rex x86)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (x86)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 4) reg)
          (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 8) rex))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="X86ISA____REG-INDEXP.html">reg-indexp</a> reg rex)))
 (<a href="ACL2____B_A2.html">b*</a>
  ((reg (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____NFIX.html">nfix</a> reg) :exec reg)))
  (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQL.html">eql</a> rex 0)) (<a href="COMMON-LISP_____C3.html">&lt;</a> reg 4))
         (<a href="COMMON-LISP____LET.html">let</a> ((qword (<a href="COMMON-LISP____THE.html">the</a> (signed-byte 64) (rgfi reg x86))))
              (<a href="X86ISA____N08.html">n08</a> qword)))
        (t (<a href="COMMON-LISP____LET.html">let</a> ((qword (<a href="COMMON-LISP____THE.html">the</a> (signed-byte 64)
                             (rgfi (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 4) (<a href="COMMON-LISP____-.html">-</a> reg 4))
                                   x86))))
                (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____PART-SELECT.html">part-select</a> qword :low 8 :width 8)
                     :exec (<a href="X86ISA____N08.html">n08</a> (<a href="COMMON-LISP____ASH.html">ash</a> qword -8))))))))</pre> 
<p><b>Theorem: </b>n08p-rr08</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 n08p-rr08
 (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> 8 (<a href="X86ISA____RR08.html">rr08</a> reg rex x86))
 :rule-classes
 (:rewrite
  (:type-prescription
      :corollary (<a href="ACL2____NATP.html">natp</a> (<a href="X86ISA____RR08.html">rr08</a> reg rex x86))
      :hints
      (("Goal" :in-theory '(<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> integer-range-p natp))))
  (:linear
   :corollary (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 0 (<a href="X86ISA____RR08.html">rr08</a> reg rex x86))
                   (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="X86ISA____RR08.html">rr08</a> reg rex x86) 256))
   :hints
   (("Goal"
        :in-theory '(<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> integer-range-p (:e expt)))))))</pre> 
<p><b>Function: </b>wr08$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 wr08$inline (reg rex byte x86)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (x86)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 4) reg)
          (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 8) rex)
          (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 8) byte))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="X86ISA____REG-INDEXP.html">reg-indexp</a> reg rex)))
 (<a href="ACL2____B_A2.html">b*</a>
  ((reg (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____NFIX.html">nfix</a> reg) :exec reg)))
  (<a href="COMMON-LISP____COND.html">cond</a>
   ((<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQL.html">eql</a> rex 0)) (<a href="COMMON-LISP_____C3.html">&lt;</a> reg 4))
    (<a href="COMMON-LISP____LET.html">let</a>
     ((qword (<a href="COMMON-LISP____THE.html">the</a> (signed-byte 64) (rgfi reg x86))))
     (!rgfi
      reg
      (<a href="X86ISA____N64-TO-I64.html">n64-to-i64</a>
       (<a href="ACL2____MBE.html">mbe</a>
        :logic (<a href="ACL2____PART-INSTALL.html">part-install</a> byte
                             (<a href="ACL2____PART-SELECT.html">part-select</a> qword :low 0 :width 64)
                             :low 0
                             :width 8)
        :exec (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 64)
                   (<a href="COMMON-LISP____LOGIOR.html">logior</a> (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 64)
                                (<a href="COMMON-LISP____LOGAND.html">logand</a> 18446744073709551360 qword))
                           byte))))
      x86)))
   (t
    (<a href="COMMON-LISP____LET_A2.html">let*</a>
     ((index (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 4)
                  (<a href="COMMON-LISP____-.html">-</a> (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 4) reg) 4)))
      (qword (<a href="COMMON-LISP____THE.html">the</a> (signed-byte 64)
                  (rgfi index x86))))
     (!rgfi
      index
      (<a href="X86ISA____N64-TO-I64.html">n64-to-i64</a>
       (<a href="ACL2____MBE.html">mbe</a>
        :logic (<a href="ACL2____PART-INSTALL.html">part-install</a> byte
                             (<a href="ACL2____PART-SELECT.html">part-select</a> qword :low 0 :width 64)
                             :low 8
                             :width 8)
        :exec (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 64)
                   (<a href="COMMON-LISP____LOGIOR.html">logior</a> (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 64)
                                (<a href="COMMON-LISP____LOGAND.html">logand</a> 18446744073709486335 qword))
                           (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 16)
                                (<a href="COMMON-LISP____ASH.html">ash</a> byte 8))))))
      x86))))))</pre> 
<p><b>Theorem: </b>x86p-wr08</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> x86p-wr08
        (<a href="ACL2____IMPLIES.html">implies</a> (x86p x86)
                 (x86p (<a href="X86ISA____WR08.html">wr08</a> reg rex byte x86))))</pre> 
<p><b>Theorem: </b>loghead-logtail-logext-for-rr08/wr08</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> loghead-logtail-logext-for-rr08/wr08
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LOGHEAD.html">loghead</a> 8 (<a href="ACL2____LOGTAIL.html">logtail</a> 8 (<a href="ACL2____LOGEXT.html">logext</a> 64 x)))
                        (<a href="ACL2____LOGHEAD.html">loghead</a> 8 (<a href="ACL2____LOGTAIL.html">logtail</a> 8 x)))))</pre> 
<p><b>Theorem: </b>rr08-wr08-same</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rr08-wr08-same
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="X86ISA____RR08.html">rr08</a> reg rex (<a href="X86ISA____WR08.html">wr08</a> reg rex byte x86))
               (<a href="ACL2____LOGHEAD.html">loghead</a> 8 byte)))</pre> 
<p><b>Theorem: </b>rr08-wr08-different</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rr08-wr08-different
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____NFIX.html">nfix</a> reg1) (<a href="ACL2____NFIX.html">nfix</a> reg2)))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="X86ISA____RR08.html">rr08</a> reg1 rex1 (<a href="X86ISA____WR08.html">wr08</a> reg2 rex2 byte x86))
                        (<a href="X86ISA____RR08.html">rr08</a> reg1 rex1 x86))))</pre> 
<p><b>Function: </b>rr16$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> rr16$inline (reg x86)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (x86)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 4) reg))
       (<a href="X86ISA____N16.html">n16</a> (<a href="COMMON-LISP____THE.html">the</a> (signed-byte 64) (rgfi reg x86))))</pre> 
<p><b>Theorem: </b>n16p-rr16</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 n16p-rr16
 (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> 16 (<a href="X86ISA____RR16.html">rr16</a> reg x86))
 :rule-classes
 (:rewrite
  (:type-prescription
      :corollary (<a href="ACL2____NATP.html">natp</a> (<a href="X86ISA____RR16.html">rr16</a> reg x86))
      :hints
      (("Goal" :in-theory '(<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> integer-range-p natp))))
  (:linear
   :corollary (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 0 (<a href="X86ISA____RR16.html">rr16</a> reg x86))
                   (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="X86ISA____RR16.html">rr16</a> reg x86) 65536))
   :hints
   (("Goal"
        :in-theory '(<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> integer-range-p (:e expt)))))))</pre> 
<p><b>Function: </b>wr16$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 wr16$inline (reg val x86)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (x86)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 4) reg)
          (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 16) val))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((qword (<a href="COMMON-LISP____THE.html">the</a> (signed-byte 64) (rgfi reg x86))))
  (!rgfi
   reg
   (<a href="X86ISA____N64-TO-I64.html">n64-to-i64</a>
    (<a href="ACL2____MBE.html">mbe</a>
       :logic (<a href="ACL2____PART-INSTALL.html">part-install</a> val (<a href="ACL2____PART-SELECT.html">part-select</a> qword :low 0 :width 64)
                            :low 0
                            :width 16)
       :exec (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 64)
                  (<a href="COMMON-LISP____LOGIOR.html">logior</a> (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 64)
                               (<a href="COMMON-LISP____LOGAND.html">logand</a> qword 18446744073709486080))
                          val))))
   x86)))</pre> 
<p><b>Theorem: </b>x86p-wr16</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> x86p-wr16
        (<a href="ACL2____IMPLIES.html">implies</a> (x86p x86)
                 (x86p (<a href="X86ISA____WR16.html">wr16</a> reg val x86))))</pre> 
<p><b>Theorem: </b>rr16-wr16-same</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rr16-wr16-same
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="X86ISA____RR16.html">rr16</a> reg (<a href="X86ISA____WR16.html">wr16</a> reg val x86))
               (<a href="ACL2____LOGHEAD.html">loghead</a> 16 val)))</pre> 
<p><b>Theorem: </b>rr16-wr16-different</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rr16-wr16-different
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____NFIX.html">nfix</a> reg1) (<a href="ACL2____NFIX.html">nfix</a> reg2)))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="X86ISA____RR16.html">rr16</a> reg1 (<a href="X86ISA____WR16.html">wr16</a> reg2 val x86))
                        (<a href="X86ISA____RR16.html">rr16</a> reg1 x86))))</pre> 
<p><b>Function: </b>rr32$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> rr32$inline (reg x86)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (x86)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 4) reg))
       (<a href="X86ISA____N32.html">n32</a> (<a href="COMMON-LISP____THE.html">the</a> (signed-byte 64) (rgfi reg x86))))</pre> 
<p><b>Theorem: </b>n32p-rr32</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 n32p-rr32
 (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> 32 (<a href="X86ISA____RR32.html">rr32</a> reg x86))
 :rule-classes
 (:rewrite
  (:type-prescription
      :corollary (<a href="ACL2____NATP.html">natp</a> (<a href="X86ISA____RR32.html">rr32</a> reg x86))
      :hints
      (("Goal" :in-theory '(<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> integer-range-p natp))))
  (:linear
   :corollary (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 0 (<a href="X86ISA____RR32.html">rr32</a> reg x86))
                   (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="X86ISA____RR32.html">rr32</a> reg x86) 4294967296))
   :hints
   (("Goal"
        :in-theory '(<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> integer-range-p (:e expt)))))))</pre> 
<p><b>Function: </b>wr32$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> wr32$inline (reg val x86)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (x86)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 4) reg)
                (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 32) val))
       (!rgfi reg (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="X86ISA____N32.html">n32</a> val) :exec val)
              x86))</pre> 
<p><b>Theorem: </b>x86p-wr32</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> x86p-wr32
        (<a href="ACL2____IMPLIES.html">implies</a> (x86p x86)
                 (x86p (<a href="X86ISA____WR32.html">wr32</a> reg val x86))))</pre> 
<p><b>Theorem: </b>rr32-wr32-same</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rr32-wr32-same
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="X86ISA____RR32.html">rr32</a> reg (<a href="X86ISA____WR32.html">wr32</a> reg val x86))
               (<a href="ACL2____LOGHEAD.html">loghead</a> 32 val)))</pre> 
<p><b>Theorem: </b>rr32-wr32-different</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rr32-wr32-different
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____NFIX.html">nfix</a> reg1) (<a href="ACL2____NFIX.html">nfix</a> reg2)))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="X86ISA____RR32.html">rr32</a> reg1 (<a href="X86ISA____WR32.html">wr32</a> reg2 val x86))
                        (<a href="X86ISA____RR32.html">rr32</a> reg1 x86))))</pre> 
<p><b>Function: </b>rr64$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> rr64$inline (reg x86)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (x86)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 4) reg))
       (<a href="X86ISA____N64.html">n64</a> (<a href="COMMON-LISP____THE.html">the</a> (signed-byte 64) (rgfi reg x86))))</pre> 
<p><b>Theorem: </b>n64p-rr64</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 n64p-rr64
 (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> 64 (<a href="X86ISA____RR64.html">rr64</a> reg x86))
 :rule-classes
 (:rewrite
  (:type-prescription
      :corollary (<a href="ACL2____NATP.html">natp</a> (<a href="X86ISA____RR64.html">rr64</a> reg x86))
      :hints
      (("Goal" :in-theory '(<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> integer-range-p natp))))
  (:linear
   :corollary (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 0 (<a href="X86ISA____RR64.html">rr64</a> reg x86))
                   (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="X86ISA____RR64.html">rr64</a> reg x86) 18446744073709551616))
   :hints
   (("Goal"
        :in-theory '(<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> integer-range-p (:e expt)))))))</pre> 
<p><b>Function: </b>wr64$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> wr64$inline (reg val x86)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (x86)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 4) reg)
                (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 64) val))
       (!rgfi reg (<a href="X86ISA____N64-TO-I64.html">n64-to-i64</a> val) x86))</pre> 
<p><b>Theorem: </b>x86p-wr64</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> x86p-wr64
        (<a href="ACL2____IMPLIES.html">implies</a> (x86p x86)
                 (x86p (<a href="X86ISA____WR64.html">wr64</a> reg val x86))))</pre> 
<p><b>Theorem: </b>rr64-wr64-same</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rr64-wr64-same
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="X86ISA____RR64.html">rr64</a> reg (<a href="X86ISA____WR64.html">wr64</a> reg val x86))
               (<a href="ACL2____LOGHEAD.html">loghead</a> 64 val)))</pre> 
<p><b>Theorem: </b>rr64-wr64-different</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rr64-wr64-different
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____NFIX.html">nfix</a> reg1) (<a href="ACL2____NFIX.html">nfix</a> reg2)))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="X86ISA____RR64.html">rr64</a> reg1 (<a href="X86ISA____WR64.html">wr64</a> reg2 val x86))
                        (<a href="X86ISA____RR64.html">rr64</a> reg1 x86))))</pre> 
<p><b>Function: </b>rgfi-size$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> rgfi-size$inline (nbytes index rex x86)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (x86)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 4) nbytes)
                (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 4) index)
                (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 8) rex))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="X86ISA____REG-INDEXP.html">reg-indexp</a> index rex)
                                   (<a href="COMMON-LISP____MEMBER.html">member</a> nbytes '(1 2 4 8)))))
       (<a href="COMMON-LISP____CASE.html">case</a> nbytes (1 (<a href="X86ISA____RR08.html">rr08</a> index rex x86))
             (2 (<a href="X86ISA____RR16.html">rr16</a> index x86))
             (4 (<a href="X86ISA____RR32.html">rr32</a> index x86))
             (8 (<a href="X86ISA____RR64.html">rr64</a> index x86))
             (otherwise 0)))</pre> 
<p><b>Theorem: </b>natp-of-rgfi-size</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> natp-of-rgfi-size
        (<a href="ACL2____B_A2.html">b*</a> ((val (rgfi-size$inline nbytes index rex x86)))
            (<a href="ACL2____NATP.html">natp</a> val))
        :rule-classes :type-prescription)</pre> 
<p><b>Function: </b>!rgfi-size$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 !rgfi-size$inline
 (nbytes index val rex x86)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (x86)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 4) nbytes)
          (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 4) index)
          (<a href="COMMON-LISP____TYPE.html">type</a> integer val)
          (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 8) rex))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="X86ISA____REG-INDEXP.html">reg-indexp</a> index rex)
                             (<a href="COMMON-LISP____MEMBER.html">member</a> nbytes '(1 2 4 8))
                             (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> (<a href="COMMON-LISP____ASH.html">ash</a> nbytes 3) val))))
 (<a href="COMMON-LISP____CASE.html">case</a> nbytes (1 (<a href="X86ISA____WR08.html">wr08</a> index rex val x86))
       (2 (<a href="X86ISA____WR16.html">wr16</a> index val x86))
       (4 (<a href="X86ISA____WR32.html">wr32</a> index val x86))
       (8 (<a href="X86ISA____WR64.html">wr64</a> index val x86))
       (otherwise x86)))</pre> 
<p><b>Theorem: </b>x86p-of-!rgfi-size</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   x86p-of-!rgfi-size
   (<a href="ACL2____IMPLIES.html">implies</a> (x86p x86)
            (<a href="ACL2____B_A2.html">b*</a> ((x86 (!rgfi-size$inline nbytes index val rex x86)))
                (x86p x86)))
   :rule-classes :rewrite)</pre> 

</body>
</html>
