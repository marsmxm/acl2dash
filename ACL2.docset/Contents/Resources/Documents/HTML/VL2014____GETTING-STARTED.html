<html>
<head>
<meta charset="UTF-8">
<title>Getting-started</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=VL2014____GETTING-STARTED">Click for Getting-started in the Full Manual</a></h3>

<p>Getting started with VL2014.</p><h3>Introduction</h3> 
 
<p><b>VL2014</b> (hereafter VL) is an <a href="ACL2____ACL2.html">ACL2::ACL2</a> library for working 
with <a href="http://en.wikipedia.org/wiki/Verilog" target="_blank"><nobr>Verilog<img src="../Icon_External_Link.png" title="External link to http://en.wikipedia.org/wiki/Verilog"></nobr></a> and <a href="http://en.wikipedia.org/wiki/SystemVerilog" target="_blank"><nobr>SystemVerilog<img src="../Icon_External_Link.png" title="External link to http://en.wikipedia.org/wiki/SystemVerilog"></nobr></a> source 
code.  It includes:</p> 
 
<ul> 
 <li>An internal representation for Verilog <a href="VL2014____SYNTAX.html">syntax</a>,</li> 
 <li>A <a href="VL2014____LOADER.html">loader</a> for parsing Verilog source code into this representation,</li> 
 <li>Utilities for inspecting and analyzing parsed designs,</li> 
 <li>Various <a href="VL2014____TRANSFORMS.html">transforms</a> that can simplify these designs, and</li> 
 <li>Pretty-printing and other report-generation functions.</li> 
</ul> 
 
<p>Much of VL is general purpose Verilog processing code that is independent of 
particular analysis or back-end tool.  This approach has allowed us to use VL 
to implement a family of Verilog-related tools.  Here are some examples:</p> 
 
<ul> 
 
<li>VL can build <a href="ACL2____ESIM.html">esim</a> models of Verilog modules for formal verification 
with ACL2.  This is the basis for much of Centaur's formal verification 
efforts.</li> 
 
<li>The VL <a href="VL2014____KIT.html">kit</a> is a standalone command-line executable that you can 
build on top of ACL2 and VL.  It includes commands for <a href="VL2014____LINT.html">lint</a>ing Verilog 
designs, converting Verilog modules into a JSON format, and other 
commands.</li> 
 
<li>VL has been used to build a web-based "module browser" that lets you see 
the source code for our modules with, e.g., hyperlinks for navigating between 
wires and following wires.  This is now integrated into the VL <a href="VL2014____KIT.html">kit</a>; 
<a href="VL2014____SERVER.html">server</a>.</li> 
 
<li>(unreleased) We have used VL to implement <i>samev</i>, a sequential 
equivalence checking tool with a tick-based timing model that handles both RTL 
and transistor-level constructs.</li> 
 
<li>(unreleased) We have used it to implement <i>VL-Mangle</i>, a web-based 
Verilog refactoring tool.  A paper describing this tool can be found in: Jared 
Davis. <a href="http://www.cs.utexas.edu/users/jared/publications/2013-doform-embedding/embedding.pdf" target="_blank"><nobr>Embedding 
ACL Models in End-User Applications<img src="../Icon_External_Link.png" title="External link to http://www.cs.utexas.edu/users/jared/publications/2013-doform-embedding/embedding.pdf"></nobr></a>.  In <a href="http://www.cs.bham.ac.uk/research/projects/formare/events/aisb2013/" target="_blank"><nobr>Do-Form 
2013<img src="../Icon_External_Link.png" title="External link to http://www.cs.bham.ac.uk/research/projects/formare/events/aisb2013/"></nobr></a>.  April, 2013, Exeter, UK.</li> 
 
</ul> 
 
<p>We imagine that other users of VL may wish to reuse its parsing and 
transformations to easily implement other tools.</p> 
 
<h3>Starting Points</h3> 
 
<p>If you want to use VL to do formal verification of hardware, you might start 
with the <a href="ACL2____ESIM-TUTORIAL.html">ACL2::esim-tutorial</a>, which is a hands-on guide that will take 
you through using VL and <a href="ACL2____ESIM.html">esim</a> to verify some simple circuits.</p> 
 
<p>The first step in using VL in any other capacity on a real project is 
probably to try to get it to parse your design; see the documentation for the 
<a href="VL2014____LOADER.html">loader</a>.  You may want to read the notes about <a href="VL2014____SUPPORTED-CONSTRUCTS.html">supported-constructs</a>.</p> 
 
<p>Once you have parsed your design (or at least some portion of it) you will 
have a list of modules.  You might want to at least glance through the 
documentation for <a href="VL2014____SYNTAX.html">syntax</a>, which explains how modules are represented. 
This may be particularly useful if you are going to write your own analysis 
tools.</p> 
 
<p>You may find it useful to pretty-print modules, see for instance <a href="VL2014____VL-PPCS-MODULE.html">vl-ppcs-module</a> and perhaps more generally the VL <a href="VL2014____PRINTER.html">printer</a>.</p> 
 
<p>After getting a feel for how modules are represented, it would be good to 
look at the available <a href="VL2014____TRANSFORMS.html">transforms</a>.  For instance, you might look at the 
code for <a href="VL2014____VL-SIMPLIFY.html">vl-simplify</a> to see the transforms used in the <a href="ACL2____ESIM.html">esim</a> flow. 
You could also look at <span class="v">run-vl-lint-main</span> which uses a different 
transformation sequence for toward linting.</p> 
 
<p>If you are going to write any Verilog-processing tools of your own, you 
should probably read through how VL deals with <a href="VL2014____WARNINGS.html">warnings</a> and then take a 
look at <a href="VL2014____MLIB.html">mlib</a>, which provides many functions for working with expressions 
and ranges, finding modules and module items, working with the module 
hierarchy, generating fresh names, and working with modules at the bit 
level.</p>
</body>
</html>
