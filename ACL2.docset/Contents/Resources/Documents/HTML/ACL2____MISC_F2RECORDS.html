<html>
<head>
<meta charset="UTF-8">
<title>Misc/records</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____MISC_F2RECORDS">Click for Misc/records in the Full Manual</a></h3>

<p>A <span class="v">misc/record</span> is an <a href="ACL2____ALISTS.html">alist</a>-like 
data structure that associates keys to values, but features efficient, 
unconditional rewrite rules about its <span class="v">get</span> and <span class="v">set</span> operations.</p><h3>Introduction</h3> 
 
<p>Note: See also the following paper:</p> 
 
<blockquote> Matt Kaufmann and Rob Sumners.  <a href="http://www.cs.utexas.edu/users/moore/acl2/workshop-2002/contrib/kaufmann-sumners/rcd.pdf" target="_blank"><nobr>Efficient 
Rewriting of Data Structures in ACL2<img src="../Icon_External_Link.png" title="External link to http://www.cs.utexas.edu/users/moore/acl2/workshop-2002/contrib/kaufmann-sumners/rcd.pdf"></nobr></a>.  In: Proceedings of <a href="http://www.cs.utexas.edu/users/moore/acl2/workshop-2002/" target="_blank"><nobr>ACL2 Workshop 
2002<img src="../Icon_External_Link.png" title="External link to http://www.cs.utexas.edu/users/moore/acl2/workshop-2002/"></nobr></a>.  (<a href="http://www.cs.utexas.edu/users/moore/acl2/workshop-2002/contrib/kaufmann-sumners/rcdsld.pdf" target="_blank"><nobr>Slides<img src="../Icon_External_Link.png" title="External link to http://www.cs.utexas.edu/users/moore/acl2/workshop-2002/contrib/kaufmann-sumners/rcdsld.pdf"></nobr></a>)</blockquote> 
 
<p>We define properties of a generic record accessor function and updater 
function.  The basic functions are:</p> 
 
<ul> 
 
<li>
<span class="v">(<a href="ACL2____G.html">g</a> a r)</span> — returns the value at address <span class="v">a</span> in record 
<span class="v">r</span>
</li> 
 
<li>
<span class="v">(<a href="ACL2____S.html">s</a> a v r)</span> — returns a new record by setting address <span class="v">a</span> to 
value <span class="v">v</span> in record <span class="v">r</span>
</li> 
 
</ul> 
 
<p>The following main lemmas are ``exported'' about record <a href="ACL2____G.html">g</a>et and <a href="ACL2____S.html">s</a>et:</p> 
 
<pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> g-same-s
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____G.html">g</a> a (<a href="ACL2____S.html">s</a> a v r))
         v))

(<a href="ACL2____DEFTHM.html">defthm</a> g-diff-s
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> a b))
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____G.html">g</a> a (<a href="ACL2____S.html">s</a> b v r))
                  (<a href="ACL2____G.html">g</a> a r))))

(<a href="ACL2____DEFTHM.html">defthm</a> s-same-g
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____S.html">s</a> a (<a href="ACL2____G.html">g</a> a r) r)
         r))

(<a href="ACL2____DEFTHM.html">defthm</a> s-same-s
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____S.html">s</a> a y (<a href="ACL2____S.html">s</a> a x r))
         (<a href="ACL2____S.html">s</a> a y r)))

(<a href="ACL2____DEFTHM.html">defthm</a> s-diff-s
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> a b))
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____S.html">s</a> b y (<a href="ACL2____S.html">s</a> a x r))
                  (<a href="ACL2____S.html">s</a> a x (<a href="ACL2____S.html">s</a> b y r))))
  :rule-classes ((:rewrite :loop-stopper ((b a s)))))</pre> 
 
<p>We also include some auxiliary lemmas which have proven useful.</p> 
 
<pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> access-of-nil-is-nil
  (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____G.html">g</a> a nil)))

(<a href="ACL2____DEFTHM.html">defthm</a> record-set-cannot-be-nil
  (<a href="ACL2____IMPLIES.html">implies</a> v (<a href="ACL2____S.html">s</a> a v r)))

(<a href="ACL2____DEFTHM.html">defthm</a> record-get-non-nil-cannot-be-nil
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____G.html">g</a> a r) r))</pre> 
 
<h3>Extensions and Related Books</h3> 
 
<p>The <span class="v">misc/records</span> book has been widely popular, especially for 
representing memories and heaps.  This popularity has led to some variants and 
extensions.</p> 
 
<p>Records make no distinction between addresses that are unbound versus 
addresses that are bound to <span class="v">nil</span>.  This generally makes it difficult to 
reason about the domain of a record, and difficult to iterate through the keys 
of a record.  The <span class="v">coi/records</span> books add several theorems, as well as 
functions like <span class="v">rkeys</span> and useful lemmas like <span class="v">rkeyquiv-by-multiplicity</span> 
that allow you to prove records are equal by showing that they agree for any 
arbitrary key in a ``pick-a-point'' fashion.  These are generally not well 
documented, so see the books themselves for details.</p> 
 
<p>The <a href="ACL2____MEMORY.html">memory</a> library defines <span class="v">memory</span> data structures which are very 
similar to <span class="v">misc/records</span> and provide the same read-over-write theorems, but 
which are intended to be more efficient for representing processor memories. 
These functions have restrictive guards that require addresses must be natural 
numbers below 2^n for some n, but use a tree-like structure for 
O(\log_2 n) performance.</p> 
 
<p>The <a href="ACL2____DEFRSTOBJ.html">defrstobj</a> library allows certain <a href="ACL2____STOBJ.html">stobj</a>s to be reasoned 
about as if they were <a href="ACL2____MISC_F2RECORDS.html">misc/records</a>.  This may be useful for developing 
efficient processor models.</p> 
 
<p>The keys and values of <span class="v">misc/records</span> are essentially untyped.  The book 
<span class="v">coi/records/defrecord</span> provides a way to introduce alternate ``typed'' 
records.  See also: David Greve and Matthew Wilding.  <a href="http://www.cs.utexas.edu/users/moore/acl2/workshop-2003/contrib/greve-wilding_defrecord/defrecord.pdf" target="_blank"><nobr>Typed 
ACL2 Records<img src="../Icon_External_Link.png" title="External link to http://www.cs.utexas.edu/users/moore/acl2/workshop-2003/contrib/greve-wilding_defrecord/defrecord.pdf"></nobr></a>.  ACL2 Workshop 2003.  An alternative typed record 
implementation is also provided by the <a href="ACL2____DEFRSTOBJ.html">defrstobj</a> books, see <a href="ACL2____DEF-TYPED-RECORD.html">def-typed-record</a>.</p> 
 
 
<h3>Implementation Notes</h3> 
 
<p>We normalize the record structures (which allows the equality based rewrite 
rules) as alists where the keys (cars) are ordered using the total-order <a href="ACL2_____C3_C3.html">&lt;&lt;</a>. We define a set of ``-aux'' functions which assume well-formed records, 
defined by <span class="v">rcdp</span>, and then prove the desired properties using hypothesis 
assuming well-formed records.</p> 
 
<p>We then remove these well-formed record hypothesis by defining an invertible 
mapping, <span class="v">acl2-&gt;rcd</span> taking any ACL2 object and returning a well-formed 
record. We then prove the desired properties using the proper translations of 
the -aux functions to the acl2 objects, and subsequently remove the well-formed 
record hypothesis.</p>
</body>
</html>
