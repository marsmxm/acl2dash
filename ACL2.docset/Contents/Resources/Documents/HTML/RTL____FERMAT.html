<html>
<head>
<meta charset="UTF-8">
<title>Fermat</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=RTL____FERMAT">Click for Fermat in the Full Manual</a></h3>

<p>This book contains a proof of Fermat's Theorem: if <span class="v">p</span> is a prime and <span class="v">m</span> 
 is not divisible by <span class="v">p</span>, then <span class="v">mod(m^(p-1),p) = 1</span>.</p>The proof depends on Euclid's Theorem: 
 
<h3>Definitions and Theorems</h3>We shall construct two lists of integers, each of which is a permutation of the other. 
 <p><b>Function: </b>perm</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> perm (a b)
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> a)
           (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____MEMBER.html">member</a> (<a href="COMMON-LISP____CAR.html">car</a> a) b)
               (perm (<a href="COMMON-LISP____CDR.html">cdr</a> a) (<a href="ACL2____REMOVE1.html">remove1</a> (<a href="COMMON-LISP____CAR.html">car</a> a) b))
               nil)
           (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> b))))</pre>The first list is <pre class="code">positives(p-1) = (1, 2, ..., p-1)</pre> 
 <p><b>Function: </b>positives</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> positives (n)
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> n)
           nil (<a href="COMMON-LISP____CONS.html">cons</a> n (positives (<a href="COMMON-LISP____1-.html">1-</a> n)))))</pre>The second list is <pre class="code">mod-prods(p-1,a,p) = (<a href="COMMON-LISP____MOD.html">mod</a>(a,p), mod(2*a,p), ..., mod((p-1)*a,p))</pre> 
 <p><b>Function: </b>mod-prods</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> mod-prods (n m p)
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> n)
           nil
           (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> m n) p)
                 (mod-prods (<a href="COMMON-LISP____1-.html">1-</a> n) m p))))</pre>The proof is based on the pigeonhole principle, as stated below. 
 <p><b>Theorem: </b>not-member-remove1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> not-member-remove1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____MEMBER.html">member</a> x l))
                 (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____MEMBER.html">member</a> x (<a href="ACL2____REMOVE1.html">remove1</a> y l)))))</pre> 
 <p><b>Theorem: </b>perm-member</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> perm-member
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (perm a b) (<a href="COMMON-LISP____MEMBER.html">member</a> x a))
                 (<a href="COMMON-LISP____MEMBER.html">member</a> x b)))</pre> 
 <p><b>Function: </b>distinct-positives</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> distinct-positives (l n)
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> l)
           (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> n))
                (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> (<a href="COMMON-LISP____CAR.html">car</a> l)))
                (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="COMMON-LISP____CAR.html">car</a> l) n)
                (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____MEMBER.html">member</a> (<a href="COMMON-LISP____CAR.html">car</a> l) (<a href="COMMON-LISP____CDR.html">cdr</a> l)))
                (distinct-positives (<a href="COMMON-LISP____CDR.html">cdr</a> l) n))
           t))</pre> 
 <p><b>Theorem: </b>member-positives</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> member-positives
        (<a href="ACL2____IFF.html">iff</a> (<a href="COMMON-LISP____MEMBER.html">member</a> x (positives n))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> n))
                  (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> x))
                  (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> x n))))</pre> 
 <p><b>Theorem: </b>pigeonhole-principle</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pigeonhole-principle
        (<a href="ACL2____IMPLIES.html">implies</a> (distinct-positives l (<a href="ACL2____LEN.html">len</a> l))
                 (perm (positives (<a href="ACL2____LEN.html">len</a> l)) l))
        :rule-classes nil)</pre>We must show that <span class="v">mod-prods(p-1,m,p)</span> is a list of length <span class="v">p-1</span> of distinct 
 integers between <span class="v">1</span> and <span class="v">p-1</span>. 
 <p><b>Theorem: </b>len-mod-prods</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> len-mod-prods
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____NATP.html">natp</a> n)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> (mod-prods n m p)) n)))</pre> 
 <p><b>Theorem: </b>mod-distinct</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-distinct
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (primep p)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> i))
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> i p)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> j))
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> j p)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP_____D3.html">=</a> j i))
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> m)
                      (<a href="COMMON-LISP____NOT.html">not</a> (divides p m)))
                 (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> m i) p)
                             (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> m j) p)))))</pre> 
 <p><b>Theorem: </b>mod-p-bnds</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-p-bnds
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (primep p)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> i))
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> i p)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> m)
                      (<a href="COMMON-LISP____NOT.html">not</a> (divides p m)))
                 (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> 0 (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> m i) p))
                      (<a href="COMMON-LISP_____E3.html">&gt;</a> p (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> m i) p))))
        :rule-classes nil)</pre> 
 <p><b>Theorem: </b>mod-prods-distinct-positives</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-prods-distinct-positives
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (primep p)
                      (<a href="ACL2____NATP.html">natp</a> n)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> n p)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> m)
                      (<a href="COMMON-LISP____NOT.html">not</a> (divides p m)))
                 (distinct-positives (mod-prods n m p)
                                     (<a href="COMMON-LISP____1-.html">1-</a> p)))
        :rule-classes nil)</pre> 
 <p><b>Theorem: </b>perm-mod-prods</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> perm-mod-prods
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (primep p)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> m)
                      (<a href="COMMON-LISP____NOT.html">not</a> (divides p m)))
                 (perm (positives (<a href="COMMON-LISP____1-.html">1-</a> p))
                       (mod-prods (<a href="COMMON-LISP____1-.html">1-</a> p) m p)))
        :rule-classes nil)</pre>The product of the members of a list is invariant under permutation: 
 <p><b>Function: </b>times-list</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> times-list (l)
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> l)
           (<a href="COMMON-LISP_____A2.html">*</a> (<a href="ACL2____IFIX.html">ifix</a> (<a href="COMMON-LISP____CAR.html">car</a> l)) (times-list (<a href="COMMON-LISP____CDR.html">cdr</a> l)))
           1))</pre> 
 <p><b>Theorem: </b>perm-times-list</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> perm-times-list
        (<a href="ACL2____IMPLIES.html">implies</a> (perm l1 l2)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (times-list l1) (times-list l2)))
        :rule-classes nil)</pre>It follows that the product of the members of <span class="v">mod-prods(p-1,m,p)</span> is <span class="v">(p-1)!</span>. 
 <p><b>Theorem: </b>times-list-positives</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> times-list-positives
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (times-list (positives n))
               (fact n)))</pre> 
 <p><b>Theorem: </b>times-list-equal-fact</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> times-list-equal-fact
        (<a href="ACL2____IMPLIES.html">implies</a> (perm (positives n) l)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (times-list l) (fact n))))</pre> 
 <p><b>Theorem: </b>times-list-mod-prods</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> times-list-mod-prods
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (primep p)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> m)
                      (<a href="COMMON-LISP____NOT.html">not</a> (divides p m)))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (times-list (mod-prods (<a href="COMMON-LISP____1-.html">1-</a> p) m p))
                        (fact (<a href="COMMON-LISP____1-.html">1-</a> p)))))</pre>On the other hand, the product modulo <span class="v">p</span> may be computed as follows. 
 <p><b>Theorem: </b>mod-mod-prods</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-mod-prods
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> p)) (<a href="COMMON-LISP____INTEGERP.html">integerp</a> m) (<a href="ACL2____NATP.html">natp</a> n))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> (times-list (mod-prods n m p)) p)
                        (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> (fact n) (<a href="COMMON-LISP____EXPT.html">expt</a> m n)) p)))
        :rule-classes nil)</pre>Fermat's theorem now follows easily. 
 <p><b>Theorem: </b>not-divides-p-fact</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> not-divides-p-fact
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (primep p) (<a href="ACL2____NATP.html">natp</a> n) (<a href="COMMON-LISP_____C3.html">&lt;</a> n p))
                 (<a href="COMMON-LISP____NOT.html">not</a> (divides p (fact n))))
        :rule-classes nil)</pre> 
 <p><b>Theorem: </b>mod-times-prime</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-times-prime
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (primep p)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> a)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> b)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> c)
                      (<a href="COMMON-LISP____NOT.html">not</a> (divides p a))
                      (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> a b) p) (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> a c) p)))
                 (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____MOD.html">mod</a> b p) (<a href="COMMON-LISP____MOD.html">mod</a> c p)))
        :rule-classes nil)</pre> 
 <p><b>Theorem: </b>fermat</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fermat
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (primep p)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> m)
                      (<a href="COMMON-LISP____NOT.html">not</a> (divides p m)))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP____EXPT.html">expt</a> m (<a href="COMMON-LISP____1-.html">1-</a> p)) p) 1))
        :rule-classes nil)</pre>
</body>
</html>
