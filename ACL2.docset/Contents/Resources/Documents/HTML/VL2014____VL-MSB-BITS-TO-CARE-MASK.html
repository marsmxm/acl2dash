<html>
<head>
<meta charset="UTF-8">
<title>Vl-msb-bits-to-care-mask</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=VL2014____VL-MSB-BITS-TO-CARE-MASK">Click for Vl-msb-bits-to-care-mask in the Full Manual</a></h3>

<p>Construct a bit-mask that captures the non-wild bits from a casex 
pattern or the right-hand side of a <span class="v">==?</span> or <span class="v">!=?</span> expression.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(vl-msb-bits-to-care-mask msb-bits care-bits value) 
   
care-mask</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">msb-bits</span>  MSB-ordered bits from the RHS.<br><font color="#606060">Guard <span class="v">(<a href="VL2014____VL-BITLIST-P.html">vl-bitlist-p</a> msb-bits)</span>.</font>
</dd> 
  <dd>
<span class="tt">care-bits</span>  Set of bit values that are cares; usually {1,0} or {1,0,X}.<br><font color="#606060">Guard <span class="v">(<a href="VL2014____VL-BITLIST-P.html">vl-bitlist-p</a> care-bits)</span>.</font>
</dd> 
  <dd>
<span class="tt">value</span>  Value we're constructing, zero to begin with.<br><font color="#606060">Guard <span class="v">(<a href="ACL2____NATP.html">natp</a> value)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">care-mask</span>  <font color="#606060">Type <span class="v">(<a href="ACL2____NATP.html">natp</a> care-mask)</span>.</font>
</dd> 
 
</dl></div> 
 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>vl-msb-bits-to-care-mask</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
    vl-msb-bits-to-care-mask
    (msb-bits care-bits value)
    (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="VL2014____VL-BITLIST-P.html">vl-bitlist-p</a> msb-bits)
                                (<a href="VL2014____VL-BITLIST-P.html">vl-bitlist-p</a> care-bits)
                                (<a href="ACL2____NATP.html">natp</a> value))))
    (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____TRUE-LISTP.html">true-listp</a> care-bits)))
    (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'vl-msb-bits-to-care-mask))
         (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
         (<a href="ACL2____B_A2.html">b*</a> ((<a href="ACL2____VALUE.html">value</a> (<a href="ACL2____LNFIX.html">lnfix</a> value))
              ((when (<a href="COMMON-LISP____ATOM.html">atom</a> msb-bits)) value)
              (bit1 (vl-bit-fix (<a href="COMMON-LISP____CAR.html">car</a> msb-bits)))
              (<a href="ACL2____VALUE.html">value</a> (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____MEMBER-EQ.html">member-eq</a> bit1 (<a href="VL2014____VL-BITLIST-FIX.html">vl-bitlist-fix</a> care-bits))
                         (<a href="COMMON-LISP____LOGIOR.html">logior</a> 1 (<a href="COMMON-LISP____ASH.html">ash</a> value 1))
                         (<a href="COMMON-LISP____ASH.html">ash</a> value 1))))
             (<a href="VL2014____VL-MSB-BITS-TO-CARE-MASK.html">vl-msb-bits-to-care-mask</a> (<a href="COMMON-LISP____CDR.html">cdr</a> msb-bits)
                                       care-bits value))))</pre> 
<p><b>Theorem: </b>natp-of-vl-msb-bits-to-care-mask</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 natp-of-vl-msb-bits-to-care-mask
 (<a href="ACL2____B_A2.html">b*</a>
   ((care-mask (<a href="VL2014____VL-MSB-BITS-TO-CARE-MASK.html">vl-msb-bits-to-care-mask</a> msb-bits care-bits value)))
   (<a href="ACL2____NATP.html">natp</a> care-mask))
 :rule-classes :type-prescription)</pre> 
<p><b>Theorem: </b>unsigned-byte-p-of-vl-msb-bits-to-care-mask-general</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    unsigned-byte-p-of-vl-msb-bits-to-care-mask-general
    (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> n value)
             (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a>
                  (<a href="COMMON-LISP_____B2.html">+</a> n (<a href="ACL2____LEN.html">len</a> msb-bits))
                  (<a href="VL2014____VL-MSB-BITS-TO-CARE-MASK.html">vl-msb-bits-to-care-mask</a> msb-bits cares value))))</pre> 
<p><b>Theorem: </b>unsigned-byte-p-of-vl-msb-bits-to-care-mask-zero</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     unsigned-byte-p-of-vl-msb-bits-to-care-mask-zero
     (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> (<a href="ACL2____LEN.html">len</a> msb-bits)
                      (<a href="VL2014____VL-MSB-BITS-TO-CARE-MASK.html">vl-msb-bits-to-care-mask</a> msb-bits cares 0)))</pre> 
<p><b>Theorem: </b>upper-bound-of-vl-msb-bits-to-care-mask-zero</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> upper-bound-of-vl-msb-bits-to-care-mask-zero
        (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="VL2014____VL-MSB-BITS-TO-CARE-MASK.html">vl-msb-bits-to-care-mask</a> msb-bits cares 0)
           (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="ACL2____LEN.html">len</a> msb-bits)))
        :rule-classes ((:rewrite) (:linear)))</pre> 
<p><b>Theorem: </b>vl-msb-bits-to-care-mask-of-vl-bitlist-fix-msb-bits</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> vl-msb-bits-to-care-mask-of-vl-bitlist-fix-msb-bits
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="VL2014____VL-MSB-BITS-TO-CARE-MASK.html">vl-msb-bits-to-care-mask</a> (<a href="VL2014____VL-BITLIST-FIX.html">vl-bitlist-fix</a> msb-bits)
                                         care-bits value)
               (<a href="VL2014____VL-MSB-BITS-TO-CARE-MASK.html">vl-msb-bits-to-care-mask</a> msb-bits care-bits value)))</pre> 
<p><b>Theorem: </b>vl-msb-bits-to-care-mask-vl-bitlist-equiv-congruence-on-msb-bits</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 vl-msb-bits-to-care-mask-vl-bitlist-equiv-congruence-on-msb-bits
 (<a href="ACL2____IMPLIES.html">implies</a>
  (<a href="VL2014____VL-BITLIST-EQUIV.html">vl-bitlist-equiv</a> msb-bits msb-bits-equiv)
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="VL2014____VL-MSB-BITS-TO-CARE-MASK.html">vl-msb-bits-to-care-mask</a> msb-bits care-bits value)
         (<a href="VL2014____VL-MSB-BITS-TO-CARE-MASK.html">vl-msb-bits-to-care-mask</a> msb-bits-equiv care-bits value)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>vl-msb-bits-to-care-mask-of-vl-bitlist-fix-care-bits</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  vl-msb-bits-to-care-mask-of-vl-bitlist-fix-care-bits
  (<a href="COMMON-LISP____EQUAL.html">equal</a>
       (<a href="VL2014____VL-MSB-BITS-TO-CARE-MASK.html">vl-msb-bits-to-care-mask</a> msb-bits (<a href="VL2014____VL-BITLIST-FIX.html">vl-bitlist-fix</a> care-bits)
                                 value)
       (<a href="VL2014____VL-MSB-BITS-TO-CARE-MASK.html">vl-msb-bits-to-care-mask</a> msb-bits care-bits value)))</pre> 
<p><b>Theorem: </b>vl-msb-bits-to-care-mask-vl-bitlist-equiv-congruence-on-care-bits</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 vl-msb-bits-to-care-mask-vl-bitlist-equiv-congruence-on-care-bits
 (<a href="ACL2____IMPLIES.html">implies</a>
  (<a href="VL2014____VL-BITLIST-EQUIV.html">vl-bitlist-equiv</a> care-bits care-bits-equiv)
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="VL2014____VL-MSB-BITS-TO-CARE-MASK.html">vl-msb-bits-to-care-mask</a> msb-bits care-bits value)
         (<a href="VL2014____VL-MSB-BITS-TO-CARE-MASK.html">vl-msb-bits-to-care-mask</a> msb-bits care-bits-equiv value)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>vl-msb-bits-to-care-mask-of-nfix-value</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   vl-msb-bits-to-care-mask-of-nfix-value
   (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="VL2014____VL-MSB-BITS-TO-CARE-MASK.html">vl-msb-bits-to-care-mask</a> msb-bits care-bits (<a href="ACL2____NFIX.html">nfix</a> value))
          (<a href="VL2014____VL-MSB-BITS-TO-CARE-MASK.html">vl-msb-bits-to-care-mask</a> msb-bits care-bits value)))</pre> 
<p><b>Theorem: </b>vl-msb-bits-to-care-mask-nat-equiv-congruence-on-value</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 vl-msb-bits-to-care-mask-nat-equiv-congruence-on-value
 (<a href="ACL2____IMPLIES.html">implies</a>
  (<a href="ACL2____NAT-EQUIV.html">acl2::nat-equiv</a> value value-equiv)
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="VL2014____VL-MSB-BITS-TO-CARE-MASK.html">vl-msb-bits-to-care-mask</a> msb-bits care-bits value)
         (<a href="VL2014____VL-MSB-BITS-TO-CARE-MASK.html">vl-msb-bits-to-care-mask</a> msb-bits care-bits value-equiv)))
 :rule-classes :congruence)</pre> 

</body>
</html>
