<html>
<head>
<meta charset="UTF-8">
<title>Congruence</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____CONGRUENCE">Click for Congruence in the Full Manual</a></h3>

<p>The relations to maintain while simplifying arguments</p><p>See <a href="ACL2____RULE-CLASSES.html">rule-classes</a> for a general discussion of rule classes 
 and how they are used to build rules from formulas.  An example <span class="v">:</span><span class="tt"><a href="ACL2____COROLLARY.html">corollary</a></span> formula from which a rule of class <span class="v">:congruence</span> might be built, 
 assuming that <span class="v">set-equal</span> is a known <a href="ACL2____EQUIVALENCE.html">equivalence</a> relation, is:</p> 
 
 <pre class="code">Example:
(<a href="ACL2____DEFTHM.html">defthm</a> set-equal-implies-iff-memb-2
  (<a href="ACL2____IMPLIES.html">implies</a> (set-equal x y)
           (<a href="ACL2____IFF.html">iff</a> (memb e x) (memb e y)))
  :rule-classes :congruence)</pre> 
 
 <p>Also see <a href="ACL2____DEFCONG.html">defcong</a> and see <a href="ACL2____EQUIVALENCE.html">equivalence</a>.</p> 
 
 <p>NOTE: This topic discusses so-called ``classic'' congruence rules.  A more 
 general class of rules, so-called ``patterned'' congruence rules, is 
 supported.  We discuss only classic congruence rules below; for a discussion 
 of patterned congruence rules, first read the present topic and then see <a href="ACL2____PATTERNED-CONGRUENCE.html">patterned-congruence</a>.</p> 
 
 <pre class="code">General Form:
(<a href="ACL2____IMPLIES.html">implies</a> (equiv1 xk xk-equiv)
         (equiv2 (fn x1... xk       ...xn)
                 (fn x1... xk-equiv ...xn)))</pre> 
 
 <p>where <span class="v">equiv1</span> and <span class="v">equiv2</span> are known equivalence relations, <span class="v">fn</span> 
 is an <span class="v">n-ary</span> function symbol other than <span class="v">if</span>, and the <span class="v">xi</span> and 
 <span class="v">xk-equiv</span> are all distinct variables.  The effect of such a rule is to 
 record that the <span class="v">equiv2</span>-equivalence of <span class="v">fn</span>-expressions can be 
 maintained if, while rewriting the <span class="v">kth</span> argument position, 
 <span class="v">equiv1</span>-equivalence is maintained.  See <a href="ACL2____EQUIVALENCE.html">equivalence</a> for a general 
 discussion of the issues.  We say that <span class="v">equiv2</span>, above, is the ``outside 
 equivalence'' in the rule and <span class="v">equiv1</span> is the ``inside equivalence for the 
 <span class="v">k</span>th argument.''</p> 
 
 <p>The macro form <span class="v">(<a href="ACL2____DEFCONG.html">defcong</a> equiv1 equiv2 (fn x1 ... x1) k)</span> is an 
 abbreviation for a <span class="tt"><a href="ACL2____DEFTHM.html">defthm</a></span> of rule-class <span class="v">:congruence</span> that attempts 
 to establish that <span class="v">equiv2</span> is maintained by maintaining <span class="v">equiv1</span> in 
 <span class="v">fn</span>'s <span class="v">k</span>th argument.  The <span class="tt"><a href="ACL2____DEFCONG.html">defcong</a></span> macro automatically 
 generates the general formula shown above.  See <a href="ACL2____DEFCONG.html">defcong</a>.</p> 
 
 <p>The <span class="v">memb</span> example above tells us that <span class="v">(memb e x)</span> is 
 propositionally equivalent to <span class="v">(memb e y)</span>, provided <span class="v">x</span> and <span class="v">y</span> are 
 <span class="v">set-equal</span>.  The outside equivalence is <span class="tt"><a href="ACL2____IFF.html">iff</a></span> and the inside 
 equivalence for the second argument is <span class="v">set-equal</span>.  If we see a <span class="v">memb</span> 
 expression in a propositional context, e.g., as a literal of a clause or test 
 of an <span class="tt"><a href="COMMON-LISP____IF.html">if</a></span> (but not, for example, as an argument to <span class="tt"><a href="COMMON-LISP____CONS.html">cons</a></span>), we 
 can rewrite its second argument maintaining <span class="v">set-equality</span>.  For example, a 
 rule stating the commutativity of <span class="tt"><a href="COMMON-LISP____APPEND.html">append</a></span> (modulo set-equality) could 
 be applied in this context.  Since equality is a refinement of all equivalence 
 relations, all equality rules are always available.  See <a href="ACL2____REFINEMENT.html">refinement</a>.</p> 
 
 <p>All known congruence rules about a given outside equivalence and <span class="v">fn</span> 
 can be used independently.  That is, consider two congruence rules with the 
 same outside equivalence, <span class="v">equiv</span>, and about the same function <span class="v">fn</span>. 
 Suppose one says that <span class="v">equiv1</span> is the inside equivalence for the first 
 argument and the other says <span class="v">equiv2</span> is the inside equivalence for the 
 second argument.  Then <span class="v">(fn a b)</span> is <span class="v">equiv</span> <span class="tt">(fn a' b')</span> 
 provided <span class="v">a</span> is <span class="v">equiv1</span> to <span class="v">a'</span> and <span class="v">b</span> is <span class="v">equiv2</span> to 
 <span class="v">b'</span>.  This is an easy consequence of the transitivity of <span class="v">equiv</span>.  It 
 permits you to think independently about the inside equivalences.</p> 
 
 <p>Furthermore, it is possible that more than one inside equivalence for a 
 given argument slot will maintain a given outside equivalence.  For example, 
 <span class="v">(<a href="COMMON-LISP____LENGTH.html">length</a> a)</span> is equal to <span class="tt">(length a')</span> if <span class="v">a</span> and <span class="v">a'</span> are 
 related either by <span class="v">list-equal</span> or by <span class="tt"><a href="COMMON-LISP____STRING-EQUAL.html">string-equal</a></span>.  You may prove 
 two (or more) congruence rules for the same slot of a function.  The result is 
 that the system uses a new, ``generated'' equivalence relation for that slot 
 with the result that rules of both (or all) kinds are available while 
 rewriting.</p> 
 
 <p>Congruence rules can be <a href="ACL2____DISABLE.html">disable</a>d.  For example, if you have two 
 different inside equivalences for a given argument position and you find that 
 the <span class="v">:</span><span class="tt"><a href="ACL2____REWRITE.html">rewrite</a></span> rules for one are unexpectedly preventing the 
 application of the desired rule, you can disable the rule that introduced the 
 unwanted inside equivalence.</p> 
 
 <p><b>NOTE</b> however that unlike other rules, the tracking of congruence 
 rules is incomplete.  Specifically: when congruence rules are used by the 
 rewriter as it descends through terms, to maintain the generated equivalence 
 relation used for rewriting, ACL2 does not track the congruence rules that are 
 used, even though it is relevant that they are all <a href="ACL2____ENABLE.html">enable</a>d.  Congruence 
 rules that are used only in this way will therefore not appear in the <a href="ACL2____SUMMARY.html">summary</a>.</p> 
 
 <p><i>Remark on Replacing IFF by EQUAL.</i> You may encounter a warning 
 suggesting that a congruence rule ``can be strengthened by replacing the 
 second equivalence relation, IFF, by EQUAL.''  Suppose for example that this 
 warning occurs when you submit the following rule:</p> 
 
 <pre class="code">(<a href="ACL2____DEFCONG.html">defcong</a> equiv1 iff (fn x y) 2)</pre> 
 
 <p>which is shorthand for the following:</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equiv1-implies-iff-fn-2
       (<a href="ACL2____IMPLIES.html">implies</a> (equiv1 y y-equiv)
                (<a href="ACL2____IFF.html">iff</a> (fn x y) (fn x y-equiv)))
       :rule-classes (:congruence))</pre> 
 
 <p>The warning is telling you that ACL2 was able to deduce that <span class="v">fn</span> always 
 returns a Boolean, and hence a trivial but useful consequence is obtained by 
 replacing <span class="tt"><a href="ACL2____IFF.html">iff</a></span> by <span class="tt"><a href="COMMON-LISP____EQUAL.html">equal</a></span> </p> 
 
 <pre class="code">(<a href="ACL2____DEFCONG.html">defcong</a> equiv1 equal (fn x y) 2)</pre> 
 
 <p> which is shorthand for the following:</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equiv1-implies-equal-fn-2
       (<a href="ACL2____IMPLIES.html">implies</a> (equiv1 y y-equiv)
                (<a href="COMMON-LISP____EQUAL.html">equal</a> (fn x y) (fn x y-equiv)))
       :rule-classes (:congruence))</pre> 
 
 <p>If you have difficulty proving the latter directly, you can derive it from 
 the former by giving a suitable hint, minimally as follows.</p> 
 
 <pre class="code">(<a href="ACL2____DEFCONG.html">defcong</a> equiv1 equal (fn x y) 2
  :hints (("Goal"
           :use equiv1-implies-iff-fn-2
           :in-theory
           (<a href="ACL2____UNION-THEORIES.html">union-theories</a> '((:type-prescription fn))
                           (<a href="ACL2____THEORY.html">theory</a> 'minimal-theory)))))</pre> 
 
 <p>By heeding this warning, you may avoid unnecessary <span class="tt"><a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a></span> 
 warnings later.  We now explain why, but see <a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> for 
 relevant background material.</p> 
 
 <p>For example, suppose you have proved the ``<span class="v">iff</span>'' version of the 
 congruence rule above, and later you submit the following rewrite rule.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-list-perm
  (<a href="ACL2____IMPLIES.html">implies</a> (equiv1 x y)
           (fn x y)))</pre> 
 
 <p>Since <span class="v">fn</span> is known to return a Boolean, ACL2 performs an optimization 
 that stores this rule as though it were the following.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-list-perm
  (<a href="ACL2____IMPLIES.html">implies</a> (equiv1 x y)
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (fn x y) t)))</pre> 
 
 <p>Thus, if ACL2's rewriter sees a term <span class="v">(fn a b)</span> in a context where the 
 equivalence relation <span class="tt"><a href="ACL2____IFF.html">iff</a></span> is not being maintained, then it cannot use 
 rule <span class="v">equiv1-implies-iff-fn-2</span>, so it rewrites argument <span class="v">a</span> without the 
 benefit of knowing that it suffices to maintain <span class="v">equiv1</span>; and then it 
 caches the result.  When ACL2 subsequently attempts to relieve the hypothesis 
 <span class="v">(equiv1 x y)</span>, it will rewrite <span class="v">x</span> simply by returning the rewritten 
 value of <span class="v">a</span> from the result cache.  This is unfortunate if <span class="v">a</span> could 
 have been rewritten more completely under maintenance of the equivalence 
 relation <span class="v">equiv1</span>  which is legal in the hypothesis since <span class="v">a</span> is 
 an argument of <span class="v">equiv1</span>, which is an <a href="ACL2____EQUIVALENCE.html">equivalence</a> relation.  The user 
 who observes the warning from rule <span class="v">equiv1-implies-iff-fn-2</span>, and replaces 
 it with <span class="v">equiv1-implies-equal-fn-2</span>, will avoid this unfortunate 
 case.</p>
</body>
</html>
