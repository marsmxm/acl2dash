<html>
<head>
<meta charset="UTF-8">
<title>Radix-4 Booth Encoding</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=RTL____Radix-4_02Booth_02Encoding">Click for Radix-4 Booth Encoding in the Full Manual</a></h3>

<p>Radix-4 Booth Encoding</p><h3>Definitions and Theorems</h3><p><b>Function: </b>theta</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> theta (i y)
       (<a href="COMMON-LISP_____B2.html">+</a> (bitn y (<a href="COMMON-LISP____1-.html">1-</a> (<a href="COMMON-LISP_____A2.html">*</a> 2 i)))
          (bitn y (<a href="COMMON-LISP_____A2.html">*</a> 2 i))
          (<a href="COMMON-LISP_____A2.html">*</a> -2 (bitn y (<a href="COMMON-LISP____1_B2.html">1+</a> (<a href="COMMON-LISP_____A2.html">*</a> 2 i))))))</pre><p><b>Theorem: </b>theta-bounds</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> theta-bounds
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> -2 (theta i y))
             (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (theta i y) 2))
        :rule-classes :linear)</pre><p><b>Function: </b>sum-theta</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> sum-theta (m y)
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> m)
           0
           (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP_____A2.html">*</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP_____A2.html">*</a> 2 (<a href="COMMON-LISP____1-.html">1-</a> m)))
                 (theta (<a href="COMMON-LISP____1-.html">1-</a> m) y))
              (sum-theta (<a href="COMMON-LISP____1-.html">1-</a> m) y))))</pre><p><b>Theorem: </b>sum-theta-lemma-signed</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sum-theta-lemma-signed
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____POSP.html">posp</a> m) (bvecp y (<a href="COMMON-LISP_____A2.html">*</a> 2 m)))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (sum-theta m y) (si y (<a href="COMMON-LISP_____A2.html">*</a> 2 m)))))</pre><p><b>Function: </b>bmux4signed</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> bmux4signed (zeta x n)
       (<a href="COMMON-LISP____CASE.html">case</a> zeta (1 x)
             (-1 (bits (<a href="COMMON-LISP____LOGNOT.html">lognot</a> x) (<a href="COMMON-LISP____1-.html">1-</a> n) 0))
             (2 (bits (<a href="COMMON-LISP_____A2.html">*</a> 2 x) (<a href="COMMON-LISP____1-.html">1-</a> n) 0))
             (-2 (bits (<a href="COMMON-LISP____LOGNOT.html">lognot</a> (<a href="COMMON-LISP_____A2.html">*</a> 2 x)) (<a href="COMMON-LISP____1-.html">1-</a> n) 0))
             (0 0)))</pre><p><b>Theorem: </b>bvecp-bmux4signed</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   bvecp-bmux4signed
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> zeta)
                 (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> -2 zeta)
                 (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> zeta 2)
                 (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)
                 (bvecp x n))
            (bvecp (bmux4signed zeta x n) n))
   :rule-classes
   ((:rewrite :corollary (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> zeta)
                                       (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> -2 zeta)
                                       (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> zeta 2)
                                       (bvecp x n)
                                       (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n))
                                  (bvecp (bmux4signed zeta x n) n)))
    (:type-prescription
         :corollary (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> zeta)
                                  (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> -2 zeta)
                                  (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> zeta 2)
                                  (bvecp x n)
                                  (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n))
                             (<a href="ACL2____NATP.html">natp</a> (bmux4signed zeta x n))))
    (:linear :corollary (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> zeta)
                                      (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> -2 zeta)
                                      (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> zeta 2)
                                      (bvecp x n)
                                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n))
                                 (<a href="COMMON-LISP_____C3.html">&lt;</a> (bmux4signed zeta x n)
                                    (<a href="COMMON-LISP____EXPT.html">expt</a> 2 n))))))</pre><p><b>Function: </b>tau</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> tau (zeta sign)
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> zeta 0)
           0 (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> 0 zeta) sign (lognot1 sign))))</pre><p><b>Function: </b>neg</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> neg (x) (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> x 0) 1 0))</pre><p><b>Function: </b>pp4signed-theta</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> pp4signed-theta (i x y n)
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ZEROP.html">zerop</a> i)
           (cat 1 1
                (lognot1 (tau (theta i y) (bitn x (<a href="COMMON-LISP____1-.html">1-</a> n))))
                1 (bmux4signed (theta i y) x n)
                n)
           (cat 1 1
                (lognot1 (tau (theta i y) (bitn x (<a href="COMMON-LISP____1-.html">1-</a> n))))
                1 (bmux4signed (theta i y) x n)
                n 0 1 (neg (theta (<a href="COMMON-LISP____1-.html">1-</a> i) y))
                1 0 (<a href="COMMON-LISP_____A2.html">*</a> 2 (<a href="COMMON-LISP____1-.html">1-</a> i)))))</pre><p><b>Function: </b>sum-pp4signed-theta</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> sum-pp4signed-theta (x y m n)
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> m)
           0
           (<a href="COMMON-LISP_____B2.html">+</a> (pp4signed-theta (<a href="COMMON-LISP____1-.html">1-</a> m) x y n)
              (sum-pp4signed-theta x y (<a href="COMMON-LISP____1-.html">1-</a> m) n))))</pre><p><b>Theorem: </b>booth4signed-corollary</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> booth4signed-corollary
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____POSP.html">posp</a> m)
                      (<a href="ACL2____POSP.html">posp</a> n)
                      (bvecp x n)
                      (bvecp y (<a href="COMMON-LISP_____A2.html">*</a> 2 m)))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (sum-pp4signed-theta x y m n)
                        (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP____-.html">-</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 n))
                           (<a href="COMMON-LISP____-.html">-</a> (<a href="COMMON-LISP_____A2.html">*</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP_____A2.html">*</a> 2 (<a href="COMMON-LISP____1-.html">1-</a> m)))
                                 (neg (theta (<a href="COMMON-LISP____1-.html">1-</a> m) y))))
                           (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP_____B2.html">+</a> n (<a href="COMMON-LISP_____A2.html">*</a> 2 m)))
                           (<a href="COMMON-LISP_____A2.html">*</a> (si x n) (si y (<a href="COMMON-LISP_____A2.html">*</a> 2 m)))))))</pre><p><b>Theorem: </b>booth4signed-corollary-alt</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> booth4signed-corollary-alt
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____POSP.html">posp</a> m)
                      (<a href="ACL2____POSP.html">posp</a> n)
                      (bvecp x n)
                      (bvecp y (<a href="COMMON-LISP_____A2.html">*</a> 2 m)))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 n)
                           (<a href="COMMON-LISP_____A2.html">*</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP_____A2.html">*</a> 2 (<a href="COMMON-LISP____1-.html">1-</a> m)))
                              (neg (theta (<a href="COMMON-LISP____1-.html">1-</a> m) y)))
                           (sum-pp4signed-theta x y m n))
                        (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP_____B2.html">+</a> n (<a href="COMMON-LISP_____A2.html">*</a> 2 m)))
                           (<a href="COMMON-LISP_____A2.html">*</a> (si x n) (si y (<a href="COMMON-LISP_____A2.html">*</a> 2 m)))))))</pre><p><b>Theorem: </b>sum-theta-lemma</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sum-theta-lemma
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> m))
                      (bvecp y (<a href="COMMON-LISP____1-.html">1-</a> (<a href="COMMON-LISP_____A2.html">*</a> 2 m))))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> y (sum-theta m y)))
        :rule-classes nil)</pre><p><b>Function: </b>bmux4</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> bmux4 (zeta x n)
       (<a href="COMMON-LISP____CASE.html">case</a> zeta (1 x)
             (-1 (bits (<a href="COMMON-LISP____LOGNOT.html">lognot</a> x) (<a href="COMMON-LISP____1-.html">1-</a> n) 0))
             (2 (<a href="COMMON-LISP_____A2.html">*</a> 2 x))
             (-2 (bits (<a href="COMMON-LISP____LOGNOT.html">lognot</a> (<a href="COMMON-LISP_____A2.html">*</a> 2 x)) (<a href="COMMON-LISP____1-.html">1-</a> n) 0))
             (0 0)))</pre><p><b>Function: </b>pp4-theta</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> pp4-theta (i x y n)
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ZEROP.html">zerop</a> i)
           (cat 1 1 (bitn (<a href="COMMON-LISP____LOGNOT.html">lognot</a> (neg (theta i y))) 0)
                1 (bmux4 (theta i y) x n)
                n)
           (cat 1 1 (bitn (<a href="COMMON-LISP____LOGNOT.html">lognot</a> (neg (theta i y))) 0)
                1 (bmux4 (theta i y) x n)
                n 0 1 (neg (theta (<a href="COMMON-LISP____1-.html">1-</a> i) y))
                1 0 (<a href="COMMON-LISP_____A2.html">*</a> 2 (<a href="COMMON-LISP____1-.html">1-</a> i)))))</pre><p><b>Function: </b>sum-pp4-theta</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> sum-pp4-theta (x y m n)
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> m)
           0
           (<a href="COMMON-LISP_____B2.html">+</a> (pp4-theta (<a href="COMMON-LISP____1-.html">1-</a> m) x y n)
              (sum-pp4-theta x y (<a href="COMMON-LISP____1-.html">1-</a> m) n))))</pre><p><b>Theorem: </b>booth4-corollary-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> booth4-corollary-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> n))
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> m))
                      (bvecp x (<a href="COMMON-LISP____1-.html">1-</a> n))
                      (bvecp y (<a href="COMMON-LISP____1-.html">1-</a> (<a href="COMMON-LISP_____A2.html">*</a> 2 m))))
                 (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 n) (sum-pp4-theta x y m n))
                    (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP_____B2.html">+</a> n (<a href="COMMON-LISP_____A2.html">*</a> 2 m))) (<a href="COMMON-LISP_____A2.html">*</a> x y))))
        :rule-classes nil)</pre><p><b>Function: </b>pp4p-theta</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> pp4p-theta (i x y n)
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ZEROP.html">zerop</a> i)
           (cat (bitn (<a href="COMMON-LISP____LOGNOT.html">lognot</a> (neg (theta i y))) 0)
                1 (neg (theta i y))
                1 (neg (theta i y))
                1 (bmux4 (theta i y) x n)
                n)
           (cat 1 1 (bitn (<a href="COMMON-LISP____LOGNOT.html">lognot</a> (neg (theta i y))) 0)
                1 (bmux4 (theta i y) x n)
                n 0 1 (neg (theta (<a href="COMMON-LISP____1-.html">1-</a> i) y))
                1 0 (<a href="COMMON-LISP_____A2.html">*</a> 2 (<a href="COMMON-LISP____1-.html">1-</a> i)))))</pre><p><b>Function: </b>sum-pp4p-theta</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> sum-pp4p-theta (x y m n)
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> m)
           0
           (<a href="COMMON-LISP_____B2.html">+</a> (pp4p-theta (<a href="COMMON-LISP____1-.html">1-</a> m) x y n)
              (sum-pp4p-theta x y (<a href="COMMON-LISP____1-.html">1-</a> m) n))))</pre><p><b>Theorem: </b>booth4-corollary-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> booth4-corollary-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> n))
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> m))
                      (bvecp x (<a href="COMMON-LISP____1-.html">1-</a> n))
                      (bvecp y (<a href="COMMON-LISP____1-.html">1-</a> (<a href="COMMON-LISP_____A2.html">*</a> 2 m))))
                 (<a href="COMMON-LISP_____D3.html">=</a> (bits (sum-pp4p-theta x y m n)
                          (<a href="COMMON-LISP____1-.html">1-</a> (<a href="COMMON-LISP_____B2.html">+</a> n (<a href="COMMON-LISP_____A2.html">*</a> 2 m)))
                          0)
                    (<a href="COMMON-LISP_____A2.html">*</a> x y)))
        :rule-classes nil)</pre><p><b>Function: </b>mag</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> mag (i y)
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____MEMBER.html">member</a> (bits y (<a href="COMMON-LISP____1_B2.html">1+</a> (<a href="COMMON-LISP_____A2.html">*</a> 2 i)) (<a href="COMMON-LISP____1-.html">1-</a> (<a href="COMMON-LISP_____A2.html">*</a> 2 i)))
                   '(3 4))
           2
           (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____MEMBER.html">member</a> (bits y (<a href="COMMON-LISP_____A2.html">*</a> 2 i) (<a href="COMMON-LISP____1-.html">1-</a> (<a href="COMMON-LISP_____A2.html">*</a> 2 i)))
                       '(1 2))
               1 0)))</pre><p><b>Function: </b>nbit</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> nbit (i y) (bitn y (<a href="COMMON-LISP____1_B2.html">1+</a> (<a href="COMMON-LISP_____A2.html">*</a> 2 i))))</pre><p><b>Theorem: </b>theta-rewrite</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> theta-rewrite
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> y) (<a href="ACL2____NATP.html">natp</a> i))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (theta i y)
                        (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____D3.html">=</a> (nbit i y) 1)
                            (<a href="COMMON-LISP____-.html">-</a> (mag i y))
                            (mag i y)))))</pre><p><b>Function: </b>bmux4p</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> bmux4p (i x y n)
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____D3.html">=</a> (nbit i y) 1)
           (bits (<a href="COMMON-LISP____LOGNOT.html">lognot</a> (<a href="COMMON-LISP_____A2.html">*</a> (mag i y) x)) (<a href="COMMON-LISP____1-.html">1-</a> n) 0)
           (<a href="COMMON-LISP_____A2.html">*</a> (mag i y) x)))</pre><p><b>Theorem: </b>bvecp-bmux4p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bvecp-bmux4p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> n)) (bvecp x (<a href="COMMON-LISP____1-.html">1-</a> n)))
                 (bvecp (bmux4p i x y n) n)))</pre><p><b>Theorem: </b>bmux4p-rewrite</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bmux4p-rewrite
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> n))
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> m))
                      (bvecp x (<a href="COMMON-LISP____1-.html">1-</a> n))
                      (bvecp y (<a href="COMMON-LISP____1-.html">1-</a> (<a href="COMMON-LISP_____A2.html">*</a> 2 m)))
                      (<a href="ACL2____NATP.html">natp</a> i)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> i m))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (bmux4p i x y n)
                        (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP_____A2.html">*</a> (theta i y) x)
                           (<a href="COMMON-LISP_____A2.html">*</a> (<a href="COMMON-LISP____1-.html">1-</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 n)) (nbit i y))))))</pre><p><b>Function: </b>pp4p</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> pp4p (i x y n)
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ZEROP.html">zerop</a> i)
           (cat (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____D3.html">=</a> (nbit 0 y) 0) 1 0)
                1 (nbit 0 y)
                1 (nbit 0 y)
                1 (bmux4p 0 x y n)
                n)
           (cat 1 1 (<a href="COMMON-LISP____LOGNOT.html">lognot</a> (nbit i y))
                1 (bmux4p i x y n)
                n 0 1 (nbit (<a href="COMMON-LISP____1-.html">1-</a> i) y)
                1 0 (<a href="COMMON-LISP_____A2.html">*</a> 2 (<a href="COMMON-LISP____1-.html">1-</a> i)))))</pre><p><b>Theorem: </b>pp4p0-rewrite</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pp4p0-rewrite
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> n))
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> m))
                      (bvecp x (<a href="COMMON-LISP____1-.html">1-</a> n))
                      (bvecp y (<a href="COMMON-LISP____1-.html">1-</a> (<a href="COMMON-LISP_____A2.html">*</a> 2 m))))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (pp4p 0 x y n)
                        (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP_____B2.html">+</a> n 2))
                           (<a href="COMMON-LISP_____A2.html">*</a> (theta 0 y) x)
                           (<a href="COMMON-LISP____-.html">-</a> (nbit 0 y))))))</pre><p><b>Theorem: </b>pp4p-rewrite</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pp4p-rewrite
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> n))
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> m))
                      (bvecp x (<a href="COMMON-LISP____1-.html">1-</a> n))
                      (bvecp y (<a href="COMMON-LISP____1-.html">1-</a> (<a href="COMMON-LISP_____A2.html">*</a> 2 m)))
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> i))
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> i m))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (pp4p i x y n)
                        (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP_____B2.html">+</a> n (<a href="COMMON-LISP_____A2.html">*</a> 2 i) 1))
                           (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP_____B2.html">+</a> n (<a href="COMMON-LISP_____A2.html">*</a> 2 i)))
                           (<a href="COMMON-LISP_____A2.html">*</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP_____A2.html">*</a> 2 i)) (theta i y) x)
                           (<a href="COMMON-LISP_____A2.html">*</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP_____A2.html">*</a> 2 (<a href="COMMON-LISP____1-.html">1-</a> i)))
                              (nbit (<a href="COMMON-LISP____1-.html">1-</a> i) y))
                           (<a href="COMMON-LISP____-.html">-</a> (<a href="COMMON-LISP_____A2.html">*</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP_____A2.html">*</a> 2 i)) (nbit i y)))))))</pre><p><b>Function: </b>sum-pp4p</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> sum-pp4p (x y m n)
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> m)
           0
           (<a href="COMMON-LISP_____B2.html">+</a> (pp4p (<a href="COMMON-LISP____1-.html">1-</a> m) x y n)
              (sum-pp4p x y (<a href="COMMON-LISP____1-.html">1-</a> m) n))))</pre><p><b>Theorem: </b>booth4-corollary-3</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> booth4-corollary-3
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> n))
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> m))
                      (bvecp x (<a href="COMMON-LISP____1-.html">1-</a> n))
                      (bvecp y (<a href="COMMON-LISP____1-.html">1-</a> (<a href="COMMON-LISP_____A2.html">*</a> 2 m))))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (sum-pp4p x y m n)
                        (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP_____A2.html">*</a> x y) (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP_____B2.html">+</a> n (<a href="COMMON-LISP_____A2.html">*</a> 2 m)))))))</pre> 
 

</body>
</html>
