<html>
<head>
<meta charset="UTF-8">
<title>Check-function-definition-top/nontop</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=SYNTHETO____CHECK-FUNCTION-DEFINITION-TOP_F2NONTOP">Click for Check-function-definition-top/nontop in the Full Manual</a></h3>

<p>Check if a function definition (at the top level or not) 
          is statically well-formed.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(check-function-definition-top/nontop fundef ctxt) 
  → 
(mv err? obligs)</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">fundef</span> — <font color="#606060">Guard <span class="v">(<a href="SYNTHETO____FUNCTION-DEFINITIONP.html">function-definitionp</a> fundef)</span>.</font>
</dd> 
  <dd>
<span class="tt">ctxt</span> — <font color="#606060">Guard <span class="v">(<a href="SYNTHETO____CONTEXTP.html">contextp</a> ctxt)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">obligs</span> — <font color="#606060">Type <span class="v">(<a href="SYNTHETO____PROOF-OBLIGATION-LISTP.html">proof-obligation-listp</a> obligs)</span>.</font>
</dd> 
 
</dl></div> 
<p>This is used both by <span class="tt"><a href="SYNTHETO____CHECK-FUNCTION-DEFINITION.html">check-function-definition</a></span> 
     and by <span class="tt"><a href="SYNTHETO____CHECK-FUNCTION-DEFINITION-LIST.html">check-function-definition-list</a></span>.</p><p>At the top level, the context has no 
     types being defined, 
     functions being defined, 
     variables in scope, 
     obligation variables, or 
     obligation hypotheses. 
     But the caller of this function, 
     either  <span class="tt"><a href="SYNTHETO____CHECK-FUNCTION-DEFINITION.html">check-function-definition</a></span> 
     or <span class="tt"><a href="SYNTHETO____CHECK-FUNCTION-DEFINITION-LIST.html">check-function-definition-list</a></span>, 
     extends the context component for the functions being defined; 
     thus, this function definition's header is always in the context. 
     This motivates the extra guard condition of this ACL2 function.</p><p>First we check the header; 
     recall that part of that check is that 
     no function with that name is already defined. 
     We augment the context with the function's inputs. 
     If here is a precondition, 
     we check it and ensure it returns a boolean, 
     and we add the precondition as an obligation hypothesis to the context. 
     We check the function's definer. 
     We further augment the context with the function outputs. 
     If there is a postcondition, 
     we check it and ensure it returns a boolean; 
     note that we are assuming the precondition (if any) 
     in checking the postcondition. 
     We also generate a proof obligation saying that the postcondition holds; 
     note that the precondition (if any) is in 
     the hypotheses of that proof obligation.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>check-function-definition-top/nontop</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 check-function-definition-top/nontop
 (fundef ctxt)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SYNTHETO____FUNCTION-DEFINITIONP.html">function-definitionp</a> fundef)
                             (<a href="SYNTHETO____CONTEXTP.html">contextp</a> ctxt))))
 (<a href="COMMON-LISP____DECLARE.html">declare</a>
  (<a href="ACL2____XARGS.html">xargs</a>
      :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NULL.html">null</a> (<a href="SYNTHETO____CONTEXT-_E3TYPES.html">context-&gt;types</a> ctxt))
                  (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> (<a href="SYNTHETO____FUNCTION-DEFINITION-_E3HEADER.html">function-definition-&gt;header</a> fundef)
                                (<a href="SYNTHETO____CONTEXT-_E3FUNCTIONS.html">context-&gt;functions</a> ctxt))
                  (<a href="OMAP____EMPTY.html">omap::empty</a> (<a href="SYNTHETO____CONTEXT-_E3VARIABLES.html">context-&gt;variables</a> ctxt))
                  (<a href="COMMON-LISP____NULL.html">null</a> (<a href="SYNTHETO____CONTEXT-_E3OBLIGATION-VARS.html">context-&gt;obligation-vars</a> ctxt))
                  (<a href="COMMON-LISP____NULL.html">null</a> (<a href="SYNTHETO____CONTEXT-_E3OBLIGATION-HYPS.html">context-&gt;obligation-hyps</a> ctxt)))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((__function__ 'check-function-definition-top/nontop))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
  (<a href="ACL2____B_A2.html">b*</a>
   (((<a href="SYNTHETO____FUNCTION-DEFINITION.html">function-definition</a> fundef) fundef)
    (err? (<a href="SYNTHETO____CHECK-FUNCTION-HEADER.html">check-function-header</a> fundef.header ctxt))
    (fn-name
         (<a href="SYNTHETO____IDENTIFIER-_E3NAME.html">identifier-&gt;name</a> (<a href="SYNTHETO____FUNCTION-HEADER-_E3NAME.html">function-header-&gt;name</a> fundef.header)))
    ((when err?) (<a href="ACL2____MV.html">mv</a> err? nil))
    (inputs (<a href="SYNTHETO____FUNCTION-HEADER-_E3INPUTS.html">function-header-&gt;inputs</a> fundef.header))
    (outputs (<a href="SYNTHETO____FUNCTION-HEADER-_E3OUTPUTS.html">function-header-&gt;outputs</a> fundef.header))
    (in-var-ctxt (<a href="SYNTHETO____TYPED-VARIABLES-TO-VARIABLE-CONTEXT.html">typed-variables-to-variable-context</a> inputs))
    (ctxt (<a href="SYNTHETO____CONTEXT-ADD-VARIABLES.html">context-add-variables</a> in-var-ctxt ctxt))
    (ctxt (<a href="SYNTHETO____CHANGE-CONTEXT.html">change-context</a> ctxt
                          :obligation-vars inputs))
    ((<a href="ACL2____MV.html">mv</a> err? pre-obligs ctxt)
     (<a href="COMMON-LISP____IF.html">if</a>
      (<a href="COMMON-LISP____NOT.html">not</a> fundef.precondition)
      (<a href="ACL2____MV.html">mv</a> nil nil ctxt)
      (<a href="ACL2____B_A2.html">b*</a>
       ((pre-result (<a href="SYNTHETO____CHECK-EXPRESSION.html">check-expression</a> fundef.precondition ctxt)))
       (<a href="SYNTHETO____TYPE-RESULT-CASE.html">type-result-case</a>
        pre-result
        :err (<a href="ACL2____MV.html">mv</a> pre-result.info nil ctxt)
        :ok
        (<a href="ACL2____B_A2.html">b*</a>
         ((<a href="SYNTHETO____TYPE.html">type</a> (<a href="SYNTHETO____ENSURE-SINGLE-TYPE.html">ensure-single-type</a> pre-result.types))
          ((when (<a href="COMMON-LISP____NOT.html">not</a> type))
           (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____LIST.html">list</a> :multi-valued-precondition fundef.precondition)
               nil ctxt))
          ((unless (<a href="SYNTHETO____TYPE-EQUIV.html">type-equiv</a> type (<a href="SYNTHETO____TYPE-BOOLEAN.html">type-boolean</a>)))
           (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____LIST.html">list</a> :non-boolean-precondition fundef.precondition)
               nil ctxt))
          (ctxt (<a href="SYNTHETO____CONTEXT-ADD-CONDITION.html">context-add-condition</a> fundef.precondition ctxt)))
         (<a href="ACL2____MV.html">mv</a> nil pre-result.obligations ctxt))))))
    ((when err?) (<a href="ACL2____MV.html">mv</a> err? nil))
    (output-types (<a href="SYNTHETO____TYPED-VARIABLE-LIST-_E3TYPE-LIST.html">typed-variable-list-&gt;type-list</a> outputs))
    ((<a href="ACL2____MV.html">mv</a> err? def-obligs)
     (<a href="SYNTHETO____CHECK-FUNCTION-DEFINER.html">check-function-definer</a> fundef.definer
                             output-types fn-name ctxt))
    ((when err?) (<a href="ACL2____MV.html">mv</a> err? nil))
    (ctxt
       (<a href="SYNTHETO____CHANGE-CONTEXT.html">change-context</a>
            ctxt
            :obligation-vars (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="SYNTHETO____CONTEXT-_E3OBLIGATION-VARS.html">context-&gt;obligation-vars</a> ctxt)
                                     outputs)))
    ((<a href="ACL2____MV.html">mv</a> err? post-obligs)
     (<a href="COMMON-LISP____IF.html">if</a>
      (<a href="COMMON-LISP____NOT.html">not</a> fundef.postcondition)
      (<a href="ACL2____MV.html">mv</a> nil nil)
      (<a href="ACL2____B_A2.html">b*</a>
       ((var-ctxt (<a href="SYNTHETO____TYPED-VARIABLES-TO-VARIABLE-CONTEXT.html">typed-variables-to-variable-context</a> outputs))
        (ctxt (<a href="SYNTHETO____CONTEXT-ADD-VARIABLES.html">context-add-variables</a> var-ctxt ctxt))
        (post-result (<a href="SYNTHETO____CHECK-EXPRESSION.html">check-expression</a> fundef.postcondition ctxt)))
       (<a href="SYNTHETO____TYPE-RESULT-CASE.html">type-result-case</a>
        post-result
        :err (<a href="ACL2____MV.html">mv</a> post-result.info nil)
        :ok
        (<a href="ACL2____B_A2.html">b*</a>
         ((<a href="SYNTHETO____TYPE.html">type</a> (<a href="SYNTHETO____ENSURE-SINGLE-TYPE.html">ensure-single-type</a> post-result.types))
          ((when (<a href="COMMON-LISP____NOT.html">not</a> type))
           (<a href="ACL2____MV.html">mv</a>
             (<a href="COMMON-LISP____LIST.html">list</a> :multi-valued-postcondition fundef.postcondition)
             nil))
          ((unless (<a href="SYNTHETO____TYPE-EQUIV.html">type-equiv</a> type (<a href="SYNTHETO____TYPE-BOOLEAN.html">type-boolean</a>)))
           (<a href="ACL2____MV.html">mv</a>
              (<a href="COMMON-LISP____LIST.html">list</a> :non-boolean-postcondition fundef.postcondition)
              nil)))
         (<a href="ACL2____MV.html">mv</a> nil post-result.obligations))))))
    ((when err?) (<a href="ACL2____MV.html">mv</a> err? nil))
    (fn-body (<a href="SYNTHETO____FUNCTION-DEFINER-CASE.html">function-definer-case</a> fundef.definer
                                    :regular fundef.definer.body
                                    :quantified nil))
    (recursive-p (<a href="SYNTHETO____FUNCTION-CALLED-IN.html">function-called-in</a> fn-name fn-body))
    (fn-result-expr
     (<a href="COMMON-LISP____IF.html">if</a>
      (<a href="COMMON-LISP____AND.html">and</a> fn-body fundef.postcondition)
      (<a href="COMMON-LISP____IF.html">if</a>
       recursive-p
       (<a href="SYNTHETO____MAKE-EXPRESSION-CALL.html">make-expression-call</a>
            :function (<a href="SYNTHETO____MAKE-IDENTIFIER.html">make-identifier</a> :name fn-name)
            :types nil
            :arguments
            (<a href="SYNTHETO____TYPED-VARIABLE-LIST-_E3-EXPRESSION-VARIABLE-LIST.html">typed-variable-list-&gt;-expression-variable-list</a> inputs))
       fn-body)
      nil))
    (oblig?
     (<a href="COMMON-LISP____IF.html">if</a>
      fn-result-expr
      (<a href="SYNTHETO____NON-TRIVIAL-PROOF-OBLIGATION.html">non-trivial-proof-obligation</a>
          (<a href="SYNTHETO____CONTEXT-_E3OBLIGATION-VARS.html">context-&gt;obligation-vars</a> ctxt)
          (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="SYNTHETO____CONTEXT-_E3OBLIGATION-HYPS.html">context-&gt;obligation-hyps</a> ctxt)
                  (<a href="COMMON-LISP____LIST.html">list</a> (<a href="SYNTHETO____OBLIGATION-HYP-BINDING.html">obligation-hyp-binding</a>
                             (<a href="SYNTHETO____MAKE-BINDING.html">make-binding</a> :variables outputs
                                           :value fn-result-expr))))
          fundef.postcondition fn-body)
      nil)))
   (<a href="ACL2____MV.html">mv</a> nil
       (<a href="COMMON-LISP____APPEND.html">append</a> pre-obligs
               def-obligs post-obligs oblig?)))))</pre> 
<p><b>Theorem: </b>proof-obligation-listp-of-check-function-definition-top/nontop.obligs</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 proof-obligation-listp-of-check-function-definition-top/nontop.obligs
 (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?err? ?obligs)
       (<a href="SYNTHETO____CHECK-FUNCTION-DEFINITION-TOP_F2NONTOP.html">check-function-definition-top/nontop</a> fundef ctxt)))
     (<a href="SYNTHETO____PROOF-OBLIGATION-LISTP.html">proof-obligation-listp</a> obligs))
 :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>check-function-definition-top/nontop-of-function-definition-fix-fundef</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 check-function-definition-top/nontop-of-function-definition-fix-fundef
 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____CHECK-FUNCTION-DEFINITION-TOP_F2NONTOP.html">check-function-definition-top/nontop</a>
             (<a href="SYNTHETO____FUNCTION-DEFINITION-FIX.html">function-definition-fix</a> fundef)
             ctxt)
        (<a href="SYNTHETO____CHECK-FUNCTION-DEFINITION-TOP_F2NONTOP.html">check-function-definition-top/nontop</a> fundef ctxt)))</pre> 
<p><b>Theorem: </b>check-function-definition-top/nontop-function-definition-equiv-congruence-on-fundef</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 check-function-definition-top/nontop-function-definition-equiv-congruence-on-fundef
 (<a href="ACL2____IMPLIES.html">implies</a>
   (<a href="SYNTHETO____FUNCTION-DEFINITION-EQUIV.html">function-definition-equiv</a> fundef fundef-equiv)
   (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____CHECK-FUNCTION-DEFINITION-TOP_F2NONTOP.html">check-function-definition-top/nontop</a> fundef ctxt)
          (<a href="SYNTHETO____CHECK-FUNCTION-DEFINITION-TOP_F2NONTOP.html">check-function-definition-top/nontop</a> fundef-equiv ctxt)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>check-function-definition-top/nontop-of-context-fix-ctxt</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 check-function-definition-top/nontop-of-context-fix-ctxt
 (<a href="COMMON-LISP____EQUAL.html">equal</a>
    (<a href="SYNTHETO____CHECK-FUNCTION-DEFINITION-TOP_F2NONTOP.html">check-function-definition-top/nontop</a> fundef (<a href="SYNTHETO____CONTEXT-FIX.html">context-fix</a> ctxt))
    (<a href="SYNTHETO____CHECK-FUNCTION-DEFINITION-TOP_F2NONTOP.html">check-function-definition-top/nontop</a> fundef ctxt)))</pre> 
<p><b>Theorem: </b>check-function-definition-top/nontop-context-equiv-congruence-on-ctxt</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 check-function-definition-top/nontop-context-equiv-congruence-on-ctxt
 (<a href="ACL2____IMPLIES.html">implies</a>
   (<a href="SYNTHETO____CONTEXT-EQUIV.html">context-equiv</a> ctxt ctxt-equiv)
   (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____CHECK-FUNCTION-DEFINITION-TOP_F2NONTOP.html">check-function-definition-top/nontop</a> fundef ctxt)
          (<a href="SYNTHETO____CHECK-FUNCTION-DEFINITION-TOP_F2NONTOP.html">check-function-definition-top/nontop</a> fundef ctxt-equiv)))
 :rule-classes :congruence)</pre> 

</body>
</html>
