<html>
<head>
<meta charset="UTF-8">
<title>Eval-literal</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=YUL____EVAL-LITERAL">Click for Eval-literal in the Full Manual</a></h3>

<p>Evaluate a literal.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(eval-literal lit) → val</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">lit</span> — <font color="#606060">Guard <span class="v">(<a href="YUL____LITERALP.html">literalp</a> lit)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">val</span> — <font color="#606060">Type <span class="v">(<a href="YUL____VALUE-RESULTP.html">value-resultp</a> val)</span>.</font>
</dd> 
 
</dl></div> 
<p>Since for now our only values are 256-bit words, 
     we evaluate boolean literals to 0 (for false) and 1 (for true), 
     viewing the word as an unsigned integer. 
     This is not described in [Yul], but it was discussed on Gitter. 
     This should apply to at least the EVM dialect of Yul, 
     while other dialects that include a boolean type 
     may need to evaluate boolean literals differently. 
     We will generalize this aspect of our formalization at some point.</p><p>A decimal or hexadecimal literal evaluates to the word 
     whose unsigned integer value is the number represented by the literal. 
     This number must fit in 256 bits, otherwise it is an error.</p><p>Plain and hex strings are evaluated as described in 
     <span class="tt"><a href="YUL____EVAL-PLAIN-STRING-LITERAL.html">eval-plain-string-literal</a></span> and <span class="tt"><a href="YUL____EVAL-HEX-STRING-LITERAL.html">eval-hex-string-literal</a></span>.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>eval-literal</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 eval-literal (lit)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="YUL____LITERALP.html">literalp</a> lit)))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((__function__ 'eval-literal))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
  (<a href="YUL____LITERAL-CASE.html">literal-case</a>
   lit
   :boolean (<a href="COMMON-LISP____IF.html">if</a> lit.get (<a href="YUL____VALUE.html">value</a> 1) (<a href="YUL____VALUE.html">value</a> 0))
   :dec-number (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____UBYTE256P.html">acl2::ubyte256p</a> lit.get)
                   (<a href="YUL____VALUE.html">value</a> lit.get)
                   (<a href="FTY____ERR.html">err</a> (<a href="COMMON-LISP____LIST.html">list</a> :dec-number-too-large lit.get)))
   :hex-number
   (<a href="ACL2____B_A2.html">b*</a>
    ((num
      (<a href="STR____HEX-DIGIT-CHARS-VALUE.html">str::hex-digit-chars-value</a> (<a href="YUL____HEX-DIGIT-LIST-_E3CHARS.html">hex-digit-list-&gt;chars</a> lit.get))))
    (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____UBYTE256P.html">acl2::ubyte256p</a> num)
        (<a href="YUL____VALUE.html">value</a> num)
        (<a href="FTY____ERR.html">err</a> (<a href="COMMON-LISP____LIST.html">list</a> :hex-number-too-large lit.get))))
   :plain-string (<a href="YUL____EVAL-PLAIN-STRING-LITERAL.html">eval-plain-string-literal</a> lit.get)
   :hex-string (<a href="YUL____EVAL-HEX-STRING-LITERAL.html">eval-hex-string-literal</a> lit.get))))</pre> 
<p><b>Theorem: </b>value-resultp-of-eval-literal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> value-resultp-of-eval-literal
        (<a href="ACL2____B_A2.html">b*</a> ((val (<a href="YUL____EVAL-LITERAL.html">eval-literal</a> lit)))
            (<a href="YUL____VALUE-RESULTP.html">value-resultp</a> val))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>eval-literal-of-literal-fix-lit</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> eval-literal-of-literal-fix-lit
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="YUL____EVAL-LITERAL.html">eval-literal</a> (<a href="YUL____LITERAL-FIX.html">literal-fix</a> lit))
               (<a href="YUL____EVAL-LITERAL.html">eval-literal</a> lit)))</pre> 
<p><b>Theorem: </b>eval-literal-literal-equiv-congruence-on-lit</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> eval-literal-literal-equiv-congruence-on-lit
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="YUL____LITERAL-EQUIV.html">literal-equiv</a> lit lit-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="YUL____EVAL-LITERAL.html">eval-literal</a> lit)
                        (<a href="YUL____EVAL-LITERAL.html">eval-literal</a> lit-equiv)))
        :rule-classes :congruence)</pre> 

</body>
</html>
