<html>
<head>
<meta charset="UTF-8">
<title>Atj-tutorial-shallow</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=JAVA____ATJ-TUTORIAL-SHALLOW">Click for Atj-tutorial-shallow in the Full Manual</a></h3>

<p>ATJ tutorial: Shallow Embedding Approach.</p><p>This tutorial page introduces 
    the use of AIJ with the shallow embedding approach. 
    This approach provides much richer features than the <a href="JAVA____ATJ-TUTORIAL-DEEP.html">deep embedding approach</a>. These features will be presented throughout several tutorial pages. 
    This page describes the more basic features.</p><h5>AIJ's Role</h5><p>In the shallow embedding, <a href="JAVA____ATJ-TUTORIAL-AIJ.html">AIJ</a> plays a more limited role than in the deep embedding. 
    The shallow embedding uses <a href="JAVA____ATJ-TUTORIAL-ACL2-VALUES.html">AIJ's default Java representation of the ACL2 values</a> and <a href="JAVA____ATJ-TUTORIAL-NATIVE-FUNCTIONS.html">AIJ's natively implemented ACL2 functions</a>, but it does not use <a href="JAVA____ATJ-TUTORIAL-ACL2-TERMS.html">AIJ's representation of the ACL2 terms</a> and <a href="JAVA____ATJ-TUTORIAL-EVALUATOR.html">AIJ's evaluator</a>. <a href="JAVA____ATJ-TUTORIAL-ACL2-ENVIRONMENT.html">AIJ's representation of the ACL2 environment</a> is used partially by the shallow embedding, 
    which uses the package definitions but not the function definitions.</p><p>Thus, in the shallow embedding only a portion of the AIJ API is used, 
    namely the one to build and unbuild ACL2 values, 
    the one to invoke the native implementations, 
    and the one to build package definitions. 
    The portion to build function definitions 
    and to execute functions via interpretation 
    is not used.</p><h5>ATJ's Role</h5><p>In the shallow embedding, ATJ plays a different role, 
    compared to the deep embedding. 
    The only commonality is that, in both shallow and deep embedding, 
    ATJ generates Java code 
    to build the ACL2 package definitions via AIJ's API.</p><p>However, in the shallow embedding, 
    ATJ does not generate Java code 
    to build the ACL2 function definitions via AIJ's API, 
    because ACL2 functions have a different Java representation 
    in the shallow embedding. 
    Furthermore, in the shallow embedding, 
    ATJ does not generate Java code that provides a wrapper API 
    to invoke AIJ's interpreter, 
    because ACL2 functions are not executed via interpretation 
    in the shallow embedding.</p><p>Instead, in the shallow embedding, 
    ATJ generates Java code that ``resembles'' the code of the ACL2 functions. 
    ATJ generates, in essence, a Java method for each ACL2 function. 
    The method takes the same inputs and returns the same outputs 
    as the corresponding ACL2 function 
    (`same' in the sense of the Java representations of such inputs and ouputs); 
    it calculates the outputs from the inputs 
    by mimicking the computation steps performed by the ACL2 function. 
    This is best clarified through an example.</p><h5>Example of Generated Code</h5><p>Consider the factorial function example in <a href="JAVA____ATJ-TUTORIAL-DEEP.html">atj-tutorial-deep</a>:</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> fact (n)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____NATP.html">natp</a> n)))
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> n)
      1
    (<a href="COMMON-LISP_____A2.html">*</a> n (fact (<a href="COMMON-LISP____1-.html">1-</a> n)))))</pre><p>To generate shallowly embedded Java code for that function, 
    include ATJ via</p><pre class="code">(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "kestrel/java/atj/atj" :dir :system)</pre><p>as before, and call ATJ via</p><pre class="code">(<a href="JAVA____ATJ.html">java::atj</a> fact :deep nil :guards nil)</pre><p>where <span class="v">:deep nil</span> specifies the shallow embedding approach 
    and <span class="v">:guards nil</span> specifies not to assume the guards' satisfaction 
    (more on this in subsequent tutorial pages).</p><p>As in the deep embedding approach, 
    two Java files, <span class="v">Acl2Code.java</span> and <span class="v">Acl2CodeEnvironment.java</span>, 
    are generated (in the current directory), 
    each of which contains 
    a single Java class with the same name (without <span class="v">.java</span>); 
    the first class is public, the second package-private. 
    Also as in the deep embedding, 
    the files import all the (public) AIJ classes, 
    which are in the <span class="v">edu.kestrel.acl2.aij</span> Java package, 
    and a few classes from the Java standard library.</p><p>The <span class="v">Acl2CodeEnvironment</span> class 
    starts with a package-private <span class="v">build()</span> method 
    that calls a number of methods to define ACL2 packages, 
    as in the deep embedding approach; 
    but this method does not call any methods to define ACL2 functions. 
    This method is followed by 
    the declarations of the (private) methods that it calls, 
    as in the deep embedding approach: 
    these methods that define the packages are identical 
    in the shallow and deep embedding approaches.</p><p>As in the deep embedding, 
    the <span class="v">Acl2Code</span> class starts with a static initializer 
    to build the ACL2 environment; see <a href="JAVA____ATJ-TUTORIAL-DEEP.html">atj-tutorial-deep</a> for details.</p><p>The static analyzer in the <span class="v">Acl2Code</span> class 
    is followed by the same empty <span class="v">initialize()</span> method 
    as in the deep embedding; see <a href="JAVA____ATJ-TUTORIAL-DEEP.html">atj-tutorial-deep</a> for details. 
    However, unlike the deep embedding approach, 
    there is no <span class="v">call(Acl2Symbol, Acl2Value[])</span> method, 
    because, as explained below, 
    (the Java representations of) the ACL2 functions 
    are called directly as methods.</p><p>After the <span class="v">initialize()</span> method, 
    there are a number of nested static classes, 
    each of which corresponds to an ACL2 package. 
    These are a strict subset of the packages 
    whose Java representation is built in the static initializer; 
    for instance, there is no nested class for the <span class="v">"KEYWORD"</span> package 
    (in this example; in other examples, there is such a class).</p><p>The nested class <span class="v">ACL2</span> is for the <span class="v">"ACL2"</span> package. 
    Its <span class="v">fact(Acl2Value)</span> method is generated from the <span class="v">fact</span> function; 
    the correspondence of its Java body 
    with the ACL2 unnormalized body 
    (visible via <span class="v">(<a href="ACL2____UBODY.html">ubody</a> 'fact nil (<a href="ACL2____W.html">w</a> state))</span>, or via <span class="v">:props fact</span>) 
    should be apparent. 
    This method is in the <span class="v">ACL2</span> class because 
    the <span class="tt"><a href="ACL2____SYMBOL-PACKAGE-NAME.html">symbol-package-name</a></span> of the (function) symbol <span class="v">fact</span> 
    is <span class="v">"ACL2"</span>. 
    For the same reason, this class includes a method <span class="v">zp(Acl2Value)</span> 
    generated from the <a href="ACL2____ZP.html">zp</a> function; 
    again the correspondence of its Java body 
    with the ACL2 unnormalized body should be apparent. 
    The nested class <span class="v">ACL2</span> also contains methods 
    that correspond to Java primitive functions 
    (which have no unnormalized body) 
    such as <span class="v">binary_star(Acl2Value,Acl2Value)</span>, 
    whose Java body calls AIJ's native Java implementation. 
    (The reason for introducing wrappers of the native Java implementations 
    such as <span class="v">binary_star(Acl2Value,Acl2Value)</span> 
    is that they are more readable than 
    the qualified method references in <span class="v">Acl2NativeFunction</span>; 
    presumably a JIT could remove the run-time penalty of the wrappers.)</p><p>The nested class <span class="v">COMMON_LISP</span> is for the <span class="v">"COMMON-LISP"</span> package. 
    Its <span class="v">not(Acl2Value)</span> method is generated from the <span class="tt"><a href="COMMON-LISP____NOT.html">not</a></span> function; 
    again, the correspondence of this method's body 
    with the unnormalized body of <span class="tt"><a href="COMMON-LISP____NOT.html">not</a></span> should be apparent. 
    This method is in the <span class="v">COMMON_LISP</span> class because 
    the <span class="tt"><a href="ACL2____SYMBOL-PACKAGE-NAME.html">symbol-package-name</a></span> of the (function) symbol <span class="tt"><a href="COMMON-LISP____NOT.html">not</a></span> 
    is <span class="v">"COMMON_LISP"</span>.</p><p>Note that the function <span class="v">acl2::fact</span> is translated 
    to the method <span class="v">ACL2.fact(...)</span>, 
    the function <span class="v">acl2::zp</span> is translated 
    to the method <span class="v">ACL2.zp(...)</span>, 
    the function <span class="v">common-lisp::not</span> is translated 
    to the method <span class="v">COMMON_LISP.not(...)</span>, 
    and so on: 
    package to class, double colon to dot, and name to method. 
    Running ATJ with <span class="v">:verbose t</span> 
    as explained in <a href="JAVA____ATJ-TUTORIAL-SCREEN-OUTPUT.html">atj-tutorial-screen-output</a> 
    displays the exact correspondence 
    between ACL2 package names and Java class names, 
    and between ACL2 function symbol names and Java method names. 
    Since ACL2 is more liberal 
    about the characters allowed in package and symbol names 
    than Java is about the characters allowed in class and method names, 
    sometimes there must be differences between the ACL2 and Java names.</p><p>Since the <span class="v">zp(Acl2Value)</span> method is in the <span class="v">ACL2</span> class 
    while the <span class="v">not(Acl2Value)</span> method is in the <span class="v">COMMON_LISP</span> class, 
    it seems that the body of <span class="v">zp(Acl2Value)</span> should call 
    <span class="v">COMMON_LISP.not(...)</span> instead of just <span class="v">not(...)</span>. 
    However, in ACL2 the package <span class="v">"ACL2"</span> imports 
    the symbol with name <span class="v">"NOT"</span> from the package <span class="v">"COMMON-LISP"</span>. 
    This is reflected in the Java code generated by ATJ: 
    the class <span class="v">ACL2</span> has a method <span class="v">not(Acl2Value)</span> 
    that calls the method in the <span class="v">COMMON_LISP</span> class. 
    This is the case for all the methods generated from 
    function symbols imported in packages: 
    the importing package has a synonym method 
    that calls the one in the class corresponding to 
    the <span class="tt"><a href="ACL2____SYMBOL-PACKAGE-NAME.html">symbol-package-name</a></span> of the function symbol. 
    Introducing these synonym methods may be the closest way 
    to mimic ACL2's ability to refer to the same symbol 
    using different package prefixes: 
    while <span class="v">acl2::not</span> and <span class="v">common-lisp::not</span> denote the same ACL2 symbol, 
    in the generated Java code the method calls 
    <span class="v">ACL2.not(x)</span> and <span class="v">COMMON_LISP.not(x)</span> have the same effect 
    (presumably a JIT could remove the run-time penalty of these synonyms).</p><p>After the nested classes, 
    there are three constants (i.e. final static fields) 
    for the ACL2 integers 0, 1, and -1. 
    These are all the quoted constants that occur in the unnormalized bodies 
    of <span class="v">fact</span> and of the non-primitive functions 
    directly or indirectly called by <span class="v">fact</span>, 
    namely <span class="tt"><a href="ACL2____ZP.html">zp</a></span> and <span class="tt"><a href="COMMON-LISP____NOT.html">not</a></span>; 
    these are discussed also in <a href="JAVA____ATJ-TUTORIAL-DEEP.html">atj-tutorial-deep</a>. 
    The quoted constants <span class="v">1</span> and <span class="v">-1</span> occur in <span class="v">fact</span>, 
    and the quoted constant <span class="v">0</span> occurs in <span class="tt"><a href="ACL2____ZP.html">zp</a></span>; 
    no quoted constant appears in <span class="tt"><a href="COMMON-LISP____NOT.html">not</a></span>.</p><h5>Example of External Code</h5><p>Similarly to the example in <a href="JAVA____ATJ-TUTORIAL-DEEP.html">atj-tutorial-deep</a>, 
    external Java code must call <span class="v">initialize()</span> 
    before calling (the Java methods corresponding to) the ACL2 functions, 
    and also before using AIJ's API to build the values 
    to pass as arguments to the functions.</p><p>The following simple example of external Java code 
    is similar to the one in <a href="JAVA____ATJ-TUTORIAL-DEEP.html">atj-tutorial-deep</a>, 
    with a few differences explained below:</p><pre class="code">import edu.kestrel.acl2.aij.*;

public class Test {
    public static void main(String[] args)
        throws Acl2UndefinedPackageException {
        Acl2Code.initialize();
        Acl2Value argument = Acl2Integer.make(100);
        Acl2Value result = Acl2Code.ACL2.fact(argument);
        System.out.println("Result: " + result + ".");
    }
}</pre><p>With the shallow embedding, 
    we do not build the symbol that names the function. 
    We build the arguments of the function (just one in this case), 
    but not an array to hold them. 
    And instead of calling <span class="v">Acl2Code.call(function, arguments)</span>, 
    we call directly the method that corresponds to the ACL2 function.</p><h5>Example of Compiling and Running the Code</h5><p>The code can be compiled and run 
    in the same way as in <a href="JAVA____ATJ-TUTORIAL-DEEP.html">atj-tutorial-deep</a>.</p><h5>Java Stack Space Considerations</h5><p>The Java stack space considerations made in <a href="JAVA____ATJ-TUTORIAL-DEEP.html">atj-tutorial-deep</a> 
    partially apply to the shallow embedding approach. 
    The Java methods generated from recursive ACL2 functions are recursive, 
    unless the ACL2 functions are tail-recursive 
    (in which case, as described later, 
    the generated Java methods use loops instead of recursion). 
    This is the case for the method generated from the <span class="v">fact</span> function, 
    which is (non-tail-)recursive. 
    If these recursive methods are called with sufficiently large numbers, 
    the JVM may run out of stack space.</p><p>However, this should happen more rarely than in the deep embedding. 
    The reason is that, in the shallow embedding, 
    the Java stack frames correspond to the ACL2/Lisp stack frames, 
    i.e. there is one for every method/function call. 
    In contrast, when AIJ's recursive interpreter is run, 
    there may be many Java stack frames for each ACL2 function, 
    corresponding to the terms and subterms of the function body: 
    the frames are for the recursive calls of the AIJ interpreter.</p><p>Furthermore, as mentioned above, if an ACL2 function is tail-recursive, 
    the generated Java method uses a loop. 
    ATJ uses the well-known technique of tail recursion elimination. 
    Thus, in an ACL2 development, one can write tail-recursive functions, 
    or perhaps use APT's tail recursion transformation <a href="APT____TAILREC.html"><span class="v">tailrec</span></a> to turn non-tail-recursive functions into equivalent tail-recursive ones, 
    prior to invoking ATJ.</p><h5>Test Generation</h5><p>ATJ's <a href="JAVA____ATJ-TUTORIAL-TESTS.html">test generation facility</a> is available for the shallow embedding in the same way as 
    it is available for the deep embedding. 
    The examples in <a href="JAVA____ATJ-TUTORIAL-TESTS.html">atj-tutorial-tests</a>, 
    which were described for the deep embedding, 
    also apply to the shallow embedding. 
    The generated testing code is slightly different 
    in the way that it calls the functions being tested; 
    the difference is the same as illustrated in the example above 
    of external code that calls the Java method for the factorial function.</p><div class="box"></div><p><b>Previous:</b> <a href="JAVA____ATJ-TUTORIAL-TESTS.html">Generation of Tests</a></p><p><b>Next:</b> <a href="JAVA____ATJ-TUTORIAL-SHALLOW-GUARDS.html">Guards in the Shallow Embedding Approach</a></p>
</body>
</html>
