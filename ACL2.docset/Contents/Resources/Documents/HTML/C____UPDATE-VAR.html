<html>
<head>
<meta charset="UTF-8">
<title>Update-var</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=C____UPDATE-VAR">Click for Update-var in the Full Manual</a></h3>

<p>Update a variable in a <a href="C____ATC-SYMBOLIC-COMPUTATION-STATES.html">canonical representation of computation states</a>.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(update-var var val compst) → new-compst</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">var</span> — <font color="#606060">Guard <span class="v">(<a href="C____IDENTP.html">identp</a> var)</span>.</font>
</dd> 
  <dd>
<span class="tt">val</span> — <font color="#606060">Guard <span class="v">(<a href="C____VALUEP.html">valuep</a> val)</span>.</font>
</dd> 
  <dd>
<span class="tt">compst</span> — <font color="#606060">Guard <span class="v">(<a href="C____COMPUSTATEP.html">compustatep</a> compst)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">new-compst</span> — <font color="#606060">Type <span class="v">(<a href="C____COMPUSTATEP.html">compustatep</a> new-compst)</span>.</font>
</dd> 
 
</dl></div> 
<p>This is like <span class="tt"><a href="C____WRITE-VAR.html">write-var</a></span>, but it does not return an error. 
     First, its guard requires at least one frame, 
     so we always get a frame via <span class="tt"><a href="C____TOP-FRAME.html">top-frame</a></span>. 
     (Actually, given that this function is only used for symbolic execution, 
     it does not need to be guard-verified; 
     the same applies to <span class="tt"><a href="C____ADD-FRAME.html">add-frame</a></span> and <span class="tt"><a href="C____ADD-VAR.html">add-var</a></span>, 
     but for now we keep them guard-verified.) 
     Second, as we go through the scopes, 
     when we reach the outermost scope without finding the variable, 
     we add it to that scope anyhow: 
     this ensures that the variable is always there, 
     which simplifies other rules; 
     we check that the variable is actually there 
     when we turn <span class="tt"><a href="C____WRITE-VAR.html">write-var</a></span> into <span class="tt"><a href="C____UPDATE-VAR.html">update-var</a></span>, 
     in another rule. 
     Third, we do not check the type of the new value 
     against the type of the old value if the variable exists, 
     and instead we unconditionally overwrite the old value with the new value: 
     this ensures that the new value is always there, 
     which simplified other rules; 
     we check that the types match 
     when we turn <span class="tt"><a href="C____WRITE-VAR.html">write-var</a></span> into <span class="tt"><a href="C____UPDATE-VAR.html">update-var</a></span>, 
     in another rule.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>update-var-aux</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> update-var-aux (var val scopes)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="C____IDENTP.html">identp</a> var)
                                   (<a href="C____VALUEP.html">valuep</a> val)
                                   (<a href="C____SCOPE-LISTP.html">scope-listp</a> scopes))))
       (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'update-var-aux))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
            (<a href="ACL2____B_A2.html">b*</a> (((when (<a href="COMMON-LISP____ENDP.html">endp</a> scopes)) nil)
                 (<a href="C____SCOPE.html">scope</a> (<a href="C____SCOPE-FIX.html">scope-fix</a> (<a href="COMMON-LISP____CAR.html">car</a> scopes)))
                 (pair (<a href="OMAP____IN.html">omap::in</a> (<a href="C____IDENT-FIX.html">ident-fix</a> var) scope))
                 ((when (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____CONSP.html">consp</a> pair) (<a href="COMMON-LISP____ENDP.html">endp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> scopes))))
                  (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="OMAP____UPDATE.html">omap::update</a> (<a href="C____IDENT-FIX.html">ident-fix</a> var)
                                      (<a href="C____VALUE-FIX.html">value-fix</a> val)
                                      scope)
                        (<a href="C____SCOPE-LIST-FIX.html">scope-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> scopes)))))
                (<a href="COMMON-LISP____CONS.html">cons</a> scope
                      (update-var-aux var val (<a href="COMMON-LISP____CDR.html">cdr</a> scopes))))))</pre> 
<p><b>Theorem: </b>scope-listp-of-update-var-aux</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> scope-listp-of-update-var-aux
        (<a href="ACL2____B_A2.html">b*</a> ((new-scopes (update-var-aux var val scopes)))
            (<a href="C____SCOPE-LISTP.html">scope-listp</a> new-scopes))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>consp-of-update-var-aux</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> consp-of-update-var-aux
        (<a href="ACL2____B_A2.html">b*</a> ((?new-scopes (update-var-aux var val scopes)))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CONSP.html">consp</a> new-scopes)
                   (<a href="COMMON-LISP____CONSP.html">consp</a> scopes))))</pre> 
<p><b>Theorem: </b>update-var-aux-of-ident-fix-var</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> update-var-aux-of-ident-fix-var
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (update-var-aux (<a href="C____IDENT-FIX.html">ident-fix</a> var)
                               val scopes)
               (update-var-aux var val scopes)))</pre> 
<p><b>Theorem: </b>update-var-aux-ident-equiv-congruence-on-var</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> update-var-aux-ident-equiv-congruence-on-var
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____IDENT-EQUIV.html">ident-equiv</a> var var-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (update-var-aux var val scopes)
                        (update-var-aux var-equiv val scopes)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>update-var-aux-of-value-fix-val</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> update-var-aux-of-value-fix-val
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (update-var-aux var (<a href="C____VALUE-FIX.html">value-fix</a> val)
                               scopes)
               (update-var-aux var val scopes)))</pre> 
<p><b>Theorem: </b>update-var-aux-value-equiv-congruence-on-val</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> update-var-aux-value-equiv-congruence-on-val
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____VALUE-EQUIV.html">value-equiv</a> val val-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (update-var-aux var val scopes)
                        (update-var-aux var val-equiv scopes)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>update-var-aux-of-scope-list-fix-scopes</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> update-var-aux-of-scope-list-fix-scopes
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (update-var-aux var val (<a href="C____SCOPE-LIST-FIX.html">scope-list-fix</a> scopes))
               (update-var-aux var val scopes)))</pre> 
<p><b>Theorem: </b>update-var-aux-scope-list-equiv-congruence-on-scopes</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> update-var-aux-scope-list-equiv-congruence-on-scopes
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____SCOPE-LIST-EQUIV.html">scope-list-equiv</a> scopes scopes-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (update-var-aux var val scopes)
                        (update-var-aux var val scopes-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>update-var</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> update-var (var val compst)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="C____IDENTP.html">identp</a> var)
                                   (<a href="C____VALUEP.html">valuep</a> val)
                                   (<a href="C____COMPUSTATEP.html">compustatep</a> compst))))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP_____E3.html">&gt;</a> (<a href="C____COMPUSTATE-FRAMES-NUMBER.html">compustate-frames-number</a> compst)
                                 0)))
       (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'update-var))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
            (<a href="ACL2____B_A2.html">b*</a> ((<a href="C____FRAME.html">frame</a> (<a href="C____TOP-FRAME.html">top-frame</a> compst))
                 (scopes (<a href="C____FRAME-_E3SCOPES.html">frame-&gt;scopes</a> frame))
                 (new-scopes (update-var-aux var val scopes))
                 (new-frame (<a href="C____CHANGE-FRAME.html">change-frame</a> frame
                                          :scopes new-scopes)))
                (<a href="C____PUSH-FRAME.html">push-frame</a> new-frame (<a href="C____POP-FRAME.html">pop-frame</a> compst)))))</pre> 
<p><b>Theorem: </b>compustatep-of-update-var</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> compustatep-of-update-var
        (<a href="ACL2____B_A2.html">b*</a> ((new-compst (<a href="C____UPDATE-VAR.html">update-var</a> var val compst)))
            (<a href="C____COMPUSTATEP.html">compustatep</a> new-compst))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>update-var-of-ident-fix-var</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> update-var-of-ident-fix-var
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____UPDATE-VAR.html">update-var</a> (<a href="C____IDENT-FIX.html">ident-fix</a> var) val compst)
               (<a href="C____UPDATE-VAR.html">update-var</a> var val compst)))</pre> 
<p><b>Theorem: </b>update-var-ident-equiv-congruence-on-var</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> update-var-ident-equiv-congruence-on-var
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____IDENT-EQUIV.html">ident-equiv</a> var var-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____UPDATE-VAR.html">update-var</a> var val compst)
                        (<a href="C____UPDATE-VAR.html">update-var</a> var-equiv val compst)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>update-var-of-value-fix-val</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> update-var-of-value-fix-val
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____UPDATE-VAR.html">update-var</a> var (<a href="C____VALUE-FIX.html">value-fix</a> val) compst)
               (<a href="C____UPDATE-VAR.html">update-var</a> var val compst)))</pre> 
<p><b>Theorem: </b>update-var-value-equiv-congruence-on-val</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> update-var-value-equiv-congruence-on-val
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____VALUE-EQUIV.html">value-equiv</a> val val-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____UPDATE-VAR.html">update-var</a> var val compst)
                        (<a href="C____UPDATE-VAR.html">update-var</a> var val-equiv compst)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>update-var-of-compustate-fix-compst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> update-var-of-compustate-fix-compst
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____UPDATE-VAR.html">update-var</a> var val (<a href="C____COMPUSTATE-FIX.html">compustate-fix</a> compst))
               (<a href="C____UPDATE-VAR.html">update-var</a> var val compst)))</pre> 
<p><b>Theorem: </b>update-var-compustate-equiv-congruence-on-compst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> update-var-compustate-equiv-congruence-on-compst
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____COMPUSTATE-EQUIV.html">compustate-equiv</a> compst compst-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____UPDATE-VAR.html">update-var</a> var val compst)
                        (<a href="C____UPDATE-VAR.html">update-var</a> var val compst-equiv)))
        :rule-classes :congruence)</pre> 

</body>
</html>
