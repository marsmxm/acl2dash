<html>
<head>
<meta charset="UTF-8">
<title>Grammar-parser-completeness</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ABNF____GRAMMAR-PARSER-COMPLETENESS">Click for Grammar-parser-completeness in the Full Manual</a></h3>

<p>Completeness theorems for the parser of ABNF grammars.</p><p>For every terminated tree rooted at <span class="v">rulelist</span> 
     that satisfies the <a href="ABNF____GRAMMAR-PARSER-DISAMBIGUATING-RESTRICTIONS.html">disambiguating restrictions</a>, <span class="tt"><a href="ABNF____PARSE-GRAMMAR.html">parse-grammar</a></span> succeeds on the string at the leaves of the tree 
     and returns that tree: 
     <p><b>Theorem: </b>parse-grammar-when-tree-match</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  parse-grammar-when-tree-match
  (<a href="ACL2____IMPLIES.html">implies</a>
       (<a href="COMMON-LISP____AND.html">and</a> (<a href="ABNF____TREE-MATCH-ELEMENT-P.html">tree-match-element-p</a> tree (<a href="ABNF____ELEMENT-RULENAME.html">element-rulename</a> *rulelist*)
                                  *all-concrete-syntax-rules*)
            (<a href="ABNF____TREE-TERMINATEDP.html">tree-terminatedp</a> tree)
            (<a href="ABNF____TREE-RULELIST-RESTRICTION-P.html">tree-rulelist-restriction-p</a> tree))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ABNF____PARSE-GRAMMAR.html">parse-grammar</a> (<a href="ABNF____TREE-_E3STRING.html">tree-&gt;string</a> tree))
              (<a href="ABNF____TREE-FIX.html">tree-fix</a> tree))))</pre></p><p>This is proved by proving the following, 
     for each parsing function out of which <span class="tt"><a href="ABNF____PARSE-GRAMMAR.html">parse-grammar</a></span> is built: 
     if a (list of) terminated tree(s) matches a certain syntactic entity 
     and possibly satisfies certain <a href="ABNF____GRAMMAR-PARSER-DISAMBIGUATING-RESTRICTIONS.html">disambiguating restrictions</a>, then running the parsing function on the <span class="tt"><a href="COMMON-LISP____APPEND.html">append</a></span> of 
     (i) the string at the leaves of the tree(s) and 
     (ii) some remaining input 
     possibly satisfying certain hypotheses explained below, 
     succeeds and yields that (list of) tree(s) and that remaining input. 
     More precisely, the parsing function yields 
     the (list of) tree(s) fixed with <span class="tt"><a href="ABNF____TREE-FIX.html">tree-fix</a></span> or <span class="tt"><a href="ABNF____TREE-LIST-FIX.html">tree-list-fix</a></span> 
     and the remaining input fixed with <span class="tt"><a href="ACL2____NAT-LIST-FIX.html">nat-list-fix</a></span>; 
     an alternative formulation is to avoid these fixing functions 
     but include the hypotheses 
     that the (list of) tree(s) satisfies <span class="tt"><a href="ABNF____TREEP.html">treep</a></span> or <span class="tt"><a href="ABNF____TREE-LISTP.html">tree-listp</a></span> 
     and that the remaining input satisfies <span class="tt"><a href="ACL2____NAT-LISTP.html">nat-listp</a></span>.</p><p>For example, the completeness theorem <span class="tt"><a href="ABNF____PARSE-ALPHA-WHEN-TREE-MATCH.html">parse-alpha-when-tree-match</a></span> 
     says that running <span class="tt"><a href="ABNF____PARSE-ALPHA.html">parse-alpha</a></span> on the <span class="tt"><a href="COMMON-LISP____APPEND.html">append</a></span> of 
     (i) the leaves of a terminated tree that matches <span class="v">ALPHA</span>, and 
     (ii) some remaining input, 
     succeeds and yields 
     (the fixing of) that tree and (the fixing of) that remaining input. 
     Since <span class="v">ALPHA</span> is not involved in the <a href="ABNF____GRAMMAR-PARSER-DISAMBIGUATING-RESTRICTIONS.html">disambiguating restrictions</a>, <span class="tt"><a href="ABNF____PARSE-ALPHA-WHEN-TREE-MATCH.html">parse-alpha-when-tree-match</a></span> has no hypothesis 
     related to those disambiguating restrictions. 
     This theorem also has no hypothesis on the remaining input, 
     as explained below.</p><p>The completeness theorem of <span class="tt"><a href="ABNF____PARSE-ANY.html">parse-any</a></span> 
     does not involve trees but makes an analogous statement: 
     running <span class="tt"><a href="ABNF____PARSE-ANY.html">parse-any</a></span> on 
     the <span class="tt"><a href="COMMON-LISP____CONS.html">cons</a></span> of a natural number and some remaining natural numbers, 
     returns (the fixing of) that natural number and 
     (the fixing of) the remaining natural numbers.</p><h3>Hypotheses on the Remaining Input</h3><p>In all the completeness theorems, 
     the remaining input (following the string at the leaves of the tree(s)) 
     is denoted by the variable <span class="v">rest-input</span>. 
     The hypotheses on the remaining input, when present, 
     are that certain parsing functions fail on the remaining input.</p><p>If a parsing function ignores the remaining input, 
     the corresponding completeness theorem 
     has no hypotheses on the remaining input. 
     This is the case for parsing functions that, 
     like <span class="tt"><a href="ABNF____PARSE-ALPHA.html">parse-alpha</a></span> mentioned above, 
     parse a fixed number of natural numbers from the input. 
     This is also the case for 
     parsing functions that parse a fixed number of natural numbers 
     after parsing a variable number of natural numbers: 
     for example, 
     <span class="tt"><a href="ABNF____PARSE-PROSE-VAL.html">parse-prose-val</a></span> always parses the closing angle bracket 
     (which is a single character) 
     after parsing a variable number of characters 
     after parsing the opening angle bracket.</p><p>In contrast, 
     if a parsing function ``examines'' (part of) the remaining input, 
     the corresponding completeness theorem 
     has hypotheses on the remaining input. 
     If a parsing function examines part of the remaining input, 
     but that part of the remaining input is absent from the returned tree(s) 
     (by hypothesis of the function's completeness theorem), 
     it means that the function attempts but fails 
     to parse further into the remaining input, 
     backtracking and returning a (list of) tree(s) 
     only for the input that precedes the remaining input. 
     Thus, the completeness theorem for the function 
     must include hypotheses stating or implying such parsing failures. 
     Without these hypotheses, 
     parsing further into the remaining input might succeed, 
     extending the tree(s) and rendering the theorem untrue. 
     Some concrete examples are given below.</p><p>A parsing function for 
     a repetition of zero or more instances of some syntactic entity 
     always examines the remaining input to decide when to stop. 
     The function's completeness theorem has a hypothesis on the remaining input 
     stating or implying that 
     parsing another instance of the syntactic entity fails. 
     For example, <span class="tt"><a href="ABNF____PARSE-_A2BIT.html">parse-*bit</a></span> stops when <span class="tt"><a href="ABNF____PARSE-BIT.html">parse-bit</a></span> fails; 
     this parsing failure occurs in the remaining input. 
     The completeness theorem <span class="tt"><a href="ABNF____PARSE-_A2BIT-WHEN-TREE-LIST-MATCH.html">parse-*bit-when-tree-list-match</a></span> 
     has the hypothesis that <span class="tt"><a href="ABNF____PARSE-BIT.html">parse-bit</a></span> fails on the remaining input. 
     Without this hypothesis, the theorem would not hold because, 
     if another <span class="v">BIT</span> could be parsed from the remaining input, 
     then <span class="tt"><a href="ABNF____PARSE-_A2BIT.html">parse-*bit</a></span> would return (at least) an additional tree 
     beyond the list of trees hypothesized in the theorem.</p><p>A parsing function for an optional occurrence of some syntactic entity 
     may examine the remaining input. 
     This happens when parsing the syntactic entity fails, 
     in which case the function returns a tree without leaves, 
     because the optional entity is absent. 
     The function's completeness theorem has a hypothesis on the remaining input 
     stating or implying that parsing the syntactic entity fails. 
     For example, <span class="tt"><a href="ABNF____PARSE-_F3_52I.html">parse-?%i</a></span> may fail to parse <span class="v">"%i"</span>; 
     this parsing failure occurs in the remaining input, 
     because the function returns a tree without leaves, 
     reflecting the absence of the syntactic entity. 
     The completeness theorem <span class="tt"><a href="ABNF____PARSE-_F3_52I-WHEN-TREE-MATCH.html">parse-?%i-when-tree-match</a></span> 
     has the hypothesis that <span class="tt"><a href="ABNF____PARSE-ICHAR2.html">parse-ichar2</a></span> 
     (with arguments <span class="v">#\%</span> and <span class="v">#\i</span>) 
     fails on the remaining input. 
     Without this hypothesis, the theorem would not hold because, 
     if <span class="v">"%i"</span> could be parsed from the remaining input 
     but the tree hypothesized by the theorem had no leaves, 
     then <span class="tt"><a href="ABNF____PARSE-_F3_52I.html">parse-?%i</a></span> would return a tree with leaves instead.</p><p>The kind of hypothesis on the remaining input 
     described in the previous paragraph, 
     for the completeness theorems of parsing functions 
     that parse optional entities, 
     is stronger than needed. 
     If the parsing function succeeds in parsing the optional entity, 
     then it does not examine the remaining input, returning a tree with leaves. 
     So the hypothesis on the remaining input could be weakened 
     to require the parsing failure to happen only if the tree has no leaves. 
     However, in syntactically valid ABNF grammars, 
     the stronger hypothesis is always satisfied 
     (e.g. <span class="v">[ "%i" ]</span> cannot be followed by <span class="v">"%i"</span>), 
     so there is no loss in using the stronger hypothesis; 
     the stronger hypothesis keeps the completeness theorems simpler 
     without precluding the eventual proof 
     of the top-level completeness theorem.</p><p>If a parsing function calls, or may call, another parsing function 
     as its last action, 
     the former's completeness theorem ``inherits'' 
     the hypotheses on the remaining input 
     from the latter's completeness theorem. 
     If the hypotheses were not inherited, 
     the called function may successfully parse some of the remaining input, 
     returning more or different subtrees 
     than hypothesized by the calling function's completeness theorem, 
     rendering the theorem untrue. 
     For example, 
     since <span class="tt"><a href="ABNF____PARSE-1_A2BIT.html">parse-1*bit</a></span> calls <span class="tt"><a href="ABNF____PARSE-_A2BIT.html">parse-*bit</a></span> as its last action, 
     <span class="tt"><a href="ABNF____PARSE-1_A2BIT-WHEN-TREE-LIST-MATCH.html">parse-1*bit-when-tree-list-match</a></span> inherits from 
     <span class="tt"><a href="ABNF____PARSE-_A2BIT-WHEN-TREE-LIST-MATCH.html">parse-*bit-when-tree-list-match</a></span> 
     the hypothesis that <span class="tt"><a href="ABNF____PARSE-BIT.html">parse-bit</a></span> fails on the remaining input; 
     otherwise, <span class="tt"><a href="ABNF____PARSE-_A2BIT.html">parse-*bit</a></span> could return additional <span class="v">BIT</span> trees 
     and so <span class="tt"><a href="ABNF____PARSE-1_A2BIT.html">parse-1*bit</a></span> could return additional <span class="v">BIT</span> trees as well. 
     As another example, 
     since <span class="tt"><a href="ABNF____PARSE-DOT-1_A2BIT.html">parse-dot-1*bit</a></span> calls <span class="tt"><a href="ABNF____PARSE-1_A2BIT.html">parse-1*bit</a></span> as its last action, 
     <span class="tt"><a href="ABNF____PARSE-DOT-1_A2BIT-WHEN-TREE-MATCH.html">parse-dot-1*bit-when-tree-match</a></span> inherits from 
     <span class="tt"><a href="ABNF____PARSE-_A2BIT-WHEN-TREE-LIST-MATCH.html">parse-*bit-when-tree-list-match</a></span> 
     the hypothesis that <span class="tt"><a href="ABNF____PARSE-BIT.html">parse-bit</a></span> fails on the remaining input; 
     otherwise, <span class="tt"><a href="ABNF____PARSE-1_A2BIT.html">parse-1*bit</a></span> could return additional <span class="v">BIT</span> trees 
     and so <span class="tt"><a href="ABNF____PARSE-DOT-1_A2BIT.html">parse-dot-1*bit</a></span> could return a tree 
     with additional <span class="v">BIT</span> subtrees. 
     As a third example, 
     since <span class="tt"><a href="ABNF____PARSE-BIN_F2DEC_F2HEX-VAL.html">parse-bin/dec/hex-val</a></span> may call <span class="tt"><a href="ABNF____PARSE-BIN-VAL.html">parse-bin-val</a></span> 
     (and <span class="tt"><a href="ABNF____PARSE-DEC-VAL.html">parse-dec-val</a></span> and <span class="tt"><a href="ABNF____PARSE-HEX-VAL.html">parse-hex-val</a></span>) 
     as its last action, 
     <span class="tt"><a href="ABNF____PARSE-BIN_F2DEC_F2HEX-VAL-WHEN-TREE-MATCH.html">parse-bin/dec/hex-val-when-tree-match</a></span> inherits from 
     <span class="tt"><a href="ABNF____PARSE-BIN-VAL-WHEN-TREE-MATCH.html">parse-bin-val-when-tree-match</a></span> 
     (and <span class="tt"><a href="ABNF____PARSE-DEC-VAL-WHEN-TREE-MATCH.html">parse-dec-val-when-tree-match</a></span> 
     and <span class="tt"><a href="ABNF____PARSE-HEX-VAL-WHEN-TREE-MATCH.html">parse-hex-val-when-tree-match</a></span>) 
     various parsing failure hypotheses on the remaining input.</p><p>As a slight generalization of the situation 
     described in the previous paragraph, 
     a parsing function may call, as its last action, 
     another parsing function that may return a tree without leaves. 
     In this case, the calling parsing function's completeness theorem inherits 
     the hypotheses on the remaining input 
     also from the completeness theorem of 
     the parsing function that it calls just before the last one. 
     For example, 
     <span class="tt"><a href="ABNF____PARSE-ELEMENTS.html">parse-elements</a></span> calls <span class="tt"><a href="ABNF____PARSE-_A2CWSP.html">parse-*cwsp</a></span> as its last action, 
     and thus <span class="tt"><a href="ABNF____PARSE-ELEMENTS-WHEN-TREE-MATCH.html">parse-elements-when-tree-match</a></span> inherits 
     from <span class="tt"><a href="ABNF____PARSE-_A2CWSP-WHEN-TREE-LIST-MATCH.html">parse-*cwsp-when-tree-list-match</a></span> 
     the hypothesis that <span class="tt"><a href="ABNF____PARSE-CWSP.html">parse-cwsp</a></span> fails on the remaining input, 
     as explained earlier. 
     But since <span class="tt"><a href="ABNF____PARSE-_A2CWSP.html">parse-*cwsp</a></span> may return a tree with no leaves 
     (if no instances of <span class="v">c-wsp</span> follow the <span class="v">alternation</span>), 
     <span class="tt"><a href="ABNF____PARSE-ELEMENTS-WHEN-TREE-MATCH.html">parse-elements-when-tree-match</a></span> also inherits 
     the hypotheses on the remaining input 
     from <span class="tt"><a href="ABNF____PARSE-ALTERNATION-WHEN-TREE-MATCH.html">parse-alternation-when-tree-match</a></span>.</p><p>As illustrated by 
     the <span class="tt"><a href="ABNF____PARSE-BIN_F2DEC_F2HEX-VAL-WHEN-TREE-MATCH.html">parse-bin/dec/hex-val-when-tree-match</a></span> example above, 
     when a parsing function may call a set of different parsing functions 
     as its last action, 
     the calling function's completeness theorem inherits 
     from the called functions' completeness theorems 
     all the hypotheses on the remaining input. 
     The resulting hypotheses, in the calling function's completeness theorem, 
     are stronger than needed: 
     they could be weakened to require an inherited parsing failure hypothesis 
     only if the subtree(s) correspond(s) to the called function. 
     For example, in <span class="tt"><a href="ABNF____PARSE-BIN_F2DEC_F2HEX-VAL-WHEN-TREE-MATCH.html">parse-bin/dec/hex-val-when-tree-match</a></span>, 
     the failure of <span class="tt"><a href="ABNF____PARSE-BIT.html">parse-bit</a></span> could be required only if 
     the <span class="v">(bin-val / dec-val / hex-val)</span> tree has a <span class="v">bin-val</span> subtree. 
     However, in syntactically valid ABNF grammars, 
     the stronger hypotheses are always satisfied 
     (e.g. <span class="v">dec-val</span> cannot be followed by <span class="v">BIT</span>), 
     so there is no loss in using the stronger hypotheses; 
     the stronger hypotheses keep the completeness theorems simpler 
     without precluding the eventual proof 
     of the top-level completeness theorem.</p><p>In the rules in [RFC:4], certain repeated and optional syntactic entities 
     ``nest to the right'', 
     e.g. <span class="v">1*BIT</span> nests to the right inside <span class="v">1*("." 1*BIT)</span>. 
     When this kind of nesting occurs, 
     the completeness theorem 
     of the parsing function for the outer repetition or option 
     has not only the parsing failure hypotheses on the remaining input 
     relative to the outer repetition or option, 
     but also the parsing failure hypotheses on the remaining input 
     relative to the inner repetition or option. 
     For example, <span class="tt"><a href="ABNF____PARSE-1_A2-DOT-1_A2BIT-WHEN-TREE-LIST-MATCH.html">parse-1*-dot-1*bit-when-tree-list-match</a></span> 
     (and <span class="tt"><a href="ABNF____PARSE-_A2-DOT-1_A2BIT-WHEN-TREE-LIST-MATCH.html">parse-*-dot-1*bit-when-tree-list-match</a></span>) 
     includes not only the failure of <span class="tt"><a href="ABNF____PARSE-DOT-1_A2BIT.html">parse-dot-1*bit</a></span> 
     (actually, a stronger hypothesis, as explained below), 
     but also the failure of <span class="tt"><a href="ABNF____PARSE-BIT.html">parse-bit</a></span>. 
     As another example, <span class="tt"><a href="ABNF____PARSE-BIN-VAL-REST-WHEN-TREE-MATCH.html">parse-bin-val-rest-when-tree-match</a></span> 
     includes the failure of <span class="tt"><a href="ABNF____PARSE-BIT.html">parse-bit</a></span> for the <span class="v">1*BIT</span> repetition 
     as well as (stronger hypotheses, as explained below, implying) 
     the failure of (both alternatives inside) 
     the <span class="v">[ 1*("." 1*BIT) "/" ("-" 1*BIT) ]</span> option.</p><p>Besides the cases already mentioned 
     of stronger hypotheses on the remaining input 
     (that keep the theorems simpler while not precluding the top-level proof), 
     there are other cases in which completeness theorems have 
     stronger parsing failure hypotheses than needed. 
     An example, as hinted above, 
     is <span class="tt"><a href="ABNF____PARSE-1_A2-DOT-1_A2BIT-WHEN-TREE-LIST-MATCH.html">parse-1*-dot-1*bit-when-tree-list-match</a></span>: 
     instead of having a hypothesis 
     requiring the failure of <span class="tt"><a href="ABNF____PARSE-1_A2-DOT-1_A2BIT.html">parse-1*-dot-1*bit</a></span>, 
     the theorem has the stronger hypothesis that 
     <span class="tt"><a href="ABNF____PARSE-ICHAR.html">parse-ichar</a></span> with argument <span class="v">#\.</span> fails. 
     However, in syntactically valid ABNF grammars, 
     the stronger hypotheses are always satisfied 
     (e.g. <span class="v">1*("." 1*BIT)</span> cannot be followed by <span class="v">"."</span> 
     unless that is followed by <span class="v">BIT</span>), 
     so there is no loss in using the stronger hypotheses; 
     the stronger hypotheses keep the completeness theorems simpler 
     without precluding the eventual proof 
     of the top-level completeness theorem.</p><p>The two alternatives parsed by <span class="tt"><a href="ABNF____PARSE-EQUAL-_F2-EQUAL-SLASH.html">parse-equal-/-equal-slash</a></span> 
     are one a prefix of the other. 
     Therefore, <span class="tt"><a href="ABNF____PARSE-EQUAL-_F2-EQUAL-SLASH-WHEN-TREE-MATCH.html">parse-equal-/-equal-slash-when-tree-match</a></span> 
     has the hypothesis that <span class="tt"><a href="ABNF____PARSE-ICHAR.html">parse-ichar</a></span> with argument <span class="v">#\/</span> 
     fails on the remaining input. 
     Without this hypothesis, the tree hypothesized in the theorem 
     could match just <span class="v">"="</span>, 
     but the remaining input could start with <span class="v">"/"</span>, 
     in which case <span class="tt"><a href="ABNF____PARSE-EQUAL-_F2-EQUAL-SLASH.html">parse-equal-/-equal-slash</a></span> 
     would return a tree matching <span class="v">"=/"</span> instead, 
     rendering the theorem untrue. 
     This hypothesis on the remaining input is stronger than needed: 
     it could be weakened to requiring the parsing failure 
     only if the tree matches <span class="v">"="</span>. 
     However, in syntactically valid ABNF grammars, 
     the stronger hypothesis is always satisfied 
     (i.e. <span class="v">"=/"</span> cannot be followed by <span class="v">"/"</span>), 
     so there is no loss in using the stronger hypothesis; 
     the stronger hypothesis keeps this completeness theorem simpler 
     without precluding the eventual proof 
     of the top-level completeness theorem.</p><p>Since 
     (i) <span class="tt"><a href="ABNF____PARSE-RULE.html">parse-rule</a></span> calls <span class="tt"><a href="ABNF____PARSE-CNL.html">parse-cnl</a></span> as its last action, 
     (ii) <span class="tt"><a href="ABNF____PARSE-CNL.html">parse-cnl</a></span> always returns a tree with leaves, and 
     (iii) <span class="tt"><a href="ABNF____PARSE-CNL-WHEN-TREE-MATCH.html">parse-cnl-when-tree-match</a></span> has 
     no hypotheses on the remaining input, 
     it may seem that <span class="tt"><a href="ABNF____PARSE-RULE-WHEN-TREE-MATCH.html">parse-rule-when-tree-match</a></span> 
     needs no hypotheses on the remaining input. 
     However, before calling <span class="tt"><a href="ABNF____PARSE-CNL.html">parse-cnl</a></span>, 
     <span class="tt"><a href="ABNF____PARSE-RULE.html">parse-rule</a></span> calls <span class="tt"><a href="ABNF____PARSE-ELEMENTS.html">parse-elements</a></span>, 
     which may parse the ending <span class="v">c-nl</span> 
     and then attempt and fail to parse <span class="v">WSP</span> after <span class="v">c-nl</span> 
     (this is how the <a href="ABNF____GRAMMAR-PARSER-IMPLEMENTATION.html">grammar parser implementation</a> resolves the <span class="v">rulelist</span> ambiguity). 
     Thus, <span class="tt"><a href="ABNF____PARSE-RULE.html">parse-rule</a></span> may actually examine part of the remaining input. 
     The needed hypothesis is that <span class="tt"><a href="ABNF____PARSE-WSP.html">parse-wsp</a></span> 
     fails on the remaining input: 
     if <span class="v">WSP</span> could be parsed from the remaining input, 
     <span class="tt"><a href="ABNF____PARSE-RULE.html">parse-rule</a></span> would put that with the <span class="v">c-nl</span> 
     under an additional <span class="v">c-wsp</span> instance 
     under <span class="v">elements</span> and under <span class="v">rule</span>, 
     thus returning a different tree than hypothesized in the theorem.</p><p>An analogous discussion to the one in the previous paragraph 
     applies to <span class="tt"><a href="ABNF____PARSE-_A2CWSP-CNL.html">parse-*cwsp-cnl</a></span>. 
     Thus, <span class="tt"><a href="ABNF____PARSE-_A2CWSP-CNL-WHEN-TREE-MATCH.html">parse-*cwsp-cnl-when-tree-match</a></span> has the hypothesis that 
     <span class="tt"><a href="ABNF____PARSE-WSP.html">parse-wsp</a></span> fails on the remaining input.</p><h3>Hypotheses on the Tree(s)</h3><p>Most completeness theorems include 
     hypotheses saying that the trees are terminated. 
     This ensures that the strings at the leaves of the trees 
     consist of natural numbers and not rule names, 
     since the parsing functions operate on natural numbers. 
     A few completeness theorems do not need those hypotheses 
     because the corresponding syntactic entities can only be matched 
     by trees whose leaves are natural numbers, e.g. 
     <span class="tt"><a href="ABNF____PARSE-EXACT-WHEN-TREE-MATCH.html">parse-exact-when-tree-match</a></span>, 
     <span class="tt"><a href="ABNF____PARSE-ICHAR-WHEN-TREE-MATCH.html">parse-ichar-when-tree-match</a></span>, and 
     <span class="tt"><a href="ABNF____PARSE-_F3_52I-WHEN-TREE-MATCH.html">parse-?%i-when-tree-match</a></span>.</p><p>The completeness theorems 
     <span class="tt"><a href="ABNF____PARSE-_A2-RULE-_F2-_A2CWSP-CNL-WHEN-TREE-LIST-MATCH-AND-RESTRICTION.html">parse-*-rule-/-*cwsp-cnl-when-tree-list-match-and-restriction</a></span> and 
     <span class="tt"><a href="ABNF____PARSE-RULELIST-WHEN-TREE-MATCH-AND-RESTRICTION.html">parse-rulelist-when-tree-match-and-restriction</a></span>, 
     as suggested by the ending of their names, 
     have hypotheses saying that the (list of) tree(s) satisfies <a href="ABNF____GRAMMAR-PARSER-DISAMBIGUATING-RESTRICTIONS.html">the disambiguating restrictions</a>. Without these hypotheses, the theorems would not hold 
     because there would be multiple choices of trees for certain inputs, 
     but the parser only produces one choice for each input.</p><h3>Proof Methods</h3><p>The completeness theorems of the more ``basic'' parsing functions 
     <span class="tt"><a href="ABNF____PARSE-ANY.html">parse-any</a></span>, 
     <span class="tt"><a href="ABNF____PARSE-EXACT.html">parse-exact</a></span>, 
     <span class="tt"><a href="ABNF____PARSE-IN-RANGE.html">parse-in-range</a></span>, 
     <span class="tt"><a href="ABNF____PARSE-ICHAR.html">parse-ichar</a></span>, and 
     <span class="tt"><a href="ABNF____PARSE-ICHAR2.html">parse-ichar2</a></span> 
     are proved by expanding the necessary definitions. 
     The proofs for <span class="tt"><a href="ABNF____PARSE-EXACT.html">parse-exact</a></span> and <span class="tt"><a href="ABNF____PARSE-IN-RANGE.html">parse-in-range</a></span> 
     use <span class="tt"><a href="ABNF____PARSE-ANY-OF-CONS.html">parse-any-of-cons</a></span> as a rewrite rule, 
     obviating the need to expand <span class="tt"><a href="ABNF____PARSE-ANY.html">parse-any</a></span>. 
     The proofs for <span class="tt"><a href="ABNF____PARSE-EXACT.html">parse-exact</a></span> and <span class="tt"><a href="ABNF____PARSE-IN-RANGE.html">parse-in-range</a></span> 
     also expand some tree-related functions, which seems odd 
     because it should be possible to treat trees as abstract data types; 
     there may be ways to avoid that, perhaps by adding some tree lemmas.</p><p>Each of the other completeness theorems is proved, generally speaking, 
     by reducing the tree matching hypothesis 
     to one or more subtree matching facts, 
     reducing the call to the parsing function on the (list of) tree(s) 
     to calls to other parsing functions on (lists of) subtrees, 
     and using the already proved theorems for the called parsing functions 
     to show that the calling parsing function returns the right results. 
     The completeness theorems are used as rewrite rules 
     (implicitly, since they are enabled). 
     The subtree matching facts to which the tree matching hypothesis reduces 
     are used to relieve the hypotheses of these rewrite rules.</p><p>For example, <span class="tt"><a href="ABNF____PARSE-CR-WHEN-TREE-MATCH.html">parse-cr-when-tree-match</a></span> is proved as follows. 
     The hypothesis that the tree matches <span class="v">CR</span> is reduced 
     to the fact that its (only) subtree matches <span class="v">%x0D</span>. 
     The call to <span class="tt"><a href="ABNF____PARSE-CR.html">parse-cr</a></span> in the conclusion is reduced 
     to a call to <span class="tt"><a href="ABNF____PARSE-EXACT.html">parse-exact</a></span> with argument <span class="v">#x0d</span> 
     on the <span class="tt"><a href="COMMON-LISP____APPEND.html">append</a></span> of 
     (i) the string at the leaves of the subtree and 
     (ii) the remaining input. 
     The rewrite rule <span class="tt"><a href="ABNF____PARSE-EXACT-WHEN-TREE-MATCH.html">parse-exact-when-tree-match</a></span> then applies 
     (whose hypothesis is relieved 
     via the aforementioned fact that the subtree matches <span class="v">%0D</span>), 
     rewriting the call to <span class="tt"><a href="ABNF____PARSE-EXACT.html">parse-exact</a></span> to the triple consisting of 
     <span class="v">nil</span> (i.e. success), the subtree, and the remaining input. 
     Therefore, <span class="tt"><a href="ABNF____PARSE-CR.html">parse-cr</a></span>, by its definition, 
     returns the triple consisting of 
     <span class="v">nil</span> (i.e. success), 
     the <span class="v">CR</span> tree with the <span class="v">%x0D</span> subtree, 
     and the remaining input. 
     Thus, <span class="tt"><a href="ABNF____PARSE-CR-WHEN-TREE-MATCH.html">parse-cr-when-tree-match</a></span> is proved.</p><p>This reduction approach works also when there are multiple subtrees. 
     For example, <span class="tt"><a href="ABNF____PARSE-CRLF-WHEN-TREE-MATCH.html">parse-crlf-when-tree-match</a></span> is proved as follows. 
     The hypothesis that the tree matches <span class="v">CRLF</span> is reduced 
     to the first subtree matching <span class="v">CR</span> 
     and the second subtree matching <span class="v">LF</span>. 
     The call to <span class="tt"><a href="ABNF____PARSE-CRLF.html">parse-crlf</a></span> is reduced to 
     a call to <span class="tt"><a href="ABNF____PARSE-CR.html">parse-cr</a></span> 
     on the string at the leaves of the first subtree 
     and a call to <span class="tt"><a href="ABNF____PARSE-LF.html">parse-lf</a></span> 
     on the string at the leaves of the second subtree. 
     Then <span class="tt"><a href="ABNF____PARSE-CR-WHEN-TREE-MATCH.html">parse-cr-when-tree-match</a></span> and <span class="tt"><a href="ABNF____PARSE-LF-WHEN-TREE-MATCH.html">parse-lf-when-tree-match</a></span> 
     apply.</p><p>Since completeness theorems generally have hypotheses 
     about the trees being terminated, 
     in order to apply completeness theorems as rewrite rules to subtrees 
     (in the reduction approach outlined above), 
     the hypothesis that the trees are terminated 
     must be reduced to facts that subtrees are terminated 
     to relieve the hypotheses of the rewrite rules. 
     Thus, 
     we enable <span class="tt"><a href="ABNF____TREE-TERMINATEDP.html">tree-terminatedp</a></span> just before the completeness theorems 
     and we disable it just after. 
     The existing enabled rewrite rules take care of 
     <span class="tt"><a href="ABNF____TREE-LIST-TERMINATEDP.html">tree-list-terminatedp</a></span> and <span class="tt"><a href="ABNF____TREE-LIST-LIST-TERMINATEDP.html">tree-list-list-terminatedp</a></span>.</p><p>Similarly, when calls to parsing functions on trees 
     are reduced to calls to parsing functions on subtrees, 
     the strings at the leaves of the trees must be reduced to 
     strings at the leaves of the subtrees. 
     Thus, we enable 
     <span class="tt"><a href="ABNF____TREE-_E3STRING.html">tree-&gt;string</a></span>, 
     <span class="tt"><a href="ABNF____TREE-LIST-_E3STRING.html">tree-list-&gt;string</a></span>, and 
     <span class="tt"><a href="ABNF____TREE-LIST-LIST-_E3STRING.html">tree-list-list-&gt;string</a></span> 
     just before the completeness theorems 
     and we disable them just after. 
     The existing enabled rules about 
     <span class="tt"><a href="ABNF____TREE-LIST-_E3STRING.html">tree-list-&gt;string</a></span> and 
     <span class="tt"><a href="ABNF____TREE-LIST-LIST-_E3STRING.html">tree-list-list-&gt;string</a></span> 
     do not suffice: 
     if these two functions are not enabled, 
     the proofs of some completeness theorems fails.</p><p>The <span class="tt"><a href="ABNF____TREE-MATCH-ELEMENT-P.html">tree-match-element-p</a></span> hypotheses of the completeness theorems 
     are expanded via explicit <span class="v">:expand</span> hints; 
     just enabling <span class="tt"><a href="ABNF____TREE-MATCH-ELEMENT-P.html">tree-match-element-p</a></span> does not perform the expansion 
     (presumably due to ACL2's heuristics for expanding recursive functions). 
     Since many repetitions consist of one element, 
     the rewrite rule <span class="tt"><a href="ABNF____TREE-LIST-MATCH-REPETITION-P-OF-1-REPETITION.html">tree-list-match-repetition-p-of-1-repetition</a></span> 
     is used in many completeness proofs: 
     we enable it just before the completeness theorems 
     and disabled it just after. 
     There is no direct use of the definitions of 
     <span class="tt"><a href="ABNF____TREE-LIST-LIST-MATCH-ALTERNATION-P.html">tree-list-list-match-alternation-p</a></span> and 
     <span class="tt"><a href="ABNF____TREE-LIST-LIST-MATCH-CONCATENATION-P.html">tree-list-list-match-concatenation-p</a></span> 
     because the alternations and concatenations in the completeness theorems 
     always have an explicit list structure and thus rewrite rules like 
     <span class="tt"><a href="ABNF____TREE-LIST-LIST-MATCH-ALTERNATION-P-OF-CONS-ALTERNATION.html">tree-list-list-match-alternation-p-of-cons-alternation</a></span> suffice. 
     Repetition are handled via the rules 
     <span class="tt"><a href="ABNF____TREE-LIST-MATCH-REPETITION-P-OF-0_B2-REPS-WHEN-CONSP.html">tree-list-match-repetition-p-of-0+-reps-when-consp</a></span> and 
     <span class="tt"><a href="ABNF____TREE-LIST-MATCH-REPETITION-P-OF-1_B2-REPETITIONS.html">tree-list-match-repetition-p-of-1+-repetitions</a></span> 
     where needed, as explained below.</p><p>If a parsing function may backtrack, 
     its completeness theorem uses a disambiguation theorem as a rewrite rule, 
     by explicitly enabling it 
     (with just one exception: 
     <span class="tt"><a href="ABNF____PARSE-ALPHA-WHEN-TREE-MATCH.html">parse-alpha-when-tree-match</a></span> uses 
     <span class="tt"><a href="ABNF____FAIL-1ST-RANGE-WHEN-MATCH-2ND-RANGE.html">fail-1st-range-when-match-2nd-range</a></span> with a <span class="v">:use</span> hint, 
     because the latter does not quite apply as a rewrite rule there). 
     For example, 
     in the proof of the completeness theorem <span class="tt"><a href="ABNF____PARSE-WSP-WHEN-TREE-MATCH.html">parse-wsp-when-tree-match</a></span>, 
     the hypothesis that the tree matches <span class="v">WSP</span> 
     reduces to two cases for the subtree: 
     either the subtree matches <span class="v">SP</span> or the subtree matches <span class="v">HTAB</span>. 
     In the first case, 
     the completeness theorem <span class="tt"><a href="ABNF____PARSE-SP-WHEN-TREE-MATCH.html">parse-sp-when-tree-match</a></span> 
     implies that <span class="tt"><a href="ABNF____PARSE-SP.html">parse-sp</a></span> succeeds, so <span class="tt"><a href="ABNF____PARSE-WSP.html">parse-wsp</a></span> succeeds 
     and <span class="tt"><a href="ABNF____PARSE-WSP-WHEN-TREE-MATCH.html">parse-wsp-when-tree-match</a></span> is proved. 
     In the second case, in order to use, in a similar way, 
     the completeness theorem <span class="tt"><a href="ABNF____PARSE-HTAB-WHEN-TREE-MATCH.html">parse-htab-when-tree-match</a></span>, 
     we need to show that <span class="tt"><a href="ABNF____PARSE-SP.html">parse-sp</a></span> fails, 
     so that <span class="tt"><a href="ABNF____PARSE-WSP.html">parse-wsp</a></span> reduces to <span class="tt"><a href="ABNF____PARSE-HTAB.html">parse-htab</a></span> by backtracking 
     and then <span class="tt"><a href="ABNF____PARSE-WSP-WHEN-TREE-MATCH.html">parse-wsp-when-tree-match</a></span> is proved 
     using <span class="tt"><a href="ABNF____PARSE-HTAB-WHEN-TREE-MATCH.html">parse-htab-when-tree-match</a></span>. 
     The disambiguation theorem <span class="tt"><a href="ABNF____FAIL-SP-WHEN-MATCH-HTAB.html">fail-sp-when-match-htab</a></span> 
     serves to show that, in the second case above, <span class="tt"><a href="ABNF____PARSE-SP.html">parse-sp</a></span> fails.</p><p>All the completeness theorems for parsing functions that may backtrack 
     follow this proof pattern, 
     which motivates the formulation of the disambiguation theorems. 
     In particular, 
     it motivates the ``asymmetric'' use of trees and parsing functions 
     to show incompatibility 
     (as opposed to showing incompatibility 
     between parsing functions or between trees).</p><p>Some completeness theorems use some disambiguation theorems 
     not to show that the parsing function must backtrack, 
     but to relieve hypotheses of other completeness theorems. 
     For example, 
     in the completeness theorem 
     <span class="tt"><a href="ABNF____PARSE-1_A2-DOT-1_A2BIT-WHEN-TREE-LIST-MATCH.html">parse-1*-dot-1*bit-when-tree-list-match</a></span>, 
     the disambiguation theorem <span class="tt"><a href="ABNF____FAIL-BIT-WHEN-MATCH-_A2-DOT-1_A2BIT.html">fail-bit-when-match-*-dot-1*bit</a></span> 
     serves to relieve the <span class="tt"><a href="ABNF____PARSE-BIT.html">parse-bit</a></span> failure hypothesis 
     of the <span class="tt"><a href="ABNF____PARSE-DOT-1_A2BIT-WHEN-TREE-MATCH.html">parse-dot-1*bit-when-tree-match</a></span> completeness theorem.</p><p>If a parsing function parses a repetition of one or more elements 
     (e.g. <span class="tt"><a href="ABNF____PARSE-1_A2BIT.html">parse-1*bit</a></span>), 
     its completeness theorem 
     (e.g. <span class="tt"><a href="ABNF____PARSE-1_A2BIT-WHEN-TREE-LIST-MATCH.html">parse-1*bit-when-tree-list-match</a></span>) 
     is proved by 
     using <span class="tt"><a href="ABNF____TREE-LIST-MATCH-REPETITION-P-OF-1_B2-REPETITIONS.html">tree-list-match-repetition-p-of-1+-repetitions</a></span> 
     to reduce the matching to 
     a single element and to a repetition of zero or more elements, 
     and then using the completeness theorems 
     for the element 
     (e.g. <span class="tt"><a href="ABNF____PARSE-BIT-WHEN-TREE-MATCH.html">parse-bit-when-tree-match</a></span>) 
     and for the repetition of zero or more elements 
     (e.g. <span class="tt"><a href="ABNF____PARSE-_A2BIT-WHEN-TREE-LIST-MATCH.html">parse-*bit-when-tree-list-match</a></span>).</p><p>If a parsing function is singly recursive (e.g. <span class="tt"><a href="ABNF____PARSE-_A2BIT.html">parse-*bit</a></span>), 
     i.e. it parses a repetition of zero or more elements, 
     its completeness theorem is proved by induction 
     on the length of the list of trees that matches the repetition; 
     induction on the parsing function does not work, 
     because the argument of the parsing function is not a variable 
     (it is <span class="v">(<a href="COMMON-LISP____APPEND.html">append</a> (<a href="ABNF____TREE-LIST-_E3STRING.html">tree-list-&gt;string</a> trees) rest-input)</span>). 
     We enable <span class="tt"><a href="ABNF____TREE-LIST-MATCH-REPETITION-P-OF-0_B2-REPS-WHEN-CONSP.html">tree-list-match-repetition-p-of-0+-reps-when-consp</a></span> 
     to handle the induction step of the proof. 
     We also disable the rewrite rule <span class="v">acl2::nat-list-fix-of-append</span> 
     because it interferes with the proof 
     by preventing <span class="tt"><a href="ACL2____NAT-LIST-FIX.html">nat-list-fix</a></span> from being eliminated 
     via the rewrite rule that shows that the parsing function fixes the input 
     (e.g. the theorem <a href="ABNF____PARSE-_A2BIT.html"><span class="v">parse-*bit-of-nat-list-fix-input</span></a>).</p><p>The proof of the mutually recursive parsing functions 
     (i.e. <span class="tt"><a href="ABNF____PARSE-ALTERNATION.html">parse-alternation</a></span>, <span class="tt"><a href="ABNF____PARSE-CONCATENATION.html">parse-concatenation</a></span>, etc.) 
     is more complex. 
     As with the singly recursive parsing functions, 
     a straightforward induction on the mutually recursive parsing functions 
     does not work because their arguments are not variables 
     (they are 
     <span class="v">(<a href="COMMON-LISP____APPEND.html">append</a> (<a href="ABNF____TREE-_E3STRING.html">tree-&gt;string</a> tree) rest-input)</span> and 
     <span class="v">(<a href="COMMON-LISP____APPEND.html">append</a> (<a href="ABNF____TREE-LIST-_E3STRING.html">tree-list-&gt;string</a> trees) rest-input)</span>). 
     In analogy with 
     the completeness theorems for the singly recursive parsing functions, 
     we could try an induction on the sizes of the trees 
     (variables <span class="v">tree</span> and <span class="v">trees</span>), 
     but the formulation seems somewhat complicated, 
     due to the presence of multiple parsing functions.</p><p>Instead, we take the desired formulation of each completeness theorem 
     of the mutually recursive parsing functions, 
     we add a hypothesis that a new variable <span class="v">input</span> is equal to 
     <span class="v">(<a href="COMMON-LISP____APPEND.html">append</a> (<a href="ABNF____TREE-_E3STRING.html">tree-&gt;string</a> tree) rest-input)</span> or 
     <span class="v">(<a href="COMMON-LISP____APPEND.html">append</a> (<a href="ABNF____TREE-LIST-_E3STRING.html">tree-list-&gt;string</a> trees) rest-input)</span>, 
     we universally quantify 
     the <span class="v">tree</span> or <span class="v">trees</span> variable and the <span class="v">rest-input</span> variable 
     into a <span class="tt"><a href="STD____DEFINE-SK.html">define-sk</a></span> predicate with argument <span class="v">input</span>, 
     and we prove all these predicates by induction on 
     the mutually recursive functions. 
     That is, we prove that the parsing functions 
     satisfy their ``completeness properties'' for every way 
     in which their input can be ``split'' 
     into (the string at the leaves of) a (list of) tree(s) 
     and some remaining input. 
     The predicates capture these completeness properties.</p><p>The predicates are <span class="tt"><a href="ABNF____PRED-ALTERNATION.html">pred-alternation</a></span>, 
     <span class="tt"><a href="ABNF____PRED-CONCATENATION.html">pred-concatenation</a></span>, etc. 
     They are not guard-verified because they only serve 
     to prove the completeness of the mutually recursive parsing functions. 
     The consequents of the implications in their bodies 
     call the parsing functions on 
     <span class="v">(<a href="COMMON-LISP____APPEND.html">append</a> (<a href="ABNF____TREE-_E3STRING.html">tree-&gt;string</a> tree) rest-input)</span> or 
     <span class="v">(<a href="COMMON-LISP____APPEND.html">append</a> (<a href="ABNF____TREE-LIST-_E3STRING.html">tree-list-&gt;string</a> trees) rest-input)</span>, 
     and not on the shorter <span class="v">input</span> that the antecedents assert to be equal, 
     for a practical reason: 
     if we used <span class="v">input</span> in the consequents, 
     the rewrite rules generated by <span class="tt"><a href="STD____DEFINE-SK.html">define-sk</a></span> 
     (e.g. <span class="v">pred-alternation-necc</span>) 
     would have <span class="v">tree</span>, <span class="v">trees</span>, and <span class="v">rest-input</span> as free variables, 
     making their use harder. 
     The predicates also include 
     the fact that the remaining input satisfies <span class="tt"><a href="ACL2____NAT-LISTP.html">nat-listp</a></span>, 
     instead of using <span class="tt"><a href="ACL2____NAT-LIST-FIX.html">nat-list-fix</a></span> in the consequent: 
     this is because the <span class="tt"><a href="ACL2____NAT-LIST-FIX.html">nat-list-fix</a></span> approach causes the proofs to fail 
     (perhaps due to some interaction with the equality with <span class="v">input</span>), 
     so we use <span class="tt"><a href="ACL2____NAT-LISTP.html">nat-listp</a></span> instead in the predicates.</p><p>We prove by induction on the mutually recursive parsing functions that 
     all the predicates hold for every <span class="v">input</span> argument: 
     see 
     <span class="tt"><a href="ABNF____PARSE-ALT_F2CONC_F2REP_F2ELEM_F2GROUP_F2OPTION-WHEN-TREE-_F2-TREE-LIST-MATCH-LEMMAS.html">parse-alt/conc/rep/elem/group/option-when-tree-/-tree-list-match-lemmas</a></span>. 
     These are completeness lemmas, 
     from which the completeness theorems are proved with ease. 
     The completeness theorem have the same formulation as the ones 
     for the other, non-recursive or singly recursive parsing functions; 
     in particular, they use <span class="tt"><a href="ACL2____NAT-LIST-FIX.html">nat-list-fix</a></span> instead of <span class="tt"><a href="ACL2____NAT-LISTP.html">nat-listp</a></span> 
     on the remaining input.</p><p>The induction proof of the conpleteness lemmas generates 
     5 base cases and 26 induction steps. 
     We prove each of them separately 
     (these are the theorems whose names end with 
     <span class="v">-base-case</span> and <span class="v">-induction-step-N</span> where <span class="v">N</span> is a number, 
     e.g. <span class="tt"><a href="ABNF____PARSE-ELEMENT-WHEN-TREE-MATCH-BASE-CASE.html">parse-element-when-tree-match-base-case</a></span> 
     and <span class="tt"><a href="ABNF____PARSE-ALTERNATION-WHEN-TREE-MATCH-INDUCTION-STEP-2.html">parse-alternation-when-tree-match-induction-step-2</a></span>. 
     Attempting to prove the completeness lemmas by induction in one shot fails, 
     perhaps due to interference between the different hints 
     used for the base cases and induction steps; 
     however, 
     it may be possible to find a way to prove the lemmas in one shot.</p><p>The formulation of each base case and induction step 
     is derived directly from the output 
     generated by 
     the <span class="v">defthm-parse-alt/conc/rep/elem/group/option-flag</span> form. 
     Attempting to prove each base case and induction step in one shot fails, 
     perhaps because of the equality between <span class="v">input</span> and 
     <span class="v">(<a href="COMMON-LISP____APPEND.html">append</a> (<a href="ABNF____TREE-_E3STRING.html">tree-&gt;string</a> tree) rest-input)</span> or 
     <span class="v">(<a href="COMMON-LISP____APPEND.html">append</a> (<a href="ABNF____TREE-LIST-_E3STRING.html">tree-list-&gt;string</a> trees) rest-input)</span>. 
     So, we prove each base case and induction step via a local lemma 
     where the predicate in the conclusion of the base case or induction step 
     is replaced with its definition; 
     the base case or induction step is then proved just by 
     expanding the predicate definition 
     and using the local lemma as a rewrite rule.</p><p>The proof of each local lemma for base cases and induction steps 
     is similar to the proofs of the completeness theorems 
     of the non-recursive and singly recursive parsing functions. 
     In addition, these local lemmas use (implicitly) 
     the rewrite rules generated by <span class="tt"><a href="STD____DEFINE-SK.html">define-sk</a></span> 
     (e.g. <span class="v">pred-alternation-necc</span>); 
     some disambiguation theorems are sometimes enabled 
     to relieve the hypotheses of these <span class="tt"><a href="STD____DEFINE-SK.html">define-sk</a></span> rewrite rules. 
     The induction steps that involve lists of trees 
     (as opposed to single trees) 
     use a <span class="v">:cases</span> hint to split on whether the lists are empty or not.</p><p>Earlier we explained that some completeness theorems have 
     stronger parsing failure hypotheses on the remaining input 
     than needed, in order to keep the theorems simpler. 
     These theorems enable certain <a href="ABNF____GRAMMAR-PARSER-PARSING-FAILURE-PROPAGATION.html">parsing failure propagation theorems</a> to turn the stronger hypotheses into 
     the facts needed to show the weaker parsing failures 
     within the parsing functions. 
     For example, 
     in the completeness theorem <span class="tt"><a href="ABNF____PARSE-_A2-DOT-1_A2BIT-WHEN-TREE-LIST-MATCH.html">parse-*-dot-1*bit-when-tree-list-match</a></span>, 
     the parsing failure propagation theorem 
     <span class="tt"><a href="ABNF____FAIL-DOT-1_A2BIT-WHEN-FAIL-DOT.html">fail-dot-1*bit-when-fail-dot</a></span> 
     is used to turn the hypothesis that 
     <span class="tt"><a href="ABNF____PARSE-ICHAR.html">parse-ichar</a></span> with argument <span class="v">#\.</span> fails 
     into the fact that <span class="tt"><a href="ABNF____PARSE-DOT-1_A2BIT.html">parse-dot-1*bit</a></span> fails, 
     needed to show that <span class="tt"><a href="ABNF____PARSE-_A2-DOT-1_A2BIT.html">parse-*-dot-1*bit</a></span> stops 
     before the remaining input.</p>
</body>
</html>
