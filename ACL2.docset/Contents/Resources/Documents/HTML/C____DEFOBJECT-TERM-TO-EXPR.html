<html>
<head>
<meta charset="UTF-8">
<title>Defobject-term-to-expr</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=C____DEFOBJECT-TERM-TO-EXPR">Click for Defobject-term-to-expr in the Full Manual</a></h3>

<p>Turn a constant expression term into the represented expression.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(defobject-term-to-expr term ctx state) → (mv erp val state)</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">term</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> term)</span>.</font>
</dd> 
  <dd>
<span class="tt">ctx</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____CTXP.html">ctxp</a> ctx)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">val</span> — <font color="#606060">Type <span class="v">(tuple (<a href="C____EXPR.html">expr</a> exprp) (<a href="C____TYPE.html">type</a> typep) val)</span>.</font>
</dd> 
 
</dl></div> 
<p>If the term is not a constant expression term, stop with an error. 
     If it is, also return the type of the expression.</p><p>In essence, this generates C code for 
     a term used in the initializer of the external object.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>defobject-term-to-expr</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 defobject-term-to-expr (term ctx state)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (<a href="ACL2____STATE.html">state</a>)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> term) (<a href="ACL2____CTXP.html">ctxp</a> ctx))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((__function__ 'defobject-term-to-expr))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
  (<a href="ACL2____B_A2.html">b*</a>
   (((acl2::fun (irrelevant))
     (<a href="COMMON-LISP____LIST.html">list</a> (<a href="C____IRR-EXPR.html">irr-expr</a>) (<a href="C____IRR-TYPE.html">irr-type</a>)))
    ((<a href="ACL2____MV.html">mv</a> erp (<a href="COMMON-LISP____LIST.html">list</a> okp const out-type) state)
     (<a href="C____ATC-CHECK-ICONST.html">atc-check-iconst</a> term ctx state))
    ((when erp) (<a href="ACL2____MV.html">mv</a> erp (irrelevant) state))
    ((when okp)
     (<a href="ACL2____VALUE.html">acl2::value</a> (<a href="COMMON-LISP____LIST.html">list</a> (<a href="C____EXPR-CONST.html">expr-const</a> (<a href="C____CONST-INT.html">const-int</a> const))
                        out-type)))
    ((<a href="ACL2____MV.html">mv</a> okp op arg in-type out-type)
     (<a href="C____ATC-CHECK-UNOP.html">atc-check-unop</a> term))
    ((when okp)
     (<a href="ACL2____B_A2.html">b*</a>
      (((<a href="ACL2____ER.html">er</a> (<a href="COMMON-LISP____LIST.html">list</a> arg-expr type))
        (<a href="C____DEFOBJECT-TERM-TO-EXPR.html">defobject-term-to-expr</a> arg ctx state))
       ((unless (<a href="COMMON-LISP____EQUAL.html">equal</a> type in-type))
        (<a href="ACL2____ER-SOFT_B2.html">er-soft+</a>
         ctx t (irrelevant)
         "The unary operator ~x0 ~
                         is applied to a term ~x1 returning ~x2, ~
                         but a ~x3 operand is expected."
         op arg type in-type)))
      (<a href="ACL2____VALUE.html">acl2::value</a> (<a href="COMMON-LISP____LIST.html">list</a> (<a href="C____MAKE-EXPR-UNARY.html">make-expr-unary</a> :op op :arg arg-expr)
                         out-type))))
    ((<a href="ACL2____MV.html">mv</a> okp
         op arg1 arg2 in-type1 in-type2 out-type)
     (<a href="C____ATC-CHECK-BINOP.html">atc-check-binop</a> term))
    ((when okp)
     (<a href="ACL2____B_A2.html">b*</a>
      (((<a href="ACL2____ER.html">er</a> (<a href="COMMON-LISP____LIST.html">list</a> arg1-expr type1))
        (<a href="C____DEFOBJECT-TERM-TO-EXPR.html">defobject-term-to-expr</a> arg1 ctx state))
       ((<a href="ACL2____ER.html">er</a> (<a href="COMMON-LISP____LIST.html">list</a> arg2-expr type2))
        (<a href="C____DEFOBJECT-TERM-TO-EXPR.html">defobject-term-to-expr</a> arg2 ctx state))
       ((unless (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> type1 in-type1)
                     (<a href="COMMON-LISP____EQUAL.html">equal</a> type2 in-type2)))
        (<a href="ACL2____ER-SOFT_B2.html">er-soft+</a>
         ctx t (irrelevant)
         "The binary operator ~x0 ~
                         is applied to a term ~x1 returning ~x2
                         and to a term ~x3 returning ~x4,
                         but a ~x5 and a ~x6 operand is expected."
         op arg1
         type1 arg2 type2 in-type1 in-type2)))
      (<a href="ACL2____VALUE.html">acl2::value</a> (<a href="COMMON-LISP____LIST.html">list</a> (<a href="C____MAKE-EXPR-BINARY.html">make-expr-binary</a> :op op
                                           :arg1 arg1-expr
                                           :arg2 arg2-expr)
                         out-type))))
    ((<a href="ACL2____MV.html">mv</a> okp tyname arg in-type out-type)
     (<a href="C____ATC-CHECK-CONV.html">atc-check-conv</a> term))
    ((when okp)
     (<a href="ACL2____B_A2.html">b*</a>
      (((<a href="ACL2____ER.html">er</a> (<a href="COMMON-LISP____LIST.html">list</a> arg-expr type))
        (<a href="C____DEFOBJECT-TERM-TO-EXPR.html">defobject-term-to-expr</a> arg ctx state))
       ((unless (<a href="COMMON-LISP____EQUAL.html">equal</a> type in-type))
        (<a href="ACL2____ER-SOFT_B2.html">er-soft+</a>
         ctx t (irrelevant)
         "The conversion from ~x0 to ~x1 ~
                         is applied to a term ~x2 returning ~x3, ~
                         but a ~x0 operand is expected."
         in-type out-type arg type)))
      (<a href="ACL2____VALUE.html">acl2::value</a> (<a href="COMMON-LISP____LIST.html">list</a> (<a href="C____MAKE-EXPR-CAST.html">make-expr-cast</a> :type tyname
                                         :arg arg-expr)
                         out-type)))))
   (<a href="ACL2____ER-SOFT_B2.html">er-soft+</a>
    ctx t (irrelevant)
    "The term ~x0 used as an array element initializer ~
               does not have the required form."
    term))))</pre> 
<p><b>Theorem: </b>return-type-of-defobject-term-to-expr.val</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> return-type-of-defobject-term-to-expr.val
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?erp ?val acl2::?state)
              (<a href="C____DEFOBJECT-TERM-TO-EXPR.html">defobject-term-to-expr</a> term ctx state)))
            (tuple (<a href="C____EXPR.html">expr</a> exprp) (<a href="C____TYPE.html">type</a> typep) val))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>true-listp-of-defobject-term-to-expr.val</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> true-listp-of-defobject-term-to-expr.val
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?erp ?val acl2::?state)
              (<a href="C____DEFOBJECT-TERM-TO-EXPR.html">defobject-term-to-expr</a> term ctx state)))
            (<a href="ACL2____TRUE-LISTP.html">true-listp</a> val))
        :rule-classes :type-prescription)</pre> 

</body>
</html>
