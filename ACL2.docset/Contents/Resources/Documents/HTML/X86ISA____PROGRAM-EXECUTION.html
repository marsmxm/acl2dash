<html>
<head>
<meta charset="UTF-8">
<title>Program-execution</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=X86ISA____PROGRAM-EXECUTION">Click for Program-execution in the Full Manual</a></h3>

<p>Setting up the x86 ISA model for a program run</p><p>IMPORTANT: Note that if these books were built using any 
  other value of <span class="v">X86ISA_EXEC</span> except <span class="v">t</span>, then instructions 
  like <span class="v">SYSCALL</span> and <span class="v">RDRAND</span> will not be available for 
  execution, though reasoning about them will still be possible. See 
  <a href="X86ISA____X86ISA-BUILD-INSTRUCTIONS.html">x86isa-build-instructions</a> for details.</p> 
 
<p>First, obtain the x86 machine-code version of the program 
you want to execute on the model. Note that we support only <a href="http://en.wikipedia.org/wiki/Executable_and_Linkable_Format" target="_blank"><nobr>ELF<img src="../Icon_External_Link.png" title="External link to http://en.wikipedia.org/wiki/Executable_and_Linkable_Format"></nobr></a> 
(created on Linux machines) and <a href="http://en.wikipedia.org/wiki/Mach-O" target="_blank"><nobr>Mach-O<img src="../Icon_External_Link.png" title="External link to http://en.wikipedia.org/wiki/Mach-O"></nobr></a> binaries 
(created on Darwin/Apple machines).</p> 
 
<p>Here is a sample popcount program in C that will be used for 
illustration throughout this section.</p> 
 
<pre class="code">// FILENAME: popcount.c 
// From Sean Anderson's Bit Twiddling Hacks 
// See https://graphics.stanford.edu/~seander/bithacks.html 
 
#include <span class="v">&lt;stdio.h&gt;</span> 
#include <span class="v">&lt;stdlib.h&gt;</span> 
 
int popcount_32 (unsigned int v) { 
  v = v - ((v <span class="v">&gt;&gt;</span> 1) <span class="v">&amp;</span> 0x55555555); 
  v = (v <span class="v">&amp;</span> 0x33333333) + ((v <span class="v">&gt;&gt;</span> 2) <span class="v">&amp;</span> 0x33333333); 
  v = ((v + (v <span class="v">&gt;&gt;</span> 4) <span class="v">&amp;</span> 0xF0F0F0F) * 0x1010101) <span class="v">&gt;&gt;</span> 24; 
  return(v); 
} 
 
int main (int argc, char *argv[], char *env[]) { 
  int v; 
  printf ("\nEnter a 32-bit number: "); 
  scanf  ("%d", <span class="v">&amp;</span>v); 
  v = v <span class="v">&amp;</span> 0xffffffff; 
  printf ("\nPopcount of %d is: %d\n", v, popcount_32(v)); 
  return 0; 
} 
</pre> 
 
<p>We can use the following command to obtain the x86 binary 
corresponding to this program; we will call this binary 
<span class="v">popcount.o</span>.</p> 
 
<pre class="code">gcc popcount.c -o popcount.o 
</pre> 
 
<p>You can see the assembly and machine code corresponding to this 
program using utilities like <span class="v">objdump</span> on Linux machines and 
<span class="v">otool</span> on Mac machines.  Example invocations are as follows:</p> 
 
<p>On Linux machines:</p> 
<pre class="code">objdump -d popcount.o 
</pre> 
<p>On Mac machines:</p> 
<pre class="code">otool -tvj popcount.o 
</pre> 
 
<p><b>Note that the assembly and machine code can differ from machine 
to machine, program run to program run.  All the concrete values of 
addresses, etc. used in this example can be different for you.</b></p> 
 
<p>The following events describe the process of setting up the x86 ISA 
  model for the execution of <span class="v">popcount.o</span>.</p> 
 
<ol> 
 
<li>
<p>Include the top-level book (i.e., X86ISA/top.lisp) in a fresh 
ACL2 session.</p> 
 
<pre class="code">(include-book "top" :ttags :all)</pre> 
 
<p>Alternatively, it can be faster to just include 
tools/execution/top.lisp.</p> 
 
<pre class="code">(include-book "tools/execution/top" :ttags :all)</pre> 
 
<p>You should always be in the <span class="v">X86ISA</span> package when working with 
the x86 books.  If you start an ACL2 session when standing under any 
of the x86 directories, your ACL2 session will start in the 
<span class="v">X86ISA</span> package.  Otherwise, you also need the following form 
after the above <span class="v">include-book</span>.</p> 
 
<pre class="code">(in-package "X86ISA") 
</pre> 
 
</li> 
 
<li> If you desire to run the model in the <a href="X86ISA____APP-VIEW.html">app-view</a>, skip this 
step.  Use the function <span class="tt"><a href="X86ISA____INIT-SYS-VIEW.html">init-sys-view</a></span> to switch the model to 
the system-level view and load our default configuration of 1G page 
tables (set up to provide an identity mapping from linear to physical 
addresses) into the model's memory at the provided address, i.e., 
<span class="v">0x0</span> in our example.  Of course, this is a contrived example.  For 
more flexibility in constructing and loading page tables, see <a href="X86ISA____SETTING-UP-PAGE-TABLES.html">Setting-up-page-tables</a>. 
 
<pre class="code">(init-sys-view 0 x86) 
</pre> 
</li> 
 
<li>
<p>Read and load <span class="v">popcount.o</span> into the x86 model's memory using the 
macro <span class="v">binary-file-load</span>.</p> 
 
<pre class="code"> (binary-file-load "popcount.o" :elf t) ;; or :mach-o t</pre> 
 
<p><span class="v">binary-file-load</span> will fail if <span class="v">popcount.o</span> is not a supported 
ELF or Mach-O file.</p> 
</li> 
 
<li>
<p>Use <span class="tt"><a href="X86ISA____INIT-X86-STATE-64.html">init-x86-state-64</a></span> to modify other components of the 
x86 state, like the instruction pointer, registers, arguments in 
memory, if necessary.  This function only writes the specified values 
into the x86 state while preserving any values previously written to 
the x86 state.  For example, the following form will <i>not</i> make 
changes to any general-purpose registers except <span class="v">rdi</span> and <span class="v">rsp</span>. 
Note that the function <span class="v">init-x86-state-64</span> sets up the state to be 
in 64-bit mode of operation of an x86 machine --- see <span class="tt"><a href="X86ISA____INIT-X86-STATE.html">init-x86-state</a></span> for an initialization function that does not do 
so.</p> 
 
<pre class="code">(init-x86-state-64 
 ;; Status (MS and fault field) 
 nil 
 ;; Start Address --- set the RIP to this address 
 #x100000f12 
 ;; Initial values of General-Purpose Registers 
 '((#.*rdi* . #xff00ff00) 
   (#.*rsp* . #.*2^45*)) 
 ;; Control Registers: a value of nil will not nullify existing 
 ;; values. 
 nil 
 ;; Model-Specific Registers: a value of nil will not nullify existing 
 ;; values. 
 nil 
 ;; Segment Registers: a value of nil will not nullify existing values. 
 nil ; visible portion 
 nil nil nil ; hidden portion 
 ;; Rflags Register 
 2 
 ;; Memory image: a value of nil will not nullify existing values. 
 nil 
 ;; x86 state 
 x86) 
</pre> 
 
<p><b>Aside</b>: Some other ways to initialize the x86 state are 
listed below.  The list is not exhaustive.</p> 
 
<ul> 
 
<li><p>The memory image argument of <span class="tt"><a href="X86ISA____INIT-X86-STATE.html">init-x86-state</a></span> accepts 
alists satisfying <span class="tt"><a href="X86ISA____N64P-BYTE-ALISTP.html">n64p-byte-alistp</a></span>.  This can be used to 
provide a program binary in the form of a list of address-byte pairs 
rather using <span class="v">binary-file-load</span> to parse and load the binary 
automatically.</p></li> 
 
<li><p>The function <span class="tt"><a href="X86ISA____LOAD-PROGRAM-INTO-MEMORY.html">load-program-into-memory</a></span> also accepts 
programs that satisfy <span class="v">n64p-byte-alistp</span>.</p></li> 
 
<li><p>Of course, <span class="tt"><a href="X86ISA____WML08.html">wml08</a></span> (and its friends like <span class="tt"><a href="X86ISA____WRITE-BYTES-TO-MEMORY.html">write-bytes-to-memory</a></span>) can also be used to write a program to the 
memory.  Initialization of other components of the x86 state can be 
done by using the appropriate updater functions directly.  For 
example, <span class="v">!stri</span> can be used to update system registers like 
<span class="v">GDTR</span> and <span class="v">IDTR</span> when operating in the system-level 
view.</p></li> 
 
</ul> 
 
<p>All the mechanisms to initialize the x86 state aside, how do we 
know what values to put in the x86 state?  This is an important and 
interesting question.  Its answer depends on the program (or snippet 
of a program) we intend to execute and requires the user to be 
familiar with x86 assembly and calling conventions. For this popcount 
example, suppose all we wanted to execute was the <span class="v">popcount_32</span> 
routine with an actual concrete argument, say <span class="v">0xff00ff00</span>. One way 
to figure out what the start and halt addresses should be in this case 
is to look at the output from <span class="v">objdump</span> or <span class="v">otool</span> for 
instructions in the <span class="v">main</span> routine that look like the 
following:</p> 
 
<pre class="code">... 
100000f10: 89 c7                mov    %eax,%edi 
100000f12: e8 49 ff ff ff       callq  100000e60 <span class="v">&lt;_popcount_32&gt;</span> 
100000f17: 48 8d 3d 66 00 00 00 lea    0x66(%rip),%rdi 
... 
</pre> 
 
<p>We set the start address to be the address of the instruction that 
calls the <span class="v">popcount_32</span> function (i.e., <span class="v">0x100000f12</span> here) 
and halt address to be the address of the instruction following it 
(i.e., <span class="v">0x100000f17</span> here).</p> 
 
<p>Before entering <span class="v">popcount_32</span>, the component of the x86 state 
that contains the concrete argument (i.e., <span class="v">0xff00ff00</span> in our 
example) should be initialized appropriately too. How do we know 
which component is used for this purpose?  Knowledge of calling 
conventions can help here --- for example, on 64-bit Linux, if the 
argument is of the integer type, then the next available register of 
the following sequence is used for argument passing: <span class="v">rdi</span>, 
<span class="v">rsi</span>, <span class="v">rdx</span>, <span class="v">rcx</span>, <span class="v">r8</span>, and <span class="v">r9</span>.  For more details, 
see <a href="http://www.x86-64.org/documentation/abi.pdf" target="_blank"><nobr>this<img src="../Icon_External_Link.png" title="External link to http://www.x86-64.org/documentation/abi.pdf"></nobr></a> 
and <a href="http://www.agner.org/optimize/calling_conventions.pdf" target="_blank"><nobr>this<img src="../Icon_External_Link.png" title="External link to http://www.agner.org/optimize/calling_conventions.pdf"></nobr></a>. 
For our example program, the register <span class="v">rdi</span> (more accurately, 
register <span class="v">edi</span> --- the lower 32 bits of the register <span class="v">rdi</span>) is 
used to pass the concrete argument to <span class="v">popcount_32</span>.  We can 
confirm this by inspecting the assembly.  For example, in the 
<span class="v">main</span> routine, before the call to <span class="v">popcount_32</span>, we might 
observe an instruction that moves the argument to <span class="v">edi</span> --- see the 
instruction at address <span class="v">100000f10</span> in the assembly snippet above. 
Another clue can be the assembly corresponding to the <span class="v">popcount_32</span> 
routine, where we might see an instruction moving the value in 
<span class="v">edi</span> to the stack --- see the instruction at address 
<span class="v">100000e64</span> below.</p> 
 
<pre class="code">... 
0000000100000e60 <span class="v">&lt;_popcount_32&gt;</span>: 
   100000e60:   55                     push   %rbp 
   100000e61:   48 89 e5               mov    %rsp,%rbp 
   100000e64:   89 7d fc               mov    %edi,-0x4(%rbp) 
... 
</pre> 
 
<p>It should be emphasized is that it is the user's responsibility to 
ensure that the state is initialized "correctly", i.e., the program 
does not overlap with the page tables, the stack pointer is 
initialized so that the stack does not run out of memory nor does it 
overwrite the program during execution (in our example, <span class="v">2^45</span> is 
the initial value of the stack pointer for this very reason), etc. 
Essentially, the user takes on the job of the operating system plus 
the compiler/linker, etc.  Unless the program of choice is being 
executed "on top of" these system programs which are also being 
executed on the model, there is probably no way to remove this burden 
from the user.</p> 
 
</li> 
 
<li> 
 
<p>Run the program using <span class="tt"><a href="X86ISA____X86-RUN.html">x86-run</a></span> or <span class="tt"><a href="X86ISA____X86-RUN-STEPS.html">x86-run-steps</a></span> or 
<span class="tt"><a href="X86ISA____X86-RUN-HALT.html">x86-run-halt</a></span>.  To run one instruction only, use <a href="X86ISA____X86-FETCH-DECODE-EXECUTE.html">x86-fetch-decode-execute</a>.  You can also see <a href="X86ISA____DYNAMIC-INSTRUMENTATION.html">Dynamic-instrumentation</a> for details about dynamically debugging the 
program by inserting breakpoints and logging the x86 state into a 
file, etc.</p> 
 
<pre class="code">(x86-run-halt  #x100000f17 ;; halt-address 
               10000       ;; limit on number of steps to be run 
               x86) 
 
;; or 
;;    (x86-run-steps 10000 x86) 
 
;; or 
;;    (x86-run 10000 x86) 
</pre> 
 
<p>How do know that the program ran to completion?  After executing 
the above form, we can inspect the contents of the following 
fields:</p> 
 
<pre class="code">(fault x86) 
(ms x86) 
(rip x86) 
</pre> 
 
<p>If the <span class="v">fault</span> and <span class="v">ms</span> fields are empty, then the program 
didn't run to completion and the x86 state is poised to continue 
execution.  If <span class="v">rip</span> is at the <span class="v">halt-address</span>, <span class="v">ms</span> contains 
a legal halt message, and <span class="v">fault</span> is empty, then the program ran to 
completion successfully.  If you see some other error message in 
either <span class="v">ms</span> or <span class="v">fault</span>, you need to figure out what went wrong 
during the program execution --- the <a href="X86ISA____DYNAMIC-INSTRUMENTATION.html">Dynamic-instrumentation</a> 
utilities can help in debugging.</p> 
 
<p>Where did the number <span class="v">10000</span> in the argument to <span class="v">x86-run</span> or 
<span class="v">x86-run-steps</span> or <span class="v">x86-run-halt</span> come from?  This number is the 
clock, i.e., the upper limit on the number of instructions the x86 
interpreter will execute.  Fewer instructions that this number can be 
executed if the program reached the halt address sooner or if an error 
is encountered (in which case the <span class="v">ms</span> field will contain the 
error message).  It might also be the case that this argument to these 
functions is less than the number of instructions required to run the 
program to completion.  So, how do we pick the value of the clock?</p> 
 
<p>This, again, is up to the user.  Guessing the clock value is an 
answer.  In our example, <span class="v">10000</span> is large enough --- this example 
program is small enough that it takes only around a couple dozen 
instructions to run to completion.  You need not worry about the 
interpreter stepping uselessly after the program halts (or encounters 
an error) because then, the <span class="v">ms</span> or <span class="v">fault</span> fields will contain 
a message and these functions will stop executing as soon as these 
fields are non-nil.  On the other hand, if the clock you provided is 
not sufficient, then you can always execute these functions again and 
the program execution will continue.</p> 
 
</li> 
 
<li> 
 
<p>Inspect the output of the program.  For this program, register 
<span class="v">eax</span> contains the return value --- x86-64 Linux calling 
conventions dictate that <span class="v">rax</span> be the first return register.  Of 
course, as before, we can inspect the assembly to confirm if this is 
the case.</p> 
 
<pre class="code">(rgfi *rax* x86) ;; Note that eax is the low 32 bits of rax. 
</pre> 
 
<p>For the value <span class="v">0xff00ff00</span>, the register <span class="v">rax</span> should contain 
16.</p> 
 
<p>If you wish to run this program again in the same ACL2 session, 
remember to initialize the x86 state appropriately.</p> 
 
</li> 
 
</ol>
</body>
</html>
