<html>
<head>
<meta charset="UTF-8">
<title>Value</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=C____VALUE">Click for Value in the Full Manual</a></h3>

<p>Fixtype of values.</p><p>This is a tagged union type, introduced by <a href="FTY____DEFTAGSUM.html">fty::deftagsum</a>.</p> 
<h5>Member Tags → Types</h5><dl>
<dt>
<span class="tt">:uchar</span> → <a href="C____VALUE-UCHAR.html">value-uchar</a>
</dt> 
<dt>
<span class="tt">:schar</span> → <a href="C____VALUE-SCHAR.html">value-schar</a>
</dt> 
<dt>
<span class="tt">:ushort</span> → <a href="C____VALUE-USHORT.html">value-ushort</a>
</dt> 
<dt>
<span class="tt">:sshort</span> → <a href="C____VALUE-SSHORT.html">value-sshort</a>
</dt> 
<dt>
<span class="tt">:uint</span> → <a href="C____VALUE-UINT.html">value-uint</a>
</dt> 
<dt>
<span class="tt">:sint</span> → <a href="C____VALUE-SINT.html">value-sint</a>
</dt> 
<dt>
<span class="tt">:ulong</span> → <a href="C____VALUE-ULONG.html">value-ulong</a>
</dt> 
<dt>
<span class="tt">:slong</span> → <a href="C____VALUE-SLONG.html">value-slong</a>
</dt> 
<dt>
<span class="tt">:ullong</span> → <a href="C____VALUE-ULLONG.html">value-ullong</a>
</dt> 
<dt>
<span class="tt">:sllong</span> → <a href="C____VALUE-SLLONG.html">value-sllong</a>
</dt> 
<dt>
<span class="tt">:pointer</span> → <a href="C____VALUE-POINTER.html">value-pointer</a>
</dt> 
<dt>
<span class="tt">:array</span> → <a href="C____VALUE-ARRAY.html">value-array</a>
</dt> 
<dt>
<span class="tt">:struct</span> → <a href="C____VALUE-STRUCT.html">value-struct</a>
</dt> 
</dl> 
<p>For now we only support the standard unsigned and signed integer values 
       (except <span class="v">_Bool</span> values), 
       pointer values with any referenced type, 
       arrays of values of any type, 
       and structures of member values of any type. 
       Note that plain <span class="v">char</span> values are not 
       standard unsigned or signed integer values [C:6.2.5/7]; 
       currently we do not cover plain <span class="v">char</span> values.</p><p>Pointers are mentioned in several places in [C], 
       but there seems to be no specific place in [C] that defines them. 
       Nonetheless, we can get a precise picture from various places. 
       [C:6.2.5/20] says that pointer types describe objects 
       whose values provide references to entities. 
       [C:6.3.2.3] specifies several things about pointers; 
       in particular, it talks about null pointers. 
       Thus, the picture is the following: 
       a pointer is either an object designator or a null pointer 
       (see the discussion in <a href="C____OBJECT-DESIGNATORS.html">object-designators</a> 
       about lower-level addresses vs. higher-level object designators). 
       In our defensive dynamic semantics, 
       where values are tagged by their types, 
       we also include, as part of the pointer, 
       the type of its referenced value.</p><p>Thus, we define a pointer as consisting of 
       an optional object designator and a type. 
       The object designator is absent for a null pointer; 
       note that [C] does not prescribe 0 to represent a null pointer, 
       even though 0 is used in null pointer constants [C:6.3.2.3/3]. 
       The type is not the pointer type, but the referenced type; 
       this way, we avoid having to constrain the type to be a pointer type.</p><p>Array values are modeled as consisting of 
       the element type and a non-empty list of values. 
       [C:6.2.5/20] requires arrays to be non-empty.</p><p>Arrays are indexed via integers 
       [C] only provides minimum requirements for the sizes of integer types, 
       not maximum requirements. 
       Other than practical considerations, 
       nothing, mathematically, prevents some integer types 
       to consists of thousands or millions of bits. 
       So our model of arrays requires them to be non-empty, 
       but puts no maximum limits on their length.</p><p>This definition of arrays alone does not prevent arrays 
       from having values of different types. 
       That all the values have the element type 
       can and will be enforced in separate predicates.</p><p>Structures are modeled as consisting of a tag (identifier) 
       and a non-empty list of member values. 
       The tag is the one that identifies the structure type; 
       we only model structures with non-anonymous types. 
       [C:6.2.5/20] requires at least one member. 
       The member values must have distinct names; 
       we do not capture this requirement here, but we may in the future.</p><p>The requirement that the member values 
       match the members of the structure type 
       requires contextual information about the structure type. 
       So this requirement cannot be captured in this definition of values.</p> 
 
<p><b>Theorem: </b>valuep-when-uchar-arrayp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> valuep-when-uchar-arrayp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____UCHAR-ARRAYP.html">uchar-arrayp</a> x) (<a href="C____VALUEP.html">valuep</a> x)))</pre> 
<p><b>Theorem: </b>valuep-when-schar-arrayp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> valuep-when-schar-arrayp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____SCHAR-ARRAYP.html">schar-arrayp</a> x) (<a href="C____VALUEP.html">valuep</a> x)))</pre> 
<p><b>Theorem: </b>valuep-when-ushort-arrayp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> valuep-when-ushort-arrayp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____USHORT-ARRAYP.html">ushort-arrayp</a> x) (<a href="C____VALUEP.html">valuep</a> x)))</pre> 
<p><b>Theorem: </b>valuep-when-sshort-arrayp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> valuep-when-sshort-arrayp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____SSHORT-ARRAYP.html">sshort-arrayp</a> x) (<a href="C____VALUEP.html">valuep</a> x)))</pre> 
<p><b>Theorem: </b>valuep-when-uint-arrayp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> valuep-when-uint-arrayp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____UINT-ARRAYP.html">uint-arrayp</a> x) (<a href="C____VALUEP.html">valuep</a> x)))</pre> 
<p><b>Theorem: </b>valuep-when-sint-arrayp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> valuep-when-sint-arrayp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____SINT-ARRAYP.html">sint-arrayp</a> x) (<a href="C____VALUEP.html">valuep</a> x)))</pre> 
<p><b>Theorem: </b>valuep-when-ulong-arrayp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> valuep-when-ulong-arrayp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____ULONG-ARRAYP.html">ulong-arrayp</a> x) (<a href="C____VALUEP.html">valuep</a> x)))</pre> 
<p><b>Theorem: </b>valuep-when-slong-arrayp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> valuep-when-slong-arrayp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____SLONG-ARRAYP.html">slong-arrayp</a> x) (<a href="C____VALUEP.html">valuep</a> x)))</pre> 
<p><b>Theorem: </b>valuep-when-ullong-arrayp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> valuep-when-ullong-arrayp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____ULLONG-ARRAYP.html">ullong-arrayp</a> x) (<a href="C____VALUEP.html">valuep</a> x)))</pre> 
<p><b>Theorem: </b>valuep-when-sllong-arrayp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> valuep-when-sllong-arrayp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____SLLONG-ARRAYP.html">sllong-arrayp</a> x) (<a href="C____VALUEP.html">valuep</a> x)))</pre> 
<p><b>Theorem: </b>value-kind-when-uchar-arrayp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> value-kind-when-uchar-arrayp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____UCHAR-ARRAYP.html">uchar-arrayp</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____VALUE-KIND.html">value-kind</a> x) :array)))</pre> 
<p><b>Theorem: </b>value-kind-when-schar-arrayp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> value-kind-when-schar-arrayp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____SCHAR-ARRAYP.html">schar-arrayp</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____VALUE-KIND.html">value-kind</a> x) :array)))</pre> 
<p><b>Theorem: </b>value-kind-when-ushort-arrayp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> value-kind-when-ushort-arrayp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____USHORT-ARRAYP.html">ushort-arrayp</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____VALUE-KIND.html">value-kind</a> x) :array)))</pre> 
<p><b>Theorem: </b>value-kind-when-sshort-arrayp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> value-kind-when-sshort-arrayp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____SSHORT-ARRAYP.html">sshort-arrayp</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____VALUE-KIND.html">value-kind</a> x) :array)))</pre> 
<p><b>Theorem: </b>value-kind-when-uint-arrayp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> value-kind-when-uint-arrayp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____UINT-ARRAYP.html">uint-arrayp</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____VALUE-KIND.html">value-kind</a> x) :array)))</pre> 
<p><b>Theorem: </b>value-kind-when-sint-arrayp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> value-kind-when-sint-arrayp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____SINT-ARRAYP.html">sint-arrayp</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____VALUE-KIND.html">value-kind</a> x) :array)))</pre> 
<p><b>Theorem: </b>value-kind-when-ulong-arrayp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> value-kind-when-ulong-arrayp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____ULONG-ARRAYP.html">ulong-arrayp</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____VALUE-KIND.html">value-kind</a> x) :array)))</pre> 
<p><b>Theorem: </b>value-kind-when-slong-arrayp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> value-kind-when-slong-arrayp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____SLONG-ARRAYP.html">slong-arrayp</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____VALUE-KIND.html">value-kind</a> x) :array)))</pre> 
<p><b>Theorem: </b>value-kind-when-ullong-arrayp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> value-kind-when-ullong-arrayp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____ULLONG-ARRAYP.html">ullong-arrayp</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____VALUE-KIND.html">value-kind</a> x) :array)))</pre> 
<p><b>Theorem: </b>value-kind-when-sllong-arrayp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> value-kind-when-sllong-arrayp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____SLLONG-ARRAYP.html">sllong-arrayp</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____VALUE-KIND.html">value-kind</a> x) :array)))</pre> 

</body>
</html>
