<html>
<head>
<meta charset="UTF-8">
<title>Atc-read-object-rules</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=C____ATC-READ-OBJECT-RULES">Click for Atc-read-object-rules in the Full Manual</a></h3>

<p>Rules about <span class="tt"><a href="C____READ-OBJECT.html">read-object</a></span>.</p><p>The theorems about <span class="tt"><a href="C____READ-OBJECT.html">read-object</a></span> 
     skip over all the functions that represent the computation states, 
     except for possibly <span class="tt"><a href="C____UPDATE-OBJECT.html">update-object</a></span>: 
     this is similar to the interaction 
     between <span class="tt"><a href="C____READ-VAR.html">read-var</a></span> and <span class="tt"><a href="C____UPDATE-VAR.html">update-var</a></span>.</p><p>We include the rule for commutativity of <span class="tt"><a href="C____OBJECT-DISJOINTP.html">object-disjointp</a></span>, 
     so it does not matter the order of the disjoint objects 
     in the hypotheses of the rules vs. the available hypothesis 
     during the symbolic execution 
     (i.e. commutativity normalizes them, via its loop stopper).</p> 
 
<h3>Definitions and Theorems</h3><p><b>Theorem: </b>read-object-of-add-frame</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> read-object-of-add-frame
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____READ-OBJECT.html">read-object</a> objdes (<a href="C____ADD-FRAME.html">add-frame</a> fun compst))
               (<a href="C____READ-OBJECT.html">read-object</a> objdes compst)))</pre> 
<p><b>Theorem: </b>read-object-of-enter-scope</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> read-object-of-enter-scope
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____READ-OBJECT.html">read-object</a> objdes (<a href="C____ENTER-SCOPE.html">enter-scope</a> compst))
               (<a href="C____READ-OBJECT.html">read-object</a> objdes compst)))</pre> 
<p><b>Theorem: </b>read-object-of-add-var</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> read-object-of-add-var
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____READ-OBJECT.html">read-object</a> objdes (<a href="C____ADD-VAR.html">add-var</a> var val compst))
               (<a href="C____READ-OBJECT.html">read-object</a> objdes compst)))</pre> 
<p><b>Theorem: </b>read-object-of-update-var</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> read-object-of-update-var
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____READ-OBJECT.html">read-object</a> objdes (<a href="C____UPDATE-VAR.html">update-var</a> var val compst))
               (<a href="C____READ-OBJECT.html">read-object</a> objdes compst)))</pre> 
<p><b>Theorem: </b>read-object-of-update-object-same</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     read-object-of-update-object-same
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____OBJDESIGN-KIND.html">objdesign-kind</a> objdes) :address)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____READ-OBJECT.html">read-object</a> objdes
                                  (<a href="C____UPDATE-OBJECT.html">update-object</a> objdes val compst))
                     (<a href="C____VALUE-FIX.html">value-fix</a> val))))</pre> 
<p><b>Theorem: </b>read-object-of-update-object-disjoint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    read-object-of-update-object-disjoint
    (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____OBJECT-DISJOINTP.html">object-disjointp</a> objdes objdes2)
             (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____READ-OBJECT.html">read-object</a> objdes
                                 (<a href="C____UPDATE-OBJECT.html">update-object</a> objdes2 val compst))
                    (<a href="C____READ-OBJECT.html">read-object</a> objdes compst))))</pre> 

</body>
</html>
