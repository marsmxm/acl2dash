<html>
<head>
<meta charset="UTF-8">
<title>With-prover-step-limit</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____WITH-PROVER-STEP-LIMIT">Click for With-prover-step-limit in the Full Manual</a></h3>

<p>Limit the number of steps for proofs</p><p>Logically, <span class="v">(<a href="ACL2____WITH-PROVER-STEP-LIMIT.html">with-prover-step-limit</a> expr form)</span> is equivalent to 
 <span class="v">form</span>, except that if the number of ``prover steps'' executed during 
 evaluation of <span class="v">form</span> exceeds a bound specified by the value of <span class="v">expr</span>, 
 then that proof will abort.  See <a href="ACL2____SET-PROVER-STEP-LIMIT.html">set-prover-step-limit</a> for a related 
 utility that sets the limit on prover steps globally instead of setting it for 
 just one form, and for a discussion of the notion of ``prover steps'', which 
 could change in future ACL2 releases.  For a related utility based on time 
 instead of prover steps, see <a href="ACL2____WITH-PROVER-TIME-LIMIT.html">with-prover-time-limit</a>; but as discussed 
 in the <a href="COMMON-LISP____DOCUMENTATION.html">documentation</a> for <span class="tt"><a href="ACL2____SET-PROVER-STEP-LIMIT.html">set-prover-step-limit</a></span>, there is at 
 best a loose connection between the counting of steps and <span class="tt"><a href="ACL2____WITH-PROVER-TIME-LIMIT.html">with-prover-time-limit</a></span>.</p> 
 
 <p>The arguments of <span class="v">(<a href="ACL2____WITH-PROVER-STEP-LIMIT.html">with-prover-step-limit</a> expr form)</span> are evaluated. 
 However, the (optional) argument <span class="v">flg</span> is not evaluated in 
 <span class="v">(<a href="ACL2____WITH-PROVER-STEP-LIMIT.html">with-prover-step-limit</a> expr flg form)</span>.</p> 
 
 <p>Depending on the machine you are using, you may have less than a half-hour 
 of time before the number of prover steps exceeds the maximum limit on prover 
 steps that may be imposed, which is one less than the value of 
 <span class="v">*default-step-limit*</span>.  But there is no limit unless you explicitly call 
 <span class="v">with-prover-step-limit</span> or <span class="tt"><a href="ACL2____SET-PROVER-STEP-LIMIT.html">set-prover-step-limit</a></span>.</p> 
 
 <p>For examples of how step-limits work besides those presented below, see the 
 community book <span class="v">books/misc/misc2/step-limits.lisp</span>.</p> 
 
 <p>For a utility that returns an indicator of the number of prover steps most 
 recently taken, see <a href="ACL2____LAST-PROVER-STEPS.html">last-prover-steps</a>.</p> 
 
 <p>Note that <span class="v">with-prover-step-limit</span> may not be called inside definitions, 
 and that it is simply the identity macro in raw Lisp.  However, 
 <span class="v">with-prover-step-limit!</span> may be called in place of 
 <span class="v">with-prover-step-limit</span>, with the effect described here even in raw 
 Lisp.</p> 
 
 <pre class="code">Examples:

; Limit (mini-proveall) to 100,000 prover steps (which happens to suffice)
(<a href="ACL2____WITH-PROVER-STEP-LIMIT.html">with-prover-step-limit</a> 100000 (mini-proveall))

; Same as above for the inner call of with-prover-step-limit; so the
; mini-proveall call completes, but then we get an error because the second
; argument of the outer with-prover-step-limit call took more than 200
; steps.
(<a href="ACL2____WITH-PROVER-STEP-LIMIT.html">with-prover-step-limit</a>
 200
 (<a href="ACL2____WITH-PROVER-STEP-LIMIT.html">with-prover-step-limit</a> 100000 (mini-proveall)))

; Same as preceding form just above, except that this time there is no error,
; because the inner call of with-prover-step-limit has an extra argument
; of t inserted into the second argument position, which specifies that this
; entire inner call is treated as though it uses no prover steps.
(<a href="ACL2____WITH-PROVER-STEP-LIMIT.html">with-prover-step-limit</a>
 200
 (<a href="ACL2____WITH-PROVER-STEP-LIMIT.html">with-prover-step-limit</a> 100000 t (mini-proveall)))

; The inner call limits (mini-proveall) to 200 prover steps, which fails
; almost immediately.
(<a href="ACL2____WITH-PROVER-STEP-LIMIT.html">with-prover-step-limit</a> 100000 (<a href="ACL2____WITH-PROVER-STEP-LIMIT.html">with-prover-step-limit</a> 200 (mini-proveall)))

; Do not limit the number of prover steps, regardless of such a limit imposed
; globally or by the surrounding context.
(<a href="ACL2____WITH-PROVER-STEP-LIMIT.html">with-prover-step-limit</a> nil (mini-proveall))

; Same as just above (indeed, nil above is converted to
; *default-step-limit*):
(<a href="ACL2____WITH-PROVER-STEP-LIMIT.html">with-prover-step-limit</a> *default-step-limit* (mini-proveall))

; Advanced example: Limit the indicated theorem to 100 steps, and when the
; proof does not complete, then put down a label instead.
(<a href="ACL2____MV-LET.html">mv-let</a> (erp val state)
        (<a href="ACL2____WITH-PROVER-STEP-LIMIT.html">with-prover-step-limit</a>
         100
         (<a href="ACL2____THM.html">thm</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="COMMON-LISP____APPEND.html">append</a> x x) x)
                     (<a href="COMMON-LISP____APPEND.html">append</a> x x x))))
        (<a href="COMMON-LISP____IF.html">if</a> erp
            (<a href="ACL2____DEFLABEL.html">deflabel</a> foo :doc "Attempt failed.")
          (<a href="ACL2____VALUE.html">value</a> (<a href="COMMON-LISP____LIST.html">list</a> :succeeded-with val))))

; Use extra argument of t to avoid ``charging'' steps for the indicated
; form.
(<a href="ACL2____WITH-PROVER-STEP-LIMIT.html">with-prover-step-limit</a>
 500
 (<a href="ACL2____ENCAPSULATE.html">encapsulate</a>
  ()
  (<a href="ACL2____WITH-PROVER-STEP-LIMIT.html">with-prover-step-limit</a>
   500
   t ; Don't charge prover steps for this first defthm.
   (<a href="ACL2____DEFTHM.html">defthm</a> test1
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____APPEND.html">append</a> x (<a href="COMMON-LISP____APPEND.html">append</a> y z))
            (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="COMMON-LISP____APPEND.html">append</a> x y) z))
     :rule-classes nil))
  (<a href="ACL2____DEFTHM.html">defthm</a> test2
    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____APPEND.html">append</a> x (<a href="COMMON-LISP____APPEND.html">append</a> y z))
           (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="COMMON-LISP____APPEND.html">append</a> x y) z))
    :rule-classes nil)))

General Forms:
(<a href="ACL2____WITH-PROVER-STEP-LIMIT.html">with-prover-step-limit</a> expr form)
(<a href="ACL2____WITH-PROVER-STEP-LIMIT.html">with-prover-step-limit</a> expr flg form)</pre> 
 
 <p>where <span class="v">form</span> is an arbitrary form to evaluate, and <span class="v">expr</span> evaluates 
 to one of the following: <span class="v">nil</span>; a natural number not exceeding the value of 
 <span class="v">*default-step-limit*</span>; or the special value, <span class="v">:START</span>.  The optional 
 extra argument in the second position, <span class="v">flg</span>, must be Boolean if 
 supplied.</p> 
 
 <p>If the value of <span class="v">expr</span> is a natural number less than the value of 
 <span class="v">*default-step-limit*</span>, then that value is the maximum number of prover 
 steps permitted during evaluation of <span class="v">form</span> before an error occurs.  If 
 however the value of <span class="v">expr</span> is <span class="v">nil</span> or is the value of 
 <span class="v">*default-step-limit*</span>, then no limit is placed on the number of prover 
 steps during processing of <span class="v">form</span>.  Otherwise, the value of <span class="v">expr</span> 
 should be the keyword <span class="v">:START</span>, which is intended for use by the ACL2 
 implementation and may have semantics that change with new ACL2 versions.</p> 
 
 <p>Finally we describe the optional extra Boolean argument, <span class="v">flg</span>.  If 
 <span class="v">flg</span> is <span class="v">nil</span> or omitted, then a running count of prover steps is 
 maintained after <span class="v">form</span> is evaluated; otherwise, that count is not affected 
 by evaluation of <span class="v">form</span>.  To see how this works when <span class="v">flg</span> is nil or 
 omitted, consider an event of shape <span class="v">(<a href="COMMON-LISP____PROGN.html">progn</a> form1 form2)</span>, where we are 
 tracking prover steps (say, because of a superior call of 
 <span class="v">with-prover-step-limit</span>).  If <span class="v">n</span> is the number of prover steps 
 available when the <span class="tt"><a href="COMMON-LISP____PROGN.html">progn</a></span> form is entered, and if <span class="v">s</span> prover steps 
 are executed while evaluating <span class="v">form1</span>, then <span class="v">n-s</span> steps are available 
 for evaluation of <span class="v">form2</span> provided <span class="v">s</span> does not exceed <span class="v">n</span>; 
 otherwise, an error occurs.  In particular, this is the case if <span class="v">form1</span> is 
 an event <span class="tt">(with-prover-step-limit k form1')</span>.  However, if <span class="v">form1</span> 
 is an event <span class="tt">(with-prover-step-limit k t form1')</span>, then because of the 
 extra argument of <span class="v">t</span>, no steps are ``charged'' to <span class="v">form</span>; that is, all 
 <span class="v">n</span> steps, rather than <span class="v">n-s</span> steps, are available for evaluation of 
 <span class="v">form2</span>.</p>
</body>
</html>
