<html>
<head>
<meta charset="UTF-8">
<title>Cstate-to-vars</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=YUL____CSTATE-TO-VARS">Click for Cstate-to-vars in the Full Manual</a></h3>

<p>Turn a computation state into a variable table.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(cstate-to-vars cstate) → varset</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">cstate</span> — <font color="#606060">Guard <span class="v">(<a href="YUL____CSTATEP.html">cstatep</a> cstate)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">varset</span> — <font color="#606060">Type <span class="v">(<a href="YUL____IDENTIFIER-SETP.html">identifier-setp</a> varset)</span>.</font>
</dd> 
 
</dl></div> 
<p>A variable table is the static counterpart of 
     the local state of a computation state in the dynamic execution. 
     The variable table consists of the keys of the omap.</p><p>We prove a theorem to fold the body of this function 
     into the function call. 
     This is the opposite of unfolding the definition. 
     We use this rule in the main static soundness theorem. 
     This rule is not very satisfactory; 
     we will look into avoiding it in some way.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>cstate-to-vars</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> cstate-to-vars (<a href="YUL____CSTATE.html">cstate</a>)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="YUL____CSTATEP.html">cstatep</a> cstate)))
       (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'cstate-to-vars))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
            (<a href="OMAP____KEYS.html">omap::keys</a> (<a href="YUL____CSTATE-_E3LOCAL.html">cstate-&gt;local</a> cstate))))</pre> 
<p><b>Theorem: </b>identifier-setp-of-cstate-to-vars</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> identifier-setp-of-cstate-to-vars
        (<a href="ACL2____B_A2.html">b*</a> ((varset (<a href="YUL____CSTATE-TO-VARS.html">cstate-to-vars</a> cstate)))
            (<a href="YUL____IDENTIFIER-SETP.html">identifier-setp</a> varset))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>cstate-to-vars-fold-def</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> cstate-to-vars-fold-def
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="OMAP____KEYS.html">omap::keys</a> (<a href="YUL____CSTATE-_E3LOCAL.html">cstate-&gt;local</a> cstate))
               (<a href="YUL____CSTATE-TO-VARS.html">cstate-to-vars</a> cstate)))</pre> 
<p><b>Theorem: </b>cstate-to-vars-of-cstate-fix-cstate</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> cstate-to-vars-of-cstate-fix-cstate
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="YUL____CSTATE-TO-VARS.html">cstate-to-vars</a> (<a href="YUL____CSTATE-FIX.html">cstate-fix</a> cstate))
               (<a href="YUL____CSTATE-TO-VARS.html">cstate-to-vars</a> cstate)))</pre> 
<p><b>Theorem: </b>cstate-to-vars-cstate-equiv-congruence-on-cstate</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> cstate-to-vars-cstate-equiv-congruence-on-cstate
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="YUL____CSTATE-EQUIV.html">cstate-equiv</a> cstate cstate-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="YUL____CSTATE-TO-VARS.html">cstate-to-vars</a> cstate)
                        (<a href="YUL____CSTATE-TO-VARS.html">cstate-to-vars</a> cstate-equiv)))
        :rule-classes :congruence)</pre> 

</body>
</html>
