<html>
<head>
<meta charset="UTF-8">
<title>Tail-recursive-p</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____TAIL-RECURSIVE-P">Click for Tail-recursive-p in the Full Manual</a></h3>

<p>Check if a singly recursive function is tail-recursive.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(tail-recursive-p fn wrld) → yes/no</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">fn</span> — <font color="#606060">Guard <span class="v">(<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> fn) (<a href="COMMON-LISP_____D3.html">=</a> 1 (<a href="ACL2____LEN.html">len</a> (<a href="ACL2____IRECURSIVEP.html">irecursivep</a> fn wrld))))</span>.</font>
</dd> 
  <dd>
<span class="tt">wrld</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____PLIST-WORLDP.html">plist-worldp</a> wrld)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">yes/no</span> — <font color="#606060">Type <span class="v">(<a href="ACL2____BOOLEANP.html">booleanp</a> yes/no)</span>.</font>
</dd> 
 
</dl></div> 
<p>A singly recursive function is tail-recursive if 
     each of its recursive calls are the last action taken by the function 
     on that execution path. 
     We recursively examine the body of the function 
     to see whether that is the case.</p><p>Variables and quoted constants cannot contain recursive calls 
     and thus pass the check. 
     Calls of <span class="tt"><a href="COMMON-LISP____IF.html">if</a></span> are non-strict, and thus they are treated specially: 
     they pass the check if 
     their `then' and `else' branches individually pass the check 
     (since just one of these branches is executed each time) 
     and their test has no recursive calls 
     (because after the test a branch has to be evaluated, 
     so evaluating the test is never the function's last action).</p><p>Calls of other named functions pass the check 
     if the arguments do not contain recursive calls. 
     This applies both when the called function is <span class="v">fn</span> 
     (in which case it is a tail-recursive call), 
     and when the called function is not <span class="v">fn</span> 
     (in which case it is not a recursive call).</p><p>Calls of lambda expressions pass the check 
     if the arguments do not contain recursive calls 
     and the body of the lambda expression passes the check. 
     The body of the lambda expression is the last thing 
     to be evaluated in the call.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>tail-recursive-p-aux</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 tail-recursive-p-aux (fn term)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> fn) (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> term))))
 (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'tail-recursive-p-aux))
      (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
      (<a href="ACL2____B_A2.html">b*</a> (((when (<a href="ACL2____VARIABLEP.html">variablep</a> term)) t)
           ((when (<a href="ACL2____FQUOTEP.html">fquotep</a> term)) t)
           ((when (<a href="COMMON-LISP____EQ.html">eq</a> (<a href="ACL2____FFN-SYMB.html">ffn-symb</a> term) 'if))
            (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____FFNNAMEP.html">ffnnamep</a> fn (<a href="ACL2____FARGN.html">fargn</a> term 1)))
                 (tail-recursive-p-aux fn (<a href="ACL2____FARGN.html">fargn</a> term 2))
                 (tail-recursive-p-aux fn (<a href="ACL2____FARGN.html">fargn</a> term 3))))
           ((when (<a href="ACL2____FFNNAMEP-LST.html">ffnnamep-lst</a> fn (<a href="ACL2____FARGS.html">fargs</a> term)))
            nil)
           ((when (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="ACL2____FFN-SYMB.html">ffn-symb</a> term))) t))
          (tail-recursive-p-aux fn (<a href="ACL2____LAMBDA-BODY.html">lambda-body</a> (<a href="ACL2____FFN-SYMB.html">ffn-symb</a> term))))))</pre> 
<p><b>Theorem: </b>booleanp-of-tail-recursive-p-aux</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> booleanp-of-tail-recursive-p-aux
        (<a href="ACL2____B_A2.html">b*</a> ((yes/no (tail-recursive-p-aux fn term)))
            (<a href="ACL2____BOOLEANP.html">booleanp</a> yes/no))
        :rule-classes :rewrite)</pre> 
<p><b>Function: </b>tail-recursive-p</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
  tail-recursive-p (fn wrld)
  (<a href="COMMON-LISP____DECLARE.html">declare</a>
       (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PLIST-WORLDP.html">plist-worldp</a> wrld)
                          (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> fn)
                               (<a href="COMMON-LISP_____D3.html">=</a> 1 (<a href="ACL2____LEN.html">len</a> (<a href="ACL2____IRECURSIVEP.html">irecursivep</a> fn wrld)))))))
  (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'tail-recursive-p))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
       (tail-recursive-p-aux fn (<a href="ACL2____UBODY_B2.html">ubody+</a> fn wrld))))</pre> 
<p><b>Theorem: </b>booleanp-of-tail-recursive-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> booleanp-of-tail-recursive-p
        (<a href="ACL2____B_A2.html">b*</a> ((yes/no (<a href="ACL2____TAIL-RECURSIVE-P.html">tail-recursive-p</a> fn wrld)))
            (<a href="ACL2____BOOLEANP.html">booleanp</a> yes/no))
        :rule-classes :rewrite)</pre> 

</body>
</html>
