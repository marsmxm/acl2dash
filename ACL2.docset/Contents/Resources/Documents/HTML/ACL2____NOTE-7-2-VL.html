<html>
<head>
<meta charset="UTF-8">
<title>Note-7-2-vl</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____NOTE-7-2-VL">Click for Note-7-2-vl in the Full Manual</a></h3>

<p>Notes about changes to <a href="ACL2____VL.html">vl</a> and <a href="ACL2____SV.html">sv</a> in ACL2 7.2.</p><p>Below we describe changes since the ACL2 7.1 release to the 
unstable, development version of <a href="ACL2____VL.html">vl</a>.  Note that the stable version, 
<a href="ACL2____VL2014.html">vl2014</a>, is essentially unchanged except for minor bugfixes.  See also 
<a href="ACL2____NOTE-7-1-VL.html">note-7-1-vl</a> for some background about VL and VL2014.</p> 
 
 
<h3>Extended SystemVerilog Support</h3> 
 
<p>Much of the development work has focused on supporting additional features 
of SystemVerilog.</p> 
 
<p><b>Interfaces.</b> VL and SV now have much better support for interfaces. 
They can now contain functions, tasks, assignments, etc.  Modports are now 
generally understood: they participate in scopes, are sanity checked for name 
clashes, are supported in submodule instantiation, etc.  Interface usage in 
submodule instances are properly type checked and are generally supported in VL 
and through SV.  Note that interface arrays are not yet supported.</p> 
 
<p><b>Assertions.</b> VL's parser and pretty-printer now support many 
SystemVerilog assertion features, including at least sequence/property 
expressions (see <a href="VL____PROPERTY-EXPRESSIONS.html">vl::property-expressions</a>), procedural assertions (see 
<a href="VL____VL-ASSERTSTMT.html">vl::vl-assertstmt</a> and <a href="VL____VL-CASSERTSTMT.html">vl::vl-cassertstmt</a>), sequence and property 
declarations (see <a href="VL____VL-SEQUENCE.html">vl::vl-sequence</a> and <a href="VL____VL-PROPERTY.html">vl::vl-property</a>), and 
module-level assertions (see <a href="VL____VL-ASSERTION.html">vl::vl-assertion</a> and <a href="VL____VL-CASSERTION.html">vl::vl-cassertion</a>).  Note that all of this assertion-related stuff is 
currently ignored by the SV flow.  However, modules with assertions should at 
least no longer result in parse errors, and these structures may some day be a 
useful basis for implementing assertion checking tools.</p> 
 
<p><b>Aliases.</b> Alias constructs should now work in VL and are also 
supported by SV.</p> 
 
<p><b>Expressions.</b> The <span class="v">**</span> (exponent/power) operator, <span class="v">inside</span> 
operator are now supported in both <a href="ACL2____VL.html">vl</a> and SV.  Note that NCV/VCS 
disagree about the sizing of <span class="v">inside</span> operators and that in general these 
operators may be buggy on commercial tools.  Added support for a few additional 
system functions like <span class="v">$dimensions</span>, etc.</p> 
 
<p><b>Statements.</b> The parsing and representation of <a href="VL____STATEMENTS.html">vl::statements</a> 
has been extended in various ways.  Note that our support for statements in SV 
is still rather limited, so just because we can parse these things doesn't 
necessarily mean they will be handled all the way through the SV flow:</p> 
 
<ul> 
 
<li>
<span class="v">break</span> and <span class="v">continue</span> statements are now implemented.</li> 
 
<li>Statement labels are now supported.</li> 
 
<li>There is better support for subroutine call statements; so we can now parse 
things like <span class="v">void'(...)</span> and otherwise do slightly better with calls of 
tasks/functions in statements.</li> 
 
<li>We now permit function calls/task enables with explicit parens but no 
arguments.  (In Verilog-2005, was is syntactically legal to write statements 
like <span class="v">mytask;</span> but not <span class="v">mytask();</span> with the explicit parens, even though 
they seem like they should be equivalent.  In SystemVerilog both forms are 
allowed, but we had previously only supported the <span class="v">mytask;</span> version.)</li> 
 
<li>Block statements (<span class="v">begin/end</span>, <span class="v">fork/join</span>, ...) can now have 
typedefs.  We can now parse <span class="v">fork/join_any</span> and <span class="v">fork/join_none</span> 
statements.</li> 
 
<li>
<span class="v">final</span> statements are now allowed.  Much like <span class="v">initial</span> statements, 
these are simply ignored in the SV flow.</li> 
 
</ul> 
 
 
<p><b>DPI import/exports.</b> DPI import/exports, used to connect SystemVerilog 
to C programs, are now tolerated by VL's parser and are now to some degree 
understood by other parts of VL.  For instance, they are known to <a href="VL____SCOPESTACK.html">vl::scopestack</a>s and can be considered when checking for name clashes, 
introducing implicit wires, etc.  See <a href="VL____VL-DPIIMPORT.html">vl::vl-dpiimport</a> and <a href="VL____VL-DPIEXPORT.html">vl::vl-dpiexport</a>.</p> 
 
 
<p><b>Instances.</b> Module and gate instance arrays can now use the 
single-expression ranges, i.e., we now support things like:</p> 
 
<pre class="code">and foo [3] (o, a, b);
submod foo [3] (a, b, c);</pre> 
 
<p>Note that SystemVerilog also allows multiple-dimension instance arrays, but 
those are still unsupported.</p> 
 
 
<p><b>Other.</b> Many bugfixes (e.g., to the parser, scoping, etc) have 
resulted in VL being able to successfully load additional designs.</p> 
 
 
<h3>Scoping and <a href="VL____ANNOTATE.html">vl::annotate</a> improvements.</h3> 
 
<p>The SV and Linter flows now use a unified <a href="VL____ANNOTATE.html">vl::annotate</a> meta-transform 
to prepare the design for analysis.  This transform has been significantly 
improved to do a better job with scoping issues related to functions, tasks, 
generate constructs, and statements.  This provides broad improvements to what 
VL can successfully parse and translate.</p> 
 
<p>The <a href="VL____MAKE-IMPLICIT-WIRES.html">vl::make-implicit-wires</a> transformation, which plays a 
surprisingly important role in getting scoping right, now more closely matches 
commercial tools like NCV and VCS.  We are particularly more careful about how 
implicit wires are inferred from expressions involving indexing/selection like 
<span class="v">foo[w]</span>.  In general, in a structure pattern like <span class="v">'{foo : 3}</span>, it's 
tricky to tell whether <span class="v">foo</span> is a structure member or a parameter.  VL now 
handles this much better and our strategy is documented; see <a href="VL____VL-PATTERNKEY-AMBIGUITY.html">vl::vl-patternkey-ambiguity</a>.  It also used to be that such patterns could fool 
VL into inferring implicit wires for <span class="v">foo</span>!  This has been fixed.</p> 
 
<p>Much of <span class="v">make-implicit-wires</span> has been moved into the related <a href="VL____SHADOWCHECK.html">vl::shadowcheck</a> transform.  The representation of functions and tasks has been 
adjusted to better support correct scoping and shadowchecking, and shadowcheck 
now understands user-defined types.  Shadowcheck was also incorrectly handling 
certain situations with package imports, which has been fixed.  It also now 
checks for name clashes in all scopes and produces good warnings in this case. 
Finally, shadowcheck treats the global scope in a less incorrect way, fixing 
many problems with global package imports.</p> 
 
<p>VL's scoping of generates also used to be completely wrong.  While it still 
has some known bugs, it has been significantly improved.  The scoping of 
<span class="v">genvars</span> is also improved.  Bugs have also been fixed related to 
disambiguating types from expressions in functions and tasks, and also in the 
handling of types versus interfaces in ports.</p> 
 
 
<h3>Generates, Elaboration</h3> 
 
<p>One of the trickiest parts of VL is elaboration, where parameters are 
expanded into constants, generate blocks are resolved, etc.  To evaluate a 
parameter like</p> 
 
<pre class="code">parameter foo = $bits(mypkg::mytype_t) + blah2size(settings.blah);</pre> 
 
<p>we need to evaluate its expression.  This can involve looking up the values 
of other parameters from other places in the hierarchy, evaluating system and 
user-defined functions, etc.  Functions are defined in terms of statements, so 
we need to understand statements as well.  This all gets to be a very messy 
mutual recursion.</p> 
 
<p>VL's implementation of elaboration now reuses much of the SV code for 
converting Verilog expressions into <a href="SV____SVEX.html">sv::svex</a>es, and is now able to 
resolve many significantly more complex parameters and generates.</p> 
 
 
<h3>Linter</h3> 
 
<p>The <a href="VL____VL-LINT.html">vl::vl-lint</a> tool now uses much more of the SV code.  It shares the 
<a href="VL____ANNOTATE.html">vl::annotate</a> code with the SV flow and also uses SV-based elaboration, 
which provides much better handling of generates and allows it to 
unparameterize modules involving types and other complex expressions.  The very 
useful size warnings from VL2014 have also been ported to work with the new SV 
code base.</p> 
 
<p>Various warning heuristics and messages have been tweaked.  We no longer 
complain about duplicate interface instances, since that's perfectly 
reasonable.  Parse errors have some additional context.  Lucid has been 
extended to understand new features like interfaces and modports, DPI 
imports/exports, and final blocks.</p> 
 
 
<h3>Test Suites</h3> 
 
<p>Significant work has gone into testing VL.  VL now has three test 
suites:</p> 
 
<ul> 
 
<li>
<b>centaur/vl/linttest</b> — tests of Linter functionality.  This 
notably includes a lot of tests of scoping and sizing issues.</li> 
 
<li>
<b>centaur/sv/cosims</b> — tests comparing VL+SV behavior against 
that of commercial simulators such as NCV and VCS.  These are our main tests of 
SV.  You can also search for <span class="v">no_ncv</span> or <span class="v">no_vcs</span> to discover places 
where VL disagrees with one tool or another (e.g., because the commercial tools 
don't agree.)</li> 
 
<li>
<b>centaur/sv/failtest</b> — tests that ensure VL+SV report fatal 
errors for modules that have some bad problem.  This turns out to be a nice way 
to test many scoping issues and make sure that we will reject bad 
constructs.</li> 
 
</ul> 
 
<p>Running <span class="v">make vl</span> in the <span class="v">acl2/books</span> directory now automatically also 
runs all of the linttests and failtests.  It doesn't automatically run the 
cosims, since that requires commercial simulators.)</p> 
 
<p>Each of the test suites has been extended considerably, especially in the 
tricky areas of scoping, implicit wire creation, generate handling, and also in 
order to test new features like interface support.  Many of the old VL2014 
<span class="v">systest</span> tests have also been ported to the new <span class="v">cosims</span> format.</p> 
 
 
 
<h3>Other Notes</h3> 
 
<p>VL and SV are still evolving rapidly and a lot is in flux.</p> 
 
<p>There has been significant renaming of files, moving of files, and deleting 
of dead files.  The documentation has gotten a lot of work in some areas, but 
of course there is more to do.</p> 
 
<p>Numerous minor bugfixes in all areas of VL are not mentioned, but can be 
found in the change log.</p>
</body>
</html>
