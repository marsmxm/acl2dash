<html>
<head>
<meta charset="UTF-8">
<title>Non-case-splitting-logic</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____NON-CASE-SPLITTING-LOGIC">Click for Non-case-splitting-logic in the Full Manual</a></h3>

<p>Boolean connectives that avoid case splits.</p><p>Perhaps the most common reason that ACL2 proofs take a long time is 
that they split into too many cases unnecessarily.  The alternative Boolean 
operators <span class="v">iff*</span>, <span class="v">and*</span>, <span class="v">or*</span>, <span class="v">xor*</span>, and <span class="v">if*</span> can help to 
avoid such case splits.</p> 
 
<p>A small and abstract example: Suppose foo is a function that has the following shape:</p> 
 
<pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (...)
  (<a href="COMMON-LISP____COND.html">cond</a> (&lt;exceptional-case1&gt; ...)
        (&lt;exceptional-case2&gt; ...)
        ...
        (&lt;exceptional-casen&gt; ...)
        (t ...))) ;; default case</pre> 
 
<p>And suppose that each of the N exceptional cases is a conjunction of M 
subterms.  How many cases will ACL2 typically split into in order to prove 
something about foo?</p> 
 
<p>The answer is on the order of <span class="v">M^N</span>.  You can get the exact number via the following recurrence:</p> 
 
<pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> number-of-cases (n m)
   (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> n)
       1
     (<a href="COMMON-LISP_____B2.html">+</a> 1 (<a href="COMMON-LISP_____A2.html">*</a> m (number-of-cases (<a href="COMMON-LISP____-.html">-</a> n 1) m)))))</pre> 
 
<p>This is because for each conjunction <span class="v">(<a href="COMMON-LISP____AND.html">and</a> a b c</span> that may cause an 
exceptional case, ACL2 considers the cases:</p> 
<pre class="code">(<a href="COMMON-LISP____NOT.html">not</a> a)
(<a href="COMMON-LISP____AND.html">and</a> a (<a href="COMMON-LISP____NOT.html">not</a> b))
(<a href="COMMON-LISP____AND.html">and</a> a b (<a href="COMMON-LISP____NOT.html">not</a> c))
(<a href="COMMON-LISP____AND.html">and</a> a b c)</pre> 
 
<p>In the first three cases, the conjunction is not true (this is where the 
<span class="v">* m</span> in the recurrence comes from), and in the last case it is true (this 
is where the <span class="v">+ 1</span> in the recurrence comes from).</p> 
 
<p>This is where the alternative operators come in.  If we replace the 
conjunctions above with <span class="v">and*</span> calls, then instead of splitting into 
<span class="v">M^N</span> cases, we split into <span class="v">N+1</span> cases!  This usually works because when 
we are in case K, we care that the conjuncts of <span class="v">&lt;exceptional-casek&gt;</span> were 
true, but usually not which of the conjuncts of <span class="v">&lt;exceptional-case0&gt;</span> 
through <span class="v">exceptional-casek-1</span> were untrue.</p> 
 

</body>
</html>
