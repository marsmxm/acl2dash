<html>
<head>
<meta charset="UTF-8">
<title>Print-cl-cache</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____PRINT-CL-CACHE">Click for Print-cl-cache in the Full Manual</a></h3>

<p>Information about the cache supporting <span class="v">apply$</span></p><pre class="code">General Form: 
(print-cl-cache) 
</pre> 
 
  <p>Logically this function always returns <span class="v">NIL</span> but it prints to the 
  comment window information about the cache that supports the application of 
  quoted <span class="v">LAMBDA</span> objects by <span class="tt"><a href="ACL2____APPLY_42.html">apply$</a></span>.  The name stands for Print 
  Compiled Lambda Cache.</p> 
 
  <p>In general there is a non-empty cache line for each <span class="v">LAMBDA</span> object 
  used in a <span class="v">defun</span> or seen by <span class="v">verify-guards</span> or by <span class="v">apply$</span> in the 
  evaluation theory.  But the cache has a maximal size.  If a new <span class="v">LAMBDA</span> 
  object is seen when the cache is full, the least recently used line is 
  re-used for the new <span class="v">LAMBDA</span> object.  By default the maximal cache size is 
  1000.  This can be changed -- with the side-effect of clearing the cache -- 
  by exiting the ACL2 loop with <span class="v">:q</span> and doing <span class="v">(setq *cl-cache* k)</span>, 
  where <span class="v">k</span> is the new maximal size.</p> 
 
  <p>When <span class="v">print-cl-cache</span> is called it prints a block about each non-empty 
  cache line enumerated from 0, and listed in the order that the cache is 
  searched when a <span class="v">LAMBDA</span> object is <span class="v">apply$</span>d.  Each block contains:</p> 
 
  <ul> 
  <li>
<span class="v">:lambda-object</span> - a fully translated <span class="v">LAMBDA</span> object</li> 
 
  <li>
<span class="v">:status</span> - one of four keywords with the following meanings: 
      <ul> 
 
      <li>
<span class="v">:GOOD</span> - the <span class="v">LAMBDA</span> object is well-formed and Common Lisp 
          compliant (``guard verified'') in the current world</li> 
 
      <li>
<span class="v">:BAD</span> - the <span class="v">LAMBDA</span> object is not well-formed or not Common 
          Lisp compliant (``guard verified'') in the current world, but 
          (with high probability) there is a world in which it is well-formed 
          and compliant</li> 
 
      <li>
<span class="v">:UGLY</span> - the <span class="v">LAMBDA</span> object is so ill-formed it can never be 
          <span class="v">:GOOD</span> in any world, e.g., <span class="v">(<a href="COMMON-LISP____LAMBDA.html">LAMBDA</a> (T) (<a href="COMMON-LISP____CONS.html">CONS</a> 3 . 4))</span>
</li> 
 
      <li>
<span class="v">:UNKNOWN</span> - we do not know the status of this object in the 
          current world and leave it to <span class="v">apply$</span> to determine the proper 
          status the next time this object is <span class="v">apply$</span>d.</li> 
 
      </ul> 
     </li> 
  <li>
<span class="v">:abs-event-no</span> - the absolute event number (in the current world) at 
      which the <span class="v">LAMBDA</span> object was proved to have status <span class="v">:GOOD</span>, or 
      <span class="v">NIL</span> if its status is not <span class="v">:GOOD</span>
</li> 
 
  <li>
<span class="v">:extracts</span> - some parts of the <span class="v">LAMBDA</span> object sufficient to 
      confirm well-formedness.  Well-formedness must be re-confirmed if the 
      world is retracted to before the object became <span class="v">:GOOD</span>
</li> 
 
  <li>
<span class="v">:problem</span> - One of the following values. 
      <ul> 
      <li>
<span class="v">NIL</span> - no problem; status is <span class="v">:GOOD</span>
</li> 
 
      <li>
<span class="v">NOT-WELL-FORMED</span> - the <span class="v">LAMBDA</span> is syntactically plausible but 
          not well-formed but could, perhaps, become well-formed in a suitable 
          extension of the current world, e.g., the body calls an undefined 
          function (but perhaps it can be defined), the body contains a 
          <span class="v">:program</span> mode function (but perhaps that could be upgraded to 
          <span class="v">:logic</span> mode), the body contains an unbadged or unwarranted 
          function symbol (but perhaps <span class="v">defbadge</span> or <span class="v">defwarrant</span> could 
          resolve the issue), etc.</li> 
 
      <li>
<span class="v">(GUARD-USES-NON-COMPLIANT-FNS . fns)</span> - <span class="v">fns</span> is a list of 
          function symbols used in the guard of the <span class="v">LAMBDA</span> object that 
          have not yet had their guards verified.</li> 
 
      <li>
<span class="v">(BODY-USES-NON-COMPLIANT-FNS . fns)</span> -  <span class="v">fns</span> is a list of 
          function symbols used in the body of the <span class="v">LAMBDA</span> object that 
          have not yet had their guards verified.</li> 
 
      <li>
<span class="v">(UNPROVED-GUARD-CLAUSES . cl-set)</span> - <span class="v">cl-set</span> is the list of 
          guard conjectures -- written as clauses -- that tau was unable to 
          prove.</li> 
 
      <li>
<span class="v">RE-VALIDATION-INTERRUPTED</span> - an interrupt aborted the updating of 
           this cache line</li> 
 
      </ul> 
     </li> 
  <li>
<span class="v">:hits</span> - The number of times <span class="v">apply$</span> has seen this <span class="v">LAMBDA</span> 
      object</li> 
 
  <li>
<span class="v">:guard-code</span> - <span class="v">NIL</span> or the string ``&lt;code&gt;'' indicating that 
      the guard has been compiled</li> 
 
  <li>
<span class="v">:lambda-code</span> - <span class="v">NIL</span> or the string ``&lt;code&gt;'' indicating that 
      the <span class="v">LAMBDA</span> object has been compiled</li> 
 
  </ul> 
 
  <h3>Using This Information to Speed Up LAMBDA Application</h3> 
 
  <p><i>Remember:</i> A lot of programmers spend enormous amounts of time and 
  effort optimizing code that runs adequately fast!  Do not make the mistake of 
  investing your time here unless you really have a critical ACL2 top-level 
  read-eval-print form that you <i>know</i> runs too slowly!</p> 
 
  <p>If you see a <span class="v">LAMBDA</span> object in the cache with <span class="v">:status</span> <span class="v">:BAD</span> then it 
  is being interpreted.  If you believe it can be converted to <span class="v">:GOOD</span> and thus 
  compiled, <i>and you believe you will <span class="v">apply$</span> it often enough in the future 
  to warrant trying to speed it up,</i> then here are some tips.</p> 
 
  <p>To be converted from <span class="v">:BAD</span> to <span class="v">:GOOD</span> a <span class="v">LAMBDA</span> has to be both 
  well-formed and guard verified.  The cache doesn't try to verify objects that 
  are not well-formed.  So first make sure your object is well-formed and then 
  once it is make sure it is guard verified.</p> 
 
  <p>If the <span class="v">:problem</span> is <span class="v">NOT-WELL-FORMED</span> the <span class="v">:lambda-object</span> 
  does not pass the <span class="tt"><a href="ACL2____WELL-FORMED-LAMBDA-OBJECTP.html">well-formed-lambda-objectp</a></span> test.  That predicate 
  gives no hint as to why, but if you call <span class="v">:</span><span class="tt"><a href="ACL2____TRANSLAM.html">translam</a></span> on the 
  <span class="v">:lambda-object</span> it might give you more information.  E.g.,</p> 
 
  <pre class="code">ACL2 !&gt;:translam (<a href="COMMON-LISP____LAMBDA.html">lambda</a> (x) (bar x))

ACL2 Error in TRANSLAM: The body of a LAMBDA object or lambda$ term
should be fully badged but BAR is used in (BAR X) and has no badge.</pre> 
 
  <p>Other typical problems are that a function which was formerly in 
  <span class="v">:logic</span> mode is now in <span class="v">:program</span> mode because of an undo, or the 
  <span class="v">LAMBDA</span> object is not <a href="ACL2____TAME.html">tame</a>, as in</p> 
 
  <pre class="code">ACL2 !&gt;:translam (<a href="COMMON-LISP____LAMBDA.html">lambda</a> (x) (<a href="ACL2____APPLY_42.html">apply$</a> (<a href="COMMON-LISP____CONS.html">cons</a> x 'nil) 'sq))

ACL2 Error in TRANSLAM:  The body of a LAMBDA object or lambda$ term
must be tame and (<a href="ACL2____APPLY_42.html">APPLY$</a> (<a href="COMMON-LISP____CONS.html">CONS</a> X 'NIL) 'SQ) is not.</pre> 
 
  <p>Here the <span class="v">LAMBDA</span> is unfixable because the arguments to <span class="v">apply$</span> are 
  in the wrong order.  Typing the object correctly may fix the problem.</p> 
 
  <p>In any case, you may need to extend the world to convert functions to 
  <span class="v">:logic</span> mode, obtain <a href="ACL2____WARRANT.html">warrant</a>s (or at least <a href="ACL2____BADGE.html">badge</a>s for 
  functions that return multiple results), or even use a different <span class="v">LAMBDA</span> 
  object.</p> 
 
  <p>When you think you've got a well-formed <span class="v">LAMBDA</span> object, you can get 
  the cache to update itself by applying the (new?) object in the (new?) 
  world,</p> 
 
  <pre class="code">ACL2 !&gt;(<a href="ACL2____APPLY_42.html">apply$</a> '(<a href="COMMON-LISP____LAMBDA.html">lambda</a> (x) (<a href="ACL2____APPLY_42.html">apply$</a> 'sq (<a href="COMMON-LISP____CONS.html">cons</a> x 'nil))) '(5))
25
ACL2 !&gt;(<a href="ACL2____PRINT-CL-CACHE.html">print-cl-cache</a>)</pre> 
 
  <p>and see if the status is <span class="v">:GOOD</span> and, if not, what the <span class="v">:problem</span> 
  is.</p> 
 
  <p>If the problem is one of <span class="v">GUARD-USES-NON-COMPLIANT-FNS</span>, 
  <span class="v">BODY-USES-NON-COMPLIANT-FNS</span>, or <span class="v">UNPROVED-GUARD-CLAUSES</span>, the 
  <span class="v">LAMBDA</span> object is well-formed but not guard verified.  Again, you may 
  need to further extend the world by calling <span class="tt"><a href="ACL2____VERIFY-GUARDS.html">verify-guards</a></span> on the 
  listed function symbols in first two problems or call <span class="v">verify-guard</span> on 
  the lambda object itself for an opportunity to supply <span class="v">:hints</span> to prove 
  the guard clauses listed in the third problem.</p> 
 
  <p>For example, suppose we define <span class="v">squ</span> with a guard of <span class="v">natp</span>,</p> 
 
  <pre class="code">(<a href="ACL2____DEFUN_42.html">defun$</a> squ (x)
   (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (satisfies natp) x))
   (<a href="COMMON-LISP_____A2.html">*</a> x x))</pre> 
 
  <p>And suppose we define <span class="v">nfixer</span> to always return a natural number but 
  in such a way as its type-prescription is weak.</p> 
 
  <pre class="code">(<a href="ACL2____DEFUN_42.html">defun$</a> nfixer (x)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> x (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CONS.html">cons</a> x x)))
      (<a href="ACL2____NFIX.html">nfix</a> x)
      nil))</pre> 
 
  <p>Furthermore, let's disable <span class="v">nfixer</span> so the prover has no way of 
  discovering the proper type.</p> 
 
  <pre class="code">(<a href="ACL2____IN-THEORY.html">in-theory</a> (<a href="ACL2____DISABLE.html">disable</a> nfixer))</pre> 
 
  <p>If we then</p> 
 
  <pre class="code">ACL2 !&gt;(<a href="ACL2____APPLY_42.html">apply$</a> '(<a href="COMMON-LISP____LAMBDA.html">lambda</a> (x) (squ (nfixer x))) '(5))
25</pre> 
 
  <p>and use <span class="v">print-cl-cache</span>, we see that the <span class="v">:problem</span> is that <span class="v">NFIXER</span> 
  is not guard verified.  So we</p> 
 
  <pre class="code">ACL2 !&gt;(<a href="ACL2____VERIFY-GUARDS.html">verify-guards</a> nfixer)</pre> 
 
  <p>and try the <span class="v">apply$</span> and the <span class="v">print-cl-cache</span> again.  This time the <span class="v">:problem</span> is 
  <span class="v">(UNPROVED-GUARD-CLAUSES ((<a href="ACL2____NATP.html">NATP</a> (NFIXER X))))</span>.  So tau couldn't prove that 
  <span class="v">NFIXER</span> returns a <span class="v">NATP</span>.  We can thus</p> 
 
 
  <pre class="code">ACL2 !&gt;(<a href="ACL2____VERIFY-GUARDS.html">verify-guards</a> (<a href="COMMON-LISP____LAMBDA.html">lambda</a> (x) (squ (nfixer x)))
           :hints (("Goal" :in-theory (<a href="ACL2____ENABLE.html">enable</a> nfixer))))</pre> 
 
  <p>The <span class="v">verify-guards</span> should succeed.  Successful calls of 
  <span class="v">verify-guards</span> on <span class="v">LAMBDA</span> objects updates the cache, so we don't have 
  to ``trick'' the cache into updating itself by <span class="v">apply$</span>ing the <span class="v">lambda</span> 
  again.  We can now just do <span class="v">(<a href="ACL2____PRINT-CL-CACHE.html">print-cl-cache</a>)</span> and see the <span class="v">:status</span> is 
  <span class="v">:GOOD</span>.</p> 
 
  <p>Whether all this work is worth is depends on how often you're going to execute 
  this <span class="v">LAMBDA</span> object!</p> 
 
  <h3>A Single Performance Comparison</h3> 
 
  <p>Suppose we have defined <span class="v">squ</span> and <span class="v">nfixer</span>, disabled <span class="v">nfixer</span>, 
  and verified the guards of <span class="v">nfixer</span> as above.  Additionally, define the 
  <a href="ACL2____SCION.html">scion</a> that maps a predicate over a list and checks that the predicate 
  holds for every element.</p> 
 
  <pre class="code">(<a href="ACL2____DEFUN_42.html">defun$</a> always$ (pred lst)
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ENDP.html">endp</a> lst)
           t
           (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____APPLY_42.html">apply$</a> pred (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CAR.html">car</a> lst)))
                (<a href="ACL2____ALWAYS_42.html">always$</a> pred (<a href="COMMON-LISP____CDR.html">cdr</a> lst)))))</pre> 
 
  <p>and define the function that builds a list of the first <span class="v">n+1</span> naturals 
  and use it to define the misleadingly named constant <span class="v">*million*</span> which 
  contains the first million and one naturals.</p> 
 
  <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> nats-ac (n ac)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> n)
      (<a href="COMMON-LISP____CONS.html">cons</a> 0 ac)
      (nats-ac (<a href="COMMON-LISP____-.html">-</a> n 1) (<a href="COMMON-LISP____CONS.html">cons</a> n ac))))

(<a href="ACL2____DEFCONST.html">defconst</a> *million* (nats-ac 1000000 nil))</pre> 
 
  <p>Now observe that <span class="v">(<a href="COMMON-LISP____LAMBDA.html">lambda</a> (x) (<a href="ACL2____NATP.html">natp</a> (squ (nfixer x))))</span> suffers the 
  same problem we witnessed above: tau cannot prove the guard clause because 
  <span class="v">nfixer</span> is disabled.  So we can do an experiment!  How long does it take 
  to run this <span class="v">:BAD</span> lambda object over the list <span class="v">*million*</span>?  And then, 
  how long does it take to do it again after verifying its guards and turning 
  its status to <span class="v">:GOOD</span>?</p> 
 
  <pre class="code">ACL2 !&gt;(<a href="ACL2____TIME_42.html">time$</a> (<a href="ACL2____ALWAYS_42.html">always$</a> '(<a href="COMMON-LISP____LAMBDA.html">lambda</a> (x) (<a href="ACL2____NATP.html">natp</a> (squ (nfixer x)))) *million*))
; (EV-REC *RETURN-LAST-ARG3* ...) took
; 4.35 seconds realtime, 4.35 seconds runtime
; (128,000,160 bytes allocated).
T

ACL2 !&gt;(<a href="ACL2____VERIFY-GUARDS.html">verify-guards</a> (<a href="COMMON-LISP____LAMBDA.html">lambda</a> (x) (<a href="ACL2____NATP.html">natp</a> (squ (nfixer x))))
         :hints (("Goal" :in-theory (<a href="ACL2____ENABLE.html">enable</a> nfixer))))

...[successful but output elided]...

ACL2 !&gt;(<a href="ACL2____TIME_42.html">time$</a> (<a href="ACL2____ALWAYS_42.html">always$</a> '(<a href="COMMON-LISP____LAMBDA.html">lambda</a> (x) (<a href="ACL2____NATP.html">natp</a> (squ (nfixer x)))) *million*))
; (EV-REC *RETURN-LAST-ARG3* ...) took
; 0.19 seconds realtime, 0.19 seconds runtime
; (32,000,064 bytes allocated).
T</pre> 
 
  <p>So we dramatically sped up the computation.  But we almost certainly spent 
  longer than the original 4.35 seconds debugging the problems and converting 
  the object's status to <span class="v">:GOOD</span>.  So unless we're going to be doing this 
  repeatedly in the future, it probably wasn't worth it!</p>
</body>
</html>
