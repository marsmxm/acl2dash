<html>
<head>
<meta charset="UTF-8">
<title>Subst-expression-fns</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=SYNTHETO____SUBST-EXPRESSION-FNS">Click for Subst-expression-fns in the Full Manual</a></h3>

<p>Mutually recursive functions for expression substitution.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>subst-expression</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 subst-expression (<a href="COMMON-LISP____SUBST.html">subst</a> expr)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SYNTHETO____VARIABLE-SUBSTITUTIONP.html">variable-substitutionp</a> subst)
                             (<a href="SYNTHETO____EXPRESSIONP.html">expressionp</a> expr))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((__function__ 'subst-expression))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
  (<a href="SYNTHETO____EXPRESSION-CASE.html">expression-case</a>
   expr
   :literal (<a href="SYNTHETO____EXPRESSION-LITERAL.html">expression-literal</a> expr.get)
   :variable
   (<a href="ACL2____B_A2.html">b*</a> ((pair (<a href="OMAP____IN.html">omap::in</a> expr.name
                        (<a href="SYNTHETO____VARIABLE-SUBSTITUTION-FIX.html">variable-substitution-fix</a> subst))))
       (<a href="COMMON-LISP____IF.html">if</a> pair (<a href="COMMON-LISP____CDR.html">cdr</a> pair)
           (<a href="SYNTHETO____EXPRESSION-VARIABLE.html">expression-variable</a> expr.name)))
   :unary (<a href="SYNTHETO____MAKE-EXPRESSION-UNARY.html">make-expression-unary</a>
               :operator expr.operator
               :operand (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst expr.operand))
   :binary
   (<a href="SYNTHETO____MAKE-EXPRESSION-BINARY.html">make-expression-binary</a>
        :operator expr.operator
        :left-operand (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst expr.left-operand)
        :right-operand (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst expr.right-operand))
   :if (<a href="SYNTHETO____MAKE-EXPRESSION-IF.html">make-expression-if</a> :test (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst expr.test)
                           :then (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst expr.then)
                           :else (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst expr.else))
   :when
   (<a href="SYNTHETO____MAKE-EXPRESSION-IF.html">make-expression-if</a> :test (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst expr.test)
                       :then (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst expr.then)
                       :else (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst expr.else))
   :unless
   (<a href="SYNTHETO____MAKE-EXPRESSION-IF.html">make-expression-if</a> :test (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst expr.test)
                       :then (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst expr.then)
                       :else (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst expr.else))
   :cond (<a href="SYNTHETO____MAKE-EXPRESSION-COND.html">make-expression-cond</a>
              :branches (<a href="SYNTHETO____SUBST-BRANCH-LIST.html">subst-branch-list</a> subst expr.branches))
   :call
   (<a href="SYNTHETO____MAKE-EXPRESSION-CALL.html">make-expression-call</a>
        :function expr.function
        :types expr.types
        :arguments (<a href="SYNTHETO____SUBST-EXPRESSION-LIST.html">subst-expression-list</a> subst expr.arguments))
   :multi
   (<a href="SYNTHETO____MAKE-EXPRESSION-MULTI.html">make-expression-multi</a>
        :arguments (<a href="SYNTHETO____SUBST-EXPRESSION-LIST.html">subst-expression-list</a> subst expr.arguments))
   :component (<a href="SYNTHETO____MAKE-EXPRESSION-COMPONENT.html">make-expression-component</a>
                   :multi (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst expr.multi)
                   :index expr.index)
   :bind
   (<a href="ACL2____B_A2.html">b*</a>
    ((new-value (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst expr.value))
     (new-subst
      (<a href="OMAP____DELETE_A2.html">omap::delete*</a>
         (<a href="SET____MERGESORT.html">mergesort</a> (<a href="SYNTHETO____TYPED-VARIABLE-LIST-_E3NAME-LIST.html">typed-variable-list-&gt;name-list</a> expr.variables))
         (<a href="SYNTHETO____VARIABLE-SUBSTITUTION-FIX.html">variable-substitution-fix</a> subst)))
     (new-body (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> new-subst expr.body)))
    (<a href="SYNTHETO____MAKE-EXPRESSION-BIND.html">make-expression-bind</a> :variables expr.variables
                          :value new-value
                          :body new-body))
   :product-construct
   (<a href="SYNTHETO____MAKE-EXPRESSION-PRODUCT-CONSTRUCT.html">make-expression-product-construct</a>
        :type expr.type
        :fields (<a href="SYNTHETO____SUBST-INITIALIZER-LIST.html">subst-initializer-list</a> subst expr.fields))
   :product-field (<a href="SYNTHETO____MAKE-EXPRESSION-PRODUCT-FIELD.html">make-expression-product-field</a>
                       :type expr.type
                       :target (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst expr.target)
                       :field expr.field)
   :product-update
   (<a href="SYNTHETO____MAKE-EXPRESSION-PRODUCT-UPDATE.html">make-expression-product-update</a>
        :type expr.type
        :target (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst expr.target)
        :fields (<a href="SYNTHETO____SUBST-INITIALIZER-LIST.html">subst-initializer-list</a> subst expr.fields))
   :sum-construct
   (<a href="SYNTHETO____MAKE-EXPRESSION-SUM-CONSTRUCT.html">make-expression-sum-construct</a>
        :type expr.type
        :alternative expr.alternative
        :fields (<a href="SYNTHETO____SUBST-INITIALIZER-LIST.html">subst-initializer-list</a> subst expr.fields))
   :sum-field (<a href="SYNTHETO____MAKE-EXPRESSION-SUM-FIELD.html">make-expression-sum-field</a>
                   :type expr.type
                   :target (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst expr.target)
                   :alternative expr.alternative
                   :field expr.field)
   :sum-update
   (<a href="SYNTHETO____MAKE-EXPRESSION-SUM-UPDATE.html">make-expression-sum-update</a>
        :type expr.type
        :target (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst expr.target)
        :alternative expr.alternative
        :fields (<a href="SYNTHETO____SUBST-INITIALIZER-LIST.html">subst-initializer-list</a> subst expr.fields))
   :sum-test (<a href="SYNTHETO____MAKE-EXPRESSION-SUM-TEST.html">make-expression-sum-test</a>
                  :type expr.type
                  :target (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst expr.target)
                  :alternative expr.alternative)
   :bad-expression
   (<a href="SYNTHETO____MAKE-EXPRESSION-BAD-EXPRESSION.html">make-expression-bad-expression</a> :info expr.info))))</pre> 
<p><b>Function: </b>subst-expression-list</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
  subst-expression-list (<a href="COMMON-LISP____SUBST.html">subst</a> exprs)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SYNTHETO____VARIABLE-SUBSTITUTIONP.html">variable-substitutionp</a> subst)
                              (<a href="SYNTHETO____EXPRESSION-LISTP.html">expression-listp</a> exprs))))
  (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'subst-expression-list))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
       (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____ENDP.html">endp</a> exprs) nil)
             (t (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst (<a href="COMMON-LISP____CAR.html">car</a> exprs))
                      (<a href="SYNTHETO____SUBST-EXPRESSION-LIST.html">subst-expression-list</a> subst (<a href="COMMON-LISP____CDR.html">cdr</a> exprs)))))))</pre> 
<p><b>Function: </b>subst-branch</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 subst-branch (<a href="COMMON-LISP____SUBST.html">subst</a> branch)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SYNTHETO____VARIABLE-SUBSTITUTIONP.html">variable-substitutionp</a> subst)
                             (<a href="SYNTHETO____BRANCHP.html">branchp</a> branch))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((__function__ 'subst-branch))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
  (<a href="SYNTHETO____MAKE-BRANCH.html">make-branch</a>
      :condition (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst (<a href="SYNTHETO____BRANCH-_E3CONDITION.html">branch-&gt;condition</a> branch))
      :action (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst (<a href="SYNTHETO____BRANCH-_E3ACTION.html">branch-&gt;action</a> branch)))))</pre> 
<p><b>Function: </b>subst-branch-list</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
   subst-branch-list (<a href="COMMON-LISP____SUBST.html">subst</a> branches)
   (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SYNTHETO____VARIABLE-SUBSTITUTIONP.html">variable-substitutionp</a> subst)
                               (<a href="SYNTHETO____BRANCH-LISTP.html">branch-listp</a> branches))))
   (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'subst-branch-list))
        (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
        (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____ENDP.html">endp</a> branches) nil)
              (t (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="SYNTHETO____SUBST-BRANCH.html">subst-branch</a> subst (<a href="COMMON-LISP____CAR.html">car</a> branches))
                       (<a href="SYNTHETO____SUBST-BRANCH-LIST.html">subst-branch-list</a> subst (<a href="COMMON-LISP____CDR.html">cdr</a> branches)))))))</pre> 
<p><b>Function: </b>subst-initializer</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 subst-initializer (<a href="COMMON-LISP____SUBST.html">subst</a> init)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SYNTHETO____VARIABLE-SUBSTITUTIONP.html">variable-substitutionp</a> subst)
                             (<a href="SYNTHETO____INITIALIZERP.html">initializerp</a> init))))
 (<a href="COMMON-LISP____LET.html">let</a>
   ((__function__ 'subst-initializer))
   (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
   (<a href="SYNTHETO____MAKE-INITIALIZER.html">make-initializer</a>
        :field (<a href="SYNTHETO____INITIALIZER-_E3FIELD.html">initializer-&gt;field</a> init)
        :value (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst (<a href="SYNTHETO____INITIALIZER-_E3VALUE.html">initializer-&gt;value</a> init)))))</pre> 
<p><b>Function: </b>subst-initializer-list</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 subst-initializer-list (<a href="COMMON-LISP____SUBST.html">subst</a> inits)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SYNTHETO____VARIABLE-SUBSTITUTIONP.html">variable-substitutionp</a> subst)
                             (<a href="SYNTHETO____INITIALIZER-LISTP.html">initializer-listp</a> inits))))
 (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'subst-initializer-list))
      (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
      (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____ENDP.html">endp</a> inits) nil)
            (t (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="SYNTHETO____SUBST-INITIALIZER.html">subst-initializer</a> subst (<a href="COMMON-LISP____CAR.html">car</a> inits))
                     (<a href="SYNTHETO____SUBST-INITIALIZER-LIST.html">subst-initializer-list</a> subst (<a href="COMMON-LISP____CDR.html">cdr</a> inits)))))))</pre> 
 
 
<p><b>Theorem: </b>return-type-of-subst-expression.new-expr</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> return-type-of-subst-expression.new-expr
        (<a href="ACL2____B_A2.html">b*</a> ((?new-expr (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst expr)))
            (<a href="SYNTHETO____EXPRESSIONP.html">expressionp</a> new-expr))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>return-type-of-subst-expression-list.new-exprs</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> return-type-of-subst-expression-list.new-exprs
        (<a href="ACL2____B_A2.html">b*</a> ((?new-exprs (<a href="SYNTHETO____SUBST-EXPRESSION-LIST.html">subst-expression-list</a> subst exprs)))
            (<a href="SYNTHETO____EXPRESSION-LISTP.html">expression-listp</a> new-exprs))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>return-type-of-subst-branch.new-branch</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> return-type-of-subst-branch.new-branch
        (<a href="ACL2____B_A2.html">b*</a> ((?new-branch (<a href="SYNTHETO____SUBST-BRANCH.html">subst-branch</a> subst branch)))
            (<a href="SYNTHETO____BRANCHP.html">branchp</a> new-branch))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>return-type-of-subst-branch-list.new-branches</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> return-type-of-subst-branch-list.new-branches
        (<a href="ACL2____B_A2.html">b*</a> ((?new-branches (<a href="SYNTHETO____SUBST-BRANCH-LIST.html">subst-branch-list</a> subst branches)))
            (<a href="SYNTHETO____BRANCH-LISTP.html">branch-listp</a> new-branches))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>return-type-of-subst-initializer.new-init</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> return-type-of-subst-initializer.new-init
        (<a href="ACL2____B_A2.html">b*</a> ((?new-init (<a href="SYNTHETO____SUBST-INITIALIZER.html">subst-initializer</a> subst init)))
            (<a href="SYNTHETO____INITIALIZERP.html">initializerp</a> new-init))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>return-type-of-subst-initializer-list.new-inits</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> return-type-of-subst-initializer-list.new-inits
        (<a href="ACL2____B_A2.html">b*</a> ((?new-inits (<a href="SYNTHETO____SUBST-INITIALIZER-LIST.html">subst-initializer-list</a> subst inits)))
            (<a href="SYNTHETO____INITIALIZER-LISTP.html">initializer-listp</a> new-inits))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>subst-expression-of-variable-substitution-fix-subst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> subst-expression-of-variable-substitution-fix-subst
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> (<a href="SYNTHETO____VARIABLE-SUBSTITUTION-FIX.html">variable-substitution-fix</a> subst)
                                 expr)
               (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst expr)))</pre> 
<p><b>Theorem: </b>subst-expression-of-expression-fix-expr</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> subst-expression-of-expression-fix-expr
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst (<a href="SYNTHETO____EXPRESSION-FIX.html">expression-fix</a> expr))
               (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst expr)))</pre> 
<p><b>Theorem: </b>subst-expression-list-of-variable-substitution-fix-subst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     subst-expression-list-of-variable-substitution-fix-subst
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBST-EXPRESSION-LIST.html">subst-expression-list</a> (<a href="SYNTHETO____VARIABLE-SUBSTITUTION-FIX.html">variable-substitution-fix</a> subst)
                                   exprs)
            (<a href="SYNTHETO____SUBST-EXPRESSION-LIST.html">subst-expression-list</a> subst exprs)))</pre> 
<p><b>Theorem: </b>subst-expression-list-of-expression-list-fix-exprs</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    subst-expression-list-of-expression-list-fix-exprs
    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBST-EXPRESSION-LIST.html">subst-expression-list</a> subst (<a href="SYNTHETO____EXPRESSION-LIST-FIX.html">expression-list-fix</a> exprs))
           (<a href="SYNTHETO____SUBST-EXPRESSION-LIST.html">subst-expression-list</a> subst exprs)))</pre> 
<p><b>Theorem: </b>subst-branch-of-variable-substitution-fix-subst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> subst-branch-of-variable-substitution-fix-subst
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBST-BRANCH.html">subst-branch</a> (<a href="SYNTHETO____VARIABLE-SUBSTITUTION-FIX.html">variable-substitution-fix</a> subst)
                             branch)
               (<a href="SYNTHETO____SUBST-BRANCH.html">subst-branch</a> subst branch)))</pre> 
<p><b>Theorem: </b>subst-branch-of-branch-fix-branch</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> subst-branch-of-branch-fix-branch
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBST-BRANCH.html">subst-branch</a> subst (<a href="SYNTHETO____BRANCH-FIX.html">branch-fix</a> branch))
               (<a href="SYNTHETO____SUBST-BRANCH.html">subst-branch</a> subst branch)))</pre> 
<p><b>Theorem: </b>subst-branch-list-of-variable-substitution-fix-subst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> subst-branch-list-of-variable-substitution-fix-subst
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBST-BRANCH-LIST.html">subst-branch-list</a> (<a href="SYNTHETO____VARIABLE-SUBSTITUTION-FIX.html">variable-substitution-fix</a> subst)
                                  branches)
               (<a href="SYNTHETO____SUBST-BRANCH-LIST.html">subst-branch-list</a> subst branches)))</pre> 
<p><b>Theorem: </b>subst-branch-list-of-branch-list-fix-branches</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> subst-branch-list-of-branch-list-fix-branches
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBST-BRANCH-LIST.html">subst-branch-list</a> subst (<a href="SYNTHETO____BRANCH-LIST-FIX.html">branch-list-fix</a> branches))
               (<a href="SYNTHETO____SUBST-BRANCH-LIST.html">subst-branch-list</a> subst branches)))</pre> 
<p><b>Theorem: </b>subst-initializer-of-variable-substitution-fix-subst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> subst-initializer-of-variable-substitution-fix-subst
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBST-INITIALIZER.html">subst-initializer</a> (<a href="SYNTHETO____VARIABLE-SUBSTITUTION-FIX.html">variable-substitution-fix</a> subst)
                                  init)
               (<a href="SYNTHETO____SUBST-INITIALIZER.html">subst-initializer</a> subst init)))</pre> 
<p><b>Theorem: </b>subst-initializer-of-initializer-fix-init</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> subst-initializer-of-initializer-fix-init
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBST-INITIALIZER.html">subst-initializer</a> subst (<a href="SYNTHETO____INITIALIZER-FIX.html">initializer-fix</a> init))
               (<a href="SYNTHETO____SUBST-INITIALIZER.html">subst-initializer</a> subst init)))</pre> 
<p><b>Theorem: </b>subst-initializer-list-of-variable-substitution-fix-subst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    subst-initializer-list-of-variable-substitution-fix-subst
    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBST-INITIALIZER-LIST.html">subst-initializer-list</a> (<a href="SYNTHETO____VARIABLE-SUBSTITUTION-FIX.html">variable-substitution-fix</a> subst)
                                   inits)
           (<a href="SYNTHETO____SUBST-INITIALIZER-LIST.html">subst-initializer-list</a> subst inits)))</pre> 
<p><b>Theorem: </b>subst-initializer-list-of-initializer-list-fix-inits</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  subst-initializer-list-of-initializer-list-fix-inits
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBST-INITIALIZER-LIST.html">subst-initializer-list</a> subst (<a href="SYNTHETO____INITIALIZER-LIST-FIX.html">initializer-list-fix</a> inits))
         (<a href="SYNTHETO____SUBST-INITIALIZER-LIST.html">subst-initializer-list</a> subst inits)))</pre> 
<p><b>Theorem: </b>subst-expression-variable-substitution-equiv-congruence-on-subst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    subst-expression-variable-substitution-equiv-congruence-on-subst
    (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SYNTHETO____VARIABLE-SUBSTITUTION-EQUIV.html">variable-substitution-equiv</a> subst subst-equiv)
             (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst expr)
                    (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst-equiv expr)))
    :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>subst-expression-expression-equiv-congruence-on-expr</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> subst-expression-expression-equiv-congruence-on-expr
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SYNTHETO____EXPRESSION-EQUIV.html">expression-equiv</a> expr expr-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst expr)
                        (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst expr-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>subst-expression-list-variable-substitution-equiv-congruence-on-subst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 subst-expression-list-variable-substitution-equiv-congruence-on-subst
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SYNTHETO____VARIABLE-SUBSTITUTION-EQUIV.html">variable-substitution-equiv</a> subst subst-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBST-EXPRESSION-LIST.html">subst-expression-list</a> subst exprs)
                 (<a href="SYNTHETO____SUBST-EXPRESSION-LIST.html">subst-expression-list</a> subst-equiv exprs)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>subst-expression-list-expression-list-equiv-congruence-on-exprs</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     subst-expression-list-expression-list-equiv-congruence-on-exprs
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SYNTHETO____EXPRESSION-LIST-EQUIV.html">expression-list-equiv</a> exprs exprs-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBST-EXPRESSION-LIST.html">subst-expression-list</a> subst exprs)
                     (<a href="SYNTHETO____SUBST-EXPRESSION-LIST.html">subst-expression-list</a> subst exprs-equiv)))
     :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>subst-branch-variable-substitution-equiv-congruence-on-subst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> subst-branch-variable-substitution-equiv-congruence-on-subst
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SYNTHETO____VARIABLE-SUBSTITUTION-EQUIV.html">variable-substitution-equiv</a> subst subst-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBST-BRANCH.html">subst-branch</a> subst branch)
                        (<a href="SYNTHETO____SUBST-BRANCH.html">subst-branch</a> subst-equiv branch)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>subst-branch-branch-equiv-congruence-on-branch</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> subst-branch-branch-equiv-congruence-on-branch
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SYNTHETO____BRANCH-EQUIV.html">branch-equiv</a> branch branch-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBST-BRANCH.html">subst-branch</a> subst branch)
                        (<a href="SYNTHETO____SUBST-BRANCH.html">subst-branch</a> subst branch-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>subst-branch-list-variable-substitution-equiv-congruence-on-subst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   subst-branch-list-variable-substitution-equiv-congruence-on-subst
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SYNTHETO____VARIABLE-SUBSTITUTION-EQUIV.html">variable-substitution-equiv</a> subst subst-equiv)
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBST-BRANCH-LIST.html">subst-branch-list</a> subst branches)
                   (<a href="SYNTHETO____SUBST-BRANCH-LIST.html">subst-branch-list</a> subst-equiv branches)))
   :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>subst-branch-list-branch-list-equiv-congruence-on-branches</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> subst-branch-list-branch-list-equiv-congruence-on-branches
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SYNTHETO____BRANCH-LIST-EQUIV.html">branch-list-equiv</a> branches branches-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBST-BRANCH-LIST.html">subst-branch-list</a> subst branches)
                        (<a href="SYNTHETO____SUBST-BRANCH-LIST.html">subst-branch-list</a> subst branches-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>subst-initializer-variable-substitution-equiv-congruence-on-subst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   subst-initializer-variable-substitution-equiv-congruence-on-subst
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SYNTHETO____VARIABLE-SUBSTITUTION-EQUIV.html">variable-substitution-equiv</a> subst subst-equiv)
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBST-INITIALIZER.html">subst-initializer</a> subst init)
                   (<a href="SYNTHETO____SUBST-INITIALIZER.html">subst-initializer</a> subst-equiv init)))
   :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>subst-initializer-initializer-equiv-congruence-on-init</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> subst-initializer-initializer-equiv-congruence-on-init
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SYNTHETO____INITIALIZER-EQUIV.html">initializer-equiv</a> init init-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBST-INITIALIZER.html">subst-initializer</a> subst init)
                        (<a href="SYNTHETO____SUBST-INITIALIZER.html">subst-initializer</a> subst init-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>subst-initializer-list-variable-substitution-equiv-congruence-on-subst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 subst-initializer-list-variable-substitution-equiv-congruence-on-subst
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SYNTHETO____VARIABLE-SUBSTITUTION-EQUIV.html">variable-substitution-equiv</a> subst subst-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBST-INITIALIZER-LIST.html">subst-initializer-list</a> subst inits)
                 (<a href="SYNTHETO____SUBST-INITIALIZER-LIST.html">subst-initializer-list</a> subst-equiv inits)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>subst-initializer-list-initializer-list-equiv-congruence-on-inits</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   subst-initializer-list-initializer-list-equiv-congruence-on-inits
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SYNTHETO____INITIALIZER-LIST-EQUIV.html">initializer-list-equiv</a> inits inits-equiv)
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____SUBST-INITIALIZER-LIST.html">subst-initializer-list</a> subst inits)
                   (<a href="SYNTHETO____SUBST-INITIALIZER-LIST.html">subst-initializer-list</a> subst inits-equiv)))
   :rule-classes :congruence)</pre> 

</body>
</html>
