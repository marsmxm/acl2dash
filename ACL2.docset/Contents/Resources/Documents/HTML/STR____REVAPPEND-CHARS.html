<html>
<head>
<meta charset="UTF-8">
<title>Revappend-chars</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=STR____REVAPPEND-CHARS">Click for Revappend-chars in the Full Manual</a></h3>

<p>Append a string's characters onto a list, in reverse order.</p><p><span class="tt">(revappend-chars x y)</span> takes the characters from the string 
<span class="v">x</span>, reverses them, and appends the result onto <span class="v">y</span>.</p> 
 
<p>Its logical definition is nothing more than <span class="v">(<a href="COMMON-LISP____REVAPPEND.html">revappend</a> (<a href="ACL2____EXPLODE.html">explode</a> x) y)</span>.</p> 
 
<p>In the execution, we traverse the string <span class="v">x</span> using <a href="COMMON-LISP____CHAR.html">char</a> to avoid 
the overhead of <a href="COMMON-LISP____COERCE.html">coerce</a>-ing it into a character list before performing 
the <a href="COMMON-LISP____REVAPPEND.html">revappend</a>.  This reduces the overhead from <span class="v">2n</span> conses to <span class="v">n</span> 
conses, where <span class="v">n</span> is the length of <span class="v">x</span>.</p> 
 
<p>This function may seem strange at first glance, but it provides a convenient 
way to efficiently, incrementally build a string out of small parts.  For 
instance, a sequence such as:</p> 
 
<pre class="code">(<a href="COMMON-LISP____LET_A2.html">let*</a> ((acc nil)
       (acc (<a href="STR____REVAPPEND-CHARS.html">str::revappend-chars</a> "Hello, " acc))
       (acc (<a href="STR____REVAPPEND-CHARS.html">str::revappend-chars</a> "World!" acc))
       (acc ...))
   (<a href="COMMON-LISP____REVERSE.html">reverse</a> (<a href="ACL2____IMPLODE.html">implode</a> acc)))</pre> 
 
<p>Is essentially the same as:</p> 
 
<pre class="code">(<a href="COMMON-LISP____LET_A2.html">let*</a> ((acc "")
       (acc (<a href="STR____CAT.html">str::cat</a> acc "Hello, "))
       (acc (<a href="STR____CAT.html">str::cat</a> acc "World!"))
       (acc ...))
  acc)</pre> 
 
<p>But it is comparably much more efficient because it avoids the creation of 
the intermediate strings.  See the performance discussion in <a href="STR____CAT.html">cat</a> 
for more details.  Also see <a href="STR____RCHARS-TO-STRING.html">rchars-to-string</a>, which is a potentially 
more efficient way to do the final <a href="COMMON-LISP____REVERSE.html">reverse</a>/<a href="COMMON-LISP____COERCE.html">coerce</a> steps.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>revappend-chars-aux</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
  revappend-chars-aux (x n xl y)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> string x)
           (<a href="COMMON-LISP____TYPE.html">type</a> (integer 0 *) n xl)
           (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> n xl) (<a href="COMMON-LISP____EQUAL.html">equal</a> xl (<a href="COMMON-LISP____LENGTH.html">length</a> x)))))
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____ZP.html">zp</a> (<a href="COMMON-LISP____-.html">-</a> (<a href="ACL2____NFIX.html">nfix</a> xl) (<a href="ACL2____NFIX.html">nfix</a> n)))
           :exec (<a href="COMMON-LISP____EQL.html">eql</a> n xl))
      y
      (revappend-chars-aux x
                           (<a href="COMMON-LISP____THE.html">the</a> (integer 0 *)
                                (<a href="COMMON-LISP_____B2.html">+</a> 1 (<a href="COMMON-LISP____THE.html">the</a> (integer 0 *) (<a href="ACL2____LNFIX.html">lnfix</a> n))))
                           xl (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CHAR.html">char</a> x n) y))))</pre> 
<p><b>Theorem: </b>revappend-chars-aux-correct</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> revappend-chars-aux-correct
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____STRINGP.html">stringp</a> x)
                      (<a href="ACL2____NATP.html">natp</a> n)
                      (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> n xl)
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> xl (<a href="COMMON-LISP____LENGTH.html">length</a> x)))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (revappend-chars-aux x n xl y)
                        (<a href="COMMON-LISP____REVAPPEND.html">revappend</a> (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> n (<a href="COMMON-LISP____COERCE.html">coerce</a> x 'list))
                                   y))))</pre> 
<p><b>Function: </b>revappend-chars$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> revappend-chars$inline (x y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> string x))
       (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="COMMON-LISP____REVAPPEND.html">revappend</a> (<a href="COMMON-LISP____COERCE.html">coerce</a> x 'list) y)
            :exec (revappend-chars-aux x 0 (<a href="COMMON-LISP____LENGTH.html">length</a> x) y)))</pre> 
<p><b>Theorem: </b>character-listp-of-revappend-chars</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> character-listp-of-revappend-chars
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____CHARACTER-LISTP.html">character-listp</a> (<a href="STR____REVAPPEND-CHARS.html">revappend-chars</a> x y))
               (<a href="ACL2____CHARACTER-LISTP.html">character-listp</a> y)))</pre> 
 
 
<p><b>Theorem: </b>streqv-implies-equal-revappend-chars-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> streqv-implies-equal-revappend-chars-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____STREQV.html">streqv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="STR____REVAPPEND-CHARS.html">revappend-chars</a> x y)
                        (<a href="STR____REVAPPEND-CHARS.html">revappend-chars</a> x-equiv y)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>istreqv-implies-icharlisteqv-revappend-chars-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> istreqv-implies-icharlisteqv-revappend-chars-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="STR____ISTREQV.html">istreqv</a> x x-equiv)
                 (<a href="STR____ICHARLISTEQV.html">icharlisteqv</a> (<a href="STR____REVAPPEND-CHARS.html">revappend-chars</a> x y)
                               (<a href="STR____REVAPPEND-CHARS.html">revappend-chars</a> x-equiv y)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>list-equiv-implies-list-equiv-revappend-chars-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> list-equiv-implies-list-equiv-revappend-chars-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____LIST-EQUIV.html">list-equiv</a> y y-equiv)
                 (<a href="ACL2____LIST-EQUIV.html">list-equiv</a> (<a href="STR____REVAPPEND-CHARS.html">revappend-chars</a> x y)
                             (<a href="STR____REVAPPEND-CHARS.html">revappend-chars</a> x y-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>charlisteqv-implies-charlisteqv-revappend-chars-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> charlisteqv-implies-charlisteqv-revappend-chars-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="STR____CHARLISTEQV.html">charlisteqv</a> y y-equiv)
                 (<a href="STR____CHARLISTEQV.html">charlisteqv</a> (<a href="STR____REVAPPEND-CHARS.html">revappend-chars</a> x y)
                              (<a href="STR____REVAPPEND-CHARS.html">revappend-chars</a> x y-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>icharlisteqv-implies-icharlisteqv-revappend-chars-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> icharlisteqv-implies-icharlisteqv-revappend-chars-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="STR____ICHARLISTEQV.html">icharlisteqv</a> y y-equiv)
                 (<a href="STR____ICHARLISTEQV.html">icharlisteqv</a> (<a href="STR____REVAPPEND-CHARS.html">revappend-chars</a> x y)
                               (<a href="STR____REVAPPEND-CHARS.html">revappend-chars</a> x y-equiv)))
        :rule-classes (:congruence))</pre> 

</body>
</html>
