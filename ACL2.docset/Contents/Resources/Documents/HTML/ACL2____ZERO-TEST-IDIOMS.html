<html>
<head>
<meta charset="UTF-8">
<title>Zero-test-idioms</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____ZERO-TEST-IDIOMS">Click for Zero-test-idioms in the Full Manual</a></h3>

<p>How to test for 0</p><p>Below are six commonly used idioms for testing whether <span class="v">x</span> is 
 <span class="v">0</span>.  <span class="tt"><a href="ACL2____ZIP.html">Zip</a></span> and <span class="tt"><a href="ACL2____ZP.html">zp</a></span> are the preferred termination tests for 
 recursions down the integers and naturals, respectively.</p> 
 
 <pre class="code">idiom       logical              guard                 primary
            meaning                                 compiled code*

(<a href="COMMON-LISP____EQUAL.html">equal</a> x 0) (<a href="COMMON-LISP____EQUAL.html">equal</a> x 0)          t                   (<a href="COMMON-LISP____EQUAL.html">equal</a> x 0)

(<a href="COMMON-LISP____EQL.html">eql</a> x 0)   (<a href="COMMON-LISP____EQUAL.html">equal</a> x 0)          t                   (<a href="COMMON-LISP____EQL.html">eql</a> x 0)

(<a href="COMMON-LISP____ZEROP.html">zerop</a> x)   (<a href="COMMON-LISP____EQUAL.html">equal</a> x 0)          x is a number       (<a href="COMMON-LISP_____D3.html">=</a> x 0)

(<a href="COMMON-LISP_____D3.html">=</a> x 0)     (<a href="COMMON-LISP____EQUAL.html">equal</a> x 0)          x is a number       (<a href="COMMON-LISP_____D3.html">=</a> x 0)

(<a href="ACL2____ZIP.html">zip</a> x)     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____IFIX.html">ifix</a> x) 0)   x is an integer     (<a href="COMMON-LISP_____D3.html">=</a> x 0)

(<a href="ACL2____ZP.html">zp</a> x)      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____NFIX.html">nfix</a> x) 0)   x is a natural      (<a href="ACL2____INT_D3.html">int=</a> x 0)

(<a href="ACL2____ZPF.html">zpf</a> x)     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____NFIX.html">nfix</a> x) 0)   x is a fixnum &gt;= 0  (<a href="COMMON-LISP____EQL.html">eql</a> (the-fixnum x) 0)</pre> 
 
 <p>*See <a href="ACL2____GUARDS-AND-EVALUATION.html">guards-and-evaluation</a>, especially the subsection titled 
 ``Guards and evaluation V: efficiency issues''.  Primary code is relevant only 
 if <a href="ACL2____GUARD.html">guard</a>s are verified.  The ``compiled code'' shown is only 
 suggestive.</p> 
 
 <p>The first four idioms all have the same logical meaning and differ only 
 with respect to their executability and efficiency.  In the absence of 
 compiler optimizing, <span class="v">(<a href="COMMON-LISP_____D3.html">=</a> x 0)</span> is probably the most efficient, <span class="v">(<a href="COMMON-LISP____EQUAL.html">equal</a> x
 0)</span> is probably the least efficient, and <span class="v">(<a href="COMMON-LISP____EQL.html">eql</a> x 0)</span> is in between. 
 However, an optimizing compiler could always choose to compile <span class="v">(<a href="COMMON-LISP____EQUAL.html">equal</a> x
 0)</span> as <span class="v">(<a href="COMMON-LISP____EQL.html">eql</a> x 0)</span> and, in situations where <span class="v">x</span> is known at 
 compile-time to be numeric, <span class="v">(<a href="COMMON-LISP____EQL.html">eql</a> x 0)</span> as <span class="v">(<a href="COMMON-LISP_____D3.html">=</a> x 0)</span>.  So efficiency 
 considerations must, of course, be made in the context of the host 
 compiler.</p> 
 
 <p>Note also that <span class="v">(<a href="COMMON-LISP____ZEROP.html">zerop</a> x)</span> and <span class="v">(<a href="COMMON-LISP_____D3.html">=</a> x 0)</span> are indistinguishable.  They 
 have the same meaning and the same <a href="ACL2____GUARD.html">guard</a>, and can reasonably be 
 expected to generate equally efficient code.</p> 
 
 <p>Note that <span class="v">(<a href="ACL2____ZIP.html">zip</a> x)</span> and <span class="v">(<a href="ACL2____ZP.html">zp</a> x)</span> do not have the same logical 
 meanings as the others or each other.  They are not simple tests for equality 
 to <span class="v">0</span>.  They each coerce <span class="v">x</span> into a restricted domain, <span class="tt"><a href="ACL2____ZIP.html">zip</a></span> to 
 the integers and <span class="tt"><a href="ACL2____ZP.html">zp</a></span> to the natural numbers, choosing <span class="v">0</span> for <span class="v">x</span> 
 when <span class="v">x</span> is outside the domain.  Thus, <span class="v">1/2</span>, <span class="v">#c(1 3)</span>, and 
 <span class="v">'abc</span>, for example, are all ``recognized'' as zero by both <span class="tt"><a href="ACL2____ZIP.html">zip</a></span> and 
 <span class="tt"><a href="ACL2____ZP.html">zp</a></span>.  But <span class="tt"><a href="ACL2____ZIP.html">zip</a></span> reports that <span class="v">-1</span> is different from <span class="v">0</span> 
 while <span class="tt"><a href="ACL2____ZP.html">zp</a></span> reports that <span class="v">-1</span> ``is'' <span class="v">0</span>.  More precisely, <span class="v">(<a href="ACL2____ZIP.html">zip</a>
 -1)</span> is <span class="v">nil</span> while <span class="v">(<a href="ACL2____ZP.html">zp</a> -1)</span> is <span class="v">t</span>.</p> 
 
 <p>Note that the last five idioms all have <a href="ACL2____GUARD.html">guard</a>s that restrict their 
 Common Lisp executability.  If these last five are used in situations in which 
 <a href="ACL2____GUARD.html">guard</a>s are to be verified, then proof obligations are incurred as the 
 price of using them.  If guard verification is not involved in your project, 
 then the first five can be thought of as synonymous.</p> 
 
 <p><span class="tt"><a href="ACL2____ZIP.html">Zip</a></span> and <span class="tt"><a href="ACL2____ZP.html">zp</a></span> are not provided by Common Lisp but are 
 ACL2-specific functions.  Why does ACL2 provide these functions?  The answer 
 has to do with the admission of recursively defined functions and efficiency. 
 <span class="tt"><a href="ACL2____ZP.html">Zp</a></span> is provided as the zero-test in situations where the controlling 
 formal parameter is understood to be a natural number.  <span class="tt"><a href="ACL2____ZIP.html">Zip</a></span> is 
 analogously provided for the integer case.  We illustrate below.</p> 
 
 <p>Here is an admissible definition of factorial</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> fact (n) (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> n) 1 (<a href="COMMON-LISP_____A2.html">*</a> n (fact (<a href="COMMON-LISP____1-.html">1-</a> n)))))</pre> 
 
 <p>Observe the classic recursion scheme: a test against <span class="v">0</span> and recursion 
 by <span class="tt"><a href="COMMON-LISP____1-.html">1-</a></span>.  Note however that the test against <span class="v">0</span> is expressed with 
 the <span class="tt"><a href="ACL2____ZP.html">zp</a></span> idiom.  Note also the absence of a <a href="ACL2____GUARD.html">guard</a> making explicit 
 our intention that <span class="v">n</span> is a natural number.</p> 
 
 <p>This definition of factorial is readily admitted because when <span class="v">(<a href="ACL2____ZP.html">zp</a>
 n)</span></p> 
 
 <p>is false (i.e., <span class="v">nil</span>) then <span class="v">n</span> is a natural number other than <span class="v">0</span> 
 and so <span class="v">(<a href="COMMON-LISP____1-.html">1-</a> n)</span> is less than <span class="v">n</span>.  The base case, where <span class="v">(<a href="ACL2____ZP.html">zp</a> n)</span> is 
 true, handles all the ``unexpected'' inputs, such as arise with <span class="v">(fact -1)</span> 
 and <span class="v">(fact 'abc)</span>.  When calls of <span class="v">fact</span> are evaluated, <span class="v">(<a href="ACL2____ZP.html">zp</a> n)</span> 
 checks <span class="v">(<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)</span> and <span class="v">(<a href="COMMON-LISP_____E3.html">&gt;</a> n 0)</span>.  <a href="ACL2____GUARD.html">Guard</a> verification is 
 unsuccessful for this definition of <span class="v">fact</span> because <span class="tt"><a href="ACL2____ZP.html">zp</a></span> requires its 
 argument to be a natural number and there is no <a href="ACL2____GUARD.html">guard</a> on <span class="v">fact</span>, 
 above.  Thus the primary raw lisp for <span class="v">fact</span> is inaccessible and only the 
 <span class="v">:</span><span class="tt"><a href="ACL2____LOGIC.html">logic</a></span> definition (which does runtime ``type'' checking) is used 
 in computation.  In summary, this definition of factorial is easily admitted 
 and easily manipulated by the prover but is not executed as efficiently as it 
 could be.</p> 
 
 <p>Runtime efficiency can be improved by adding a <a href="ACL2____GUARD.html">guard</a> to the 
 definition.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> fact (n)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n) (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> n 0))))
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> n) 1 (<a href="COMMON-LISP_____A2.html">*</a> n (fact (<a href="COMMON-LISP____1-.html">1-</a> n)))))</pre> 
 
 <p>This <a href="ACL2____GUARD.html">guard</a>ed definition has the same termination conditions as 
 before  termination is not sensitive to the <a href="ACL2____GUARD.html">guard</a>.  But the 
 <a href="ACL2____GUARD.html">guard</a>s can be verified.  This makes the primary raw lisp definition 
 accessible during execution.  In that definition, the <span class="v">(<a href="ACL2____ZP.html">zp</a> n)</span> above is 
 compiled as <span class="v">(<a href="COMMON-LISP_____D3.html">=</a> n 0)</span>, because <span class="v">n</span> will always be a natural number when 
 the primary code is executed.  Thus, by adding a <a href="ACL2____GUARD.html">guard</a> and verifying 
 it, the elegant and easily used definition of factorial is also efficiently 
 executed on natural numbers.</p> 
 
 <p>Now let us consider an alternative definition of factorial in which <span class="v">(<a href="COMMON-LISP_____D3.html">=</a> n
 0)</span> is used in place of <span class="v">(<a href="ACL2____ZP.html">zp</a> n)</span>.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> fact (n) (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____D3.html">=</a> n 0) 1 (<a href="COMMON-LISP_____A2.html">*</a> n (fact (<a href="COMMON-LISP____1-.html">1-</a> n)))))</pre> 
 
 <p>This definition does not terminate.  For example <span class="v">(fact -1)</span> gives rise 
 to a call of <span class="v">(fact -2)</span>, etc.  Hence, this alternative is inadmissible.  A 
 plausible response is the addition of a <a href="ACL2____GUARD.html">guard</a> restricting <span class="v">n</span> to the 
 naturals:</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> fact (n)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n) (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> n 0))))
 (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____D3.html">=</a> n 0) 1 (<a href="COMMON-LISP_____A2.html">*</a> n (fact (<a href="COMMON-LISP____1-.html">1-</a> n)))))</pre> 
 
 <p>But because the termination argument is not sensitive to the <a href="ACL2____GUARD.html">guard</a>, 
 it is still impossible to admit this definition.  To influence the termination 
 argument one must change the conditions tested.  Adding a runtime test that 
 <span class="v">n</span> is a natural number would suffice and allow both admission and <a href="ACL2____GUARD.html">guard</a> verification.  But such a test would slow down the execution of the 
 compiled function.</p> 
 
 <p>The use of <span class="v">(<a href="ACL2____ZP.html">zp</a> n)</span> as the test avoids this dilemma.  <span class="tt"><a href="ACL2____ZP.html">Zp</a></span> 
 provides the logical equivalent of a runtime test that <span class="v">n</span> is a natural 
 number but the execution efficiency of a direct <span class="tt"><a href="COMMON-LISP_____D3.html">=</a></span> comparison with 
 <span class="v">0</span>, at the expense of a <a href="ACL2____GUARD.html">guard</a> conjecture to prove.  In addition, if 
 <a href="ACL2____GUARD.html">guard</a> verification and most-efficient execution are not needed, then 
 the use of <span class="v">(<a href="ACL2____ZP.html">zp</a> n)</span> allows the admission of the function without a <a href="ACL2____GUARD.html">guard</a> or other extraneous verbiage.</p> 
 
 <p>While general rules are made to be broken, it is probably a good idea to 
 get into the habit of using <span class="v">(<a href="ACL2____ZP.html">zp</a> n)</span> as your terminating ``<span class="v">0</span> test'' 
 idiom when recursing down the natural numbers.  It provides the logical power 
 of testing that <span class="v">n</span> is a non-<span class="v">0</span> natural number and allows efficient 
 execution.</p> 
 
 <p>We now turn to the analogous function, <span class="tt"><a href="ACL2____ZIP.html">zip</a></span>.  <span class="tt"><a href="ACL2____ZIP.html">Zip</a></span> is the 
 preferred <span class="v">0</span>-test idiom when recursing through the integers toward <span class="v">0</span>. 
 <span class="tt"><a href="ACL2____ZIP.html">Zip</a></span> considers any non-integer to be <span class="v">0</span> and otherwise just 
 recognizes <span class="v">0</span>.  A typical use of <span class="tt"><a href="ACL2____ZIP.html">zip</a></span> is in the definition of 
 <span class="tt"><a href="COMMON-LISP____INTEGER-LENGTH.html">integer-length</a></span>, shown below.  (ACL2 can actually accept this 
 definition, but only after appropriate lemmas have been proved.)</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> integer-length (i)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____INTEGERP.html">integerp</a> i)))
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZIP.html">zip</a> i)
      0
    (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____D3.html">=</a> i -1)
      0
      (<a href="COMMON-LISP_____B2.html">+</a> 1 (<a href="COMMON-LISP____INTEGER-LENGTH.html">integer-length</a> (<a href="COMMON-LISP____FLOOR.html">floor</a> i 2))))))</pre> 
 
 <p>Observe that the function recurs by <span class="v">(<a href="COMMON-LISP____FLOOR.html">floor</a> i 2)</span>.  Hence, calling the 
 function on <span class="v">25</span> causes calls on <span class="v">12</span>, <span class="v">6</span>, <span class="v">3</span>, <span class="v">1</span>, and 
 <span class="v">0</span>, while calling it on <span class="v">-25</span> generates calls on <span class="v">-13</span>, <span class="v">-7</span>, 
 <span class="v">-4</span>, <span class="v">-2</span>, and <span class="v">-1</span>.  By making <span class="v">(<a href="ACL2____ZIP.html">zip</a> i)</span> the first test, we 
 terminate the recursion immediately on non-integers.  The <a href="ACL2____GUARD.html">guard</a>, if 
 present, can be verified and allows the primary raw lisp definition to check 
 <span class="v">(<a href="COMMON-LISP_____D3.html">=</a> i 0)</span> as the first terminating condition (because the primary code is 
 executed only on integers).</p>
</body>
</html>
