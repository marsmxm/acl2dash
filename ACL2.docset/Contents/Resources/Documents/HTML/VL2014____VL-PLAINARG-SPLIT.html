<html>
<head>
<meta charset="UTF-8">
<title>Vl-plainarg-split</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=VL2014____VL-PLAINARG-SPLIT">Click for Vl-plainarg-split in the Full Manual</a></h3>

<p>Maybe split up an argument to a gate/module instances.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(vl-plainarg-split x elem delta)  (mv new-x delta)</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">x</span>  <font color="#606060">Guard <span class="v">(<a href="VL2014____VL-PLAINARG-P.html">vl-plainarg-p</a> x)</span>.</font>
</dd> 
  <dd>
<span class="tt">elem</span>  <font color="#606060">Guard <span class="v">(<a href="VL2014____VL-MODELEMENT-P.html">vl-modelement-p</a> elem)</span>.</font>
</dd> 
  <dd>
<span class="tt">delta</span>  <font color="#606060">Guard <span class="v">(<a href="VL2014____VL-DELTA-P.html">vl-delta-p</a> delta)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">new-x</span>  <font color="#606060">Type <span class="v">(<a href="VL2014____VL-PLAINARG-P.html">vl-plainarg-p</a> new-x)</span>, given the <a href="ACL2____GUARD.html">guard</a>.</font>
</dd> 
<dd>
<span class="tt">delta</span>  <font color="#606060">Type <span class="v">(<a href="VL2014____VL-DELTA-P.html">vl-delta-p</a> delta)</span>, given the <a href="ACL2____GUARD.html">guard</a>.</font>
</dd> 
 
</dl></div> 
<p>We only want to split up expressions that are being given as inputs 
to submodules.  If we have an output, we really want to hook up the actual 
wires being connected, not some new internal wire that we've just created.</p> 
 
<p>This is much like how, when we split up assignments, we only split up the 
right-hand sides.  That is, the left-hand side of an assignment is similar to a 
module output.  We generally think it's an error for a module output to be 
connected to some non-sliceable expression like <span class="v">a + b</span>.</p> 
 
<p>I'm less sure what to do about inouts.  For now I'm going to not split them 
up.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>vl-plainarg-split</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> vl-plainarg-split (x elem delta)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="VL2014____VL-PLAINARG-P.html">vl-plainarg-p</a> x)
                                   (<a href="VL2014____VL-MODELEMENT-P.html">vl-modelement-p</a> elem)
                                   (<a href="VL2014____VL-DELTA-P.html">vl-delta-p</a> delta))))
       (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'vl-plainarg-split))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
            (<a href="ACL2____B_A2.html">b*</a> (((<a href="VL2014____VL-PLAINARG.html">vl-plainarg</a> x) x)
                 ((unless (<a href="COMMON-LISP____EQ.html">eq</a> x.dir :vl-input))
                  (<a href="ACL2____MV.html">mv</a> x delta))
                 ((unless x.expr) (<a href="ACL2____MV.html">mv</a> x delta))
                 ((when (<a href="VL2014____VL-NOSPLIT-P.html">vl-nosplit-p</a> x.expr))
                  (<a href="ACL2____MV.html">mv</a> x delta))
                 ((<a href="ACL2____MV.html">mv</a> new-expr delta)
                  (<a href="VL2014____VL-EXPR-SPLIT.html">vl-expr-split</a> x.expr elem delta))
                 (x-prime (<a href="VL2014____CHANGE-VL-PLAINARG.html">change-vl-plainarg</a> x :expr new-expr)))
                (<a href="ACL2____MV.html">mv</a> x-prime delta))))</pre> 
<p><b>Theorem: </b>vl-plainarg-p-of-vl-plainarg-split.new-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> vl-plainarg-p-of-vl-plainarg-split.new-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____FORCE.html">force</a> (<a href="VL2014____VL-PLAINARG-P.html">vl-plainarg-p</a> x))
                      (<a href="ACL2____FORCE.html">force</a> (<a href="VL2014____VL-MODELEMENT-P.html">vl-modelement-p</a> elem))
                      (<a href="ACL2____FORCE.html">force</a> (<a href="VL2014____VL-DELTA-P.html">vl-delta-p</a> delta)))
                 (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?new-x ?delta)
                       (<a href="VL2014____VL-PLAINARG-SPLIT.html">vl-plainarg-split</a> x elem delta)))
                     (<a href="VL2014____VL-PLAINARG-P.html">vl-plainarg-p</a> new-x)))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>vl-delta-p-of-vl-plainarg-split.delta</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> vl-delta-p-of-vl-plainarg-split.delta
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____FORCE.html">force</a> (<a href="VL2014____VL-PLAINARG-P.html">vl-plainarg-p</a> x))
                      (<a href="ACL2____FORCE.html">force</a> (<a href="VL2014____VL-MODELEMENT-P.html">vl-modelement-p</a> elem))
                      (<a href="ACL2____FORCE.html">force</a> (<a href="VL2014____VL-DELTA-P.html">vl-delta-p</a> delta)))
                 (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?new-x ?delta)
                       (<a href="VL2014____VL-PLAINARG-SPLIT.html">vl-plainarg-split</a> x elem delta)))
                     (<a href="VL2014____VL-DELTA-P.html">vl-delta-p</a> delta)))
        :rule-classes :rewrite)</pre> 

</body>
</html>
