<html>
<head>
<meta charset="UTF-8">
<title>Select-segment-register</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=X86ISA____SELECT-SEGMENT-REGISTER">Click for Select-segment-register in the Full Manual</a></h3>

<p>Segment register to use for an instruction operand  in memory.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(select-segment-register proc-mode p2 p4? mod r/m sib x86) 
  → 
seg-reg</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">p2</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> 8 p2)</span>.</font>
</dd> 
  <dd>
<span class="tt">p4?</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____BOOLEANP.html">booleanp</a> p4?)</span>.</font>
</dd> 
  <dd>
<span class="tt">mod</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> 2 mod)</span>.</font>
</dd> 
  <dd>
<span class="tt">r/m</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> 3 r/m)</span>.</font>
</dd> 
  <dd>
<span class="tt">sib</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> 8 sib)</span>.</font>
</dd> 
  <dd>
<span class="tt">x86</span> — <font color="#606060">Guard <span class="v">(x86p x86)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">seg-reg</span> — <font color="#606060">Type <span class="v">(<a href="ACL2____INTEGER-RANGE-P.html">integer-range-p</a> 0 *segment-register-names-len* seg-reg)</span>.</font>
</dd> 
 
</dl></div> 
<p> 
   If there is a segment register override prefix, 
   the prefix determines the segment register, 
   according to Intel manual, Mar'17, Volume 2, Section 2.1.1. 
   </p> 
   <p> 
   Otherwise, we use the default segment selection rules 
   in Intel manual, May'18, Volume 1, Table 3-5. 
   Since we only call this function for instruction operands, 
   the CS rule does not apply. 
   The ES rule applies to string instructions, 
   but our model does not use this function 
   to determine the ES segment for string instructions 
   (which cannot be overridden, 
   at least for the string instructions we currently support), 
   so this function does not take the ES rule into account either. 
   So the result is either SS or DS, 
   based on whether the base register is one of rSP and rBP or not: 
   this determination is made based on 
   Intel manual, May'18, Volume 2, Table 2-1 if the address size is 16 bits, 
   and Intel manual, May'18, Volume 2, Table 2-2 otherwise. 
   However, when Mod is not 11b and R/M is 100b, 
   the notation [--][--] in Table 2-2 indicates the use of a SIB byte: 
   according to Intel manual, May'18, Volume 2, Table 2-3, 
   when the Base field of the SIB byte is 100b, 
   the base register is rSP, 
   and thus in this case the default segment register is SS. 
   </p> 
   <p> 
   Note that here we may recalculate the address size 
   even if that has already been calculated as part of 
   the decoding of the instruction whose operand we are accessing. 
   Thus, it may be possible to optimize the overall code. 
   </p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>select-segment-register$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
  select-segment-register$inline
  (proc-mode p2 p4? mod r/m sib x86)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (x86)))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (integer 0 4) proc-mode))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> 8 p2)
                              (<a href="ACL2____BOOLEANP.html">booleanp</a> p4?)
                              (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> 2 mod)
                              (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> 3 r/m)
                              (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> 8 sib)
                              (x86p x86))))
  (<a href="COMMON-LISP____CASE.html">case</a> p2 (46 1)
        (54 2)
        (62 3)
        (38 0)
        (100 4)
        (101 5)
        (t (<a href="ACL2____B_A2.html">b*</a> ((addr-size (<a href="X86ISA____SELECT-ADDRESS-SIZE.html">select-address-size</a> proc-mode p4? x86)))
               (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____D3.html">=</a> addr-size 2)
                   (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP_____D3.html">=</a> mod 3))
                            (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP_____D3.html">=</a> r/m 2) (<a href="COMMON-LISP_____D3.html">=</a> r/m 3)))
                       2 3)
                   (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP_____D3.html">=</a> mod 1) (<a href="COMMON-LISP_____D3.html">=</a> mod 2)) (<a href="COMMON-LISP_____D3.html">=</a> r/m 5))
                           (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP_____D3.html">=</a> mod 3))
                                (<a href="COMMON-LISP_____D3.html">=</a> r/m 4)
                                (<a href="COMMON-LISP_____D3.html">=</a> (<a href="X86ISA____SIB-_E3BASE.html">sib-&gt;base</a> sib) 4)))
                       2 3))))))</pre> 
<p><b>Theorem: </b>return-type-of-select-segment-register</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     return-type-of-select-segment-register
     (<a href="ACL2____B_A2.html">b*</a> ((seg-reg (select-segment-register$inline
                        proc-mode p2 p4? mod r/m sib x86)))
         (<a href="ACL2____INTEGER-RANGE-P.html">integer-range-p</a> 0 *segment-register-names-len* seg-reg))
     :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>range-of-select-segment-register</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> range-of-select-segment-register
        (<a href="ACL2____B_A2.html">b*</a> ((?seg-reg (select-segment-register$inline
                            proc-mode p2 p4? mod r/m sib x86)))
            (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 0 seg-reg) (<a href="COMMON-LISP_____C3.html">&lt;</a> seg-reg 6)))
        :rule-classes :linear)</pre> 

</body>
</html>
