<html>
<head>
<meta charset="UTF-8">
<title>Linear</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____LINEAR">Click for Linear in the Full Manual</a></h3>

<p>Make some arithmetic inequality rules</p><p>See <a href="ACL2____RULE-CLASSES.html">rule-classes</a> for a general discussion of rule classes, 
 including how they are used to build rules from formulas and a discussion of 
 the various keywords in a rule class description.</p> 
 
 <pre class="code">Example:
(<a href="ACL2____DEFTHM.html">defthm</a> length-member-leq-length       If inequality reasoning begins to
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____EQLABLEP.html">eqlablep</a> e)           consider how (<a href="COMMON-LISP____LENGTH.html">length</a> (<a href="COMMON-LISP____MEMBER.html">member</a> a b))
                (<a href="ACL2____TRUE-LISTP.html">true-listp</a> x))        compares to any other term, add to
           (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="COMMON-LISP____LENGTH.html">length</a> (<a href="COMMON-LISP____MEMBER.html">member</a> e x))   the set of known inequalities the fact
               (<a href="COMMON-LISP____LENGTH.html">length</a> x)))            that it is no larger than (<a href="COMMON-LISP____LENGTH.html">length</a> b),
  :rule-classes :linear)               provided (<a href="ACL2____EQLABLEP.html">eqlablep</a> a) and
                                       (<a href="ACL2____TRUE-LISTP.html">true-listp</a> b) rewrite to t.

General Form:
(<a href="COMMON-LISP____AND.html">and</a> ...
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> ...hi...)
              (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> ...hk...)
                       (<a href="COMMON-LISP____AND.html">and</a> ...
                            (rel lhs rhs)
                            ...)))
     ...)</pre> 
 
 <p>We process the <span class="v">:</span><span class="tt"><a href="ACL2____COROLLARY.html">corollary</a></span> formula of one <span class="v">:linear</span> rule 
 class object to create one or more <span class="v">:linear</span> rules.  The first step is to 
 flatten the <span class="tt"><a href="COMMON-LISP____AND.html">and</a></span> and <span class="tt"><a href="ACL2____IMPLIES.html">implies</a></span> structure of the formula, 
 transforming it into a conjunction of formulas, each of the form</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> h1 ... hn) (rel lhs rhs))</pre> 
 
 <p>where no hypothesis is a conjunction and the term <span class="v">(rel lhs rhs)</span> is a 
 call of one of the inequality relations <span class="tt"><a href="COMMON-LISP_____C3.html">&lt;</a></span>, <span class="tt"><a href="COMMON-LISP_____C3_D3.html">&lt;=</a></span>, <span class="tt"><a href="COMMON-LISP_____E3.html">&gt;</a></span>, or 
 <span class="tt"><a href="COMMON-LISP_____E3_D3.html">&gt;=</a></span>; the negation of such a call; a call of <span class="tt"><a href="COMMON-LISP_____D3.html">=</a></span> or <span class="tt"><a href="COMMON-LISP____EQUAL.html">equal</a></span>; 
 or a negated call of <span class="tt"><a href="COMMON-LISP_____F2_D3.html">/=</a></span>.  Note that we refer to all of these terms as 
 ``inequalities'' below, even the equalities.  If necessary, the hypothesis of 
 such a conjunct may be vacuous.  We create a <span class="v">:linear</span> rule for each such 
 conjunct, if possible, and otherwise cause an error.  To create a <span class="v">:linear</span> 
 rule from a term (i.e., from a single such conjunct), we apply the following 
 sequence of transformations (as well as macroexpansion, which removes calls of 
 <span class="tt"><a href="COMMON-LISP_____C3_D3.html">&lt;=</a></span>, <span class="tt"><a href="COMMON-LISP_____E3.html">&gt;</a></span>, and <span class="tt"><a href="COMMON-LISP_____E3_D3.html">&gt;=</a></span>).</p> 
 
 <ol> 
 
 <li>Remove <a href="ACL2____GUARD-HOLDERS.html">guard-holders</a> such as <span class="tt"><a href="ACL2____PROG2_42.html">prog2$</a></span> from the term to obtain 
 <span class="v">(<a href="ACL2____IMPLIES.html">implies</a> hyp concl)</span>, where <span class="v">hyp</span> is <span class="v">t</span> in the case of an 
 unconditional rule.</li> 
 
 <li>If <span class="v">concl</span> is <span class="v">(<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____NOT.html">not</a> concl2))</span>, replace <span class="v">concl</span> by 
 <span class="v">concl2</span>.</li> 
 
 <li>For the resulting <span class="v">concl</span>, replace <span class="tt"><a href="COMMON-LISP_____D3.html">=</a></span> and <span class="tt"><a href="COMMON-LISP_____F2_D3.html">/=</a></span> by <span class="tt"><a href="COMMON-LISP____EQUAL.html">equal</a></span> and <span class="v">not equal</span>, respectively.</li> 
 
 <li>Finally, the resulting <span class="v">concl</span> is processed (``linearized'') to attempt 
 to create a corresponding polynomial or disjunction of two polynomials.  This 
 process includes the evaluation of ground subexpressions, for example 
 replacing <span class="v">(<a href="COMMON-LISP_____A2.html">*</a> '3 '4)</span> by <span class="v">'12</span>, and employs techniques that include 
 <a href="ACL2____TYPE-SET.html">type-set</a> reasoning.</li> 
 
 </ol> 
 
 <p>Each rule has one or more ``trigger terms'' which may be specified by the 
 user using the <span class="v">:trigger-terms</span> field of the rule class or which may be 
 defaulted to values chosen by the system.  We discuss the determination of 
 trigger terms after discussing how linear rules are used.</p> 
 
 <p><span class="v">:Linear</span> rules are used by an arithmetic decision procedure during 
 rewriting.  See <a href="ACL2____LINEAR-ARITHMETIC.html">linear-arithmetic</a> and see <a href="ACL2____NON-LINEAR-ARITHMETIC.html">non-linear-arithmetic</a>. 
 Here we assume that the reader is familiar with the material described in 
 <span class="tt"><a href="ACL2____LINEAR-ARITHMETIC.html">linear-arithmetic</a></span>.</p> 
 
 <p>Recall that we eliminate the unknowns of an inequality in term-order, 
 largest unknowns first.  (See <a href="ACL2____TERM-ORDER.html">term-order</a>.)  In order to facilitate this 
 strategy, we store the inequalities in ``linear pots''.  For purposes of the 
 present discussion, let us say that an inequality is ``about'' its largest 
 unknown.  Then, all of the inequalities about a particular unknown are stored 
 in the same linear pot, and the pot is said to be ``labeled'' with that 
 unknown.  This storage layout groups all of the inequalities which are 
 potential candidates for cancellation with each other into one place.  It is 
 also key to the efficient operation of <span class="v">:linear</span> rules.</p> 
 
 <p>If the arithmetic decision procedure has stabilized and not yielded a 
 contradiction, we scan through the list of linear pots examining each label as 
 we go.  If the trigger term of some <span class="v">:linear</span> rule can be instantiated to 
 match the label, we so instantiate that rule and attempt to relieve the 
 hypotheses with general-purpose rewriting.  If we are successful, we rewrite 
 each of the two terms being compared by the conclusion (which is an equality 
 or inequality), under the substitution produced by the rule's instantiation. 
 We then add the resulting equality or inequality to our set of 
 inequalities. This may let cancellation continue.</p> 
 
 <p>Note: Problems may arise if you explicitly store a linear lemma under a 
 trigger term that, when instantiated, is not the largest unknown in the 
 instantiated concluding inequality.  Suppose for example you store the linear 
 rule <span class="v">(<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (fn i j) (<a href="COMMON-LISP_____F2.html">/</a> i (<a href="COMMON-LISP_____A2.html">*</a> j j)))</span> under the trigger term <span class="v">(fn i j)</span>. 
 Then when the system ``needs'' an inequality about <span class="v">(fn a b)</span>, (i.e., 
 because <span class="v">(fn a b)</span> is the label of some linear pot, and hence the largest 
 unknown in some inequality), it will appeal to the rule and deduce <span class="v">(<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (fn
 a b) (<a href="COMMON-LISP_____F2.html">/</a> a (<a href="COMMON-LISP_____A2.html">*</a> b b)))</span>.  However, the largest unknown in this inequality is 
 <span class="v">(<a href="COMMON-LISP_____F2.html">/</a> a (<a href="COMMON-LISP_____A2.html">*</a> b b))</span> and hence it will be stored in a linear pot labeled with 
 <span class="v">(<a href="COMMON-LISP_____F2.html">/</a> a (<a href="COMMON-LISP_____A2.html">*</a> b b))</span>.  The original, triggering inequality which is in a pot 
 about <span class="v">(fn a b)</span> will therefore not be canceled against the new one.  It 
 is generally best to specify as a trigger term one of the ``maximal'' terms of 
 the polynomial, as described below.</p> 
 
 <p>We now describe how the trigger terms are determined.  Most of the time, 
 the trigger terms are not specified by the user and are instead selected by 
 the system.  However, the user may specify the terms by including an explicit 
 <span class="v">:trigger-terms</span> field in the rule class, e.g.,</p> 
 
 <pre class="code">General Form of a Linear Rule Class:
(:LINEAR :COROLLARY formula
         :TRIGGER-TERMS (term1 ... termk))</pre> 
 
 <p>Each <span class="v">termi</span> must be a term and must not be a variable, quoted constant, 
 lambda application, <span class="v">let-expression</span> or <span class="v">if-expression</span>.  In addition, 
 each <span class="v">termi</span> must be such that if all the variables in the term are 
 instantiated and then the hypotheses of the corollary formula are relieved 
 (possibly instantiating additional free variables), then all the variables in 
 the concluding inequality are instantiated.  We generate a linear rule for 
 each conjunctive branch through the corollary and store each rule under each of 
 the specified triggers.  Thus, if the corollary formula contains several 
 conjuncts, the variable restrictions on the <span class="v">termi</span> must hold for each 
 conjunct.</p> 
 
 <p>If <span class="v">:trigger-terms</span> is omitted the system computes a set of trigger 
 terms.  Each conjunct of the corollary formula may be given a unique set of 
 triggers depending on the variables that occur in the conjunct and the addends 
 that occur in the concluding inequality.  In particular, the trigger terms for 
 a conjunct is the list of all ``maximal addends'' in the concluding inequality 
 after replacing, where possible based on the <a href="ACL2____CURRENT-THEORY.html">current-theory</a>, ground 
 subterms (those that have no free variables) with their values.</p> 
 
 <p>The ``addends'' of <span class="v">(<a href="COMMON-LISP_____B2.html">+</a> x y)</span> and <span class="v">(<a href="COMMON-LISP____-.html">-</a> x y)</span> are the union of the 
 addends of <span class="v">x</span> and <span class="v">y</span>.  The addends of <span class="v">(<a href="COMMON-LISP____-.html">-</a> x)</span> and <span class="v">(<a href="COMMON-LISP_____A2.html">*</a> n x)</span>, 
 where <span class="v">n</span> is a rational constant, is just <span class="v">{x}</span>.  The addends of an 
 inequality are the union of the addends of the left- and right-hand sides. 
 The addends of any other term, <span class="v">x</span>, is <span class="v">{x}</span>.</p> 
 
 <p>A term is maximal for a conjunct <span class="v">(<a href="ACL2____IMPLIES.html">implies</a> hyps concl)</span> of the corollary 
 if (a) the term is a non-variable, non-quote, non-lambda application, 
 non-<span class="tt"><a href="COMMON-LISP____LET.html">let</a></span> and non-<span class="tt"><a href="COMMON-LISP____IF.html">if</a></span> expression, (b) the term contains enough 
 variables so that when they are instantiated and the hypotheses are relieved 
 (which may bind some free variables; see <a href="ACL2____FREE-VARIABLES.html">free-variables</a>) then all the 
 variables in <span class="v">concl</span> are instantiated, and (c) no other addend is always 
 ``bigger'' than the term, in the technical sense described below.  Note that 
 the notion of ``enough variables'' in (b) is affected by hypotheses that are 
 calls of <span class="v">bind-free</span>; see <a href="ACL2____BIND-FREE.html">bind-free</a>.</p> 
 
 <p>The technical notion referenced above depends on the notion of 
 <i>fn-count</i>, the number of function symbols in a term, and 
 <i>pseudo-fn-count</i>, which is essentially the number of function symbols 
 implicit in a constant (see <a href="ACL2____TERM-ORDER.html">term-order</a>, specifically the discussion of 
 ``pseudo-function application count'' at the end).  We say <span class="v">term1</span> is 
 always bigger than <span class="v">term2</span> if all instances of <span class="v">term1</span> have a larger 
 fn-count (actually lexicographic order of fn-count and pseudo-fn-count) than 
 the corresponding instances of <span class="v">term2</span>.  This is equivalent to saying that 
 the fn-count of <span class="v">term1</span> is larger than that of <span class="v">term2</span> (by ``fn-count'' 
 here we mean the lexicographic order of fn-count and pseudo-fn-count) and the 
 variable bag for <span class="v">term2</span> is a subbag of that for <span class="v">term1</span>.  For example, 
 <span class="v">(<a href="COMMON-LISP_____F2.html">/</a> a (<a href="COMMON-LISP_____A2.html">*</a> b b))</span> is always bigger than <span class="v">(fn a b)</span> because the first has 
 two function applications and <span class="v">{a b}</span> is a subbag of <span class="v">{a b b}</span>, but 
 <span class="v">(<a href="COMMON-LISP_____F2.html">/</a> a (<a href="COMMON-LISP_____A2.html">*</a> b b))</span> is not always bigger than <span class="v">(fn a x)</span>.</p> 
 
 <p>We conclude by noting that linear rules are useless when all of the 
 polynomial's terms are provably non-numeric.  If ACL2 determines that to be 
 the case for one or more of the conclusions, then it causes an error, except 
 when <span class="v">:trigger-terms</span> is supplied explicitly by the user.</p>
</body>
</html>
