<html>
<head>
<meta charset="UTF-8">
<title>Vl-parse-any-sort-of-concatenation</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=VL2014____VL-PARSE-ANY-SORT-OF-CONCATENATION">Click for Vl-parse-any-sort-of-concatenation in the Full Manual</a></h3>

<p>Match single, multiple, or streaming concatenations, or empty 
queues.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(vl-parse-any-sort-of-concatenation &amp;key (tokstream 'tokstream) 
                                    (config 'config)) 
 
   
(mv errmsg? value new-tokstream)</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">config</span>  <font color="#606060">Guard <span class="v">(<a href="VL2014____VL-LOADCONFIG-P.html">vl-loadconfig-p</a> config)</span>.</font>
</dd> 
 
</dl></div> 
<p>Both Verilog-2005 and SystemVerilog-2012 agree on the syntax for 
concatenations and multiple concatenations:</p> 
 
<pre class="code">concatenation ::= '{' expression { ',' expression } '}'

multiple_concatenation ::= '{' expression concatenation '}'</pre> 
 
<p>By itself this is slightly tricky to parse: we don't know which production 
we're matching until we have read the initial <span class="v"> '{' expression </span>.  If we 
then find a comma, or a closing brace, we know it is a single concatenation. 
Otherwise, if we find an opening brace, we know it is a multiple 
concatenation.</p> 
 
<p>SystemVerilog-2012 complicates this by adding streaming concatenations:</p> 
 
<pre class="code">streaming_concatenation ::=
  '{' stream_operator [slice_size] stream_concatenation '}'

stream_operator ::= '&gt;&gt;' | '&lt;&lt;'</pre> 
 
<p>Fortunately, streaming concatenations are easy to identify because they 
always start with one of these <span class="v">stream_operators</span>.</p> 
 
<p>SystemVerilog also adds empty queues which are easy to identify:</p> 
 
<pre class="code">empty_queue ::= '{' '}'</pre> 
 

</body>
</html>
