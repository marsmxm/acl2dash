<html>
<head>
<meta charset="UTF-8">
<title>Failed-forcing</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____FAILED-FORCING">Click for Failed-forcing in the Full Manual</a></h3>

<p>How to deal with a proof <a href="ACL2____FAILURE.html">failure</a> in a forcing round</p><p>See <a href="ACL2____FORCING-ROUND.html">forcing-round</a> for a background discussion of the notion 
 of forcing rounds.  When a proof fails during a forcing round it means that 
 the ``gist'' of the proof succeeded but some ``technical detail'' failed.  The 
 first question you must ask yourself is whether the <a href="ACL2____FORCE.html">force</a>d goals are 
 indeed theorems.  We discuss the possibilities below.</p> 
 
 <p>If you believe the <a href="ACL2____FORCE.html">force</a>d goals are theorems, you should follow the 
 usual methodology for ``fixing'' failed ACL2 proofs, e.g., the identification 
 of key lemmas and their timely and proper use as rules.  See <a href="ACL2____FAILURE.html">failure</a>, 
 see <a href="ACL2____GAG-MODE.html">gag-mode</a>, and see <a href="ACL2____PROOF-TREE.html">proof-tree</a>.</p> 
 
 <p>The rules designed for the goals of forcing rounds are often just what is 
 needed to prove the <a href="ACL2____FORCE.html">force</a>d hypothesis at the time it is <a href="ACL2____FORCE.html">force</a>d. 
 Thus, you may find that when the system has been ``taught'' how to prove the 
 goals of the forcing round no forcing round is needed.  This is intended as a 
 feature to help structure the discovery of the necessary rules.</p> 
 
 <p>If a hint must be provided to prove a goal in a forcing round, the 
 appropriate ``goal specifier'' (the string used to identify the goal to which 
 the hint is to be applied) is just the text printed on the line above the 
 formula, e.g., <span class="v">"[1]Subgoal *1/3''"</span>.  See <a href="ACL2____GOAL-SPEC.html">goal-spec</a>.</p> 
 
 <p>If you solve a forcing problem by giving explicit <a href="ACL2____HINTS.html">hints</a> for the 
 goals of forcing rounds, you might consider whether you could avoid forcing 
 the assumption in the first place by giving those <a href="ACL2____HINTS.html">hints</a> in the 
 appropriate places of the main proof.  This is one reason that we print out 
 the origins of each <a href="ACL2____FORCE.html">force</a>d assumption.  An argument against this style, 
 however, is that an assumption might be <a href="ACL2____FORCE.html">force</a>d in hundreds of places in 
 the main goal and proved only once in the forcing round, so that by delaying 
 the proof you actually save time.</p> 
 
 <p>We now turn to the possibility that some goal in the forcing round is not a 
 theorem.</p> 
 
 <p>There are two possibilities to consider.  The first is that the original 
 theorem has insufficient hypotheses to ensure that all the <a href="ACL2____FORCE.html">force</a>d 
 hypotheses are in fact always true.  The ``fix'' in this case is to amend the 
 original conjecture so that it has adequate hypotheses.</p> 
 
 <p>A more difficult situation can arise and that is when the conjecture has 
 sufficient hypotheses but they are not present in the forcing round goal. 
 This can be caused by what we call ``premature'' forcing.</p> 
 
 <p>Because ACL2 rewrites from the inside out, it is possible that it will 
 <a href="ACL2____FORCE.html">force</a> hypotheses while the context is insufficient to establish them. 
 Consider trying to prove <span class="v">(p x (foo x))</span>.  We first rewrite the formula in 
 an empty context, i.e., assuming nothing.  Thus, we rewrite <span class="v">(foo x)</span> in an 
 empty context.  If rewriting <span class="v">(foo x)</span> <a href="ACL2____FORCE.html">force</a>s anything, that <a href="ACL2____FORCE.html">force</a>d assumption will have to be proved in an empty context.  This will 
 likely be impossible.</p> 
 
 <p>On the other hand, suppose we did not attack <span class="v">(foo x)</span> until after we 
 had expanded <span class="v">p</span>.  We might find that the value of its second argument, 
 <span class="v">(foo x)</span>, is relevant only in some cases and in those cases we might be 
 able to establish the hypotheses <a href="ACL2____FORCE.html">force</a>d by <span class="v">(foo x)</span>.  Our premature 
 forcing is thus seen to be a consequence of our ``over eager'' rewriting.</p> 
 
 <p>Here, just for concreteness, is an example you can try.  In this example, 
 <span class="v">(foo x)</span> rewrites to <span class="v">x</span> but has a <a href="ACL2____FORCE.html">force</a>d hypothesis of 
 <span class="v">(<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x)</span>.  <span class="v">P</span> does a case split on that very hypothesis and uses 
 its second argument only when <span class="v">x</span> is known to be rational.  Thus, the 
 hypothesis for the <span class="v">(foo x)</span> rewrite is satisfied.  On the false branch of 
 its case split, <span class="v">p</span> simplifies to <span class="v">(p1 x)</span> which can be proved under the 
 assumption that <span class="v">x</span> is not rational.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> p1 (x) (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x)))
(<a href="COMMON-LISP____DEFUN.html">defun</a> p (x y)(<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x) (<a href="COMMON-LISP____EQUAL.html">equal</a> x y) (p1 x)))
(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (x) x)
(<a href="ACL2____DEFTHM.html">defthm</a> foo-rewrite (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____FORCE.html">force</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x)) (<a href="COMMON-LISP____EQUAL.html">equal</a> (foo x) x)))
(<a href="ACL2____IN-THEORY.html">in-theory</a> (<a href="ACL2____DISABLE.html">disable</a> foo))</pre> 
 
 <p>The attempt then to do <span class="v">(<a href="ACL2____THM.html">thm</a> (p x (foo x)))</span> <a href="ACL2____FORCE.html">force</a>s the 
 unprovable goal <span class="v">(<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x)</span>.</p> 
 
 <p>Since all ``formulas'' are presented to the theorem prover as single terms 
 with no hypotheses (e.g., since <span class="tt"><a href="ACL2____IMPLIES.html">implies</a></span> is a function), this problem 
 would occur routinely were it not for the fact that the theorem prover expands 
 certain ``simple'' definitions immediately without doing anything that can 
 cause a hypothesis to be <a href="ACL2____FORCE.html">force</a>d.  See <a href="ACL2____SIMPLE.html">simple</a>.  This does not 
 solve the problem, since it is possible to hide the propositional structure 
 arbitrarily deeply.  For example, one could define <span class="v">p</span>, above, recursively 
 so that the test that <span class="v">x</span> is rational and the subsequent first ``real'' use 
 of <span class="v">y</span> occurred arbitrarily deeply.</p> 
 
 <p>Therefore, the problem remains: what do you do if an impossible goal is 
 <a href="ACL2____FORCE.html">force</a>d and yet you know that the original conjecture was adequately 
 protected by hypotheses?</p> 
 
 <p>One alternative is to disable forcing entirely.  See <a href="ACL2____DISABLE-FORCING.html">disable-forcing</a>.  Another is to <a href="ACL2____DISABLE.html">disable</a> the rule that caused the <a href="ACL2____FORCE.html">force</a>.</p> 
 
 <p>A third alternative is to prove that the negation of the main goal implies 
 the <a href="ACL2____FORCE.html">force</a>d hypothesis.  For example,</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> not-p-implies-rationalp
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (p x (foo x))) (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x))
  :rule-classes nil)</pre> 
 
 <p>Observe that we make no rules from this formula.  Instead, we merely 
 <span class="v">:use</span> it in the subgoal where we must establish <span class="v">(<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x)</span>.</p> 
 
 <pre class="code">(<a href="ACL2____THM.html">thm</a> (p x (foo x))
     :hints (("Goal" :use not-p-implies-rationalp)))</pre> 
 
 <p>When we said, above, that <span class="v">(p x (foo x))</span> is first rewritten in an empty 
 context we were misrepresenting the situation slightly.  When we rewrite a 
 literal we know what literal we are rewriting and we implicitly assume it 
 false.  This assumption is ``dangerous'' in that it can lead us to simplify 
 our goal to <span class="v">nil</span> and give up â€” we have even seen people make the 
 mistake of assuming the negation of what they wished to prove and then via a 
 very complicated series of transformations convince themselves that the 
 formula is false.  Because of this ``tail biting'' we make very weak use of 
 the negation of our goal.  But the use we make of it is sufficient to 
 establish the <a href="ACL2____FORCE.html">force</a>d hypothesis above.</p> 
 
 <p>A fourth alternative is to weaken your desired theorem so as to make 
 explicit the required hypotheses, e.g., to prove</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rationalp-implies-main
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x) (p x (foo x)))
  :rule-classes nil)</pre> 
 
 <p>This of course is unsatisfying because it is not what you originally 
 intended.  But all is not lost.  You can now prove your main theorem from this 
 one, letting the <span class="tt"><a href="ACL2____IMPLIES.html">implies</a></span> here provide the necessary case split.</p> 
 
 <pre class="code">(<a href="ACL2____THM.html">thm</a> (p x (foo x))
     :hints (("Goal" :use rationalp-implies-main)))</pre>
</body>
</html>
