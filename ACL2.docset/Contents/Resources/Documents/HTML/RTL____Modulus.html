<html>
<head>
<meta charset="UTF-8">
<title>Modulus</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=RTL____Modulus">Click for Modulus in the Full Manual</a></h3>

<p>Modulus</p><h3>Definitions and Theorems</h3><p><b>Theorem: </b>mod-def</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-def
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____CASE-SPLIT.html">case-split</a> (<a href="ACL2____ACL2-NUMBERP.html">acl2-numberp</a> x))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> x y)
                        (<a href="COMMON-LISP____-.html">-</a> x (<a href="COMMON-LISP_____A2.html">*</a> y (fl (<a href="COMMON-LISP_____F2.html">/</a> x y))))))
        :rule-classes nil)</pre><p><b>Theorem: </b>mod-0</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-0
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> 0 y) 0)
             (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> x 0) (<a href="ACL2____FIX.html">fix</a> x))))</pre><p><b>Theorem: </b>rationalp-mod</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rationalp-mod
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x)
                 (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> (<a href="COMMON-LISP____MOD.html">mod</a> x y)))
        :rule-classes (:rewrite :type-prescription))</pre><p><b>Theorem: </b>integerp-mod</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> integerp-mod
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> m) (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n))
                 (<a href="COMMON-LISP____INTEGERP.html">integerp</a> (<a href="COMMON-LISP____MOD.html">mod</a> m n)))
        :rule-classes (:rewrite :type-prescription))</pre><p><b>Theorem: </b>natp-mod</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> natp-mod
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> m) (<a href="ACL2____NATP.html">natp</a> n))
                 (<a href="ACL2____NATP.html">natp</a> (<a href="COMMON-LISP____MOD.html">mod</a> m n)))
        :rule-classes ((:type-prescription :typed-term (<a href="COMMON-LISP____MOD.html">mod</a> m n))))</pre><p><b>Theorem: </b>natp-mod-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> natp-mod-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> m) (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n) (<a href="COMMON-LISP_____E3.html">&gt;</a> n 0))
                 (<a href="ACL2____NATP.html">natp</a> (<a href="COMMON-LISP____MOD.html">mod</a> m n)))
        :rule-classes ((:type-prescription :typed-term (<a href="COMMON-LISP____MOD.html">mod</a> m n))))</pre><p><b>Theorem: </b>mod-bnd-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-bnd-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____CASE-SPLIT.html">case-split</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> 0 n))
                      (<a href="ACL2____CASE-SPLIT.html">case-split</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____COMPLEX-RATIONALP.html">complex-rationalp</a> m)))
                      (<a href="ACL2____CASE-SPLIT.html">case-split</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____COMPLEX-RATIONALP.html">complex-rationalp</a> n))))
                 (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="COMMON-LISP____MOD.html">mod</a> m n) n))
        :rule-classes :linear)</pre><p><b>Theorem: </b>mod-by-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-by-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> m)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> m 1) 0)))</pre><p><b>Theorem: </b>mod-bnd-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-bnd-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 0 m)
                      (<a href="ACL2____CASE-SPLIT.html">case-split</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> m)))
                 (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="COMMON-LISP____MOD.html">mod</a> m n) m))
        :rule-classes :linear)</pre><p><b>Theorem: </b>mod-does-nothing</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-does-nothing
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> m n)
                      (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 0 m)
                      (<a href="ACL2____CASE-SPLIT.html">case-split</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> m)))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> m n) m)))</pre><p><b>Theorem: </b>mod-0-fl</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-0-fl
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____ACL2-NUMBERP.html">acl2-numberp</a> m)
                 (<a href="ACL2____IFF.html">iff</a> (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____MOD.html">mod</a> m n) 0)
                      (<a href="COMMON-LISP_____D3.html">=</a> m (<a href="COMMON-LISP_____A2.html">*</a> (fl (<a href="COMMON-LISP_____F2.html">/</a> m n)) n))))
        :rule-classes nil)</pre><p><b>Theorem: </b>mod-0-int</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-0-int
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> m)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP_____D3.html">=</a> n 0)))
                 (<a href="ACL2____IFF.html">iff</a> (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____MOD.html">mod</a> m n) 0)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> (<a href="COMMON-LISP_____F2.html">/</a> m n))))
        :rule-classes nil)</pre><p><b>Theorem: </b>mod-mult-n</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-mult-n
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> a n) n) (<a href="COMMON-LISP_____A2.html">*</a> n (<a href="COMMON-LISP____MOD.html">mod</a> a 1))))</pre><p><b>Theorem: </b>mod-mult-n-alt</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-mult-n-alt
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> n a) n) (<a href="COMMON-LISP_____A2.html">*</a> n (<a href="COMMON-LISP____MOD.html">mod</a> a 1))))</pre><p><b>Theorem: </b>mod-squeeze</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-squeeze
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____MOD.html">mod</a> m n) 0)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> m (<a href="COMMON-LISP_____A2.html">*</a> (<a href="COMMON-LISP____1_B2.html">1+</a> a) n))
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="COMMON-LISP_____A2.html">*</a> (<a href="COMMON-LISP____1-.html">1-</a> a) n) m)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> a)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> m)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n))
                 (<a href="COMMON-LISP_____D3.html">=</a> m (<a href="COMMON-LISP_____A2.html">*</a> a n)))
        :rule-classes nil)</pre><p><b>Theorem: </b>mod-must-be-n</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-must-be-n
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____MOD.html">mod</a> m n) 0)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> m (<a href="COMMON-LISP_____A2.html">*</a> 2 n))
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> 0 m)
                      (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> m)
                      (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> n))
                 (<a href="COMMON-LISP_____D3.html">=</a> m n))
        :rule-classes nil)</pre><p><b>Theorem: </b>fl-mod</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fl-mod
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> m))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (fl (<a href="COMMON-LISP_____F2.html">/</a> (<a href="COMMON-LISP____MOD.html">mod</a> a (<a href="COMMON-LISP_____A2.html">*</a> m n)) n))
                        (<a href="COMMON-LISP____MOD.html">mod</a> (fl (<a href="COMMON-LISP_____F2.html">/</a> a n)) m))))</pre><p><b>Theorem: </b>mod-0-0</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-0-0
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> p)
                      (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> m)
                      (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> n))
                 (<a href="ACL2____IFF.html">iff</a> (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____MOD.html">mod</a> m (<a href="COMMON-LISP_____A2.html">*</a> n p)) 0)
                      (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____MOD.html">mod</a> m n) 0)
                           (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____MOD.html">mod</a> (fl (<a href="COMMON-LISP_____F2.html">/</a> m n)) p) 0))))
        :rule-classes nil)</pre><p><b>Theorem: </b>mod-equal-int</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-equal-int
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____MOD.html">mod</a> a n) (<a href="COMMON-LISP____MOD.html">mod</a> b n))
                      (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> a)
                      (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> b))
                 (<a href="COMMON-LISP____INTEGERP.html">integerp</a> (<a href="COMMON-LISP_____F2.html">/</a> (<a href="COMMON-LISP____-.html">-</a> a b) n)))
        :rule-classes nil)</pre><p><b>Theorem: </b>mod-equal-int-reverse</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-equal-int-reverse
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> (<a href="COMMON-LISP_____F2.html">/</a> (<a href="COMMON-LISP____-.html">-</a> a b) n))
                      (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> a)
                      (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> b)
                      (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> n)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> 0 n))
                 (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____MOD.html">mod</a> a n) (<a href="COMMON-LISP____MOD.html">mod</a> b n)))
        :rule-classes nil)</pre><p><b>Theorem: </b>mod-force-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-force-equal
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="COMMON-LISP____ABS.html">abs</a> (<a href="COMMON-LISP____-.html">-</a> a b)) n)
                      (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> a)
                      (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> b)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n))
                 (<a href="ACL2____IFF.html">iff</a> (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____MOD.html">mod</a> a n) (<a href="COMMON-LISP____MOD.html">mod</a> b n)) (<a href="COMMON-LISP_____D3.html">=</a> a b)))
        :rule-classes nil)</pre><p><b>Function: </b>congruent</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> congruent (a b n)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____REAL_F2RATIONALP.html">real/rationalp</a> a)
                                   (<a href="ACL2____REAL_F2RATIONALP.html">real/rationalp</a> b)
                                   (<a href="ACL2____REAL_F2RATIONALP.html">real/rationalp</a> n)
                                   (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP_____D3.html">=</a> n 0)))))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> a n) (<a href="COMMON-LISP____MOD.html">mod</a> b n)))</pre><p><b>Theorem: </b>mod-mult</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-mult
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> a)
                      (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> m)
                      (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> n))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____B2.html">+</a> m (<a href="COMMON-LISP_____A2.html">*</a> a n)) n)
                        (<a href="COMMON-LISP____MOD.html">mod</a> m n))))</pre><p><b>Theorem: </b>mod-force</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-force
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="COMMON-LISP_____A2.html">*</a> a n) m)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> m (<a href="COMMON-LISP_____A2.html">*</a> (<a href="COMMON-LISP____1_B2.html">1+</a> a) n))
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> a)
                      (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> m)
                      (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> n))
                 (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____MOD.html">mod</a> m n) (<a href="COMMON-LISP____-.html">-</a> m (<a href="COMMON-LISP_____A2.html">*</a> a n))))
        :rule-classes nil)</pre><p><b>Theorem: </b>mod-bnd-3</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-bnd-3
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> m (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP_____A2.html">*</a> a n) r))
                      (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="COMMON-LISP_____A2.html">*</a> a n) m)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> a)
                      (<a href="ACL2____CASE-SPLIT.html">case-split</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> m))
                      (<a href="ACL2____CASE-SPLIT.html">case-split</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> n)))
                 (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="COMMON-LISP____MOD.html">mod</a> m n) r))
        :rule-classes :linear)</pre><p><b>Theorem: </b>mod-sum</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-sum
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> a) (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> b))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____B2.html">+</a> a (<a href="COMMON-LISP____MOD.html">mod</a> b n)) n)
                        (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____B2.html">+</a> a b) n))))</pre><p><b>Theorem: </b>mod-diff</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-diff
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____CASE-SPLIT.html">case-split</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> a))
                      (<a href="ACL2____CASE-SPLIT.html">case-split</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> b)))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP____-.html">-</a> a (<a href="COMMON-LISP____MOD.html">mod</a> b n)) n)
                        (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP____-.html">-</a> a b) n))))</pre><p><b>Theorem: </b>mod-of-mod</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-of-mod
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____CASE-SPLIT.html">case-split</a> (<a href="ACL2____NATP.html">natp</a> k))
                      (<a href="ACL2____CASE-SPLIT.html">case-split</a> (<a href="ACL2____NATP.html">natp</a> n)))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP____MOD.html">mod</a> x (<a href="COMMON-LISP_____A2.html">*</a> k n)) n)
                        (<a href="COMMON-LISP____MOD.html">mod</a> x n))))</pre><p><b>Theorem: </b>mod-of-mod-cor</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-of-mod-cor
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> b a)
                      (<a href="ACL2____CASE-SPLIT.html">case-split</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> b))
                      (<a href="ACL2____CASE-SPLIT.html">case-split</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> a)))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP____MOD.html">mod</a> x (<a href="COMMON-LISP____EXPT.html">expt</a> 2 a)) (<a href="COMMON-LISP____EXPT.html">expt</a> 2 b))
                        (<a href="COMMON-LISP____MOD.html">mod</a> x (<a href="COMMON-LISP____EXPT.html">expt</a> 2 b)))))</pre><p><b>Theorem: </b>mod-prod</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-prod
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> m)
                      (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> n)
                      (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> k))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> k m) (<a href="COMMON-LISP_____A2.html">*</a> k n))
                        (<a href="COMMON-LISP_____A2.html">*</a> k (<a href="COMMON-LISP____MOD.html">mod</a> m n)))))</pre><p><b>Theorem: </b>mod-mod-times</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-mod-times
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> a)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> b)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)
                      (<a href="COMMON-LISP_____E3.html">&gt;</a> n 0))
                 (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> (<a href="COMMON-LISP____MOD.html">mod</a> a n) b) n)
                    (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> a b) n)))
        :rule-classes nil)</pre><p><b>Theorem: </b>mod-plus-mod-iff</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-plus-mod-iff
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> a)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> b)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> c)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> n)))
                 (<a href="ACL2____IFF.html">iff</a> (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____MOD.html">mod</a> a n) (<a href="COMMON-LISP____MOD.html">mod</a> b n))
                      (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____B2.html">+</a> a c) n) (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____B2.html">+</a> b c) n))))
        :rule-classes nil)</pre><p><b>Theorem: </b>mod-times-mod</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-times-mod
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> a)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> b)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> c)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ZP.html">zp</a> n))
                      (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____MOD.html">mod</a> a n) (<a href="COMMON-LISP____MOD.html">mod</a> b n)))
                 (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> a c) n) (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> b c) n)))
        :rule-classes nil)</pre><p><b>Theorem: </b>mod012</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod012
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> m)
                 (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> m 2) 0)
                     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> m 2) 1)))
        :rule-classes nil)</pre><p><b>Theorem: </b>mod-plus-mod-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-plus-mod-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> a) (<a href="COMMON-LISP____INTEGERP.html">integerp</a> b))
                 (<a href="ACL2____IFF.html">iff</a> (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____B2.html">+</a> a b) 2) (<a href="COMMON-LISP____MOD.html">mod</a> a 2))
                      (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____MOD.html">mod</a> b 2) 0)))
        :rule-classes nil)</pre><p><b>Theorem: </b>mod-mod-2-not-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-mod-2-not-equal
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____ACL2-NUMBERP.html">acl2-numberp</a> m)
                 (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____MOD.html">mod</a> m 2) (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP____1_B2.html">1+</a> m) 2))))
        :rule-classes nil)</pre><p><b>Theorem: </b>mod-2*m+1-rewrite</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-2*m+1-rewrite
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> m)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP____1_B2.html">1+</a> (<a href="COMMON-LISP_____A2.html">*</a> 2 m)) 2) 1)))</pre><p><b>Theorem: </b>mod-neg</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mod-neg
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____POSP.html">posp</a> n) (<a href="COMMON-LISP____INTEGERP.html">integerp</a> m))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP____-.html">-</a> m) n)
                        (<a href="COMMON-LISP____-.html">-</a> (<a href="COMMON-LISP____1-.html">1-</a> n) (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP____1-.html">1-</a> m) n)))))</pre> 
 

</body>
</html>
