<html>
<head>
<meta charset="UTF-8">
<title>Bip32-compliant-addresses-for-limit-p</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=BITCOIN____BIP32-COMPLIANT-ADDRESSES-FOR-LIMIT-P">Click for Bip32-compliant-addresses-for-limit-p in the Full Manual</a></h3>

<p>Check if the address keys under a given chain key in a tree 
          comply with the BIP 32 wallet structure, 
          for a given address index limit.</p><p>The chain key is identified by an account index and a chain index, 
     passed as arguments to this predicate. 
     This predicate essentially checks if the designated chain key 
     has children at all the indices below a limit 
     (passed as another argument to this predicate), 
     and has no other children.</p><p>The adverb 'essentially' above refers to the fact that 
     a child key derivation may fail, 
     and so there may be rare but mathematically possible gaps 
     in the sequence of address keys. 
     The address index limit passed as argument is often 
     the number of address keys under the chain key, 
     except for the rare cases in which there are gaps, 
     or in another case described below.</p><p>Note that the guard of this predicate requires the chain key to be valid. 
     Therefore <span class="tt"><a href="BITCOIN____BIP32-CKD_A2.html">bip32-ckd*</a></span>, as used in the definition of this predicate, 
     returns an error iff the address key is invalid, 
     i.e. iff there is an unavoidable gap in the sequence of address keys. 
     Formally, we require that 
     each address key path whose address index is below the limit 
     either is in the tree or corresponds to an invalid address key.</p><p>If the address index limit is 0, 
     this predicate holds iff the chain key has no children. 
     This corresponds to the valid situation in which, 
     in a compliant wallet, 
     a chain key has been created, 
     but no address keys under it have been created yet.</p><p>The guard of this predicate allows the address index limit to be 
     any natural number, not necessarily representable in 32 bits like indices. 
     Thus, the unlikely but mathematically possible case in which 
     all possible address keys have been created under a chain key, 
     can be accommodated by using 2^{32} (or any larger number) 
     as address index limit. 
     If the address index limit is larger than 2^{32}, 
     then the address index limit is definitely not the number of address keys, 
     even if there are no gaps in the address keys.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Theorem: </b>bip32-compliant-addresses-for-limit-p-necc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 bip32-compliant-addresses-for-limit-p-necc
 (<a href="ACL2____IMPLIES.html">implies</a>
  (<a href="BITCOIN____BIP32-COMPLIANT-ADDRESSES-FOR-LIMIT-P.html">bip32-compliant-addresses-for-limit-p</a>
       tree account-index
       chain-index address-index-limit)
  (<a href="ACL2____IMPLIES.html">implies</a>
     (<a href="ACL2____UBYTE32P.html">ubyte32p</a> address-index)
     (<a href="ACL2____B_A2.html">b*</a> ((path (<a href="COMMON-LISP____LIST.html">list</a> account-index
                      chain-index address-index)))
         (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> address-index
                (<a href="ACL2____NFIX.html">nfix</a> address-index-limit))
             (<a href="COMMON-LISP____OR.html">or</a> (<a href="BITCOIN____BIP32-PATH-IN-TREE-P.html">bip32-path-in-tree-p</a> path tree)
                 (<a href="ACL2____MV-NTH.html">mv-nth</a> 0
                         (<a href="BITCOIN____BIP32-CKD_A2.html">bip32-ckd*</a> (<a href="BITCOIN____BIP32-KEY-TREE-_E3ROOT-KEY.html">bip32-key-tree-&gt;root-key</a> tree)
                                     path)))
             (<a href="COMMON-LISP____NOT.html">not</a> (<a href="BITCOIN____BIP32-PATH-IN-TREE-P.html">bip32-path-in-tree-p</a> path tree)))))))</pre> 
<p><b>Theorem: </b>booleanp-of-bip32-compliant-addresses-for-limit-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> booleanp-of-bip32-compliant-addresses-for-limit-p
        (<a href="ACL2____B_A2.html">b*</a> ((yes/no (<a href="BITCOIN____BIP32-COMPLIANT-ADDRESSES-FOR-LIMIT-P.html">bip32-compliant-addresses-for-limit-p</a>
                          tree account-index
                          chain-index address-index-limit)))
            (<a href="ACL2____BOOLEANP.html">booleanp</a> yes/no))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>bip32-compliant-addresses-for-limit-p-of-bip32-key-tree-fix-tree</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    bip32-compliant-addresses-for-limit-p-of-bip32-key-tree-fix-tree
    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="BITCOIN____BIP32-COMPLIANT-ADDRESSES-FOR-LIMIT-P.html">bip32-compliant-addresses-for-limit-p</a>
                (<a href="BITCOIN____BIP32-KEY-TREE-FIX.html">bip32-key-tree-fix</a> tree)
                account-index
                chain-index address-index-limit)
           (<a href="BITCOIN____BIP32-COMPLIANT-ADDRESSES-FOR-LIMIT-P.html">bip32-compliant-addresses-for-limit-p</a>
                tree account-index
                chain-index address-index-limit)))</pre> 
<p><b>Theorem: </b>bip32-compliant-addresses-for-limit-p-bip32-key-tree-equiv-congruence-on-tree</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 bip32-compliant-addresses-for-limit-p-bip32-key-tree-equiv-congruence-on-tree
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="BITCOIN____BIP32-KEY-TREE-EQUIV.html">bip32-key-tree-equiv</a> tree tree-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="BITCOIN____BIP32-COMPLIANT-ADDRESSES-FOR-LIMIT-P.html">bip32-compliant-addresses-for-limit-p</a>
                      tree account-index
                      chain-index address-index-limit)
                 (<a href="BITCOIN____BIP32-COMPLIANT-ADDRESSES-FOR-LIMIT-P.html">bip32-compliant-addresses-for-limit-p</a>
                      tree-equiv account-index
                      chain-index address-index-limit)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>bip32-compliant-addresses-for-limit-p-of-ubyte32-fix-account-index</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  bip32-compliant-addresses-for-limit-p-of-ubyte32-fix-account-index
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="BITCOIN____BIP32-COMPLIANT-ADDRESSES-FOR-LIMIT-P.html">bip32-compliant-addresses-for-limit-p</a>
              tree (<a href="ACL2____UBYTE32-FIX.html">ubyte32-fix</a> account-index)
              chain-index address-index-limit)
         (<a href="BITCOIN____BIP32-COMPLIANT-ADDRESSES-FOR-LIMIT-P.html">bip32-compliant-addresses-for-limit-p</a>
              tree account-index
              chain-index address-index-limit)))</pre> 
<p><b>Theorem: </b>bip32-compliant-addresses-for-limit-p-ubyte32-equiv-congruence-on-account-index</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 bip32-compliant-addresses-for-limit-p-ubyte32-equiv-congruence-on-account-index
 (<a href="ACL2____IMPLIES.html">implies</a> (acl2::ubyte32-equiv account-index account-index-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="BITCOIN____BIP32-COMPLIANT-ADDRESSES-FOR-LIMIT-P.html">bip32-compliant-addresses-for-limit-p</a>
                      tree account-index
                      chain-index address-index-limit)
                 (<a href="BITCOIN____BIP32-COMPLIANT-ADDRESSES-FOR-LIMIT-P.html">bip32-compliant-addresses-for-limit-p</a>
                      tree account-index-equiv
                      chain-index address-index-limit)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>bip32-compliant-addresses-for-limit-p-of-ubyte32-fix-chain-index</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    bip32-compliant-addresses-for-limit-p-of-ubyte32-fix-chain-index
    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="BITCOIN____BIP32-COMPLIANT-ADDRESSES-FOR-LIMIT-P.html">bip32-compliant-addresses-for-limit-p</a>
                tree
                account-index (<a href="ACL2____UBYTE32-FIX.html">ubyte32-fix</a> chain-index)
                address-index-limit)
           (<a href="BITCOIN____BIP32-COMPLIANT-ADDRESSES-FOR-LIMIT-P.html">bip32-compliant-addresses-for-limit-p</a>
                tree account-index
                chain-index address-index-limit)))</pre> 
<p><b>Theorem: </b>bip32-compliant-addresses-for-limit-p-ubyte32-equiv-congruence-on-chain-index</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 bip32-compliant-addresses-for-limit-p-ubyte32-equiv-congruence-on-chain-index
 (<a href="ACL2____IMPLIES.html">implies</a> (acl2::ubyte32-equiv chain-index chain-index-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="BITCOIN____BIP32-COMPLIANT-ADDRESSES-FOR-LIMIT-P.html">bip32-compliant-addresses-for-limit-p</a>
                      tree account-index
                      chain-index address-index-limit)
                 (<a href="BITCOIN____BIP32-COMPLIANT-ADDRESSES-FOR-LIMIT-P.html">bip32-compliant-addresses-for-limit-p</a>
                      tree account-index
                      chain-index-equiv address-index-limit)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>bip32-compliant-addresses-for-limit-p-of-nfix-address-index-limit</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   bip32-compliant-addresses-for-limit-p-of-nfix-address-index-limit
   (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="BITCOIN____BIP32-COMPLIANT-ADDRESSES-FOR-LIMIT-P.html">bip32-compliant-addresses-for-limit-p</a>
               tree account-index
               chain-index (<a href="ACL2____NFIX.html">nfix</a> address-index-limit))
          (<a href="BITCOIN____BIP32-COMPLIANT-ADDRESSES-FOR-LIMIT-P.html">bip32-compliant-addresses-for-limit-p</a>
               tree account-index
               chain-index address-index-limit)))</pre> 
<p><b>Theorem: </b>bip32-compliant-addresses-for-limit-p-nat-equiv-congruence-on-address-index-limit</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 bip32-compliant-addresses-for-limit-p-nat-equiv-congruence-on-address-index-limit
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____NAT-EQUIV.html">nat-equiv</a> address-index-limit
                     address-index-limit-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="BITCOIN____BIP32-COMPLIANT-ADDRESSES-FOR-LIMIT-P.html">bip32-compliant-addresses-for-limit-p</a>
                      tree account-index
                      chain-index address-index-limit)
                 (<a href="BITCOIN____BIP32-COMPLIANT-ADDRESSES-FOR-LIMIT-P.html">bip32-compliant-addresses-for-limit-p</a>
                      tree account-index
                      chain-index address-index-limit-equiv)))
 :rule-classes :congruence)</pre> 

</body>
</html>
