<html>
<head>
<meta charset="UTF-8">
<title>Irrelevant-formals-info</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____IRRELEVANT-FORMALS-INFO">Click for Irrelevant-formals-info in the Full Manual</a></h3>

<p>Determine whether <a href="ACL2____IRRELEVANT-FORMALS.html">irrelevant-formals</a> are OK in definitions.</p><p>For a related utility that can 
 cause an error, see <a href="ACL2____CHK-IRRELEVANT-FORMALS-OK.html">chk-irrelevant-formals-ok</a>.</p> 
 
 <pre class="code">General Form:

(<a href="ACL2____IRRELEVANT-FORMALS-INFO.html">irrelevant-formals-info</a>
 def-or-defs ; a definition, a list of definitions, or of the form
             ; (<a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a> def1 ... defk)
 &amp;key
 wrld   ; ACL2 world; if missing or nil, this is (<a href="ACL2____W.html">w</a> state)
 ctx    ; a ctxp to use in error messages; if this is nil or missing,
        ; then ctx is 'irrelevant-formals-info
 statep ; certain defaults come from state when statep is true;
        ; default is nil
 dcls   ; which parts of the given declare forms to use
 result ; the form of the result; default is :default
 )</pre> 
 
 <p>where all arguments are evaluated, <span class="v">dcls</span> and <span class="v">result</span> are as 
 described below, and the other arguments are as described above.  The case 
 that <span class="v">def-or-defs</span> is <span class="v">(<a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a> def1 ... defk)</span> is treated 
 identically to the case it is <span class="v">(def1 ... defk)</span>.</p> 
 
 <pre class="code">Simple Example Form:

; This returns the list (X1 X3 X4 X5) of irrelevant formals.
(<a href="ACL2____IRRELEVANT-FORMALS-INFO.html">irrelevant-formals-info</a>
 '(<a href="COMMON-LISP____DEFUN.html">defun</a> f (x0 x1 x2 x3 x4 x5)
    (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____NATP.html">natp</a> x2)))
    (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x0) (f (<a href="COMMON-LISP____CDR.html">cdr</a> x0) x1 x2 x5 x4 x3) nil)))</pre> 
 
 <p>The keyword arguments have defaults that may suffice for most users.  When 
 <span class="v">:dcls</span> and <span class="v">:results</span> are omitted, the computation of irrelevant 
 formals ignores ``<span class="v">irrelevant</span>'' declarations.  That key point is probably 
 all you need to know unless you use the <span class="v">:dcls</span> or <span class="v">:results</span> keywords; 
 here is their documentation.</p> 
 
 <p>The value of <span class="v">:dcls</span> should be a subset of the list 
 <span class="v">(:measure :guard :ignore :ignorable :irrelevant)</span>, where these keywords 
 mean (respectively) that the <span class="v">:measure</span> and <span class="v">:guard</span> <span class="tt"><a href="ACL2____XARGS.html">xargs</a></span> 
 declarations as well as the <span class="v">ignore</span>, <span class="v">ignorable</span>, and <span class="v">irrelevant</span> 
 declararations are taken into account when computing the irrelevant formals. 
 This list is the default unless the value of <span class="v">:result</span> is 
 <span class="v">:default</span> (which is its default), in which case <span class="v">:dcls</span> defaults to 
 <span class="v">(:measure :guard :ignore :ignorable)</span>.  This behavior supports the common 
 usage of omitting the <span class="v">:dcls</span> and <span class="v">:result</span> arguments in order to 
 compute irrelevant formals, without considering which irrelevant formals may 
 be declared.</p> 
 
 <p>The legal values of <span class="v">:result</span> and their meanings are as follows.</p> 
 
 <ul> 
 
 <li>
<span class="v">:default</span><br> 
 If <span class="v">def-or-defs</span> is a single definition (or a list containing just a single 
 definition), the return value is a list of the irrelevant formals.  Otherwise 
 <span class="v">def-or-defs</span> is a list of two or more definitions.  If it defines function 
 symbols <span class="v">f1</span>, ..., <span class="v">fk</span> where k&gt;1, then the result is an association 
 list that associates each <span class="v">fi</span> with a list of the formals of of <span class="v">fi</span> 
 that are irrelevant.  As noted above, unless <span class="v">:dcls</span> is supplied 
 explicitly, the computation of irrelevant formals is done without the use of 
 any <span class="v">irrelevant</span> declarations.</li> 
 
 <li>
<span class="v">:raw</span><br> 
 The result is <span class="v">nil</span> if and only if the irrelevant-formals check passes. 
 The form of a non-<span class="v">nil</span> result is described below.</li> 
 
 <li>
<span class="v">:msg</span><br> 
 The result is <span class="v">nil</span> if and only if the irrelevant-formals check passes. 
 If the result is non-<span class="v">nil</span>, then it is a message (see <a href="ACL2____MSGP.html">msgp</a>) 
 explaining the failure, which is suitable for printing with the <span class="v">~@</span> 
 directive of <span class="tt"><a href="ACL2____FMT.html">fmt</a></span>.</li> 
 
 </ul> 
 
 <pre class="code">More Example Forms:

; This returns (X1 X3 X4 X5) as in the ``Simple Example Form'' above,
; thus illustrating that by default, `irrelevant' declarations are
; ignored (as explained earlier above).
(<a href="ACL2____IRRELEVANT-FORMALS-INFO.html">irrelevant-formals-info</a>
 '(<a href="COMMON-LISP____DEFUN.html">defun</a> f (x0 x1 x2 x3 x4 x5)
    (<a href="COMMON-LISP____DECLARE.html">declare</a> (irrelevant x1 x3 x5 x4)
             (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____NATP.html">natp</a> x2)))
    (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x0) (f (<a href="COMMON-LISP____CDR.html">cdr</a> x0) x1 x2 x5 x4 x3) nil)))

; Same as above.
(<a href="ACL2____IRRELEVANT-FORMALS-INFO.html">irrelevant-formals-info</a>
 '((<a href="COMMON-LISP____DEFUN.html">defun</a> f (x0 x1 x2 x3 x4 x5)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____NATP.html">natp</a> x2)))
     (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x0) (f (<a href="COMMON-LISP____CDR.html">cdr</a> x0) x1 x2 x5 x4 x3) nil))))

; Unlike the examples above, this time X2 is included in the result,
; because :guard is not in the list specified by :dcls.
(<a href="ACL2____IRRELEVANT-FORMALS-INFO.html">irrelevant-formals-info</a>
 '((<a href="COMMON-LISP____DEFUN.html">defun</a> f (x0 x1 x2 x3 x4 x5)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____NATP.html">natp</a> x2)))
     (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x0) (f (<a href="COMMON-LISP____CDR.html">cdr</a> x0) x1 x2 x5 x4 x3) nil)))
 :dcls nil)

; This returns ((F1 Y) (F2 Y)) because y is an irrelevant formal
; for both f1 and f2.
(<a href="ACL2____IRRELEVANT-FORMALS-INFO.html">irrelevant-formals-info</a>
 '((<a href="COMMON-LISP____DEFUN.html">defun</a> f1 (x y)
     (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x) (f2 (<a href="COMMON-LISP____CDR.html">cdr</a> x) y) t))
   (<a href="COMMON-LISP____DEFUN.html">defun</a> f2 (x y)
     (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x) (f1 (<a href="COMMON-LISP____CDR.html">cdr</a> x) y) nil))))

; This is handled exactly as just above.
(<a href="ACL2____IRRELEVANT-FORMALS-INFO.html">irrelevant-formals-info</a>
 '(<a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a>
   (<a href="COMMON-LISP____DEFUN.html">defun</a> f1 (x y)
     (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x) (f2 (<a href="COMMON-LISP____CDR.html">cdr</a> x) y) t))
   (<a href="COMMON-LISP____DEFUN.html">defun</a> f2 (x y)
     (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x) (f1 (<a href="COMMON-LISP____CDR.html">cdr</a> x) y) nil))))

; This is as just above, except that the missing argument in the call
; of f2 in the body of f1, a hard ACL2 error occurs:
(<a href="ACL2____IRRELEVANT-FORMALS-INFO.html">irrelevant-formals-info</a>
 '(<a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a>
   (<a href="COMMON-LISP____DEFUN.html">defun</a> f1 (x y)
     (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x) (f2 (<a href="COMMON-LISP____CDR.html">cdr</a> x)) t))
   (<a href="COMMON-LISP____DEFUN.html">defun</a> f2 (x y)
     (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x) (f1 (<a href="COMMON-LISP____CDR.html">cdr</a> x) y) nil))))

; Because of the :result argument below, we get a msgp from the
; irrelevance check.  Try running (<a href="ACL2____FMX.html">fmx</a> "~@0" x) where x is bound
; to this result.
(<a href="ACL2____IRRELEVANT-FORMALS-INFO.html">irrelevant-formals-info</a>
 '(<a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a>
   (<a href="COMMON-LISP____DEFUN.html">defun</a> f1 (x y)
     (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x) (f2 (<a href="COMMON-LISP____CDR.html">cdr</a> x) y) t))
   (<a href="COMMON-LISP____DEFUN.html">defun</a> f2 (x y)
     (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x) (f1 (<a href="COMMON-LISP____CDR.html">cdr</a> x) y) nil)))
 :result :msg)</pre> 
 
 <p>When keyword <span class="v">:result</span> is <span class="v">:raw</span> and the <a href="ACL2____IRRELEVANT-FORMALS.html">irrelevant-formals</a> 
 check fails, a list of two lists is returned: a list the associates each key, 
 a function name, with the of the formals of that function that are declared 
 irrelevant but are not; and a list of slots <span class="v">(function-name formal-position
 . formal-name)</span>, where the positions are zero-based, for the formals that are 
 irrelevant but not declared so.  Here is an example.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="ACL2____IRRELEVANT-FORMALS-INFO.html">irrelevant-formals-info</a>
        '(<a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a>
          (<a href="ACL2____DEFUND.html">defund</a> f1 (x y z)
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (irrelevant z))
            (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x) (f2 (<a href="COMMON-LISP____CDR.html">cdr</a> x) y z) z))
          (<a href="ACL2____DEFUND.html">defund</a> f2 (x y z)
            (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x) (f1 (<a href="COMMON-LISP____CDR.html">cdr</a> x) y z) nil)))
        :result :raw)
(((F1 Z)) ((F1 1 . Y) (F2 1 . Y)))
ACL2 !&gt;</pre> 
 
 <p>Remarks.</p> 
 
 <ul> 
 
 <li>The use of <span class="tt"><a href="ACL2____SET-IRRELEVANT-FORMALS-OK.html">set-irrelevant-formals-ok</a></span> has no effect on the result; 
 that is, the value of <span class="v">:irrelevant-formals-info</span> in the <span class="tt"><a href="ACL2____ACL2-DEFAULTS-TABLE.html">ACL2-defaults-table</a></span> does not affect this utility.</li> 
 
 <li>Each definition must be a call of a macro in the following list: 
 <span class="v">(<a href="COMMON-LISP____DEFUN.html">defun</a> defund defun-nx defund-nx
       defun$ defunt defun-inline defund-inline
       defun-notinline defund-notinline)</span>.</li> 
 
 <li>As noted above, an error occurs by default if the given definitions are 
 determined to be ill-formed.  However, only some of the usual checks for 
 <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> events are performed; for example, translation of measures, 
 guards, and bodies is only for logic, not execution, and only partial checks 
 are made for the <a href="COMMON-LISP____DECLARE.html">declare</a> forms.  The point of this tool is to perform 
 <a href="ACL2____IRRELEVANT-FORMALS.html">irrelevant-formals</a> checks, not to do complete checks for the given 
 forms.</li> 
 
 </ul>
</body>
</html>
