<html>
<head>
<meta charset="UTF-8">
<title>Defmapping-gen-appconds</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____DEFMAPPING-GEN-APPCONDS">Click for Defmapping-gen-appconds in the Full Manual</a></h3>

<p>Generate the applicability conditions.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(defmapping-gen-appconds doma$ domb$ alpha$ beta$ a1...an b1...bm 
                         beta-of-alpha-thm$ alpha-of-beta-thm$ 
                         guard-thms$ unconditional$ state) 
 
  → 
appconds</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">doma$</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____PSEUDO-TERMFNP.html">pseudo-termfnp</a> doma$)</span>.</font>
</dd> 
  <dd>
<span class="tt">domb$</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____PSEUDO-TERMFNP.html">pseudo-termfnp</a> domb$)</span>.</font>
</dd> 
  <dd>
<span class="tt">alpha$</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____PSEUDO-TERMFNP.html">pseudo-termfnp</a> alpha$)</span>.</font>
</dd> 
  <dd>
<span class="tt">beta$</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____PSEUDO-TERMFNP.html">pseudo-termfnp</a> beta$)</span>.</font>
</dd> 
  <dd>
<span class="tt">a1...an</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> a1...an)</span>.</font>
</dd> 
  <dd>
<span class="tt">b1...bm</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> b1...bm)</span>.</font>
</dd> 
  <dd>
<span class="tt">beta-of-alpha-thm$</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____BOOLEANP.html">booleanp</a> beta-of-alpha-thm$)</span>.</font>
</dd> 
  <dd>
<span class="tt">alpha-of-beta-thm$</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____BOOLEANP.html">booleanp</a> alpha-of-beta-thm$)</span>.</font>
</dd> 
  <dd>
<span class="tt">guard-thms$</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____BOOLEANP.html">booleanp</a> guard-thms$)</span>.</font>
</dd> 
  <dd>
<span class="tt">unconditional$</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____BOOLEANP.html">booleanp</a> unconditional$)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">appconds</span> — A <span class="tt"><a href="ACL2____EVMAC-APPCOND-LISTP.html">evmac-appcond-listp</a></span>.</dd> 
 
</dl></div> 
 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>defmapping-gen-appconds</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 defmapping-gen-appconds
 (doma$ domb$ alpha$ beta$ a1...an b1...bm
        beta-of-alpha-thm$ alpha-of-beta-thm$
        guard-thms$ unconditional$ state)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (<a href="ACL2____STATE.html">state</a>)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERMFNP.html">pseudo-termfnp</a> doma$)
                             (<a href="ACL2____PSEUDO-TERMFNP.html">pseudo-termfnp</a> domb$)
                             (<a href="ACL2____PSEUDO-TERMFNP.html">pseudo-termfnp</a> alpha$)
                             (<a href="ACL2____PSEUDO-TERMFNP.html">pseudo-termfnp</a> beta$)
                             (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> a1...an)
                             (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> b1...bm)
                             (<a href="ACL2____BOOLEANP.html">booleanp</a> beta-of-alpha-thm$)
                             (<a href="ACL2____BOOLEANP.html">booleanp</a> alpha-of-beta-thm$)
                             (<a href="ACL2____BOOLEANP.html">booleanp</a> guard-thms$)
                             (<a href="ACL2____BOOLEANP.html">booleanp</a> unconditional$))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((__function__ 'defmapping-gen-appconds))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
  (<a href="ACL2____B_A2.html">b*</a>
   ((wrld (<a href="ACL2____W.html">w</a> state))
    (n (<a href="ACL2____ARITY.html">arity</a> doma$ wrld))
    (m (<a href="ACL2____ARITY.html">arity</a> domb$ wrld)))
   (<a href="COMMON-LISP____APPEND.html">append</a>
    (<a href="ACL2____MAKE-EVMAC-APPCOND_F3.html">make-evmac-appcond?</a>
     :alpha-image
     (<a href="ACL2____B_A2.html">b*</a>
      ((antecedent (<a href="ACL2____APPLY-TERM.html">apply-term</a> doma$ a1...an))
       (consequent
        (<a href="COMMON-LISP____IF.html">if</a>
          (<a href="COMMON-LISP_____D3.html">=</a> m 1)
          (<a href="ACL2____APPLY-TERM_A2.html">apply-term*</a> domb$ (<a href="ACL2____APPLY-TERM.html">apply-term</a> alpha$ a1...an))
          (<a href="ACL2____MAKE-MV-LET-CALL.html">make-mv-let-call</a> 'mv
                            b1...bm :all (<a href="ACL2____APPLY-TERM.html">apply-term</a> alpha$ a1...an)
                            (<a href="ACL2____APPLY-TERM.html">apply-term</a> domb$ b1...bm)))))
      (<a href="ACL2____IMPLICATE.html">implicate</a> antecedent consequent)))
    (<a href="ACL2____MAKE-EVMAC-APPCOND_F3.html">make-evmac-appcond?</a>
     :beta-image
     (<a href="ACL2____B_A2.html">b*</a>
      ((antecedent (<a href="ACL2____APPLY-TERM.html">apply-term</a> domb$ b1...bm))
       (consequent
        (<a href="COMMON-LISP____IF.html">if</a>
           (<a href="COMMON-LISP_____D3.html">=</a> n 1)
           (<a href="ACL2____APPLY-TERM_A2.html">apply-term*</a> doma$ (<a href="ACL2____APPLY-TERM.html">apply-term</a> beta$ b1...bm))
           (<a href="ACL2____MAKE-MV-LET-CALL.html">make-mv-let-call</a> 'mv
                             a1...an :all (<a href="ACL2____APPLY-TERM.html">apply-term</a> beta$ b1...bm)
                             (<a href="ACL2____APPLY-TERM.html">apply-term</a> doma$ a1...an)))))
      (<a href="ACL2____IMPLICATE.html">implicate</a> antecedent consequent)))
    (<a href="ACL2____MAKE-EVMAC-APPCOND_F3.html">make-evmac-appcond?</a>
     :beta-of-alpha
     (<a href="ACL2____B_A2.html">b*</a>
      ((antecedent (<a href="COMMON-LISP____IF.html">if</a> unconditional$
                       *t* (<a href="ACL2____APPLY-TERM.html">apply-term</a> doma$ a1...an)))
       (consequent
        (<a href="COMMON-LISP____IF.html">if</a>
         (<a href="COMMON-LISP_____D3.html">=</a> n 1)
         (<a href="COMMON-LISP____IF.html">if</a>
          (<a href="COMMON-LISP_____D3.html">=</a> m 1)
          (<a href="ACL2____B_A2.html">b*</a> ((a (<a href="COMMON-LISP____CAR.html">car</a> a1...an)))
              (<a href="COMMON-LISP____CONS.html">cons</a> 'equal
                    (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="ACL2____APPLY-TERM_A2.html">apply-term*</a> beta$ (<a href="ACL2____APPLY-TERM_A2.html">apply-term*</a> alpha$ a))
                          (<a href="COMMON-LISP____CONS.html">cons</a> a 'nil))))
          (<a href="ACL2____B_A2.html">b*</a>
           ((b1...bm
               (<a href="ACL2____DEFMAPPING-DIFFERENTIATE-A_F2B-VARS.html">defmapping-differentiate-a/b-vars</a> b1...bm a1...an)))
           (<a href="ACL2____MAKE-MV-LET-CALL.html">make-mv-let-call</a>
                'mv
                b1...bm
                :all (<a href="ACL2____APPLY-TERM_A2.html">apply-term*</a> alpha$ (<a href="COMMON-LISP____CAR.html">car</a> a1...an))
                (<a href="COMMON-LISP____CONS.html">cons</a> 'equal
                      (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="ACL2____APPLY-TERM.html">apply-term</a> beta$ b1...bm)
                            (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> a1...an) 'nil))))))
         (<a href="COMMON-LISP____IF.html">if</a>
          (<a href="COMMON-LISP_____D3.html">=</a> m 1)
          (<a href="ACL2____B_A2.html">b*</a> ((aa1...aan (<a href="ACL2____DEFMAPPING-GEN-VAR-AA_F2BB.html">defmapping-gen-var-aa/bb</a> a1...an)))
              (<a href="ACL2____MAKE-MV-LET-CALL.html">make-mv-let-call</a>
                   'mv
                   aa1...aan :all
                   (<a href="ACL2____APPLY-TERM_A2.html">apply-term*</a> beta$ (<a href="ACL2____APPLY-TERM.html">apply-term</a> alpha$ a1...an))
                   (<a href="ACL2____CONJOIN-EQUALITIES.html">conjoin-equalities</a> aa1...aan a1...an)))
          (<a href="ACL2____B_A2.html">b*</a>
           ((aa1...aan (<a href="ACL2____DEFMAPPING-GEN-VAR-AA_F2BB.html">defmapping-gen-var-aa/bb</a> a1...an))
            (b1...bm
               (<a href="ACL2____DEFMAPPING-DIFFERENTIATE-A_F2B-VARS.html">defmapping-differentiate-a/b-vars</a> b1...bm a1...an)))
           (<a href="ACL2____MAKE-MV-LET-CALL.html">make-mv-let-call</a>
                'mv
                b1...bm :all (<a href="ACL2____APPLY-TERM.html">apply-term</a> alpha$ a1...an)
                (<a href="ACL2____MAKE-MV-LET-CALL.html">make-mv-let-call</a>
                     'mv
                     aa1...aan
                     :all (<a href="ACL2____APPLY-TERM.html">apply-term</a> beta$ b1...bm)
                     (<a href="ACL2____CONJOIN-EQUALITIES.html">conjoin-equalities</a> aa1...aan a1...an))))))))
      (<a href="ACL2____IMPLICATE.html">implicate</a> antecedent consequent))
     :when beta-of-alpha-thm$)
    (<a href="ACL2____MAKE-EVMAC-APPCOND_F3.html">make-evmac-appcond?</a>
     :alpha-of-beta
     (<a href="ACL2____B_A2.html">b*</a>
      ((antecedent (<a href="COMMON-LISP____IF.html">if</a> unconditional$
                       *t* (<a href="ACL2____APPLY-TERM.html">apply-term</a> domb$ b1...bm)))
       (consequent
        (<a href="COMMON-LISP____IF.html">if</a>
         (<a href="COMMON-LISP_____D3.html">=</a> n 1)
         (<a href="COMMON-LISP____IF.html">if</a>
          (<a href="COMMON-LISP_____D3.html">=</a> m 1)
          (<a href="ACL2____B_A2.html">b*</a> ((b (<a href="COMMON-LISP____CAR.html">car</a> b1...bm)))
              (<a href="COMMON-LISP____CONS.html">cons</a> 'equal
                    (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="ACL2____APPLY-TERM_A2.html">apply-term*</a> alpha$ (<a href="ACL2____APPLY-TERM_A2.html">apply-term*</a> beta$ b))
                          (<a href="COMMON-LISP____CONS.html">cons</a> b 'nil))))
          (<a href="ACL2____B_A2.html">b*</a> ((bb1...bbm (<a href="ACL2____DEFMAPPING-GEN-VAR-AA_F2BB.html">defmapping-gen-var-aa/bb</a> b1...bm)))
              (<a href="ACL2____MAKE-MV-LET-CALL.html">make-mv-let-call</a>
                   'mv
                   bb1...bbm :all
                   (<a href="ACL2____APPLY-TERM_A2.html">apply-term*</a> alpha$ (<a href="ACL2____APPLY-TERM.html">apply-term</a> beta$ b1...bm))
                   (<a href="ACL2____CONJOIN-EQUALITIES.html">conjoin-equalities</a> bb1...bbm b1...bm))))
         (<a href="COMMON-LISP____IF.html">if</a>
          (<a href="COMMON-LISP_____D3.html">=</a> m 1)
          (<a href="ACL2____B_A2.html">b*</a>
           ((b (<a href="COMMON-LISP____CAR.html">car</a> b1...bm))
            (a1...an
               (<a href="ACL2____DEFMAPPING-DIFFERENTIATE-A_F2B-VARS.html">defmapping-differentiate-a/b-vars</a> a1...an b1...bm)))
           (<a href="ACL2____MAKE-MV-LET-CALL.html">make-mv-let-call</a> 'mv
                             a1...an :all (<a href="ACL2____APPLY-TERM_A2.html">apply-term*</a> beta$ b)
                             (<a href="COMMON-LISP____CONS.html">cons</a> 'equal
                                   (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="ACL2____APPLY-TERM.html">apply-term</a> alpha$ a1...an)
                                         (<a href="COMMON-LISP____CONS.html">cons</a> b 'nil)))))
          (<a href="ACL2____B_A2.html">b*</a>
           ((bb1...bbm (<a href="ACL2____DEFMAPPING-GEN-VAR-AA_F2BB.html">defmapping-gen-var-aa/bb</a> b1...bm))
            (a1...an
               (<a href="ACL2____DEFMAPPING-DIFFERENTIATE-A_F2B-VARS.html">defmapping-differentiate-a/b-vars</a> a1...an b1...bm)))
           (<a href="ACL2____MAKE-MV-LET-CALL.html">make-mv-let-call</a>
                'mv
                a1...an :all (<a href="ACL2____APPLY-TERM.html">apply-term</a> beta$ b1...bm)
                (<a href="ACL2____MAKE-MV-LET-CALL.html">make-mv-let-call</a>
                     'mv
                     bb1...bbm
                     :all (<a href="ACL2____APPLY-TERM.html">apply-term</a> alpha$ a1...an)
                     (<a href="ACL2____CONJOIN-EQUALITIES.html">conjoin-equalities</a> bb1...bbm b1...bm))))))))
      (<a href="ACL2____IMPLICATE.html">implicate</a> antecedent consequent))
     :when alpha-of-beta-thm$)
    (<a href="ACL2____MAKE-EVMAC-APPCOND_F3.html">make-evmac-appcond?</a>
     :doma-guard (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> doma$) (<a href="ACL2____UGUARD.html">uguard</a> doma$ wrld))
                       (t (<a href="ACL2____TERM-GUARD-OBLIGATION.html">term-guard-obligation</a> (<a href="ACL2____LAMBDA-BODY.html">lambda-body</a> doma$)
                                                 state)))
     :when guard-thms$)
    (<a href="ACL2____MAKE-EVMAC-APPCOND_F3.html">make-evmac-appcond?</a>
     :domb-guard (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> domb$) (<a href="ACL2____UGUARD.html">uguard</a> domb$ wrld))
                       (t (<a href="ACL2____TERM-GUARD-OBLIGATION.html">term-guard-obligation</a> (<a href="ACL2____LAMBDA-BODY.html">lambda-body</a> domb$)
                                                 state)))
     :when guard-thms$)
    (<a href="ACL2____MAKE-EVMAC-APPCOND_F3.html">make-evmac-appcond?</a>
     :alpha-guard
     (<a href="ACL2____B_A2.html">b*</a>
      ((alpha-formals (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> alpha$) (<a href="ACL2____FORMALS.html">formals</a> alpha$ wrld))
                            (t (<a href="ACL2____LAMBDA-FORMALS.html">lambda-formals</a> alpha$))))
       (alpha-guard
            (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> alpha$) (<a href="ACL2____UGUARD.html">uguard</a> alpha$ wrld))
                  (t (<a href="ACL2____TERM-GUARD-OBLIGATION.html">term-guard-obligation</a> (<a href="ACL2____LAMBDA-BODY.html">lambda-body</a> alpha$)
                                            state)))))
      (<a href="ACL2____IMPLICATE.html">implicate</a> (<a href="ACL2____APPLY-TERM.html">apply-term</a> doma$ a1...an)
                 (<a href="ACL2____SUBCOR-VAR.html">subcor-var</a> alpha-formals a1...an alpha-guard)))
     :when guard-thms$)
    (<a href="ACL2____MAKE-EVMAC-APPCOND_F3.html">make-evmac-appcond?</a>
     :beta-guard
     (<a href="ACL2____B_A2.html">b*</a> ((beta-formals (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> beta$) (<a href="ACL2____FORMALS.html">formals</a> beta$ wrld))
                              (t (<a href="ACL2____LAMBDA-FORMALS.html">lambda-formals</a> beta$))))
          (beta-guard
               (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> beta$) (<a href="ACL2____UGUARD.html">uguard</a> beta$ wrld))
                     (t (<a href="ACL2____TERM-GUARD-OBLIGATION.html">term-guard-obligation</a> (<a href="ACL2____LAMBDA-BODY.html">lambda-body</a> beta$)
                                               state)))))
         (<a href="ACL2____IMPLICATE.html">implicate</a> (<a href="ACL2____APPLY-TERM.html">apply-term</a> domb$ b1...bm)
                    (<a href="ACL2____SUBCOR-VAR.html">subcor-var</a> beta-formals b1...bm beta-guard)))
     :when guard-thms$)))))</pre> 

</body>
</html>
