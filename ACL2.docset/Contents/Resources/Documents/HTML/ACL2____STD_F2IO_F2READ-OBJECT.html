<html>
<head>
<meta charset="UTF-8">
<title>Std/io/read-object</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____STD_F2IO_F2READ-OBJECT">Click for Std/io/read-object in the Full Manual</a></h3>

<p>Read one object from an open <span class="v">:object</span> stream.</p><p><b>Signature:</b> <span class="tt">(read-object channel state-state)</span> returns <span class="v">(<a href="ACL2____MV.html">mv</a> eofp obj
state)</span>.</p> 
 
<ul> 
 
<li>
<span class="v">channel</span> is a symbol that must refer to an open <span class="v">:object</span> input 
channel; see <a href="ACL2____OPEN-INPUT-CHANNEL.html">open-input-channel</a>.</li> 
 
<li>
<span class="v">state</span> is the ACL2 <a href="ACL2____STATE.html">state</a>.</li> 
 
</ul> 
 
<p>This is a <a href="ACL2____LOGIC.html">logic</a>-mode function, but its logical definition is tricky; 
see <a href="ACL2____LOGICAL-STORY-OF-IO.html">logical-story-of-io</a>.  The main logical consequence is the updating 
of state.</p> 
 
<p>Under the hood, we use the Lisp reader to try to read an object from the 
Lisp input stream that is associated with <span class="v">channel</span>.</p> 
 
<p>Ideally, the input stream contains well-formed S-expressions that are free 
of "bad" objects like <span class="v">0.75</span>, symbols from packages that ACL2 doesn't know 
about, etc; see <a href="ACL2____About_02Types.html">About Types</a>.  In this case, <span class="v">read-object</span> 
reads the first S-expression in the file and returns it as <span class="v">obj</span>, setting 
<span class="v">eofp</span> to <span class="v">nil</span>.  If there are no more S-expressions in the file, 
<span class="v">eofp</span> is <span class="v">t</span> and <span class="v">obj</span> is <span class="v">nil</span>.</p> 
 
<p>But the input stream can also be malformed.  For instance, we might 
encounter malformed S-expressions without enough closing parens, or bad objects 
like <span class="v">0.75</span>.  These sorts of problems will cause hard errors or raw Lisp 
errors!</p> 
 
<p>Note that if the input contains plain symbols without explicit package name 
prefixes, e.g., <span class="v">foo</span> instead of <span class="v">acl2::foo</span>, then these symbols will be 
treated as coming from the current package.  If that isn't what you want, you 
can explicily call <a href="COMMON-LISP____IN-PACKAGE.html">in-package</a> to switch into whatever package you want 
to be the default.  For example, if the file <span class="v">temp</span> contains exactly:</p> 
 
<pre class="code">foo</pre> 
 
<p>Then the following book:</p> 
 
<pre class="code">(<a href="COMMON-LISP____IN-PACKAGE.html">in-package</a> "ACL2")
(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "std/util/bstar" :dir :system)
(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "centaur/vl/portcullis" :dir :system)

(<a href="ACL2____MAKE-EVENT.html">make-event</a>
 (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?err ?val state) (<a href="COMMON-LISP____IN-PACKAGE.html">in-package</a> "VL"))
      ((<a href="ACL2____MV.html">mv</a> channel state)   (<a href="ACL2____OPEN-INPUT-CHANNEL.html">open-input-channel</a> "temp" :object state))
      ((<a href="ACL2____MV.html">mv</a> ?eofp obj state) (<a href="ACL2____READ-OBJECT.html">read-object</a> channel state))
      (<a href="ACL2____STATE.html">state</a>                (<a href="ACL2____CLOSE-INPUT-CHANNEL.html">close-input-channel</a> channel state)))
   (<a href="ACL2____VALUE.html">value</a> `(<a href="ACL2____DEFCONST.html">defconst</a> *foo* ',obj))))</pre> 
 
<p>Defines <span class="v">*foo*</span> as the symbol <span class="v">vl::foo</span>, instead of 
<span class="v">acl2::foo</span>.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Theorem: </b>state-p1-of-read-object</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> state-p1-of-read-object
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (state-p1 state)
                      (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> channel)
                      (open-input-channel-p1 channel
                                             :object state))
                 (state-p1 (<a href="ACL2____MV-NTH.html">mv-nth</a> 2 (<a href="ACL2____READ-OBJECT.html">read-object</a> channel state)))))</pre> 
<p><b>Theorem: </b>open-input-channel-p1-of-read-object</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     open-input-channel-p1-of-read-object
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (state-p1 state)
                   (open-input-channel-p1 channel
                                          :object state))
              (open-input-channel-p1
                   channel
                   :object (<a href="ACL2____MV-NTH.html">mv-nth</a> 2 (<a href="ACL2____READ-OBJECT.html">read-object</a> channel state)))))</pre> 
 
 
<p><b>Theorem: </b>state-preserved-by-read-object-when-eof</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> state-preserved-by-read-object-when-eof
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> 0 (<a href="ACL2____READ-OBJECT.html">read-object</a> channel state))
                      (state-p1 state)
                      (open-input-channel-p1 channel
                                             :object state))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> 2 (<a href="ACL2____READ-OBJECT.html">read-object</a> channel state))
                        state)))</pre> 

</body>
</html>
