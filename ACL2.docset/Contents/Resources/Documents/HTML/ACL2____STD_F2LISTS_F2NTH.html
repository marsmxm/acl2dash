<html>
<head>
<meta charset="UTF-8">
<title>Std/lists/nth</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____STD_F2LISTS_F2NTH">Click for Std/lists/nth in the Full Manual</a></h3>

<p>Lemmas about <a href="COMMON-LISP____NTH.html">nth</a> available in the <a href="ACL2____STD_F2LISTS.html">std/lists</a> library.</p> 
 
<h3>Definitions and Theorems</h3><h4>Trivial reductions</h4><p><b>Theorem: </b>nth-when-atom</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nth-when-atom
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTH.html">nth</a> n x) nil)))</pre> 
<p><b>Theorem: </b>nth-when-zp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nth-when-zp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____ZP.html">zp</a> n)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTH.html">nth</a> n x) (<a href="COMMON-LISP____CAR.html">car</a> x))))</pre> 
<p><b>Theorem: </b>nth-of-nil</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nth-of-nil (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTH.html">nth</a> n nil) nil))</pre> 
<p><b>Theorem: </b>nth-of-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nth-of-list-fix
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTH.html">nth</a> n (<a href="ACL2____LIST-FIX.html">list-fix</a> x)) (<a href="COMMON-LISP____NTH.html">nth</a> n x)))</pre> 
<p><b>Theorem: </b>nth-of-nfix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nth-of-nfix
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTH.html">nth</a> (<a href="ACL2____NFIX.html">nfix</a> n) x) (<a href="COMMON-LISP____NTH.html">nth</a> n x)))</pre> 
<p>Note: Matt Kaufmann reported that the following lemma got expensive in 
   one of his books, so we now disable it by default and instead leave enabled 
   a -cheap rule with a backchain limit.</p><p><b>Theorem: </b>nth-when-too-large</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nth-when-too-large
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____LEN.html">len</a> x) (<a href="ACL2____NFIX.html">nfix</a> n))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTH.html">nth</a> n x) nil)))</pre> 
<p><b>Theorem: </b>nth-when-too-large-cheap</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nth-when-too-large-cheap
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____LEN.html">len</a> x) (<a href="ACL2____NFIX.html">nfix</a> n))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTH.html">nth</a> n x) nil))
        :rule-classes ((:rewrite :backchain-limit-lst 1)))</pre> 
<h4>Lemmas about <a href="ACL2____ACL2-COUNT.html">ACL2-count</a> of nth</h4><p><b>Theorem: </b>acl2-count-of-nth-linear</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> acl2-count-of-nth-linear
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x)
                 (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> (<a href="COMMON-LISP____NTH.html">nth</a> i x))
                    (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> x)))
        :rule-classes :linear)</pre> 
<p><b>Theorem: </b>acl2-count-of-nth-linear-weak</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> acl2-count-of-nth-linear-weak
        (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> (<a href="COMMON-LISP____NTH.html">nth</a> i x))
            (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> x))
        :rule-classes :linear)</pre> 
<p><b>Theorem: </b>acl2-count-of-nth-rewrite</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> acl2-count-of-nth-rewrite
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> (<a href="COMMON-LISP____NTH.html">nth</a> i x))
                  (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> x))
               (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x) (<a href="COMMON-LISP_____E3.html">&gt;</a> (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> x) 0))))</pre> 
<h4>Nth with other basic list functions</h4> 
 
   <p>Note that we don't prove a rule about <a href="ACL2____UPDATE-NTH.html">update-nth</a>, because 
   <span class="v">nth-update-nth</span> is an ACL2 builtin.</p><p><b>Theorem: </b>member-of-nth</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> member-of-nth
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____NFIX.html">nfix</a> n) (<a href="ACL2____LEN.html">len</a> x))
                 (<a href="COMMON-LISP____MEMBER.html">member</a> (<a href="COMMON-LISP____NTH.html">nth</a> n x) x)))</pre> 
<p><b>Theorem: </b>nth-of-append</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nth-of-append
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTH.html">nth</a> n (<a href="COMMON-LISP____APPEND.html">append</a> x y))
               (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____NFIX.html">nfix</a> n) (<a href="ACL2____LEN.html">len</a> x))
                   (<a href="COMMON-LISP____NTH.html">nth</a> n x)
                   (<a href="COMMON-LISP____NTH.html">nth</a> (<a href="COMMON-LISP____-.html">-</a> n (<a href="ACL2____LEN.html">len</a> x)) y))))</pre> 
<p><b>Theorem: </b>nth-of-revappend</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nth-of-revappend
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTH.html">nth</a> n (<a href="COMMON-LISP____REVAPPEND.html">revappend</a> x y))
               (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____NFIX.html">nfix</a> n) (<a href="ACL2____LEN.html">len</a> x))
                   (<a href="COMMON-LISP____NTH.html">nth</a> (<a href="COMMON-LISP____-.html">-</a> (<a href="ACL2____LEN.html">len</a> x) (<a href="COMMON-LISP_____B2.html">+</a> 1 (<a href="ACL2____NFIX.html">nfix</a> n))) x)
                   (<a href="COMMON-LISP____NTH.html">nth</a> (<a href="COMMON-LISP____-.html">-</a> n (<a href="ACL2____LEN.html">len</a> x)) y))))</pre> 
<p><b>Theorem: </b>nth-of-rev</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nth-of-rev
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTH.html">nth</a> n (<a href="ACL2____REV.html">rev</a> x))
               (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____NFIX.html">nfix</a> n) (<a href="ACL2____LEN.html">len</a> x))
                   (<a href="COMMON-LISP____NTH.html">nth</a> (<a href="COMMON-LISP____-.html">-</a> (<a href="ACL2____LEN.html">len</a> x) (<a href="COMMON-LISP_____B2.html">+</a> 1 (<a href="ACL2____NFIX.html">nfix</a> n))) x)
                   nil)))</pre> 
<p><b>Theorem: </b>nth-of-reverse</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nth-of-reverse
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTH.html">nth</a> n (<a href="COMMON-LISP____REVERSE.html">reverse</a> x))
               (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____NFIX.html">nfix</a> n) (<a href="ACL2____LEN.html">len</a> x))
                   (<a href="COMMON-LISP____NTH.html">nth</a> (<a href="COMMON-LISP____-.html">-</a> (<a href="ACL2____LEN.html">len</a> x) (<a href="COMMON-LISP_____B2.html">+</a> 1 (<a href="ACL2____NFIX.html">nfix</a> n))) x)
                   nil)))</pre> 
<p><b>Theorem: </b>nth-of-take</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nth-of-take
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTH.html">nth</a> i (<a href="ACL2____TAKE.html">take</a> n l))
               (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____NFIX.html">nfix</a> i) (<a href="ACL2____NFIX.html">nfix</a> n))
                   (<a href="COMMON-LISP____NTH.html">nth</a> i l)
                   nil)))</pre> 
<p><b>Theorem: </b>nth-of-make-list-ac</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nth-of-make-list-ac
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTH.html">nth</a> n (<a href="ACL2____MAKE-LIST-AC.html">make-list-ac</a> m val acc))
               (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____NFIX.html">nfix</a> n) (<a href="ACL2____NFIX.html">nfix</a> m))
                   val (<a href="COMMON-LISP____NTH.html">nth</a> (<a href="COMMON-LISP____-.html">-</a> n (<a href="ACL2____NFIX.html">nfix</a> m)) acc))))</pre> 
<p><b>Theorem: </b>nth-of-repeat</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nth-of-repeat
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTH.html">nth</a> n (<a href="ACL2____REPEAT.html">repeat</a> m a))
               (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____NFIX.html">nfix</a> n) (<a href="ACL2____NFIX.html">nfix</a> m)) a nil)))</pre> 
<p><b>Theorem: </b>nth-of-nthcdr</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nth-of-nthcdr
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTH.html">nth</a> n (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> m x))
               (<a href="COMMON-LISP____NTH.html">nth</a> (<a href="COMMON-LISP_____B2.html">+</a> (<a href="ACL2____NFIX.html">nfix</a> n) (<a href="ACL2____NFIX.html">nfix</a> m)) x)))</pre> 
<p><b>Theorem: </b>nth-of-last</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nth-of-last
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTH.html">nth</a> n (<a href="COMMON-LISP____LAST.html">last</a> x))
               (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> n) (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____LAST.html">last</a> x)) nil)))</pre> 
<p><b>Theorem: </b>nth-of-butlast</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nth-of-butlast
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTH.html">nth</a> n (<a href="COMMON-LISP____BUTLAST.html">butlast</a> x m))
               (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____NFIX.html">nfix</a> n) (<a href="COMMON-LISP____-.html">-</a> (<a href="ACL2____LEN.html">len</a> x) (<a href="ACL2____NFIX.html">nfix</a> m)))
                   (<a href="COMMON-LISP____NTH.html">nth</a> n x)
                   nil)))</pre> 
<h4>Nth of element lists and projections</h4> 
 
  <p>These are for use with <a href="STD____DEFLIST.html">std::deflist</a> and <a href="STD____DEFPROJECTION.html">std::defprojection</a>.</p><p><b>Theorem: </b>element-p-of-nth-when-element-list-p-when-nil-element</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> element-p-of-nth-when-element-list-p-when-nil-element
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____ELEMENT-P.html">element-p</a> nil) (<a href="ACL2____ELEMENT-LIST-P.html">element-list-p</a> x))
                 (<a href="ACL2____ELEMENT-P.html">element-p</a> (<a href="COMMON-LISP____NTH.html">nth</a> n x)))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>element-p-of-nth-when-element-list-p-when-nil-unknown</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> element-p-of-nth-when-element-list-p-when-nil-unknown
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____ELEMENT-LIST-P.html">element-list-p</a> x)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____NFIX.html">nfix</a> n) (<a href="ACL2____LEN.html">len</a> x)))
                 (<a href="ACL2____ELEMENT-P.html">element-p</a> (<a href="COMMON-LISP____NTH.html">nth</a> n x)))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>element-p-of-nth-when-element-list-p-when-nil-not-element-non-negated</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 element-p-of-nth-when-element-list-p-when-nil-not-element-non-negated
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ELEMENT-P.html">element-p</a> nil))
               (<a href="ACL2____ELEMENT-LIST-P.html">element-list-p</a> x))
          (<a href="ACL2____IFF.html">iff</a> (<a href="ACL2____ELEMENT-P.html">element-p</a> (<a href="COMMON-LISP____NTH.html">nth</a> n x))
               (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____NFIX.html">nfix</a> n) (<a href="ACL2____LEN.html">len</a> x))))
 :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>element-p-of-nth-when-element-list-p-when-nil-not-element-negated</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   element-p-of-nth-when-element-list-p-when-nil-not-element-negated
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____ELEMENT-P.html">element-p</a> nil))
                 (<a href="ACL2____ELEMENT-LIST-P.html">element-list-p</a> x))
            (<a href="ACL2____IFF.html">iff</a> (non-element-p (<a href="COMMON-LISP____NTH.html">nth</a> n x))
                 (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____LEN.html">len</a> x) (<a href="ACL2____NFIX.html">nfix</a> n))))
   :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>nth-of-elementlist-projection-when-nil-preservingp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nth-of-elementlist-projection-when-nil-preservingp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____ELEMENT-XFORMER.html">element-xformer</a> nil) nil)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTH.html">nth</a> n (<a href="ACL2____ELEMENTLIST-PROJECTION.html">elementlist-projection</a> x))
                        (<a href="ACL2____ELEMENT-XFORMER.html">element-xformer</a> (<a href="COMMON-LISP____NTH.html">nth</a> n x))))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>nth-of-elementlist-projection-when-not-nil-preservingp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nth-of-elementlist-projection-when-not-nil-preservingp
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTH.html">nth</a> n (<a href="ACL2____ELEMENTLIST-PROJECTION.html">elementlist-projection</a> x))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____NFIX.html">nfix</a> n) (<a href="ACL2____LEN.html">len</a> x))
                    (<a href="ACL2____ELEMENT-XFORMER.html">element-xformer</a> (<a href="COMMON-LISP____NTH.html">nth</a> n x))))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>nth-of-element-list-fix-when-nil-element</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nth-of-element-list-fix-when-nil-element
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____ELEMENT-P.html">element-p</a> nil)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTH.html">nth</a> n (<a href="ACL2____ELEMENT-LIST-FIX.html">element-list-fix</a> x))
                        (<a href="ACL2____ELEMENT-FIX.html">element-fix</a> (<a href="COMMON-LISP____NTH.html">nth</a> n x))))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>nth-of-element-list-fix-unless-nil-element</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nth-of-element-list-fix-unless-nil-element
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTH.html">nth</a> n (<a href="ACL2____ELEMENT-LIST-FIX.html">element-list-fix</a> x))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____NFIX.html">nfix</a> n) (<a href="ACL2____LEN.html">len</a> x))
                    (<a href="ACL2____ELEMENT-FIX.html">element-fix</a> (<a href="COMMON-LISP____NTH.html">nth</a> n x))))
        :rule-classes :rewrite)</pre> 

</body>
</html>
