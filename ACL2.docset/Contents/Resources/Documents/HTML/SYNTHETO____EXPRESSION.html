<html>
<head>
<meta charset="UTF-8">
<title>Expression</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=SYNTHETO____EXPRESSION">Click for Expression in the Full Manual</a></h3>

<p>Fixtype of Syntheto expressions.</p><p>This is a tagged union type, introduced by <a href="FTY____DEFTAGSUM.html">fty::deftagsum</a>.</p> 
<h5>Member Tags → Types</h5><dl>
<dt>
<span class="tt">:literal</span> → <a href="SYNTHETO____EXPRESSION-LITERAL.html">expression-literal</a>
</dt> 
<dt>
<span class="tt">:variable</span> → <a href="SYNTHETO____EXPRESSION-VARIABLE.html">expression-variable</a>
</dt> 
<dt>
<span class="tt">:unary</span> → <a href="SYNTHETO____EXPRESSION-UNARY.html">expression-unary</a>
</dt> 
<dt>
<span class="tt">:binary</span> → <a href="SYNTHETO____EXPRESSION-BINARY.html">expression-binary</a>
</dt> 
<dt>
<span class="tt">:if</span> → <a href="SYNTHETO____EXPRESSION-IF.html">expression-if</a>
</dt> 
<dt>
<span class="tt">:when</span> → <a href="SYNTHETO____EXPRESSION-WHEN.html">expression-when</a>
</dt> 
<dt>
<span class="tt">:unless</span> → <a href="SYNTHETO____EXPRESSION-UNLESS.html">expression-unless</a>
</dt> 
<dt>
<span class="tt">:cond</span> → <a href="SYNTHETO____EXPRESSION-COND.html">expression-cond</a>
</dt> 
<dt>
<span class="tt">:call</span> → <a href="SYNTHETO____EXPRESSION-CALL.html">expression-call</a>
</dt> 
<dt>
<span class="tt">:multi</span> → <a href="SYNTHETO____EXPRESSION-MULTI.html">expression-multi</a>
</dt> 
<dt>
<span class="tt">:component</span> → <a href="SYNTHETO____EXPRESSION-COMPONENT.html">expression-component</a>
</dt> 
<dt>
<span class="tt">:bind</span> → <a href="SYNTHETO____EXPRESSION-BIND.html">expression-bind</a>
</dt> 
<dt>
<span class="tt">:product-construct</span> → <a href="SYNTHETO____EXPRESSION-PRODUCT-CONSTRUCT.html">expression-product-construct</a>
</dt> 
<dt>
<span class="tt">:product-field</span> → <a href="SYNTHETO____EXPRESSION-PRODUCT-FIELD.html">expression-product-field</a>
</dt> 
<dt>
<span class="tt">:product-update</span> → <a href="SYNTHETO____EXPRESSION-PRODUCT-UPDATE.html">expression-product-update</a>
</dt> 
<dt>
<span class="tt">:sum-construct</span> → <a href="SYNTHETO____EXPRESSION-SUM-CONSTRUCT.html">expression-sum-construct</a>
</dt> 
<dt>
<span class="tt">:sum-field</span> → <a href="SYNTHETO____EXPRESSION-SUM-FIELD.html">expression-sum-field</a>
</dt> 
<dt>
<span class="tt">:sum-update</span> → <a href="SYNTHETO____EXPRESSION-SUM-UPDATE.html">expression-sum-update</a>
</dt> 
<dt>
<span class="tt">:sum-test</span> → <a href="SYNTHETO____EXPRESSION-SUM-TEST.html">expression-sum-test</a>
</dt> 
<dt>
<span class="tt">:bad-expression</span> → <a href="SYNTHETO____EXPRESSION-BAD-EXPRESSION.html">expression-bad-expression</a>
</dt> 
</dl> 
<p>There are 
       literals, 
       variables, 
       if-then-else expressions (non-strict), 
       and function calls. 
       These all correspond to ACL2 translated terms.</p><p>The type list argument in the function call 
       is non-empty for certain built-in Syntheto functions, 
       which are polymorphic. 
       Examples are functions that operate on sequences. 
       The type list consists of actual type arguments 
       for the function's formal type parameters: 
       that is, it describes the (monomorphic) instance of the function 
       used in the call. 
       This will be useful also if and when we extend Syntheto 
       with more general polymorphic user-defined types and functions.</p><p>We have variants when-then-else and unless-then-else of if-then-else: 
       when-then-else is just like if-then-else, 
       but it may be syntactically represented as 
       an early exit in concrete syntax; 
       unless-then-else is just liked a flipped if-then-else, 
       but it may be syntactically represented as 
       an early exit in concrete syntax. 
       In ACL2, these are available as ``bindings'' in <span class="tt"><a href="ACL2____B_A2.html">b*</a></span>, 
       but they are not really bindings as such, 
       so we do not represent them as bindings.</p><p>We have a more general form of ACL2's <span class="tt"><a href="COMMON-LISP____LET.html">let</a></span> bindings, 
       which can either bind a single variable to a single-valued expression, 
       or multiple variables to a multi-valued expression. 
       The latter is like <span class="tt"><a href="ACL2____MV-LET.html">mv-let</a></span>, 
       or an <span class="tt"><a href="ACL2____MV.html">mv</a></span> binder in <span class="tt"><a href="ACL2____B_A2.html">b*</a></span>.</p><p>We also have conditional expressions, 
       consisting of sequences of branches, 
       where a branch consists of 
       a condition expression and 
       an expression that computes the value when the condition holds. 
       These correspond to <span class="tt"><a href="COMMON-LISP____COND.html">cond</a></span> in ACL2.</p><p>In addition, there are unary and binary expressions. 
       These are like function calls, 
       but syntactically they use operators that are not identifiers 
       and have an infix notation in the case of binary expressions.</p><p>We have expressions to build multi-valued expressions, 
       corresponding to ACL2's <span class="tt"><a href="ACL2____MV.html">mv</a></span>. 
       And we have expressions to obtain single-valued components 
       of multi-valued expressions, via numeric indices, 
       corresponding to ACL2's <span class="tt"><a href="ACL2____MV-NTH.html">mv-nth</a></span>.</p><p>There are also expressions to construct values of product types. 
       There are expressions to obtain the value of a field of a product type. 
       There are also expressions to ``update a value of a product type'' 
       by returning a copied value with some of its fields changed.</p><p>There are similar expressions for values of sum types. 
       They include the name of an alternative, 
       which ``selects'' the type product. 
       Note, however, that there are no anonymous product types in Syntheto: 
       the summands of a sum type are anonymous product types in a sense, 
       but they are not actual Syntheto types. 
       This is similar to how <span class="tt"><a href="FTY____DEFTAGSUM.html">fty::deftagsum</a></span> works. 
       In addition, there are expressions to test whether 
       a value of a sum type belongs to a named alternative.</p>
</body>
</html>
