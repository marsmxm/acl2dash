<html>
<head>
<meta charset="UTF-8">
<title>Special-cases-for-rewrite-rules</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____SPECIAL-CASES-FOR-REWRITE-RULES">Click for Special-cases-for-rewrite-rules in the Full Manual</a></h3>

<p>Convenient short forms for rewrite rule formulas</p><p>In principle, every rewrite rule is made from a formula of this 
 shape:</p> 
 
 <pre class="code">(IMPLIES (AND <i>hyp1</i> ... <i>hypk</i>) 
         (<i>eqv</i> <i>lhs</i> <i>rhs</i>)) 
</pre> 
 
 <p>where <i>eqv</i> is either <span class="v">EQUAL</span> or <span class="v">IFF</span> and the result of 
 expanding any abbreviations in <i>lhs</i> is the application of some function 
 symbol other than <span class="v">IF</span>.</p> 
 
 <p>* In the special case where there is only one <i>hyp</i> term, i.e., 
 <i>k</i>=1, the <span class="v">(<a href="COMMON-LISP____AND.html">AND</a></span> <i>hyp1</i><span class="v">)</span> can be written <i>hyp1</i>.</p> 
 
 <p>* In the special case where there are no <i>hyp</i> terms, <i>k</i>=0, the 
 <span class="v">(<a href="COMMON-LISP____AND.html">AND</a>)</span> term is logically just <span class="v">T</span> and the whole <span class="v">IMPLIES</span> can be 
 dropped; such a formula may be written as an unconditional <span class="v">EQUAL</span> or 
 <span class="v">IFF</span> term.</p> 
 
 <p>* If you build a rewrite rule from a formula that concludes with <span class="v">(<a href="COMMON-LISP____NOT.html">NOT</a></span> 
 <i>x</i><span class="v">)</span>, it is treated as though it were <span class="v">(<a href="COMMON-LISP____EQUAL.html">EQUAL</a></span> <i>x</i> 
 <span class="v">NIL)</span>, which is logically equivalent to what you typed.</p> 
 
 <p>* If you build a rewrite rule from a formula that concludes with an 
 <span class="v">AND</span>, ACL2 will build a rewrite rule for each conjunct of the <span class="v">AND</span>. 
 This is because</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">IMPLIES</a> hyp (<a href="COMMON-LISP____AND.html">AND</a> concl1 concl2))</pre> 
 
 <p>is propositionally equivalent to</p> 
 
 <pre class="code">(<a href="COMMON-LISP____AND.html">AND</a> (<a href="ACL2____IMPLIES.html">IMPLIES</a> hyp concl1)
     (<a href="ACL2____IMPLIES.html">IMPLIES</a> hyp concl2)).</pre> 
 
 <p>However, if you use an <span class="v">OR</span>-expression as a hypothesis, ACL2 does 
 <i>not</i> do the dual transformation.  Thus, <span class="v">(<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____OR.html">OR</a> hyp1 hyp2)
 concl)</span> generates one rewrite rule.</p> 
 
 <p>* Finally, if you build a rewrite rule from a formula that does not 
 conclude with an <span class="v">EQUAL</span>, an <span class="v">IFF</span>, a <span class="v">NOT</span>, or an <span class="v">AND,</span> but with 
 some other term, say, <i>lhs</i>, then ACL2 acts like you typed <span class="v">(<a href="ACL2____IFF.html">IFF</a></span> 
 <i>lhs</i> <span class="v">T)</span>, which is logically equivalent to what you typed.</p> 
 
 <p>Thus, regardless of what you type, every rule has <i>k</i> hypotheses.  For 
 unconditional rules, <i>k</i> is 0 and the hypotheses are vacuously true. 
 Whether or not you write an <span class="v">EQUAL</span> or an <span class="v">IFF</span> in the conclusion, every 
 rule is either an equality or a propositional equivalence, every rule has a 
 left-hand side, and every rule has a right-hand side.</p> 
 
 <p>Use your browser's <b>Back Button</b> now to return to <a href="ACL2____INTRODUCTION-TO-REWRITE-RULES-PART-1.html">introduction-to-rewrite-rules-part-1</a>.</p>
</body>
</html>
