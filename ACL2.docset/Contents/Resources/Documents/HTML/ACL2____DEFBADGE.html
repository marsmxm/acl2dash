<html>
<head>
<meta charset="UTF-8">
<title>Defbadge</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____DEFBADGE">Click for Defbadge in the Full Manual</a></h3>

<p>Issue a badge for a function so <span class="tt"><a href="ACL2____APPLY_42.html">apply$</a></span> can evaluate with it</p><p>It is best to be somewhat familiar with the documentation of <span class="tt"><a href="ACL2____APPLY_42.html">apply$</a></span> before reading this topic.</p> 
 
  <p>Before using <span class="v">defbadge</span> or a utility like <span class="tt"><a href="ACL2____DEFUN_42.html">defun$</a></span> that relies on 
  it:</p> 
 
  <pre class="code">(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "projects/apply/top" :dir :system)</pre> 
 
  <h3>Badges versus Warrants</h3> 
 
  <p>It is easy to confuse <a href="ACL2____BADGE.html">badge</a>s, which are issued by <span class="v">defbadge</span>, 
  with <a href="ACL2____WARRANT.html">warrant</a>s, which are issued by <span class="tt"><a href="ACL2____DEFWARRANT.html">defwarrant</a></span>.  Badges and 
  warrants are necessary to ACL2's support of <span class="tt"><a href="ACL2____APPLY_42.html">apply$</a></span> because ACL2 is 
  actually first-order, functions cannot be passed around as objects, ordinary 
  symbols play the role of ``function objects,'' and somehow the logic must 
  allow the association of a symbol with the function it names.  Furthermore, 
  to insure the consistency of the logic <span class="v">apply$</span> is not allowed to handle 
  certain functions such as the <span class="v">russell</span> function illustrated in <span class="tt"><a href="ACL2____INTRODUCTION-TO-APPLY_42.html">introduction-to-apply$</a></span>.  But to determine whether a newly defined function 
  is allowed to be known to <span class="v">apply$</span>, the ACL2 system must be able to 
  determine, in some sense, all the functions reachable from it.  And finally, 
  to be able to prove theorems about the application of such function names, 
  the link between the symbols and the functions and the analyzed properties of 
  the functions must available to the prover in the form of axioms. 
  Particularly vexing is the so-called ``<span class="v">local</span> problem'' which raises the 
  possibility of proving a theorem about the application of a name in the 
  context of a local definition of the corresponding function and then 
  exporting that theorem to a context where the name is defined 
  differently (see <b>Lesson 12</b> of <a href="ACL2____INTRODUCTION-TO-APPLY_42.html">introduction-to-apply$</a>).</p> 
 
  <p>Roughly speaking, badges are about syntax and warrants are about 
  semantics.  The badge for a symbol is a data structure in the ACL2 system 
  that records information like whether the symbol names a known ACL2 function, 
  how many arguments that function takes, how many results it returns, which 
  arguments are treated like function objects to be <span class="tt"><a href="ACL2____APPLY_42.html">apply$</a></span>'d, which are 
  treated like expressions to be <span class="tt"><a href="ACL2____EV_42.html">ev$</a></span>'d, and which are treated like 
  ordinary ACL2 objects to be <span class="v">car</span>'d, <span class="v">cdr</span>'d, consed, etc.  The 
  warrant for a function is in fact another function (actually a 0-ary 
  predicate) defined in the logic.  That predicate asserts some facts about the 
  symbol.  In particular, it specifies the badge of the symbol and it 
  constrains the behavior of <span class="v">apply$</span> on the symbol.</p> 
 
  <p><span class="v">Defbadge</span> analyzes the definition of a function and constructs the 
  badge if possible.  <span class="v">Defbadge</span> does not affect the logic — no 
  definitions or axioms are added.  <span class="v">Defbadge</span> can analyze both 
  <span class="v">:program</span> mode functions and <span class="v">:logic</span> mode functions. 
  <span class="v">Defwarrant</span>, on the other hand, can only analyze <span class="v">:logic</span> mode 
  functions because it must inspect the measure used to justify the termination 
  of the function and, if it is successful, it adds a <span class="v">:logic</span> mode 
  definition of the warrant to the logic.  This definition links the symbol to 
  the function via <span class="v">badge</span> and <span class="v">apply$</span> and if the warrant is a 
  hypothesis of a conjecture then the prover ``knows'' about the linkage.</p> 
 
  <p>Both <span class="v">defbadge</span> and <span class="v">defwarrant</span> affect the top-level 
  read-eval-print loop because that loop treats <span class="v">:program</span> and <span class="v">:logic</span> 
  functions differently so that it can (a) allow <span class="v">:program</span> mode terms to be 
  evaluated to carry out commands such as <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> and <span class="tt"><a href="ACL2____DEFTHM.html">defthm</a></span>, 
  query the world or build and test prototypes, and (b) allow <span class="v">:logic</span> mode 
  terms to be evaluated while guaranteeing a certain correspondence with what 
  can be proved.  See <a href="ACL2____GUARANTEES-OF-THE-TOP-LEVEL-LOOP.html">guarantees-of-the-top-level-loop</a>.</p> 
 
  <h3>Requirements of <span class="v">Defbadge</span>
</h3> 
 
  <pre class="code">General Form:
(<a href="ACL2____DEFBADGE.html">defbadge</a> fn)</pre> 
 
  <p>where <span class="v">fn</span> is a defined function name in either <span class="v">:</span><span class="tt"><a href="ACL2____PROGRAM.html">program</a></span> 
  or <span class="v">:</span><span class="tt"><a href="ACL2____LOGIC.html">logic</a></span> mode.  This command analyzes the body of <span class="v">fn</span> to 
  determine whether it satisfies certain stringent syntactic conditions 
  discussed below.  If the conditions are not met, <span class="v">defbadge</span> signals an 
  error.  Otherwise, it records a <a href="ACL2____BADGE.html">badge</a> for <span class="v">fn</span>.  Badges record the 
  input and output arities of <span class="v">fn</span> and specify which arguments are 
  ``functions'' that may be applied with <span class="v">apply$</span>, which are ``expressions'' 
  that may be evaluated with <span class="tt"><a href="ACL2____EV_42.html">ev$</a></span>, and which are neither.  The 
  conditions checked are sufficient to allow <span class="tt"><a href="ACL2____APPLY_42.html">apply$</a></span> to run the function 
  safely at the top level of the ACL2 read-eval-print loop.  However, in order 
  to prove anything about a call of <span class="v">apply$</span> on <span class="v">fn</span> — or even to 
  evaluate such a call if <span class="v">fn</span> is in <span class="v">:</span><span class="tt"><a href="ACL2____LOGIC.html">logic</a></span> mode, as discussed 
  above — <span class="v">fn</span> will need a <a href="ACL2____WARRANT.html">warrant</a> as issued by <span class="tt"><a href="ACL2____DEFWARRANT.html">defwarrant</a></span>.  <span class="v">Defbadge</span> does not issue warrants, just badges. 
  <span class="v">Defwarrant</span> can issue both badges and warrants.</p> 
 
  <p>The first condition on <span class="v">fn</span> is that it must be a defined function 
  symbol.  Since <span class="v">fn</span> must be defined it may not be a constrained function 
  such as one introduced by <span class="tt"><a href="ACL2____DEFCHOOSE.html">defchoose</a></span> or <span class="tt"><a href="ACL2____ENCAPSULATE.html">encapsulate</a></span>.  In 
  addition, <span class="v">fn</span> may not be one of a very few ``blacklisted'' symbols (see 
  the value of <span class="v">*blacklisted-apply$-fns*</span>) like <span class="tt"><a href="ACL2____SYS-CALL.html">sys-call</a></span> (which 
  requires a trust tag) or an <a href="ACL2____UNTOUCHABLE.html">untouchable</a>.  (For technical reasons, 
  untouchables are disallowed even if they are on <span class="v">temp-touchable-fns</span>; see 
  <span class="tt"><a href="ACL2____REMOVE-UNTOUCHABLE.html">remove-untouchable</a></span>.)</p> 
 
  <p>The other conditions depend on whether <span class="tt"><a href="ACL2____APPLY_42.html">apply$</a></span> is reachable from 
  <span class="v">fn</span>.  That is, can a call of <span class="v">fn</span> lead to a call of <span class="v">apply$</span>?  If 
  <span class="v">apply$</span> is not reachable from <span class="v">fn</span>, then there are no more conditions 
  on <span class="v">fn</span>.  A badge for <span class="v">fn</span> is computed and stored.  We are more precise 
  about ``reachability'' later.</p> 
 
  <p>If <span class="v">apply$</span> is reachable from <span class="v">fn</span>, then there are additional 
  conditions that must be checked.  First, <span class="v">fn</span> must not have been 
  introduced with <span class="tt"><a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a></span>.  The current badging machinery is 
  unable to enforce the syntactic restrictions for mutually-recursive cliques. 
  Another restriction is that every function mentioned in the body of <span class="v">fn</span>, 
  except <span class="v">fn</span> itself, must already have a badge.  Finally, <span class="v">fn</span> must 
  respect certain conventions regarding its use of <span class="tt"><a href="ACL2____APPLY_42.html">apply$</a></span> and other 
  <a href="ACL2____SCION.html">scion</a>s.  The basic idea of this last restriction is to make sure that 
  <span class="v">apply$</span> is always called on a ``known'' function symbol or <span class="tt"><a href="COMMON-LISP____LAMBDA.html">lambda</a></span> 
  object.  This restriction is enforced by checking the following 
  conditions:</p> 
 
  <p><i>(a)</i> It must be possible for each formal of <span class="v">fn</span> to be assigned 
  one of three <a href="ACL2____ILK.html">ilk</a>s, <span class="v">:FN</span>, <span class="v">:EXPR</span>, or <span class="v">NIL</span>, as described 
  below.  The basic idea is that a formal can be assigned ilk <span class="v">:FN</span> (or ilk 
  <span class="v">:EXPR</span>) iff it is sometimes passed into a <span class="v">:FN</span> (or <span class="v">:EXPR</span>) slot 
  in the body of <span class="v">fn</span> and is never passed into any other kind of slot.  A 
  formal can be be assigned ilk <span class="v">NIL</span> iff it is never passed into a slot of 
  ilk <span class="v">:FN</span> or <span class="v">:EXPR</span>, i.e., if it is used exclusively as an 
  ``ordinary'' object.  We are more precise below.</p> 
 
  <p><i>(b)</i> Every <span class="v">:FN</span> and <span class="v">:EXPR</span> slot of every function called in 
  the body of <span class="v">fn</span> is occupied either by a formal of <span class="v">fn</span> of the same ilk 
  or, in the case of calls of functions other than <span class="v">fn</span>, a quoted <a href="ACL2____TAME.html">tame</a> function symbol or quoted tame (preferably well-formed) <span class="v">LAMBDA</span> 
  object.  (See <span class="tt"><a href="ACL2____WELL-FORMED-LAMBDA-OBJECTP.html">well-formed-lambda-objectp</a></span>.)</p> 
 
  <p>This completes the list of restrictions imposed by <span class="v">defbadge</span>.</p> 
 
  <h3>Discussion and Examples</h3> 
 
  <p>Note that if <span class="v">apply$</span> is not reachable from <span class="v">fn</span>, the restrictions 
  imposed on <span class="v">fn</span> are comparatively generous.  Such a <span class="v">fn</span> could be 
  badged and warranted despite being defined mutually recursively or in terms 
  of unbadged or even unbadgeable functions.  Basically, if <span class="v">fn</span> doesn't 
  depend on <span class="v">apply$</span> there is no danger that some argument of <span class="v">fn</span> will 
  be treated like a function object or an expression.</p> 
 
  <p>After a successful <span class="v">defbadge</span> event for <span class="v">fn</span>, the function <span class="tt"><a href="ACL2____BADGE.html">badge</a></span> will return the computed badge (when executed in the top-level loop) 
  and <span class="tt"><a href="ACL2____APPLY_42.html">apply$</a></span> will be able to accept the <span class="v">fn</span> as a functional 
  argument.  Here is an annotated script.  First, carry out these two events, 
  defining <span class="v">foldr</span> as a <span class="v">:program</span> mode function.</p> 
 
  <pre class="code">(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "projects/apply/top" :dir :system)

(<a href="COMMON-LISP____DEFUN.html">defun</a> foldr (lst fn init)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :mode :program))
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ENDP.html">endp</a> lst)
      init
      (<a href="ACL2____APPLY_42.html">apply$</a> fn
              (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CAR.html">car</a> lst)
                    (foldr (<a href="COMMON-LISP____CDR.html">cdr</a> lst) fn init)))))</pre> 
 
  <p>Note the <span class="v">apply$</span> call in the definition.  We see that <span class="v">foldr</span> 
  treats its middle argument, <span class="v">fn</span>, as a function of arity 2.  We can run 
  <span class="v">foldr</span>, even without assigning a badge to <span class="v">foldr</span>, as long as we 
  supply a badged function symbol of arity 2 as the middle argument.  Since 
  the ACL2 primitive <span class="v">cons</span> has a badge and has arity 2, we can use it:</p> 
 
  <pre class="code">ACL2 !&gt;(foldr '(a b c) 'cons '(d e f))
(A B C D E F)</pre> 
 
  <p>Since <span class="v">foldr</span> has arity 3, we can try to apply it to a list of three 
  things.</p> 
 
  <pre class="code">(<a href="ACL2____APPLY_42.html">apply$</a> 'foldr (<a href="COMMON-LISP____LIST.html">list</a> '(a b c) 'cons '(d e f)))

ACL2 Error in TOP-LEVEL:  The value of APPLY$-USERFN is not specified
on FOLDR because FOLDR has not been badged.</pre> 
 
  <p>However, we can use <span class="v">defbadge</span> to compute and store the badge for 
  <span class="v">foldr</span>.  The badge says <span class="v">foldr</span> has input arity 3, output arity 1, and 
  treats its middle argument as a function.  We can recover the badge by 
  calling the function <span class="tt"><a href="ACL2____BADGE.html">badge</a></span>.  We can successfully apply <span class="v">foldr</span>. 
  We can even use it in a <span class="v">lambda</span> expression that we pass as the middle 
  argument to <span class="v">foldr</span>.</p> 
 
  <pre class="code">ACL2 !&gt;(<a href="ACL2____DEFBADGE.html">defbadge</a> foldr)

FOLDR now has the badge (APPLY$-BADGE 3 1 NIL :FN NIL) but has no warrant.
T

ACL2 !&gt;(<a href="ACL2____BADGE.html">badge</a> 'foldr)
(APPLY$-BADGE 3 1 NIL :FN NIL)

ACL2 !&gt;(<a href="ACL2____APPLY_42.html">apply$</a> 'foldr (<a href="COMMON-LISP____LIST.html">list</a> '(a b c) 'cons '(d e f)))
(A B C D E F)

ACL2 !&gt;(foldr '((a b c) (d e) (f g h) (i j k))
              (<a href="ACL2____LAMBDA_42.html">lambda$</a> (x y)
                (foldr x 'cons y))
              nil)
(A B C D E F G H I J K)</pre> 
 
  <h3>The ``Reachability'' Test</h3> 
 
  <p>We now clarify the test that we colloquially described above as whether 
  <span class="v">apply$</span> is reachable from <span class="v">fn</span>.  The actual test is whether 
  <span class="v">apply$-userfn</span> is ancestral in <span class="v">fn</span>.  That is, does <span class="v">fn</span> call 
  <span class="v">apply$-userfn</span>, or a function that calls <span class="v">apply$-userfn</span>, or a 
  function that calls a function that calls <span class="v">apply$-userfn</span>, etc.</p> 
 
  <p>Since the only system functions that call <span class="v">apply$-userfn</span> are 
  <span class="v">apply$</span>, <span class="v">ev$</span>, and <a href="ACL2____WARRANT.html">warrant</a>s, and since it is very unusual for 
  a user-defined function to call directly <span class="v">apply$-userfn</span>, <span class="v">ev$</span>, or 
  warrants, we think of this test colloquially as whether <span class="v">apply$</span> is 
  ancestral in <span class="v">fn</span>.</p> 
 
  <p>The test and the onerous conditions imposed when <span class="v">apply$</span> is reachable 
  is crucial to the soundness of the ACL2 proof theory.  We discuss this 
  further in the background material for <span class="tt"><a href="ACL2____APPLY_42.html">apply$</a></span>, including <a href="http://www.cs.utexas.edu/users/kaufmann/papers/apply/index.html" target="_blank"><nobr>``Limited 
  Second-Order Functionality in a First-Order Setting''<img src="../Icon_External_Link.png" title="External link to http://www.cs.utexas.edu/users/kaufmann/papers/apply/index.html"></nobr></a> by Matt Kaufmann 
  and J Strother Moore and offer a fully fleshed out metalevel proof that 
  <span class="v">apply$</span> and all <span class="v">:logic</span>-mode scions can be modelled in the comment 
  titled <span class="tt">Essay on Admitting a Model for Apply$ and the Functions that Use 
  It</span> in the ACL2 source file <span class="v">apply-raw.lisp</span>.</p> 
 
  <p>But badges are more concerned with syntax (and, for <span class="v">:program</span> mode 
  functions, evaluation) than the proof theory.  Even if we convert <span class="v">foldr</span> 
  to <span class="v">:logic</span> mode we cannot prove anything interesting about what happens 
  when it is applied with <span class="v">apply$</span>.  We can't even prove that <span class="v">foldr</span> has 
  a badge or what that badge is!</p> 
 
  <pre class="code">ACL2 !&gt;(<a href="ACL2____VERIFY-TERMINATION.html">verify-termination</a> foldr)
[Successful.  Output deleted.]
 FOLDR

ACL2 !&gt;(<a href="ACL2____THM.html">thm</a>
         (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____APPLY_42.html">apply$</a> 'foldr (<a href="COMMON-LISP____LIST.html">list</a> x 'cons z))
                (<a href="COMMON-LISP____APPEND.html">append</a> x z)))
[Unsuccessful.  Output deleted.]
******** FAILED ********

ACL2 !&gt;(<a href="ACL2____THM.html">thm</a>
         (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____BADGE.html">badge</a> 'foldr) '(APPLY$-BADGE 3 1 NIL :FN NIL)))
[Unsuccessful.  Output deleted.]
******** FAILED ********</pre> 
 
  <p>In order to prove anything nontrivial about <span class="v">foldr</span>'s badge or behavior 
  under <span class="v">apply$</span> we need the <span class="tt"><a href="ACL2____WARRANT.html">warrant</a></span> for <span class="v">foldr</span>.  Warrants are 
  issued by <span class="tt"><a href="ACL2____DEFWARRANT.html">defwarrant</a></span>.  If we execute (defwarrant foldr) and then 
  amend the failed <span class="v">thm</span> commands above by adding <span class="v">(<a href="ACL2____WARRANT.html">warrant</a> foldr)</span> as a 
  hypothesis, both amended formulas are provable.</p> 
 
  <h3>How Ilks Are Assigned</h3> 
 
  <p>If a formal variable (or its slot among the actuals) has an ilk of 
  <span class="v">:FN</span> then the variable is ``used as a function'' in the sense that it 
  might eventually reach the first argument of a call of <span class="v">apply$</span> and is 
  never passed into an ``ordinary'' slot like those for <span class="v">cons</span>.  Similarly, 
  an ilk of <span class="v">:EXPR</span> means the variable is ``used as an expression'' and may 
  eventually reach the first argument of <span class="v">ev$</span>.  An ilk of <span class="v">NIL</span> means 
  the variable is never used as a function or an expression.  The correctness 
  of this algorithm is crucial to the safe evaluation of <span class="v">apply$</span> on 
  user-defined function symbols.  It also is crucial to the termination 
  argument justifying the consistency of the proof theory created if and when 
  <span class="v">fn</span> is warranted.</p> 
 
  <p>The key to the inductive correctness of the algorithm implicity described 
  below is the fact that when the ACL2 logic is being booted up the only 
  function symbol with a slot of ilk <span class="v">:FN</span> is <span class="v">apply$</span> and the only 
  function with a slot of ilk <span class="v">:EXPR</span> is <span class="v">ev$</span>.  In both functions it is 
  the first argument slot that is so distinguished.  All other ACL2 primitives 
  that use <span class="v">apply$</span> or <span class="v">ev$</span>, e.g., <span class="v">collect$</span>, are defined, 
  admissible, badged, and warranted under the same conditions user-defined 
  functions are.</p> 
 
  <p>Let <i>v </i> be the <i>i </i>th formal parameter of a defined function 
  <i>fn</i>.  Then the ilk of <i>v </i> is <span class="v">:FN</span> iff the value of <i>v </i> 
  eventually makes its way into the first argument of <span class="v">apply$</span>, either in 
  the definition of <span class="v">fn</span> or in some function ancestral to (i.e., eventually 
  called by) <span class="v">fn</span>.  Another way to say this is that there is an occurrence 
  of <i>v </i> in a slot of ilk <span class="v">:FN</span>.  Furthermore, <i>v </i> is never used 
  any other way: every place <i>v </i> occurs in the body of <i>fn </i> is in a 
  slot of ilk <span class="v">:FN</span>.  And finally, in every recursive call of <i>fn </i>, 
  <i>v </i> is passed identically in the <i>i </i>th argument position of the 
  call.  We say such a <i>v </i> is ``used (exclusively) as a function.''</p> 
 
  <p>The <i>i </i>th formal variable <i>v </i> has ilk <span class="v">:EXPR</span> under 
  analogous conditions except that instead of eventually getting into the first 
  argument of <span class="v">apply$</span> it eventually gets into the first argument of 
  <span class="v">ev$</span>.  We say such a <i>v </i> is ``used (exclusively) as an 
  expression.''  Note: <span class="tt"><a href="ACL2____EV_42.html">ev$</a></span> is the natural notion of expression 
  evaluation in this context: look up the values of variables in the alist 
  argument to <span class="v">ev$</span>, return quoted constants, and otherwise <span class="v">apply$</span> 
  function symbols and <span class="v">LAMBDA</span> objects to the recursively obtained list of 
  values returned by evaluating the actuals.  However, <span class="v">ev$</span> first checks 
  that the expression is <span class="tt"><a href="ACL2____TAMEP.html">tamep</a></span>.</p> 
 
  <p>The <i>i </i>th formal variable <i>v </i> has ilk <span class="v">NIL</span> if it never 
  occurs in a <span class="v">:FN</span> slot and never occurs in an <span class="v">:EXPR</span> slot.  We say 
  such a <i>v </i> is ``used (exclusively) as an ordinary object.''</p>
</body>
</html>
