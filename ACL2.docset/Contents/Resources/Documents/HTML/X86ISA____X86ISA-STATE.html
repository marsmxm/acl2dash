<html>
<head>
<meta charset="UTF-8">
<title>X86isa-state</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=X86ISA____X86ISA-STATE">Click for X86isa-state in the Full Manual</a></h3>

<p>The state of the <span class="v">x86isa</span> model</p><h4>Definition of the <span class="v">x86isa</span> state</h4> 
 
 <p>The definition of the state uses nested and abstract stobjs by way 
 of community books <span class="tt"><a href="RSTOBJ2____DEFRSTOBJ.html">rstobj2::defrstobj</a></span> and <span class="tt"><a href="BIGMEM____BIGMEM.html">bigmem::bigmem</a></span>.  It may be interesting to read about the old 
 definition to see how the current definition supports all of its 
 functionality but in a more maintainable way; see <a href="X86ISA____X86ISA-STATE-HISTORY.html">x86isa-state-history</a>.</p> 
 
 <p>The <span class="v">bigmem</span> books define a memory model similar to the old 
 <span class="v">x86isa</span> memory model in that it provides a record representation 
 for reasoning and an allocate-on-demand, array-like performance for 
 execution. The x86 concrete stobj has the <span class="v">bigmem</span> stobj for its 
 memory field; <span class="v">defrstobj</span> exports the <span class="v">bigmem</span> memory accessor 
 and updater functions alongside those of other x86 fields and gives 
 us a state definition that's logically a multi-typed record. 
 <span class="v">defrstobj</span> also allows the definition of a universal accessor and 
 updater, so we still retain that feature in the <span class="v">x86isa</span> 
 books.</p> 
 
 <p>Note that the <span class="v">bigmem</span> books define a 64-bit address space, 
 though the <span class="v">x86isa</span> state restricts that to a 52-bit address space 
 because the max. physical address allowed by the x86 architecture is 
 52 (as of this writing in mid-2021).  If the max. allowed physical 
 address is increased anywhere up to 64 bits, then we can simply 
 change the size of the <span class="v">mem</span> field in the <span class="v">x86isa</span> stobj.</p> 
 
 <h4>x86 ISA state components modeled by <span class="v">x86isa</span>
</h4><h5>Fields that govern the model's operation</h5> 
 
    <p>These fields are an artifact of our x86 ISA model.</p> 
 
    <ul>
<li>
<span class="v">MS</span>: Model state, used to indicate I/O or errors 
    that our model does not handle yet.  Basically, we use the model 
    state to assert partial correctness.  If the model state is nil 
    till the end of execution, we expect the results to be correct. 
    Otherwise, all bets are off.<br><pre class="code">(ms :type t :initially nil)</pre>
</li>
<li>
<span class="v">FAULT</span>: We need some way to pass exceptions and 
    such around.  So we stuff them into the <span class="v">fault</span> slot, to be 
    processed by the step function.<br><pre class="code">(fault :type t :initially nil)</pre>
</li>
<li>
<span class="v">ENV</span>: Environment for the programs running on our 
    x86 model.<br><pre class="code">(env :type (satisfies env-alistp)
    :fix (<a href="ACL2____EC-CALL.html">ec-call</a> (env-alist-fix x))
    :initially nil)</pre>
</li>
<li>
<span class="v">UNDEF</span>: Field that seeds unknown values that 
    characterize commonly occurring undefined behavior.<br><pre class="code">(undef :type t :initially 0)</pre>
</li>
<li>
<span class="v">APP-VIEW</span>: This field acts as a switch.  When its 
    value is <span class="v">t</span>, support for system features like paging is 
    absent.  When its value is <span class="v">nil</span>, the model is in <span class="v">sys-view</span> 
    and support for system features is present.<br><pre class="code">(<a href="X86ISA____APP-VIEW.html">app-view</a> :type (satisfies booleanp)
         :fix (<a href="ACL2____BOOL-FIX.html">acl2::bool-fix</a> x)
         :initially t)</pre>
</li>
<li>
<span class="v">MARKING-VIEW</span>: This field also acts as a 
    switch. When its value is <span class="v">t</span>, then accessed and dirty bits in 
    the paging structures are set during those data structure 
    traversals, as expected. Otherwise, these bits are not set. This 
    switch is meaningful only in when the model is in <span class="v">sys-view</span>.<br><pre class="code">(marking-view :type (satisfies booleanp)
             :fix (<a href="ACL2____BOOL-FIX.html">acl2::bool-fix</a> x)
             :initially t)</pre>
</li>
<li>
<span class="v">OS-INFO</span>: This field is meaningful only in 
    <span class="v">app-view</span> mode to model system call behavior.<br><pre class="code">(os-info :type (satisfies keywordp)
        :fix (<a href="ACL2____EC-CALL.html">ec-call</a> (os-info-fix x))
        :initially :linux)</pre>
</li>
</ul><h5>Components of the x86 state specified by this model</h5> 
 
     <ul>
<li>
<span class="v">RGF</span>: The general-purpose registers are just an array of 
     signed 64-bit integers.  Note that we choose to define the GPRs 
     as signed integers for the sake of efficiency.  For instance, 
     <span class="v">-1</span> in unsigned format would occupy 64 bits, a bignum.  But 
     in the signed format, it would be a fixum.  See Intel Volume 1, 
     Section 3.4.1 (General-Purpose Registers) for information about 
     these registers.<br><pre class="code">(rgf :type (<a href="COMMON-LISP____ARRAY.html">array</a> (signed-byte 64) (16))
    :initially 0
    :fix (<a href="ACL2____LOGEXT.html">logext</a> 64 (<a href="ACL2____IFIX.html">ifix</a> x))
    :resizable nil
    :accessor rgfi
    :updater !rgfi)</pre>
</li>
<li>
<span class="v">RIP</span>: We choose the RIP to be a 48-bit signed 
    integer.  RIP can contain only canonical addresses, which range 
    from 0 to 2^47-1 and 2^64-2^47 to 2^64-1, inclusive, for the 
    64-bit mode.  So, in our model, 0 to 2^47-1 represents the lower 
    range of canonical addresses and -2^47 to -1 represents the upper 
    range of canonical addresses.  See Intel manual, Jan'19, Volume 1, 
    Section 3.5 for details about the instruction pointer.<br><pre class="code">(rip :type (signed-byte 48)
    :initially 0
    :fix (<a href="ACL2____LOGEXT.html">logext</a> 48 (<a href="ACL2____IFIX.html">ifix</a> x)))</pre>
</li>
<li>
<span class="v">RFLAGS</span>: We define the <span class="v">rflags</span> register as a 
    32-bit field, even though in the 64-bit mode, rflags is a 64-bit 
    register --- this is justified because Intel says that the top 32 
    bits of rflags are reserved. See Intel manual, Jan'19A, Volume 1, 
    Section 3.4.3 for details about <span class="v">rflags</span>.<br><pre class="code">(rflags :type (unsigned-byte 32)
       :initially 2
       :fix (<a href="ACL2____LOGHEAD.html">loghead</a> 32 (<a href="ACL2____IFIX.html">ifix</a> x)))</pre>
</li>
<li>
<span class="v">User Segment Registers</span>: 
    <p>Visible portion: 
    <pre class="code">16-bit selector INDEX(13)::TI(1)::RPL(2)</pre></p> 
    <p>Hidden/Cache portion (see Intel manual, Mar'17, Vol. 3A, Figure 3-7): 
    <pre class="code">16-bit Attributes
       32-bit Limit
       64-bit Base Address</pre></p> 
    <p>See Intel manual, Jan'19, Volume 1, Section 3.4.2 and Intel 
    manual, Jan'19, Volume 3, Sections 3.4.2 and 3.4.3 for 
    details.</p>
<br><pre class="code">(seg-visible :type (<a href="COMMON-LISP____ARRAY.html">array</a> (unsigned-byte 16) (6))
            :initially 0
            :fix (<a href="ACL2____LOGHEAD.html">loghead</a> 16 (<a href="ACL2____IFIX.html">ifix</a> x))
            :resizable nil
            :accessor seg-visiblei
            :updater !seg-visiblei)</pre>
<pre class="code">(seg-hidden-base :type (<a href="COMMON-LISP____ARRAY.html">array</a> (unsigned-byte 64) (6))
                :fix (<a href="ACL2____LOGHEAD.html">loghead</a> 64 (<a href="ACL2____IFIX.html">ifix</a> x))
                :initially 0
                :resizable nil
                :accessor seg-hidden-basei
                :updater !seg-hidden-basei)</pre>
<pre class="code">(seg-hidden-limit :type (<a href="COMMON-LISP____ARRAY.html">array</a> (unsigned-byte 32) (6))
                 :fix (<a href="ACL2____LOGHEAD.html">loghead</a> 32 (<a href="ACL2____IFIX.html">ifix</a> x))
                 :initially 0
                 :resizable nil
                 :accessor seg-hidden-limiti
                 :updater !seg-hidden-limiti)</pre>
<pre class="code">(seg-hidden-attr :type (<a href="COMMON-LISP____ARRAY.html">array</a> (unsigned-byte 16) (6))
                :fix (<a href="ACL2____LOGHEAD.html">loghead</a> 16 (<a href="ACL2____IFIX.html">ifix</a> x))
                :initially 0
                :resizable nil
                :accessor seg-hidden-attri
                :updater !seg-hidden-attri)</pre>
</li>
<li>
<span class="v">System Table Registers (GDTR and IDTR)</span>: These 
    registers point to bounded tables of (up to 8192) segment 
    descriptors.  In 64-bit mode, the system table registers are 
    extended from 48 to 80 bits.  See Intel manual, Jan'19, Volume 3, 
    Figure 2-6.<br><pre class="code">(str :type (<a href="COMMON-LISP____ARRAY.html">array</a> (unsigned-byte 80) (2))
    :fix (<a href="ACL2____LOGHEAD.html">loghead</a> 80 (<a href="ACL2____IFIX.html">ifix</a> x))
    :initially 0
    :resizable nil
    :accessor stri
    :updater !stri)</pre>
</li>
<li>
<span class="v">System Segment Registers (Task Register and LDTR)</span>: 
     <p>Visible portion: 
    <pre class="code">16-bit selector INDEX(13)::TI(1)::RPL(2)</pre></p> 
    <p>Hidden/Cache portion: 
    <pre class="code">16-bit Attributes
       32-bit Limit
       64-bit Base Address</pre></p> 
    <p>See Intel manual, Jan'19, Volume 3, Figure 2-6 for details.</p>
<br><pre class="code">(ssr-visible :type (<a href="COMMON-LISP____ARRAY.html">array</a> (unsigned-byte 16) (2))
            :initially 0
            :fix (<a href="ACL2____LOGHEAD.html">loghead</a> 16 (<a href="ACL2____IFIX.html">ifix</a> x))
            :resizable nil
            :accessor ssr-visiblei
            :updater !ssr-visiblei)</pre>
<pre class="code">(ssr-hidden-base :type (<a href="COMMON-LISP____ARRAY.html">array</a> (unsigned-byte 64) (2))
                :initially 0
                :fix (<a href="ACL2____LOGHEAD.html">loghead</a> 64 (<a href="ACL2____IFIX.html">ifix</a> x))
                :resizable nil
                :accessor ssr-hidden-basei
                :updater !ssr-hidden-basei)</pre>
<pre class="code">(ssr-hidden-limit :type (<a href="COMMON-LISP____ARRAY.html">array</a> (unsigned-byte 32) (2))
                 :initially 0
                 :fix (<a href="ACL2____LOGHEAD.html">loghead</a> 32 (<a href="ACL2____IFIX.html">ifix</a> x))
                 :resizable nil
                 :accessor ssr-hidden-limiti
                 :updater !ssr-hidden-limiti)</pre>
<pre class="code">(ssr-hidden-attr :type (<a href="COMMON-LISP____ARRAY.html">array</a> (unsigned-byte 16) (2))
                :fix (<a href="ACL2____LOGHEAD.html">loghead</a> 16 (<a href="ACL2____IFIX.html">ifix</a> x))
                :initially 0
                :resizable nil
                :accessor ssr-hidden-attri
                :updater !ssr-hidden-attri)</pre>
</li>
<li>
<span class="v">CTR</span>: Control registers --- See Intel manual, 
    Jan'19, Volume 3, Section 2.5.<br><pre class="code">(ctr :type (<a href="COMMON-LISP____ARRAY.html">array</a> (unsigned-byte 64) (17))
    :fix (<a href="ACL2____LOGHEAD.html">loghead</a> 64 (<a href="ACL2____IFIX.html">ifix</a> x))
    :initially 0
    :resizable nil
    :accessor ctri
    :updater !ctri)</pre>
</li>
<li>
<span class="v">DBG</span>: Debug registers --- See Intel manual, Jan'19, 
    Volume 3, Section 17.2.<br><pre class="code">(dbg :type (<a href="COMMON-LISP____ARRAY.html">array</a> (unsigned-byte 64) (8))
    :initially 0
    :fix (<a href="ACL2____LOGHEAD.html">loghead</a> 64 (<a href="ACL2____IFIX.html">ifix</a> x))
    :resizable nil
    :accessor dbgi
    :updater !dbgi)</pre>
</li>
<li>
<span class="v">FPU 80-bit data registers</span>: The MMX 
     registers (<span class="v">MM0</span> through <span class="v">MM7</span>) are aliased to the low 
     64-bits of the FPU data registers.  See Intel manual, Jan'19, 
     Volume 1, Section 8.1.2.<pre class="code">(fp-data :type (<a href="COMMON-LISP____ARRAY.html">array</a> (unsigned-byte 80) (8))
        :fix (<a href="ACL2____LOGHEAD.html">loghead</a> 80 (<a href="ACL2____IFIX.html">ifix</a> x))
        :initially 0
        :resizable nil
        :accessor fp-datai
        :updater !fp-datai)</pre>
</li>
<li>
<span class="v">FPU 16-bit control register</span>: See Intel manual, 
     Jan'19, Volume 1, Section 8.1.5.<pre class="code">(fp-ctrl :type (unsigned-byte 16)
        :fix (<a href="ACL2____LOGHEAD.html">loghead</a> 16 (<a href="ACL2____IFIX.html">ifix</a> x))
        :initially 0)</pre>
</li>
<li>
<span class="v">FPU 16-bit status register</span>: See Intel manual, 
     Jan'19, Volume 1, Section 8.1.3.<pre class="code">(fp-status :type (unsigned-byte 16)
          :fix (<a href="ACL2____LOGHEAD.html">loghead</a> 16 (<a href="ACL2____IFIX.html">ifix</a> x))
          :initially 0)</pre>
</li>
<li>
<span class="v">FPU 16-bit tag register</span>: See Intel manual, 
     Jan'19, Volume 1, Section 8.1.7.<pre class="code">(fp-tag :type (unsigned-byte 16)
       :fix (<a href="ACL2____LOGHEAD.html">loghead</a> 16 (<a href="ACL2____IFIX.html">ifix</a> x))
       :initially 0)</pre>
</li>
<li>
<span class="v">FPU 48-bit last instruction pointer</span>: See Intel 
     manual, Jan'19, Volume 1, Figure 8-1.<pre class="code">(fp-last-inst :type (unsigned-byte 48)
             :fix (<a href="ACL2____LOGHEAD.html">loghead</a> 48 (<a href="ACL2____IFIX.html">ifix</a> x))
             :initially 0)</pre>
</li>
<li>
<span class="v">FPU 48-bit last data (operand) pointer</span>: See Intel 
     manual, Jan'19, Volume 1, Figure 8-1.<pre class="code">(fp-last-data :type (unsigned-byte 48)
             :fix (<a href="ACL2____LOGHEAD.html">loghead</a> 48 (<a href="ACL2____IFIX.html">ifix</a> x))
             :initially 0)</pre>
</li>
<li>
<span class="v">FPU 11-bit opcode:</span> See Intel manual, Jan'19, 
     Volume 1, Figure 8-1.<br><pre class="code">(fp-opcode :type (unsigned-byte 11)
          :fix (<a href="ACL2____LOGHEAD.html">loghead</a> 11 (<a href="ACL2____IFIX.html">ifix</a> x))
          :initially 0)</pre>
</li>
<li>
<span class="v">MXCSR</span> register<pre class="code">(mxcsr :type (unsigned-byte 32)
      :fix (<a href="ACL2____LOGHEAD.html">loghead</a> 32 (<a href="ACL2____IFIX.html">ifix</a> x))
      :initially 8064)</pre>
</li>
<li>
<span class="v">OPMASK</span>: 8 opmask registers are used for 
    conditional execution and merging of data elements in the 
    destination operands of AVX-512 EVEX-encoded instructions.  They 
    are also used as operands in opmask instructions like KMOV, etc.<pre class="code">(opmsk :type (<a href="COMMON-LISP____ARRAY.html">array</a> (unsigned-byte 64) (8))
      :fix (<a href="ACL2____LOGHEAD.html">loghead</a> 64 (<a href="ACL2____IFIX.html">ifix</a> x))
      :initially 0
      :resizable nil
      :accessor opmski
      :updater !opmski)</pre>
</li>
<li>
<span class="v">ZMM</span>: ZMM 512-bit data registers --- the lower 
    256-bits of the ZMM registers are aliased to the respective 
    256-bit YMM registers and the lower 128-bit are aliased to the 
    respective 128-bit XMM registers.  Note that registers YMM16/XMM16 
    to YMM31/XMM31 are available only via the EVEX prefix (AVX-512).<pre class="code">(zmm :type (<a href="COMMON-LISP____ARRAY.html">array</a> (unsigned-byte 512) (32))
    :fix (<a href="ACL2____LOGHEAD.html">loghead</a> 512 (<a href="ACL2____IFIX.html">ifix</a> x))
    :initially 0
    :resizable nil
    :accessor zmmi
    :updater !zmmi)</pre>
</li>
<li>
<span class="v">MSR</span>: Model-specific registers<br><pre class="code">(msr :type (<a href="COMMON-LISP____ARRAY.html">array</a> (unsigned-byte 64) (8))
    :fix (<a href="ACL2____LOGHEAD.html">loghead</a> 64 (<a href="ACL2____IFIX.html">ifix</a> x))
    :initially 0
    :resizable nil
    :accessor msri
    :updater !msri)</pre>
</li>
<li>
<span class="v">MEM</span>: Field modeling <span class="v">2^52</span> bytes of physical 
    memory in <span class="v">sys-view</span> and <span class="v">2^48</span> bytes of linear memory in 
    <span class="v">app-view</span>. <br><pre class="code">(mem :type (<a href="COMMON-LISP____ARRAY.html">array</a> (unsigned-byte 8)
                 (4503599627370496))
    :initially 0
    :fix (<a href="ACL2____LOGHEAD.html">loghead</a> 8 (<a href="ACL2____IFIX.html">ifix</a> x))
    :child-stobj bigmem::mem
    :child-accessor bigmem::read-mem
    :child-updater bigmem::write-mem
    :accessor memi
    :updater !memi)</pre>
</li>
</ul>
</body>
</html>
