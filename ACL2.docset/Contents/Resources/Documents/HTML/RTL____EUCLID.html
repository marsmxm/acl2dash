<html>
<head>
<meta charset="UTF-8">
<title>Euclid</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=RTL____EUCLID">Click for Euclid in the Full Manual</a></h3>

<p>Definition of prime number and two theorems of Euclid</p><h3>Overview</h3> 
 
This book contains proofs of two theorems of Euclid: 
<ol> 
  <li>There exist infinitely many primes.</li> 
  <li>If <span class="v">p</span> is a prime divisor of <span class="v">a*b</span>, then <span class="v">p</span> divides either <span class="v">a</span> or <span class="v">b</span>.</li> 
 </ol> 
 
<h3>Definitions and Theorems</h3>We first list some basic properties of divisibility. 
 <p><b>Function: </b>divides</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> divides (x y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____ACL2-NUMBERP.html">acl2-numberp</a> x)
            (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP_____D3.html">=</a> x 0))
            (<a href="ACL2____ACL2-NUMBERP.html">acl2-numberp</a> y)
            (<a href="COMMON-LISP____INTEGERP.html">integerp</a> (<a href="COMMON-LISP_____F2.html">/</a> y x))))</pre> 
 <p><b>Theorem: </b>divides-leq</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> divides-leq
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____E3.html">&gt;</a> x 0) (<a href="COMMON-LISP_____E3.html">&gt;</a> y 0) (divides x y))
                 (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> x y))
        :rule-classes nil)</pre> 
 <p><b>Theorem: </b>divides-minus</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> divides-minus
        (<a href="ACL2____IMPLIES.html">implies</a> (divides x y)
                 (divides x (<a href="COMMON-LISP____-.html">-</a> y)))
        :rule-classes nil)</pre> 
 <p><b>Theorem: </b>divides-sum</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> divides-sum
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (divides x y) (divides x z))
                 (divides x (<a href="COMMON-LISP_____B2.html">+</a> y z)))
        :rule-classes nil)</pre> 
 <p><b>Theorem: </b>divides-product</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> divides-product
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> z) (divides x y))
                 (divides x (<a href="COMMON-LISP_____A2.html">*</a> y z)))
        :rule-classes nil)</pre> 
 <p><b>Theorem: </b>divides-transitive</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> divides-transitive
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (divides x y) (divides y z))
                 (divides x z))
        :rule-classes nil)</pre> 
 <p><b>Theorem: </b>divides-self</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> divides-self
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____ACL2-NUMBERP.html">acl2-numberp</a> x) (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP_____D3.html">=</a> x 0)))
                 (divides x x)))</pre> 
 <p><b>Theorem: </b>divides-0</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> divides-0
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____ACL2-NUMBERP.html">acl2-numberp</a> x) (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP_____D3.html">=</a> x 0)))
                 (divides x 0)))</pre> 
 <p><b>Theorem: </b>divides-mod-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> divides-mod-equal
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____REAL_F2RATIONALP.html">real/rationalp</a> a)
                      (<a href="ACL2____REAL_F2RATIONALP.html">real/rationalp</a> b)
                      (<a href="ACL2____REAL_F2RATIONALP.html">real/rationalp</a> n)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP_____D3.html">=</a> n 0)))
                 (<a href="ACL2____IFF.html">iff</a> (divides n (<a href="COMMON-LISP____-.html">-</a> a b))
                      (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____MOD.html">mod</a> a n) (<a href="COMMON-LISP____MOD.html">mod</a> b n))))
        :rule-classes nil)</pre> 
 <p><b>Theorem: </b>divides-mod-0</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> divides-mod-0
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____ACL2-NUMBERP.html">acl2-numberp</a> a)
                      (<a href="ACL2____ACL2-NUMBERP.html">acl2-numberp</a> n)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP_____D3.html">=</a> n 0)))
                 (<a href="ACL2____IFF.html">iff</a> (divides n a) (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____MOD.html">mod</a> a n) 0)))
        :rule-classes nil)</pre>Our definition of primality is based on the following function, which computes 
 the least divisor of a natural number <span class="v">n</span> that is greater than or equal to <span class="v">k</span>. 
 (In the book <span class="v">mersenne</span>, in which we are concerned with efficiency, we shall 
 introduce an equivalent version that checks for divisors only up to <span class="v">sqrt(n)</span>.) 
 <p><b>Function: </b>least-divisor</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> least-divisor (k n)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)
                (<a href="COMMON-LISP____INTEGERP.html">integerp</a> k)
                (<a href="COMMON-LISP_____C3.html">&lt;</a> 1 k)
                (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> k n))
           (<a href="COMMON-LISP____IF.html">if</a> (divides k n)
               k (least-divisor (<a href="COMMON-LISP____1_B2.html">1+</a> k) n))
           nil))</pre> 
 <p><b>Theorem: </b>least-divisor-divides</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> least-divisor-divides
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> k)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> 1 k)
                      (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> k n))
                 (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> (least-divisor k n))
                      (divides (least-divisor k n) n)
                      (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> k (least-divisor k n))
                      (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (least-divisor k n) n)))
        :rule-classes nil)</pre> 
 <p><b>Theorem: </b>least-divisor-is-least</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> least-divisor-is-least
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> k)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> 1 k)
                      (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> k n)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> d)
                      (divides d n)
                      (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> k d))
                 (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (least-divisor k n) d))
        :rule-classes nil)</pre> 
 <p><b>Function: </b>primep</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> primep (n)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)
            (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> n 2)
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (least-divisor 2 n) n)))</pre> 
 <p><b>Theorem: </b>primep-gt-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> primep-gt-1
        (<a href="ACL2____IMPLIES.html">implies</a> (primep p)
                 (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> p) (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> p 2)))
        :rule-classes :forward-chaining)</pre> 
 <p><b>Theorem: </b>primep-no-divisor</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> primep-no-divisor
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (primep p)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> d)
                      (divides d p)
                      (<a href="COMMON-LISP_____E3.html">&gt;</a> d 1))
                 (<a href="COMMON-LISP_____D3.html">=</a> d p))
        :rule-classes nil)</pre> 
 <p><b>Theorem: </b>primep-least-divisor</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> primep-least-divisor
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n) (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> n 2))
                 (primep (least-divisor 2 n)))
        :rule-classes nil)</pre>Our formulation of the infinitude of the set of primes is based on a function that 
 returns a prime that is greater than its argument: 
 <p><b>Function: </b>fact</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> fact (n)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____NATP.html">natp</a> n)))
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> n) 1 (<a href="COMMON-LISP_____A2.html">*</a> n (fact (<a href="COMMON-LISP____1-.html">1-</a> n)))))</pre> 
 <p><b>Function: </b>greater-prime</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> greater-prime (n)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____NATP.html">natp</a> n)))
       (least-divisor 2 (<a href="COMMON-LISP____1_B2.html">1+</a> (fact n))))</pre> 
 <p><b>Theorem: </b>greater-prime-divides</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> greater-prime-divides
        (divides (greater-prime n)
                 (<a href="COMMON-LISP____1_B2.html">1+</a> (fact n)))
        :rule-classes nil)</pre> 
 <p><b>Theorem: </b>divides-fact</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> divides-fact
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> k)
                      (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 1 k)
                      (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> k n))
                 (divides k (fact n))))</pre> 
 <p><b>Theorem: </b>not-divides-fact-plus1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> not-divides-fact-plus1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> k)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> 1 k)
                      (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> k n))
                 (<a href="COMMON-LISP____NOT.html">not</a> (divides k (<a href="COMMON-LISP____1_B2.html">1+</a> (fact n)))))
        :rule-classes nil)</pre> 
 <p><b>Theorem: </b>infinitude-of-primes</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> infinitude-of-primes
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)
                 (<a href="COMMON-LISP____AND.html">and</a> (primep (greater-prime n))
                      (<a href="COMMON-LISP_____E3.html">&gt;</a> (greater-prime n) n)))
        :rule-classes nil)</pre>Our main theorem of Euclid depends on the properties of the greatest common divisor, 
 which we define according to Euclid's algorithm. 
 <p><b>Function: </b>g-c-d-nat</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> g-c-d-nat (x y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> x) (<a href="ACL2____NATP.html">natp</a> y))))
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> x)
           y
           (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> y)
               x
               (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> x y)
                   (g-c-d-nat x (<a href="COMMON-LISP____-.html">-</a> y x))
                   (g-c-d-nat (<a href="COMMON-LISP____-.html">-</a> x y) y)))))</pre> 
 <p><b>Function: </b>g-c-d</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> g-c-d (x y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x) (<a href="COMMON-LISP____INTEGERP.html">integerp</a> y))))
       (g-c-d-nat (<a href="COMMON-LISP____ABS.html">abs</a> x) (<a href="COMMON-LISP____ABS.html">abs</a> y)))</pre> 
 <p><b>Theorem: </b>g-c-d-nat-pos</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> g-c-d-nat-pos
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> x)
                      (<a href="ACL2____NATP.html">natp</a> y)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____D3.html">=</a> x 0) (<a href="COMMON-LISP_____D3.html">=</a> y 0))))
                 (<a href="COMMON-LISP_____E3.html">&gt;</a> (g-c-d-nat x y) 0))
        :rule-classes nil)</pre> 
 <p><b>Theorem: </b>g-c-d-pos</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> g-c-d-pos
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> y)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____D3.html">=</a> x 0) (<a href="COMMON-LISP_____D3.html">=</a> y 0))))
                 (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> (g-c-d x y))
                      (<a href="COMMON-LISP_____E3.html">&gt;</a> (g-c-d x y) 0)))
        :rule-classes nil)</pre> 
 <p><b>Theorem: </b>divides-g-c-d-nat</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> divides-g-c-d-nat
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> x) (<a href="ACL2____NATP.html">natp</a> y))
                 (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP_____D3.html">=</a> x 0) (divides (g-c-d-nat x y) x))
                      (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP_____D3.html">=</a> y 0)
                          (divides (g-c-d-nat x y) y))))
        :rule-classes nil)</pre> 
 <p><b>Theorem: </b>g-c-d-divides</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> g-c-d-divides
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x) (<a href="COMMON-LISP____INTEGERP.html">integerp</a> y))
                 (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP_____D3.html">=</a> x 0) (divides (g-c-d x y) x))
                      (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP_____D3.html">=</a> y 0) (divides (g-c-d x y) y))))
        :rule-classes nil)</pre>It remains to be shown that the gcd of <span class="v">x</span> and <span class="v">y</span> is divisible by any common 
 divisor of <span class="v">x</span> and <span class="v">y</span>.  This depends on the observation that the gcd may be 
 expressed as a linear combination <pre class="code">r*x + s*y</pre>.  We construct the coefficients <span class="v">r</span> 
 and <span class="v">s</span> explicitly. 
 <p><b>Function: </b>r-nat</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> r-nat (x y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> x) (<a href="ACL2____NATP.html">natp</a> y))))
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> x)
           0
           (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> y)
               1
               (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> x y)
                   (<a href="COMMON-LISP____-.html">-</a> (r-nat x (<a href="COMMON-LISP____-.html">-</a> y x)) (s-nat x (<a href="COMMON-LISP____-.html">-</a> y x)))
                   (r-nat (<a href="COMMON-LISP____-.html">-</a> x y) y)))))</pre> 
 <p><b>Function: </b>s-nat</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> s-nat (x y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> x) (<a href="ACL2____NATP.html">natp</a> y))))
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> x)
           1
           (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> y)
               0
               (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> x y)
                   (s-nat x (<a href="COMMON-LISP____-.html">-</a> y x))
                   (<a href="COMMON-LISP____-.html">-</a> (s-nat (<a href="COMMON-LISP____-.html">-</a> x y) y)
                      (r-nat (<a href="COMMON-LISP____-.html">-</a> x y) y))))))</pre> 
 <p><b>Theorem: </b>r-s-nat</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> r-s-nat
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> x) (<a href="ACL2____NATP.html">natp</a> y))
                 (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP_____A2.html">*</a> (r-nat x y) x) (<a href="COMMON-LISP_____A2.html">*</a> (s-nat x y) y))
                    (g-c-d-nat x y)))
        :rule-classes nil)</pre> 
 <p><b>Function: </b>r-int</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> r-int (x y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x) (<a href="COMMON-LISP____INTEGERP.html">integerp</a> y))))
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> x 0)
           (<a href="COMMON-LISP____-.html">-</a> (r-nat (<a href="COMMON-LISP____ABS.html">abs</a> x) (<a href="COMMON-LISP____ABS.html">abs</a> y)))
           (r-nat (<a href="COMMON-LISP____ABS.html">abs</a> x) (<a href="COMMON-LISP____ABS.html">abs</a> y))))</pre> 
 <p><b>Function: </b>s-int</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> s-int (x y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x) (<a href="COMMON-LISP____INTEGERP.html">integerp</a> y))))
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> y 0)
           (<a href="COMMON-LISP____-.html">-</a> (s-nat (<a href="COMMON-LISP____ABS.html">abs</a> x) (<a href="COMMON-LISP____ABS.html">abs</a> y)))
           (s-nat (<a href="COMMON-LISP____ABS.html">abs</a> x) (<a href="COMMON-LISP____ABS.html">abs</a> y))))</pre> 
 <p><b>Theorem: </b>g-c-d-linear-combination</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> g-c-d-linear-combination
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x) (<a href="COMMON-LISP____INTEGERP.html">integerp</a> y))
                 (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP_____A2.html">*</a> (r-int x y) x) (<a href="COMMON-LISP_____A2.html">*</a> (s-int x y) y))
                    (g-c-d x y)))
        :rule-classes nil)</pre> 
 <p><b>Theorem: </b>divides-g-c-d</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> divides-g-c-d
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> y)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> d)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP_____D3.html">=</a> d 0))
                      (divides d x)
                      (divides d y))
                 (divides d (g-c-d x y))))</pre> 
 <p><b>Theorem: </b>g-c-d-prime</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> g-c-d-prime
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (primep p)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> a)
                      (<a href="COMMON-LISP____NOT.html">not</a> (divides p a)))
                 (<a href="COMMON-LISP_____D3.html">=</a> (g-c-d p a) 1))
        :rule-classes nil)</pre>The main theorem: 
 <p><b>Theorem: </b>euclid</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> euclid
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (primep p)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> a)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> b)
                      (<a href="COMMON-LISP____NOT.html">not</a> (divides p a))
                      (<a href="COMMON-LISP____NOT.html">not</a> (divides p b)))
                 (<a href="COMMON-LISP____NOT.html">not</a> (divides p (<a href="COMMON-LISP_____A2.html">*</a> a b))))
        :rule-classes nil)</pre>
</body>
</html>
