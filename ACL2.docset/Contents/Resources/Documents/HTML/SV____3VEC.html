<html>
<head>
<meta charset="UTF-8">
<title>3vec</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=SV____3VEC">Click for 3vec in the Full Manual</a></h3>

<p>A <b>3vec</b> is a <a href="SV____4VEC.html">4vec</a> that has no Z bits.</p><p>In hardware modeling, Z bits (floating/undriven wires) are:</p> 
 
<ol> 
 
<li>relatively rare—for instance, an AND gate will never produce a Z 
value.</li> 
 
<li>often indistinguishable from X—for instance, if we give an undriven 
input to an OR gate, the hardware may interpret it as either a 0 or as a 1, so 
we may as well supplied an X instead.</li> 
 
</ol> 
 
<p>In most of our <a href="SV____4VEC-OPERATIONS.html">4vec-operations</a>, we account for the second property by 
first ``unfloating'' our inputs, e.g., with <a href="SV____3VEC-FIX.html">3vec-fix</a>.  But since Z 
values are relatively rare in the first place, this unfloating is often 
unnecessary.  That is, in a circuit like:</p> 
 
<pre class="code">(<a href="COMMON-LISP____OR.html">OR</a> A (<a href="COMMON-LISP____AND.html">AND</a> B C))</pre> 
 
<p>we can tell, statically, that we don't need to unfloat the result of the 
<span class="v">(<a href="COMMON-LISP____AND.html">AND</a> B C)</span> when computing the OR, because the AND can never produce a Z 
value anyway.  This turns out to be a useful optimization during 
bit-blasting.</p> 
 

</body>
</html>
