<html>
<head>
<meta charset="UTF-8">
<title>Atj-tutorial-deep</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=JAVA____ATJ-TUTORIAL-DEEP">Click for Atj-tutorial-deep in the Full Manual</a></h3>

<p>ATJ tutorial: Deep Embedding Approach.</p><p>This tutorial page describes and exemplifies 
    most aspects of using ATJ with the deep embedding approach. 
    Other aspects are described in subsequent pages. 
    Even though, as noted in <a href="JAVA____ATJ-TUTORIAL-DEEP-SHALLOW.html">atj-tutorial-deep-shallow</a>, 
    the shallow embedding approach is generally preferred over the deep one, 
    some of the concepts common to the two approaches are discussed here. 
    So, if this tutorial page is skipped at first reading, 
    it may be necessary to come back to it 
    while reading the pages on the shallow embedding approach.</p><h5>AIJ's Role</h5><p><a href="JAVA____ATJ-TUTORIAL-AIJ.html">AIJ</a> not only provides <a href="JAVA____ATJ-TUTORIAL-ACL2-VALUES.html">a default Java representation of the ACL2 values</a>: it is a <a href="JAVA____ATJ-TUTORIAL-DEEP-SHALLOW.html">deep embedding of ACL2 in Java</a>; more precisely, a deep embedding of the 
    executable, side-effect-free, non-stobj-accessing 
    subset of the ACL2 language without guards 
    (see <a href="JAVA____ATJ-TUTORIAL-BACKGROUND.html">atj-tutorial-background</a>). 
    AIJ includes a <a href="JAVA____ATJ-TUTORIAL-ACL2-TERMS.html">Java representation of the ACL2 terms</a> (in <a href="ACL2____TERM.html">translated</a> form) 
    and a <a href="JAVA____ATJ-TUTORIAL-ACL2-ENVIRONMENT.html">Java representation of the ACL2 environment</a>, consisting of <a href="COMMON-LISP____DEFUN.html">function definitions</a> and <a href="ACL2____DEFPKG.html">package definitions</a>. AIJ also includes a <a href="JAVA____ATJ-TUTORIAL-NATIVE-FUNCTIONS.html">Java implementation of the ACL2 primitive functions</a>, and an <a href="JAVA____ATJ-TUTORIAL-EVALUATOR.html">ACL2 evaluator written in Java</a>.</p><p>Besides an <a href="JAVA____ATJ-TUTORIAL-ACL2-VALUES.html">API to build and unbuild ACL2 values</a>, AIJ also provides 
    an API to build an ACL2 environment 
    (i.e. to build ACL2 function and package definitions), 
    and an API to evaluate calls of ACL2 primitive and defined functions 
    without checking guards. 
    External Java code could use this whole API as follows 
    (see picture below):</p><ol>
<li>Build the ACL2 environment:<ol>
<li>Define the ACL2 packages of interest, 
       both built-in and user-defined, 
       in the order in which they appear in the ACL2 <a href="ACL2____WORLD.html">world</a>.</li>
<li>Define the ACL2 functions of interest, 
       both built-in and user-defined (except the primitive ones), 
       in any order.</li>
</ol>
</li>
<li>Evaluate ACL2 function calls:<ol>
<li>Build the name of the ACL2 function to call, 
       as well as zero or more ACL2 values to pass as arguments, 
       via the factory methods of the <a href="JAVA____ATJ-TUTORIAL-ACL2-VALUES.html">value classes</a>.</li>
<li>Call the <span class="v">Acl2NamedFunction.call(Acl2Value[])</span> method 
       on the function name with the (array of) arguments.</li>
<li>Unbuild the returned <span class="v">Acl2Value</span> as needed to inspect and use it, 
       using the getter methods of the <a href="JAVA____ATJ-TUTORIAL-ACL2-VALUES.html">value classes</a>.</li>
</ol>
</li>
</ol><div class="ximg"><img src="../res/kestrel-java-atj-images/aij-api.png"></div><h5>ATJ's Role</h5><p>ATJ automates the first part of the protocol described above, 
    namely the building of the ACL2 environment 
    (see picture below). 
    ATJ generates Java code 
    that uses the AIJ API to build the ACL2 environment 
    and that provides a wrapper API 
    for external Java code to evaluate ACL2 function calls. 
    The external Java code must still directly use the AIJ API 
    to build and unbuild ACL2 values 
    passed to and received from function calls.</p><div class="ximg"><img src="../res/kestrel-java-atj-images/atj-aij-api.png"></div><h5>Example of Generated Code</h5><p>For example, consider the following factorial function:</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> fact (n)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____NATP.html">natp</a> n)))
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> n)
      1
    (<a href="COMMON-LISP_____A2.html">*</a> n (fact (<a href="COMMON-LISP____1-.html">1-</a> n)))))</pre><p>To generate Java code for that function, 
    include ATJ via</p><pre class="code">(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "kestrel/java/atj/atj" :dir :system)</pre><p>and call ATJ via</p><pre class="code">(<a href="JAVA____ATJ.html">java::atj</a> fact :deep t :guards nil)</pre><p>where <span class="v">:deep t</span> specifies the deep embedding approach 
    and <span class="v">:guards nil</span> specifies not to assume the guards' satisfaction 
    (more on this in <a href="JAVA____ATJ-TUTORIAL-DEEP-GUARDS.html">atj-tutorial-deep-guards</a>).</p><p>As conveyed by the message shown on the screen by ATJ, 
    two Java files, <span class="v">Acl2Code.java</span> and  <span class="v">Acl2CodeEnvironment.java</span>, 
    are generated, 
    in the current directory (by default). 
    (If the files already exist, they are overwritten.) 
    Opening the <span class="v">Acl2Code.java</span> file reveals that it contains 
    a single Java public class called <span class="v">Acl2Code</span>. 
    The file imports all the (public) AIJ classes.</p><p>The <span class="v">Acl2Code</span> class starts with a static initializer that calls 
    the static <span class="v">build()</span> method 
    of the class <span class="v">Acl2CodeEnvironment</span>, 
    which is in the file <span class="v">Acl2CodeEnvironment.java</span>, 
    as can be seen by opening that file.</p><p>The <span class="v">Acl2CodeEnvironment</span> class starts with 
    a package-private static method <span class="v">build()</span> 
    that calls a number of methods to define ACL2 packages 
    and a number of methods to define ACL2 functions; 
    it also calls an AIJ method to validate the well-formedness of 
    all the function calls in the constructed ACL2 function definitions, 
    but the details of this are not discussed here. 
    The packages are all the known ones in the ACL2 <a href="ACL2____WORLD.html">world</a> 
    at the time that ATJ is called: 
    the method names are derived from the package names, 
    as should be apparent. 
    The functions are <span class="v">fact</span> and all the ones 
    called directly or indirectly by <span class="v">fact</span>, 
    except for the <a href="ACL2____PRIMITIVE.html">primitive functions</a>. In this case, the functions are 
    <span class="v">fact</span>, <span class="tt"><a href="ACL2____ZP.html">zp</a></span>, and <span class="tt"><a href="COMMON-LISP____NOT.html">not</a></span>:</p><ul>
<li>
<span class="v">fact</span> calls <span class="tt"><a href="ACL2____ZP.html">zp</a></span>, which calls <span class="tt"><a href="COMMON-LISP____NOT.html">not</a></span>.</li>
<li>
<span class="v">fact</span> also calls <span class="tt"><a href="COMMON-LISP_____A2.html">*</a></span> and <span class="tt"><a href="COMMON-LISP____1-.html">1-</a></span>, 
     but these are macros whose expansions call 
     the primitive functions <span class="tt"><a href="ACL2____BINARY-_A2.html">binary-*</a></span> and <span class="tt"><a href="ACL2____BINARY-_B2.html">binary-+</a></span>.</li>
<li>
<span class="tt"><a href="ACL2____ZP.html">zp</a></span> also calls the primitive function <span class="tt"><a href="COMMON-LISP____IF.html">if</a></span>, 
     and the macro <span class="tt"><a href="COMMON-LISP_____C3_D3.html">&lt;=</a></span>, whose expansion calls <span class="tt"><a href="COMMON-LISP____NOT.html">not</a></span> 
     and the primitive function <span class="tt"><a href="COMMON-LISP_____C3.html">&lt;</a></span>.</li>
<li>
<span class="tt"><a href="COMMON-LISP____NOT.html">not</a></span> calls the primitive function <span class="tt"><a href="COMMON-LISP____IF.html">if</a></span>.</li>
</ul><p>ATJ looks at the <a href="ACL2____TERM.html">translated</a> bodies of the functions, 
    where macros, and also named constants, are expanded already.</p><p>The <span class="v">build()</span> method is followed by 
    the (private) methods that it calls. 
    The package definition methods 
    build the packages' import lists (some quite long) 
    and pass them to the AIJ method to define packages; 
    the code that builds the import lists is generated by ATJ, 
    based on the results of <span class="tt"><a href="ACL2____PKG-IMPORTS.html">pkg-imports</a></span> on the known packages. 
    The function definition methods 
    build the functions' names, formal parameters, and bodies, 
    and pass them to the AIJ method to define functions; 
    the code that builds formal parameters and bodies is generated by ATJ, 
    based on the <span class="v">formals</span> and <span class="v">unnormalized-body</span> properties 
    of the function symbols. 
    The details of all these methods are unimportant here.</p><p>Back to the <span class="v">Acl2Code</span> class, 
    after the static initializer, 
    there are two public methods, 
    which form the API to the ATJ-generated Java code 
    illustrated in the picture above. 
    The <span class="v">initialize()</span> method has an empty body, 
    but its purpose is to ensure the initialization of the class, 
    and therefore the execution of the static initializer, 
    which defines all the ACL2 packages and functions of interest. 
    (In the embedding, the static initializer could be avoided, 
    putting the call of <span class="v">build()</span> directly in <span class="v">initialize()</span>. 
    But in the shallow embedding, as explained in later tutorial pages, 
    the static initializer is needed, 
    and so the same is done in the deep embedding for uniformity.) 
    The <span class="v">call(Acl2Symbol, Acl2Value[])</span> method 
    evaluates an ACL2 function call, 
    by invoking the relevant AIJ method (the details are unimportant here).</p><h5>Example of External Code</h5><p>External Java code must call <span class="v">initialize()</span> 
    not only before calling <span class="v">call(Acl2Symbol, Acl2Value[])</span>, 
    but also before using AIJ's API to build 
    the <span class="v">Acl2Symbol</span> and <span class="v">Acl2Value</span>s 
    to pass to <span class="v">call(Acl2Symbol, Acl2Value[])</span>. 
    The reason is that the building of <span class="v">Acl2Symbol</span>s 
    depends on the definitions of the known packages being in place, 
    just as in ACL2.</p><p>The following is a simple example of external Java code 
    that uses the ATJ-generated code and AIJ:</p><pre class="code">import edu.kestrel.acl2.aij.*;

public class Test {
    public static void main(String[] args)
        throws Acl2UndefinedPackageException {
        Acl2Code.initialize();
        Acl2Symbol function = Acl2Symbol.make("ACL2", "FACT");
        Acl2Value argument = Acl2Integer.make(100);
        Acl2Value[] arguments = new Acl2Value[]{argument};
        Acl2Value result = Acl2Code.call(function, arguments);
        System.out.println("Result: " + result + ".");
    }
}</pre><p>This code initializes the ACL2 environment, 
    creates the function symbol `<span class="v">acl2::fact</span>', 
    creates a singleton array of arguments with the ACL2 integer 100, 
    calls the factorial function, 
    and prints the resulting value. 
    (AIJ's API includes <span class="v">toString()</span> methods 
    to convert ACL2 values to Java strings.) 
    The <span class="v">Acl2UndefinedPackageException</span> must be declared 
    because <span class="v">call(Acl2Symbol, Acl2Value[])</span> may throw it in general, 
    even though it will not in this case.</p><h5>Example of Compiling and Running the Code</h5><p>If the code above is in a file <span class="v">Test.java</span> 
    in the same directory where <span class="v">Acl2Code.java</span> was generated, 
    it can be compiled via</p><pre class="code">javac -cp [books]/kestrel/java/aij/java/out/artifacts/AIJ_jar/AIJ.jar \
      Acl2Code.java Acl2CodeEnvironment.java Test.java</pre><p>where <span class="v">[books]/...</span> must be replaced with 
    a proper path to the AIJ jar file 
    (see <a href="JAVA____AIJ.html">the documentation of AIJ</a> for instructions on how to obtain that jar file).</p><p>After compiling, the code can be run via</p><pre class="code">java -cp [books]/kestrel/java/aij/java/out/artifacts/AIJ_jar/AIJ.jar:. \
     Test</pre><p>where again <span class="v">[books]/...</span> must be replaced with a proper path. 
    A fairly large number will be printed on the screen. 
    Some ACL2 code has just been run in Java.</p><h5>Java Stack Space Considerations</h5><p>If the <span class="v">100</span> passed to the factorial function call 
    is increased to a sufficiently large value, 
    the execution of the Java code will result in a stack overflow 
    (this is just the JVM running out of stack memory; 
    it has nothing to do with type unsafety and security exploits). 
    This is unavoidable, because in the deep embedding approach 
    the ACL2 functions are evaluated via <a href="JAVA____ATJ-TUTORIAL-EVALUATOR.html">AIJ's recursive interpreter</a>. Note also that recursive method calls in the JVM 
    may not be as efficiently implemented as recursive function calls in Lisp, 
    given that Java is an imperative language 
    and thus loops are the preferred way to repeat computations. 
    This stack overflow issue may be mitigated 
    by passing a larger stack size to the JVM, 
    via the <span class="v">-Xss</span> option to the <span class="v">java</span> command. 
    For example,</p><pre class="code">java -cp [books]/kestrel/java/aij/java/out/artifacts/AIJ_jar/AIJ.jar:. \
     -Xss1G \
     Test</pre><p>runs the factorial program with 1 GiB of stack space, 
    which should be larger than the default.</p><div class="box"></div><p><b>Previous:</b> <a href="JAVA____ATJ-TUTORIAL-DEEP-SHALLOW.html">Deep and Shallow Embedding Approaches</a></p><p><b>Next:</b> <a href="JAVA____ATJ-TUTORIAL-ACL2-TERMS.html">Java Representation of the ACL2 Terms</a></p>
</body>
</html>
