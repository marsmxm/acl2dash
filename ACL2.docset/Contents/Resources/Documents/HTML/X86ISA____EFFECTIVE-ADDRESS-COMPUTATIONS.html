<html>
<head>
<meta charset="UTF-8">
<title>Effective-address-computations</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=X86ISA____EFFECTIVE-ADDRESS-COMPUTATIONS">Click for Effective-address-computations in the Full Manual</a></h3>

<p>Computing effective address using ModR/M, SIB bytes, and 
  displacement bytes present in the instruction</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>x86-effective-addr-from-sib</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 x86-effective-addr-from-sib
 (proc-mode temp-rip rex-byte mod sib x86)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (x86)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (integer 0 4) proc-mode)
          (<a href="COMMON-LISP____TYPE.html">type</a> (signed-byte 48) temp-rip)
          (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 8) rex-byte)
          (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 2) mod)
          (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 8) sib))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="X86ISA____SIB-P.html">sib-p</a> sib)))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((__function__ 'x86-effective-addr-from-sib))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
  (<a href="ACL2____B_A2.html">b*</a>
   (((<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 3) b)
     (<a href="X86ISA____SIB-_E3BASE.html">sib-&gt;base</a> sib))
    (check-alignment? nil)
    ((<a href="ACL2____MV.html">mv</a> flg base displacement nrip-bytes x86)
     (<a href="COMMON-LISP____CASE.html">case</a>
      mod
      (0
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> b 5)
           (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?flg0 dword x86)
                 (rime-size-opt proc-mode
                                4 temp-rip 1 :x check-alignment? x86
                                :mem-ptr? nil))
                ((when flg0)
                 (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____CONS.html">cons</a> flg0 'rime-size-opt-error)
                     0 0 0 x86)))
               (<a href="ACL2____MV.html">mv</a> nil 0 dword 4 x86))
           (<a href="ACL2____MV.html">mv</a> nil
               (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> proc-mode 0)
                   (rgfi (<a href="X86ISA____REG-INDEX.html">reg-index</a> b rex-byte 0) x86)
                   (<a href="X86ISA____RR32.html">rr32</a> b x86))
               0 0 x86)))
      (1 (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?flg1 byte x86)
               (rime-size-opt proc-mode
                              1 temp-rip 1 :x check-alignment? x86
                              :mem-ptr? nil))
              ((when flg1)
               (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____CONS.html">cons</a> flg1 'rime-size-opt-error)
                   0 0 0 x86)))
             (<a href="ACL2____MV.html">mv</a> nil
                 (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> proc-mode 0)
                     (rgfi (<a href="X86ISA____REG-INDEX.html">reg-index</a> b rex-byte 0) x86)
                     (<a href="X86ISA____RR32.html">rr32</a> b x86))
                 byte 1 x86)))
      (2 (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?flg2 dword x86)
               (rime-size-opt proc-mode
                              4 temp-rip 1 :x check-alignment? x86
                              :mem-ptr? nil))
              ((when flg2)
               (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____CONS.html">cons</a> flg2 'rime-size-opt-error)
                   0 0 0 x86)))
             (<a href="ACL2____MV.html">mv</a> nil
                 (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> proc-mode 0)
                     (rgfi (<a href="X86ISA____REG-INDEX.html">reg-index</a> b rex-byte 0) x86)
                     (<a href="X86ISA____RR32.html">rr32</a> b x86))
                 dword 4 x86)))
      (otherwise (<a href="ACL2____MV.html">mv</a> 'mod-can-not-be-anything-other-than-0-1-or-2
                     0 0 0 x86))))
    (ix (<a href="X86ISA____REG-INDEX.html">reg-index</a> (<a href="X86ISA____SIB-_E3INDEX.html">sib-&gt;index</a> sib) rex-byte 1))
    (index (<a href="COMMON-LISP____CASE.html">case</a> ix (4 0)
                 (otherwise (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> proc-mode 0)
                                (rgfi ix x86)
                                (<a href="X86ISA____I32.html">i32</a> (rgfi ix x86))))))
    (scale (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 2)
                (<a href="X86ISA____SIB-_E3SCALE.html">sib-&gt;scale</a> sib)))
    (scaled-index (<a href="COMMON-LISP____ASH.html">ash</a> index scale))
    (effective-addr (<a href="COMMON-LISP_____B2.html">+</a> base scaled-index)))
   (<a href="ACL2____MV.html">mv</a> flg effective-addr
       displacement nrip-bytes x86))))</pre> 
<p><b>Theorem: </b>integerp-of-x86-effective-addr-from-sib.non-truncated-memory-address</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 integerp-of-x86-effective-addr-from-sib.non-truncated-memory-address
 (<a href="ACL2____IMPLIES.html">implies</a>
  (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____FORCE.html">force</a> (x86p x86))
       (<a href="COMMON-LISP____INTEGERP.html">integerp</a> temp-rip))
  (<a href="ACL2____B_A2.html">b*</a>
     (((<a href="ACL2____MV.html">mv</a> ?flg ?non-truncated-memory-address
           ?disp ?increment-rip-by ?x86)
       (<a href="X86ISA____X86-EFFECTIVE-ADDR-FROM-SIB.html">x86-effective-addr-from-sib</a> proc-mode
                                    temp-rip rex-byte mod sib x86)))
     (<a href="COMMON-LISP____INTEGERP.html">integerp</a> non-truncated-memory-address)))
 :rule-classes :type-prescription)</pre> 
<p><b>Theorem: </b>natp-of-x86-effective-addr-from-sib.increment-rip-by</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 natp-of-x86-effective-addr-from-sib.increment-rip-by
 (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?flg ?non-truncated-memory-address
           ?disp ?increment-rip-by ?x86)
       (<a href="X86ISA____X86-EFFECTIVE-ADDR-FROM-SIB.html">x86-effective-addr-from-sib</a> proc-mode
                                    temp-rip rex-byte mod sib x86)))
     (<a href="ACL2____NATP.html">natp</a> increment-rip-by))
 :rule-classes :type-prescription)</pre> 
<p><b>Theorem: </b>x86p-of-x86-effective-addr-from-sib.x86</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 x86p-of-x86-effective-addr-from-sib.x86
 (<a href="ACL2____IMPLIES.html">implies</a>
  (<a href="ACL2____FORCE.html">force</a> (x86p x86))
  (<a href="ACL2____B_A2.html">b*</a>
     (((<a href="ACL2____MV.html">mv</a> ?flg ?non-truncated-memory-address
           ?disp ?increment-rip-by ?x86)
       (<a href="X86ISA____X86-EFFECTIVE-ADDR-FROM-SIB.html">x86-effective-addr-from-sib</a> proc-mode
                                    temp-rip rex-byte mod sib x86)))
     (x86p x86)))
 :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>x86-effective-addr-from-sib-returns-integerp-displacement</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 x86-effective-addr-from-sib-returns-integerp-displacement
 (<a href="ACL2____IMPLIES.html">implies</a>
  (x86p x86)
  (<a href="COMMON-LISP____INTEGERP.html">integerp</a>
   (<a href="ACL2____MV-NTH.html">mv-nth</a>
      2
      (<a href="X86ISA____X86-EFFECTIVE-ADDR-FROM-SIB.html">x86-effective-addr-from-sib</a> proc-mode
                                   temp-rip rex-byte mod sib x86))))
 :rule-classes (:rewrite :type-prescription))</pre> 
<p><b>Theorem: </b>x86-effective-addr-from-sib-returns-&lt;=-increment-rip-bytes</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 x86-effective-addr-from-sib-returns-&lt;=-increment-rip-bytes
 (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a>
   (<a href="ACL2____MV-NTH.html">mv-nth</a>
        3
        (<a href="X86ISA____X86-EFFECTIVE-ADDR-FROM-SIB.html">x86-effective-addr-from-sib</a> proc-mode
                                     temp-rip rex-byte mod sib x86))
   4)
 :rule-classes :linear)</pre> 
<p><b>Theorem: </b>logext-loghead-identity</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> logext-loghead-identity
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____SIGNED-BYTE-P.html">signed-byte-p</a> n x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LOGEXT.html">logext</a> n (<a href="ACL2____LOGHEAD.html">loghead</a> n x)) x)))</pre> 
<p><b>Function: </b>x86-effective-addr-16-disp</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 x86-effective-addr-16-disp
 (proc-mode temp-rip mod x86)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (x86)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (integer 0 4) proc-mode)
          (<a href="COMMON-LISP____TYPE.html">type</a> (signed-byte 48) temp-rip)
          (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 2) mod))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="X86ISA____2BITS-P.html">2bits-p</a> mod)))
 (<a href="COMMON-LISP____LET.html">let</a>
     ((__function__ 'x86-effective-addr-16-disp))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
     (<a href="COMMON-LISP____CASE.html">case</a> mod (0 (<a href="ACL2____MV.html">mv</a> nil 0 0 x86))
           (1 (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> flg byte x86)
                    (rime-size-opt proc-mode 1 temp-rip 1 :x nil x86
                                   :mem-ptr? nil))
                   ((when flg) (<a href="ACL2____MV.html">mv</a> flg 0 0 x86)))
                  (<a href="ACL2____MV.html">mv</a> nil byte 1 x86)))
           (2 (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> flg word x86)
                    (rime-size-opt proc-mode 2 temp-rip 1 :x nil x86
                                   :mem-ptr? nil))
                   ((when flg) (<a href="ACL2____MV.html">mv</a> flg 0 0 x86)))
                  (<a href="ACL2____MV.html">mv</a> nil word 2 x86)))
           (otherwise (<a href="ACL2____MV.html">mv</a> 'mod-value-wrong 0 0 x86)))))</pre> 
<p><b>Theorem: </b>i16p-of-x86-effective-addr-16-disp.disp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 i16p-of-x86-effective-addr-16-disp.disp
 (<a href="ACL2____IMPLIES.html">implies</a>
     (x86p x86)
     (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?flg ?disp ?increment-rip-by ?x86)
           (<a href="X86ISA____X86-EFFECTIVE-ADDR-16-DISP.html">x86-effective-addr-16-disp</a> proc-mode temp-rip mod x86)))
         (<a href="X86ISA____I16P.html">i16p</a> disp)))
 :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>natp-of-x86-effective-addr-16-disp.increment-rip-by</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     natp-of-x86-effective-addr-16-disp.increment-rip-by
     (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?flg ?disp ?increment-rip-by ?x86)
           (<a href="X86ISA____X86-EFFECTIVE-ADDR-16-DISP.html">x86-effective-addr-16-disp</a> proc-mode temp-rip mod x86)))
         (<a href="ACL2____NATP.html">natp</a> increment-rip-by))
     :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>x86p-of-x86-effective-addr-16-disp.x86</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 x86p-of-x86-effective-addr-16-disp.x86
 (<a href="ACL2____IMPLIES.html">implies</a>
     (x86p x86)
     (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?flg ?disp ?increment-rip-by ?x86)
           (<a href="X86ISA____X86-EFFECTIVE-ADDR-16-DISP.html">x86-effective-addr-16-disp</a> proc-mode temp-rip mod x86)))
         (x86p x86)))
 :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>integerp-of-x86-effective-addr-16-disp.disp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 integerp-of-x86-effective-addr-16-disp.disp
 (<a href="ACL2____IMPLIES.html">implies</a>
     (x86p x86)
     (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?flg ?disp ?increment-rip-by ?x86)
           (<a href="X86ISA____X86-EFFECTIVE-ADDR-16-DISP.html">x86-effective-addr-16-disp</a> proc-mode temp-rip mod x86)))
         (<a href="COMMON-LISP____INTEGERP.html">integerp</a> disp)))
 :rule-classes :type-prescription)</pre> 
<p><b>Theorem: </b>mv-nth-2-x86-effective-addr-16-disp-&lt;=-4</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 mv-nth-2-x86-effective-addr-16-disp-&lt;=-4
 (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a>
    (<a href="ACL2____MV-NTH.html">mv-nth</a> 2
            (<a href="X86ISA____X86-EFFECTIVE-ADDR-16-DISP.html">x86-effective-addr-16-disp</a> proc-mode temp-rip mod x86))
    4)
 :rule-classes :linear)</pre> 
<p><b>Function: </b>x86-effective-addr-16</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 x86-effective-addr-16
 (proc-mode temp-rip r/m mod x86)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (x86)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (integer 0 4) proc-mode)
          (<a href="COMMON-LISP____TYPE.html">type</a> (signed-byte 48) temp-rip)
          (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 3) r/m)
          (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 2) mod))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="X86ISA____2BITS-P.html">2bits-p</a> mod) (<a href="X86ISA____3BITS-P.html">3bits-p</a> r/m))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((__function__ 'x86-effective-addr-16))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
  (<a href="COMMON-LISP____CASE.html">case</a>
   r/m
   (0 (<a href="ACL2____B_A2.html">b*</a> ((bx (<a href="X86ISA____RR16.html">rr16</a> 3 x86))
           (si (<a href="X86ISA____RR16.html">rr16</a> 6 x86))
           ((<a href="ACL2____MV.html">mv</a> flg disp increment-rip-by x86)
            (<a href="X86ISA____X86-EFFECTIVE-ADDR-16-DISP.html">x86-effective-addr-16-disp</a> proc-mode temp-rip mod x86))
           ((when flg) (<a href="ACL2____MV.html">mv</a> flg 0 0 x86)))
          (<a href="ACL2____MV.html">mv</a> nil (<a href="X86ISA____N16.html">n16</a> (<a href="COMMON-LISP_____B2.html">+</a> bx si disp))
              increment-rip-by x86)))
   (1 (<a href="ACL2____B_A2.html">b*</a> ((bx (<a href="X86ISA____RR16.html">rr16</a> 3 x86))
           (di (<a href="X86ISA____RR16.html">rr16</a> 7 x86))
           ((<a href="ACL2____MV.html">mv</a> flg disp increment-rip-by x86)
            (<a href="X86ISA____X86-EFFECTIVE-ADDR-16-DISP.html">x86-effective-addr-16-disp</a> proc-mode temp-rip mod x86))
           ((when flg) (<a href="ACL2____MV.html">mv</a> flg 0 0 x86)))
          (<a href="ACL2____MV.html">mv</a> nil (<a href="X86ISA____N16.html">n16</a> (<a href="COMMON-LISP_____B2.html">+</a> bx di disp))
              increment-rip-by x86)))
   (2 (<a href="ACL2____B_A2.html">b*</a> ((bp (<a href="X86ISA____RR16.html">rr16</a> 5 x86))
           (si (<a href="X86ISA____RR16.html">rr16</a> 6 x86))
           ((<a href="ACL2____MV.html">mv</a> flg disp increment-rip-by x86)
            (<a href="X86ISA____X86-EFFECTIVE-ADDR-16-DISP.html">x86-effective-addr-16-disp</a> proc-mode temp-rip mod x86))
           ((when flg) (<a href="ACL2____MV.html">mv</a> flg 0 0 x86)))
          (<a href="ACL2____MV.html">mv</a> nil (<a href="X86ISA____N16.html">n16</a> (<a href="COMMON-LISP_____B2.html">+</a> bp si disp))
              increment-rip-by x86)))
   (3 (<a href="ACL2____B_A2.html">b*</a> ((bp (<a href="X86ISA____RR16.html">rr16</a> 5 x86))
           (di (<a href="X86ISA____RR16.html">rr16</a> 7 x86))
           ((<a href="ACL2____MV.html">mv</a> flg disp increment-rip-by x86)
            (<a href="X86ISA____X86-EFFECTIVE-ADDR-16-DISP.html">x86-effective-addr-16-disp</a> proc-mode temp-rip mod x86))
           ((when flg) (<a href="ACL2____MV.html">mv</a> flg 0 0 x86)))
          (<a href="ACL2____MV.html">mv</a> nil (<a href="X86ISA____N16.html">n16</a> (<a href="COMMON-LISP_____B2.html">+</a> bp di disp))
              increment-rip-by x86)))
   (4 (<a href="ACL2____B_A2.html">b*</a> ((si (<a href="X86ISA____RR16.html">rr16</a> 6 x86))
           ((<a href="ACL2____MV.html">mv</a> flg disp increment-rip-by x86)
            (<a href="X86ISA____X86-EFFECTIVE-ADDR-16-DISP.html">x86-effective-addr-16-disp</a> proc-mode temp-rip mod x86))
           ((when flg) (<a href="ACL2____MV.html">mv</a> flg 0 0 x86)))
          (<a href="ACL2____MV.html">mv</a> nil (<a href="X86ISA____N16.html">n16</a> (<a href="COMMON-LISP_____B2.html">+</a> si disp))
              increment-rip-by x86)))
   (5 (<a href="ACL2____B_A2.html">b*</a> ((di (<a href="X86ISA____RR16.html">rr16</a> 7 x86))
           ((<a href="ACL2____MV.html">mv</a> flg disp increment-rip-by x86)
            (<a href="X86ISA____X86-EFFECTIVE-ADDR-16-DISP.html">x86-effective-addr-16-disp</a> proc-mode temp-rip mod x86))
           ((when flg) (<a href="ACL2____MV.html">mv</a> flg 0 0 x86)))
          (<a href="ACL2____MV.html">mv</a> nil (<a href="X86ISA____N16.html">n16</a> (<a href="COMMON-LISP_____B2.html">+</a> di disp))
              increment-rip-by x86)))
   (6
    (<a href="COMMON-LISP____CASE.html">case</a>
     mod
     (0 (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> flg disp x86)
              (rime-size-opt proc-mode 2 temp-rip 1 :x nil x86
                             :mem-ptr? nil))
             ((when flg) (<a href="ACL2____MV.html">mv</a> flg 0 0 x86)))
            (<a href="ACL2____MV.html">mv</a> nil (<a href="X86ISA____N16.html">n16</a> disp) 2 x86)))
     (otherwise
      (<a href="ACL2____B_A2.html">b*</a> ((bp (<a href="X86ISA____RR16.html">rr16</a> 5 x86))
           ((<a href="ACL2____MV.html">mv</a> flg disp increment-rip-by x86)
            (<a href="X86ISA____X86-EFFECTIVE-ADDR-16-DISP.html">x86-effective-addr-16-disp</a> proc-mode temp-rip mod x86))
           ((when flg) (<a href="ACL2____MV.html">mv</a> flg 0 0 x86)))
          (<a href="ACL2____MV.html">mv</a> nil (<a href="X86ISA____N16.html">n16</a> (<a href="COMMON-LISP_____B2.html">+</a> bp disp))
              increment-rip-by x86)))))
   (7 (<a href="ACL2____B_A2.html">b*</a> ((bx (<a href="X86ISA____RR16.html">rr16</a> 3 x86))
           ((<a href="ACL2____MV.html">mv</a> flg disp increment-rip-by x86)
            (<a href="X86ISA____X86-EFFECTIVE-ADDR-16-DISP.html">x86-effective-addr-16-disp</a> proc-mode temp-rip mod x86))
           ((when flg) (<a href="ACL2____MV.html">mv</a> flg 0 0 x86)))
          (<a href="ACL2____MV.html">mv</a> nil (<a href="X86ISA____N16.html">n16</a> (<a href="COMMON-LISP_____B2.html">+</a> bx disp))
              increment-rip-by x86)))
   (otherwise (<a href="ACL2____MV.html">mv</a> :r/m-out-of-range 0 0 x86)))))</pre> 
<p><b>Theorem: </b>n16p-of-x86-effective-addr-16.address</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     n16p-of-x86-effective-addr-16.address
     (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?flg ?address ?increment-rip-by ?x86)
           (<a href="X86ISA____X86-EFFECTIVE-ADDR-16.html">x86-effective-addr-16</a> proc-mode temp-rip r/m mod x86)))
         (<a href="X86ISA____N16P.html">n16p</a> address))
     :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>natp-of-x86-effective-addr-16.increment-rip-by</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     natp-of-x86-effective-addr-16.increment-rip-by
     (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?flg ?address ?increment-rip-by ?x86)
           (<a href="X86ISA____X86-EFFECTIVE-ADDR-16.html">x86-effective-addr-16</a> proc-mode temp-rip r/m mod x86)))
         (<a href="ACL2____NATP.html">natp</a> increment-rip-by))
     :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>x86p-of-x86-effective-addr-16.x86</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 x86p-of-x86-effective-addr-16.x86
 (<a href="ACL2____IMPLIES.html">implies</a>
      (x86p x86)
      (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?flg ?address ?increment-rip-by ?x86)
            (<a href="X86ISA____X86-EFFECTIVE-ADDR-16.html">x86-effective-addr-16</a> proc-mode temp-rip r/m mod x86)))
          (x86p x86)))
 :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>i64p-mv-nth-1-x86-effective-addr-16</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 i64p-mv-nth-1-x86-effective-addr-16
 (<a href="ACL2____SIGNED-BYTE-P.html">signed-byte-p</a>
    64
    (<a href="ACL2____MV-NTH.html">mv-nth</a> 1
            (<a href="X86ISA____X86-EFFECTIVE-ADDR-16.html">x86-effective-addr-16</a> proc-mode temp-rip r/m mod x86)))
 :rule-classes
 (:rewrite
  (:type-prescription
   :corollary
   (<a href="COMMON-LISP____INTEGERP.html">integerp</a>
    (<a href="ACL2____MV-NTH.html">mv-nth</a> 1
            (<a href="X86ISA____X86-EFFECTIVE-ADDR-16.html">x86-effective-addr-16</a> proc-mode temp-rip r/m mod x86)))
   :hints (("Goal" :in-theory '(<a href="ACL2____SIGNED-BYTE-P.html">signed-byte-p</a> integer-range-p))))
  (:linear
   :corollary
   (<a href="COMMON-LISP____AND.html">and</a>
    (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a>
       -9223372036854775808
       (<a href="ACL2____MV-NTH.html">mv-nth</a>
            1
            (<a href="X86ISA____X86-EFFECTIVE-ADDR-16.html">x86-effective-addr-16</a> proc-mode temp-rip r/m mod x86)))
    (<a href="COMMON-LISP_____C3.html">&lt;</a>
     (<a href="ACL2____MV-NTH.html">mv-nth</a> 1
             (<a href="X86ISA____X86-EFFECTIVE-ADDR-16.html">x86-effective-addr-16</a> proc-mode temp-rip r/m mod x86))
     9223372036854775808))
   :hints
   (("Goal"
         :in-theory '(<a href="ACL2____SIGNED-BYTE-P.html">signed-byte-p</a> integer-range-p (:e expt)))))))</pre> 
<p><b>Theorem: </b>natp-mv-nth-2-x86-effective-addr-16</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 natp-mv-nth-2-x86-effective-addr-16
 (<a href="ACL2____NATP.html">natp</a>
    (<a href="ACL2____MV-NTH.html">mv-nth</a> 2
            (<a href="X86ISA____X86-EFFECTIVE-ADDR-16.html">x86-effective-addr-16</a> proc-mode temp-rip r/m mod x86)))
 :rule-classes :type-prescription)</pre> 
<p><b>Theorem: </b>mv-nth-2-x86-effective-addr-16-&lt;=-4</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 mv-nth-2-x86-effective-addr-16-&lt;=-4
 (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> 2
             (<a href="X86ISA____X86-EFFECTIVE-ADDR-16.html">x86-effective-addr-16</a> proc-mode temp-rip r/m mod x86))
     4)
 :rule-classes :linear)</pre> 
<p><b>Function: </b>x86-effective-addr-32/64</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 x86-effective-addr-32/64
 (proc-mode p4 temp-rip
            rex-byte r/m mod sib num-imm-bytes x86)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (x86)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (integer 0 4) proc-mode)
          (<a href="COMMON-LISP____TYPE.html">type</a> (signed-byte 48) temp-rip)
          (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 8) rex-byte)
          (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 3) r/m)
          (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 2) mod)
          (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 8) sib)
          (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 3) num-imm-bytes))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="X86ISA____2BITS-P.html">2bits-p</a> mod)
                             (<a href="X86ISA____3BITS-P.html">3bits-p</a> r/m)
                             (<a href="X86ISA____SIB-P.html">sib-p</a> sib))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((__function__ 'x86-effective-addr-32/64))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
  (<a href="ACL2____B_A2.html">b*</a>
   (((<a href="ACL2____MV.html">mv</a> flg
         addr displacement increment-rip-by x86)
     (<a href="COMMON-LISP____CASE.html">case</a>
      mod
      (0
       (<a href="COMMON-LISP____CASE.html">case</a>
        r/m
        (4 (<a href="X86ISA____X86-EFFECTIVE-ADDR-FROM-SIB.html">x86-effective-addr-from-sib</a>
                proc-mode
                temp-rip rex-byte mod sib x86))
        (5
          (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> proc-mode 0)
              (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?flg0 dword x86)
                    (rime-size-opt 0 4 temp-rip 1 :x nil x86
                                   :mem-ptr? nil))
                   ((<a href="ACL2____MV.html">mv</a> flg next-rip)
                    (<a href="X86ISA____ADD-TO-_A2IP.html">add-to-*ip</a> 0 temp-rip (<a href="COMMON-LISP_____B2.html">+</a> 4 num-imm-bytes)
                                x86))
                   ((when flg) (<a href="ACL2____MV.html">mv</a> flg 0 0 0 x86)))
                  (<a href="ACL2____MV.html">mv</a> flg0 next-rip dword 4 x86))
              (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> flg dword x86)
                    (rime-size-opt proc-mode 4 temp-rip 1 :x nil x86
                                   :mem-ptr? nil))
                   ((when flg) (<a href="ACL2____MV.html">mv</a> flg 0 0 0 x86)))
                  (<a href="ACL2____MV.html">mv</a> nil 0 dword 4 x86))))
        (otherwise (<a href="ACL2____MV.html">mv</a> nil
                       (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> proc-mode 0)
                           (rgfi (<a href="X86ISA____REG-INDEX.html">reg-index</a> r/m rex-byte 0) x86)
                           (<a href="X86ISA____RR32.html">rr32</a> r/m x86))
                       0 0 x86))))
      (1
       (<a href="COMMON-LISP____CASE.html">case</a>
         r/m
         (4 (<a href="X86ISA____X86-EFFECTIVE-ADDR-FROM-SIB.html">x86-effective-addr-from-sib</a>
                 proc-mode
                 temp-rip rex-byte mod sib x86))
         (otherwise
              (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?flg2 byte2 x86)
                    (rime-size-opt proc-mode 1 temp-rip 1 :x nil x86
                                   :mem-ptr? nil))
                   (reg (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> proc-mode 0)
                            (rgfi (<a href="X86ISA____REG-INDEX.html">reg-index</a> r/m rex-byte 0) x86)
                            (<a href="X86ISA____RR32.html">rr32</a> r/m x86))))
                  (<a href="ACL2____MV.html">mv</a> flg2 reg byte2 1 x86)))))
      (2
       (<a href="COMMON-LISP____CASE.html">case</a>
         r/m
         (4 (<a href="X86ISA____X86-EFFECTIVE-ADDR-FROM-SIB.html">x86-effective-addr-from-sib</a>
                 proc-mode
                 temp-rip rex-byte mod sib x86))
         (otherwise
              (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?flg1 dword x86)
                    (rime-size-opt proc-mode 4 temp-rip 1 :x nil x86
                                   :mem-ptr? nil))
                   (reg (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> proc-mode 0)
                            (rgfi (<a href="X86ISA____REG-INDEX.html">reg-index</a> r/m rex-byte 0) x86)
                            (<a href="X86ISA____RR32.html">rr32</a> r/m x86))))
                  (<a href="ACL2____MV.html">mv</a> flg1 reg dword 4 x86)))))
      (otherwise (<a href="ACL2____MV.html">mv</a> 'mod-value-wrong 0 0 0 x86))))
    (dst-base (<a href="COMMON-LISP_____B2.html">+</a> addr displacement))
    (dst-base (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> proc-mode 0)
                  (<a href="COMMON-LISP____IF.html">if</a> p4 (<a href="X86ISA____N32.html">n32</a> dst-base)
                      (<a href="X86ISA____N64-TO-I64.html">n64-to-i64</a> (<a href="X86ISA____N64.html">n64</a> dst-base)))
                  (<a href="X86ISA____N32.html">n32</a> dst-base))))
   (<a href="ACL2____MV.html">mv</a> flg dst-base increment-rip-by x86))))</pre> 
<p><b>Theorem: </b>x86p-of-x86-effective-addr-32/64.x86</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 x86p-of-x86-effective-addr-32/64.x86
 (<a href="ACL2____IMPLIES.html">implies</a>
    (<a href="ACL2____FORCE.html">force</a> (x86p x86))
    (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?flg ?i64p-memory-address
              ?increment-rip-by ?x86)
          (<a href="X86ISA____X86-EFFECTIVE-ADDR-32_F264.html">x86-effective-addr-32/64</a> proc-mode p4 temp-rip rex-byte
                                    r/m mod sib num-imm-bytes x86)))
        (x86p x86)))
 :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>i64p-mv-nth-1-x86-effective-addr-32/64</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 i64p-mv-nth-1-x86-effective-addr-32/64
 (<a href="ACL2____SIGNED-BYTE-P.html">signed-byte-p</a>
  64
  (<a href="ACL2____MV-NTH.html">mv-nth</a> 1
          (<a href="X86ISA____X86-EFFECTIVE-ADDR-32_F264.html">x86-effective-addr-32/64</a> proc-mode p4 temp-rip rex-byte
                                    r/m mod sib num-imm-bytes x86)))
 :rule-classes
 (:rewrite
  (:type-prescription
   :corollary
   (<a href="COMMON-LISP____INTEGERP.html">integerp</a>
     (<a href="ACL2____MV-NTH.html">mv-nth</a>
          1
          (<a href="X86ISA____X86-EFFECTIVE-ADDR-32_F264.html">x86-effective-addr-32/64</a> proc-mode p4 temp-rip rex-byte
                                    r/m mod sib num-imm-bytes x86)))
   :hints (("Goal" :in-theory '(<a href="ACL2____SIGNED-BYTE-P.html">signed-byte-p</a> integer-range-p))))
  (:linear
   :corollary
   (<a href="COMMON-LISP____AND.html">and</a>
    (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a>
     -9223372036854775808
     (<a href="ACL2____MV-NTH.html">mv-nth</a>
          1
          (<a href="X86ISA____X86-EFFECTIVE-ADDR-32_F264.html">x86-effective-addr-32/64</a> proc-mode p4 temp-rip rex-byte
                                    r/m mod sib num-imm-bytes x86)))
    (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> 1
               (<a href="X86ISA____X86-EFFECTIVE-ADDR-32_F264.html">x86-effective-addr-32/64</a>
                    proc-mode p4 temp-rip
                    rex-byte r/m mod sib num-imm-bytes x86))
       9223372036854775808))
   :hints
   (("Goal"
         :in-theory '(<a href="ACL2____SIGNED-BYTE-P.html">signed-byte-p</a> integer-range-p (:e expt)))))))</pre> 
<p><b>Theorem: </b>natp-mv-nth-2-x86-effective-addr-32/64</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 natp-mv-nth-2-x86-effective-addr-32/64
 (<a href="ACL2____NATP.html">natp</a>
  (<a href="ACL2____MV-NTH.html">mv-nth</a> 2
          (<a href="X86ISA____X86-EFFECTIVE-ADDR-32_F264.html">x86-effective-addr-32/64</a> proc-mode p4 temp-rip rex-byte
                                    r/m mod sib num-imm-bytes x86)))
 :rule-classes :type-prescription)</pre> 
<p><b>Theorem: </b>mv-nth-2-x86-effective-addr-32/64-&lt;=-4</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mv-nth-2-x86-effective-addr-32/64-&lt;=-4
        (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> 2
                    (<a href="X86ISA____X86-EFFECTIVE-ADDR-32_F264.html">x86-effective-addr-32/64</a>
                         proc-mode p4 temp-rip
                         rex-byte r/m mod sib num-imm-bytes x86))
            4)
        :rule-classes :linear)</pre> 
<p><b>Function: </b>x86-effective-addr</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 x86-effective-addr
 (proc-mode p4 temp-rip
            rex-byte r/m mod sib num-imm-bytes x86)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (x86)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (integer 0 4) proc-mode)
          (<a href="COMMON-LISP____TYPE.html">type</a> (signed-byte 48) temp-rip)
          (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 8) rex-byte)
          (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 3) r/m)
          (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 2) mod)
          (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 8) sib)
          (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 3) num-imm-bytes))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="X86ISA____2BITS-P.html">2bits-p</a> mod)
                             (<a href="X86ISA____3BITS-P.html">3bits-p</a> r/m)
                             (<a href="X86ISA____SIB-P.html">sib-p</a> sib))))
 (<a href="COMMON-LISP____LET.html">let</a>
     ((__function__ 'x86-effective-addr))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
     (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQL.html">eql</a> 2
              (<a href="X86ISA____SELECT-ADDRESS-SIZE.html">select-address-size</a> proc-mode (<a href="COMMON-LISP____IF.html">if</a> p4 t nil)
                                   x86))
         (<a href="X86ISA____X86-EFFECTIVE-ADDR-16.html">x86-effective-addr-16</a> proc-mode temp-rip r/m mod x86)
         (<a href="X86ISA____X86-EFFECTIVE-ADDR-32_F264.html">x86-effective-addr-32/64</a> proc-mode p4 temp-rip rex-byte
                                   r/m mod sib num-imm-bytes x86))))</pre> 
<p><b>Theorem: </b>x86p-of-x86-effective-addr.x86</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 x86p-of-x86-effective-addr.x86
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____FORCE.html">force</a> (x86p x86))
          (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?flg ?i64p-memory-address
                    ?increment-rip-by ?x86)
                (<a href="X86ISA____X86-EFFECTIVE-ADDR.html">x86-effective-addr</a> proc-mode p4 temp-rip rex-byte
                                    r/m mod sib num-imm-bytes x86)))
              (x86p x86)))
 :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>i64p-mv-nth-1-x86-effective-addr</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 i64p-mv-nth-1-x86-effective-addr
 (<a href="ACL2____SIGNED-BYTE-P.html">signed-byte-p</a>
      64
      (<a href="ACL2____MV-NTH.html">mv-nth</a> 1
              (<a href="X86ISA____X86-EFFECTIVE-ADDR.html">x86-effective-addr</a> proc-mode p4 temp-rip rex-byte
                                  r/m mod sib num-imm-bytes x86)))
 :rule-classes
 (:rewrite
  (:type-prescription
   :corollary
   (<a href="COMMON-LISP____INTEGERP.html">integerp</a>
        (<a href="ACL2____MV-NTH.html">mv-nth</a> 1
                (<a href="X86ISA____X86-EFFECTIVE-ADDR.html">x86-effective-addr</a> proc-mode p4 temp-rip rex-byte
                                    r/m mod sib num-imm-bytes x86)))
   :hints (("Goal" :in-theory '(<a href="ACL2____SIGNED-BYTE-P.html">signed-byte-p</a> integer-range-p))))
  (:linear
   :corollary
   (<a href="COMMON-LISP____AND.html">and</a>
    (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> -9223372036854775808
        (<a href="ACL2____MV-NTH.html">mv-nth</a> 1
                (<a href="X86ISA____X86-EFFECTIVE-ADDR.html">x86-effective-addr</a> proc-mode p4 temp-rip rex-byte
                                    r/m mod sib num-imm-bytes x86)))
    (<a href="COMMON-LISP_____C3.html">&lt;</a>
     (<a href="ACL2____MV-NTH.html">mv-nth</a>
        1
        (<a href="X86ISA____X86-EFFECTIVE-ADDR.html">x86-effective-addr</a> proc-mode p4 temp-rip
                            rex-byte r/m mod sib num-imm-bytes x86))
     9223372036854775808))
   :hints
   (("Goal"
         :in-theory '(<a href="ACL2____SIGNED-BYTE-P.html">signed-byte-p</a> integer-range-p (:e expt)))))))</pre> 
<p><b>Theorem: </b>natp-mv-nth-2-x86-effective-addr</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  natp-mv-nth-2-x86-effective-addr
  (<a href="ACL2____NATP.html">natp</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> 2
                (<a href="X86ISA____X86-EFFECTIVE-ADDR.html">x86-effective-addr</a> proc-mode p4 temp-rip rex-byte
                                    r/m mod sib num-imm-bytes x86)))
  :rule-classes :type-prescription)</pre> 
<p><b>Theorem: </b>mv-nth-2-x86-effective-addr-&lt;=-4</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 mv-nth-2-x86-effective-addr-&lt;=-4
 (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a>
   (<a href="ACL2____MV-NTH.html">mv-nth</a>
        2
        (<a href="X86ISA____X86-EFFECTIVE-ADDR.html">x86-effective-addr</a> proc-mode p4 temp-rip
                            rex-byte r/m mod sib num-imm-bytes x86))
   4)
 :rule-classes :linear)</pre> 
<p><b>Theorem: </b>x86-effective-addr-when-64-bit-modep</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  x86-effective-addr-when-64-bit-modep
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="X86ISA____X86-EFFECTIVE-ADDR.html">x86-effective-addr</a> 0 p4 temp-rip
                             rex-byte r/m mod sib num-imm-bytes x86)
         (<a href="X86ISA____X86-EFFECTIVE-ADDR-32_F264.html">x86-effective-addr-32/64</a> 0 p4 temp-rip rex-byte
                                   r/m mod sib num-imm-bytes x86)))</pre> 

</body>
</html>
