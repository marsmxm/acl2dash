<html>
<head>
<meta charset="UTF-8">
<title>Defarbrec-process-body</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____DEFARBREC-PROCESS-BODY">Click for Defarbrec-process-body in the Full Manual</a></h3>

<p>Process the <span class="v">body</span> input.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(defarbrec-process-body body fn$ x1...xn$ ctx state) 
  → 
(mv erp result state)</pre></dt>
<dt>Returns</dt>
<dd>
<span class="tt">result</span> — A tuple <span class="v">(body$ test updates)</span> 
                        satisfying 
                        <span class="v">(<a href="ACL2____TYPED-TUPLEP.html">typed-tuplep</a> pseudo-termp
                                         pseudo-termp
                                         pseudo-term-listp
                                         result)</span>.</dd> 
 
</dl></div> 
<p>We submit the program-mode function to ACL2, 
     so that any errors in the body will be caught 
     and will stop execution with an error. 
     If the submission succeeds, the ACL2 state now includes the function, 
     which we further validate and decompose.</p><p>If the function has the form 
     assumed in the documentation of <span class="tt"><a href="ACL2____DEFARBREC.html">defarbrec</a></span>, 
     the exit test is <span class="v">test&lt;x1,...,xn&gt;</span> 
     and the updated arguments are 
     <span class="v">update-x1&lt;x1,...,xn&gt;</span>, ..., <span class="v">update-xn&lt;x1,...xn&gt;</span>. 
     If the function has a different form, 
     the exit test is the negation of the conjunction of 
     the tests that control the recursive call.</p><p>Note that the <span class="v">wrld</span> variable is bound 
     after calling <span class="tt"><a href="ACL2____TRANS-EVAL-ERROR-TRIPLE.html">trans-eval-error-triple</a></span>, 
     to ensure that the program-mode function is in that world.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>defarbrec-process-body</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 defarbrec-process-body
 (<a href="ACL2____BODY.html">body</a> fn$ x1...xn$ ctx state)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (<a href="ACL2____STATE.html">state</a>)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((__function__ 'defarbrec-process-body))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
  (<a href="ACL2____B_A2.html">b*</a>
   ((program-mode-fn
         (<a href="COMMON-LISP____CONS.html">cons</a> 'defun
               (<a href="COMMON-LISP____CONS.html">cons</a> fn$
                     (<a href="COMMON-LISP____CONS.html">cons</a> x1...xn$
                           (<a href="COMMON-LISP____CONS.html">cons</a> '(<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :mode :program))
                                 (<a href="COMMON-LISP____CONS.html">cons</a> body 'nil))))))
    ((<a href="ACL2____ER.html">er</a> &amp;)
     (<a href="ACL2____TRANS-EVAL-ERROR-TRIPLE.html">trans-eval-error-triple</a> program-mode-fn ctx state))
    (wrld (<a href="ACL2____W.html">w</a> state))
    (body$ (<a href="ACL2____UBODY.html">ubody</a> fn$ wrld))
    (description (<a href="ACL2____MSG.html">msg</a> "The function ~x0" fn$))
    ((<a href="ACL2____ER.html">er</a> &amp;)
     (<a href="ACL2____ENSURE-FUNCTION-NUMBER-OF-RESULTS_42.html">ensure-function-number-of-results$</a> fn$ 1 description t nil))
    ((<a href="ACL2____ER.html">er</a> &amp;)
     (<a href="ACL2____ENSURE-FUNCTION-NO-STOBJS_42.html">ensure-function-no-stobjs$</a> fn$ description t nil))
    (rec-calls-with-tests (<a href="ACL2____RECURSIVE-CALLS.html">recursive-calls</a> fn$ wrld))
    (num-rec-calls (<a href="ACL2____LEN.html">len</a> rec-calls-with-tests))
    ((when (<a href="COMMON-LISP_____F2_D3.html">/=</a> num-rec-calls 1))
     (<a href="ACL2____ER-SOFT_B2.html">er-soft+</a>
      ctx t nil
      "The function ~x0 must make exactly one recursive call, ~
                   but it makes ~x1 recursive calls instead."
      fn$ num-rec-calls))
    (program-mode-fns (<a href="ACL2____ALL-PROGRAM-FFN-SYMBS.html">all-program-ffn-symbs</a> body$ nil wrld))
    (program-mode-fns (<a href="ACL2____REMOVE-EQ.html">remove-eq</a> fn$ program-mode-fns))
    ((unless (<a href="COMMON-LISP____NULL.html">null</a> program-mode-fns))
     (<a href="ACL2____ER-SOFT_B2.html">er-soft+</a>
      ctx t nil
      "The function ~x0 must call ~
                   only logic-mode functions besides itself, ~
                   but it also calls the program-mode ~@1 instead."
      fn$
      (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____D3.html">=</a> (<a href="ACL2____LEN.html">len</a> program-mode-fns) 1)
          (<a href="ACL2____MSG.html">msg</a> "function ~x0" (<a href="COMMON-LISP____CAR.html">car</a> program-mode-fns))
          (<a href="ACL2____MSG.html">msg</a> "functions ~&amp;0" program-mode-fns))))
    (rec-call-with-tests (<a href="COMMON-LISP____CAR.html">car</a> rec-calls-with-tests))
    (tests (<a href="ACL2____ACCESS.html">access</a> tests-and-call
                   rec-call-with-tests :tests))
    (rec-call (<a href="ACL2____ACCESS.html">access</a> tests-and-call
                      rec-call-with-tests :call))
    (test (<a href="ACL2____DUMB-NEGATE-LIT.html">dumb-negate-lit</a> (<a href="ACL2____CONJOIN.html">conjoin</a> tests)))
    (updates (<a href="ACL2____FARGS.html">fargs</a> rec-call)))
   (<a href="ACL2____VALUE.html">value</a> (<a href="COMMON-LISP____LIST.html">list</a> body$ test updates)))))</pre> 

</body>
</html>
