<html>
<head>
<meta charset="UTF-8">
<title>Patterned-congruence</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____PATTERNED-CONGRUENCE">Click for Patterned-congruence in the Full Manual</a></h3>

<p>Removing restrictions on classic <a href="ACL2____CONGRUENCE.html">congruence</a> rules</p><p>This topic assumes familiarity with the basics of congruence rules; 
 see <a href="ACL2____CONGRUENCE.html">congruence</a>.  Some aspects of congruence rules carry over to 
 patterned congruence rules; in particular, they may be <a href="ACL2____DISABLE.html">disable</a>d, but 
 they are not tracked for reporting in the <a href="ACL2____SUMMARY.html">summary</a>.</p> 
 
 <p>We begin our discussion by showing some patterned congruence rules and 
 using them to illustrate some terminology.</p> 
 
 <pre class="code">Example forms:

; ``Shallow'' patterned congruence rule:
(<a href="ACL2____IMPLIES.html">implies</a> (e1 y1 y2)
         (e2 (f1 3 y1 (<a href="COMMON-LISP____CONS.html">cons</a> x x))
             (f1 3 y2 (<a href="COMMON-LISP____CONS.html">cons</a> x x))))

; ``Deep'' patterned congruence rule:
(<a href="ACL2____IMPLIES.html">implies</a> (e1 y1 y2)
         (e2 (<a href="ACL2____MV-NTH.html">mv-nth</a> 1 (foo x y1 z))
             (<a href="ACL2____MV-NTH.html">mv-nth</a> 1 (foo x y2 z))))

; ``Deep'' patterned congruence rule:
(<a href="ACL2____IMPLIES.html">implies</a> (e1 y1 y2)
         (e2 (<a href="ACL2____MV-NTH.html">mv-nth</a> 1 (foo x (<a href="ACL2____G.html">g</a> y1) z))
             (<a href="ACL2____MV-NTH.html">mv-nth</a> 1 (foo x (<a href="ACL2____G.html">g</a> y2) z))))</pre> 
 
 <p>In the example forms above, <span class="v">e1</span> and <span class="v">e2</span> are known equivalence 
 relations, which (as for classic congruence rules) we call the ``inner'' and 
 ``outer'' equivalences.  The examples above are not classic, because the 
 ``function symbol'' of the rule — <span class="v">f1</span> in the first example, 
 <span class="v">mv-nth</span> in the second and third examples — is not being applied to 
 distinct variables.  The first example is called ``shallow'' because the 
 ``variable'' of the rule, <span class="v">y1</span>, is a top-level argument of the ``lhs'' of 
 the rule, which is the first call of <span class="v">f1</span>; the others do not have this 
 property, as <span class="v">y1</span> is buried under further function calls.</p> 
 
 <p>We invite you to browse the community book 
 <span class="tt">demos/patterned-congruences.lisp</span>, which provides several examples of 
 patterned congruence rules and their use, as well as several examples of 
 formulas that are illegal as patterned congruence rules for various 
 reasons.</p> 
 
 <p>We now define the class of patterned congruence rules.  The general form of 
 a patterned congruence rule is</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (equiv1 x y)
         (equiv2 lhs rhs)),</pre> 
 
 <p>where the rule is not classic (see <a href="ACL2____CONGRUENCE.html">congruence</a>) and the following 
 conditions hold.  <span class="v">Equiv1</span> and <span class="v">equiv2</span> are known equivalence relations, 
 which (as in the classic case) we call the ``inner'' and ``outer'' 
 equivalences, respectively.  The terms <span class="v">lhs</span> and <span class="v">rhs</span> are function 
 calls, and we call these the <span class="v">lhs</span> and <span class="v">rhs</span> of the rule, respectively. 
 The variable <span class="v">x</span> occurs in <span class="v">lhs</span> and the variable <span class="v">y</span> occurs in 
 <span class="v">rhs</span>.  These must be the only occurrences of <span class="v">x</span> and <span class="v">y</span> in either 
 <span class="v">lhs</span> or <span class="v">rhs</span>, and <span class="v">rhs</span> must be the result of substituting <span class="v">y</span> 
 for <span class="v">x</span> in <span class="v">lhs</span>.  None of the following may occur as a function symbol 
 of <span class="v">lhs</span> (or, equivalently, <span class="v">rhs</span>): <span class="v">if</span>, <span class="v">implies</span>, <span class="v">equal</span>, 
 or a <span class="tt"><a href="COMMON-LISP____LAMBDA.html">lambda</a></span>.</p> 
 
 <p>Patterned congruence rules are used, much like classic congruence rules, by 
 the ACL2 rewriter to determine which equivalence relations to maintain as it 
 dives into a term.  Recall (see <a href="ACL2____CONGRUENCE.html">congruence</a>) that if it suffices for the 
 rewriter to maintain <span class="v">e2</span> when rewriting a term, then it suffices to 
 maintain <span class="v">e1</span> when rewriting an argument of that term provided there is an 
 applicable congruence rule with outer equivalence <span class="v">e2</span> and inner 
 equivalence <span class="v">e1</span>.  An analogous principle holds for patterned congruence 
 rules, which by the way consider refinements of the outer equivalence just as 
 is done by classic congruence rules.  But there is a new wrinkle because the 
 lhs of a patterned congruence rule is a function call that can have 
 non-variable arguments.  Consider the following events.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> e1 (x y)
  (<a href="COMMON-LISP____EQUAL.html">equal</a> x y))

(<a href="ACL2____DEFEQUIV.html">defequiv</a> e1)

(<a href="COMMON-LISP____DEFUN.html">defun</a> f10 (x)
  (<a href="COMMON-LISP____LIST.html">list</a> 3 x x))

(<a href="COMMON-LISP____DEFUN.html">defun</a> f11 (x y)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORE.html">ignore</a> y))
  x)

(<a href="ACL2____DEFTHM.html">defthm</a> e1-implies-iff-f11-cong-2
  (<a href="ACL2____IMPLIES.html">implies</a> (e1 y1 y2)
           (<a href="ACL2____IFF.html">iff</a> (f11 (f10 x) y1)
                (f11 (f10 x) y2)))
  :rule-classes (:congruence))

(<a href="ACL2____IN-THEORY.html">in-theory</a> (<a href="ACL2____DISABLE.html">disable</a> f11 (:t f11) e1))</pre> 
 
 <p>The following proof fails, because the indicated call of <span class="v">f10</span> expands 
 before the rewriter is applied to <span class="v">b2</span> — otherwise <span class="v">b2</span> would 
 rewrite to <span class="v">b1</span> because <span class="v">(e1 b1 b2)</span> is known in that context and by the 
 rule above, it suffices to maintain <span class="v">e1</span> when rewriting <span class="v">b2</span>.</p> 
 
 <pre class="code">(<a href="ACL2____THM.html">thm</a> (<a href="ACL2____IMPLIES.html">implies</a> (e1 b1 b2)
              (<a href="ACL2____IFF.html">iff</a> (f11 (f10 a)
                        b1)
                   (f11 (f10 a) ; expands before b2 is rewritten
                        b2))))</pre> 
 
 <p>On the other hand, the following succeeds because the rewrite discussed 
 above does indeed take place when the indicated call of <span class="v">f10</span> does not 
 expand.</p> 
 
 <pre class="code">(<a href="ACL2____THM.html">thm</a>
  (<a href="ACL2____IMPLIES.html">implies</a> (e1 b1 b2)
           (<a href="ACL2____IFF.html">iff</a> (f11 (f10 a)
                     b1)
                (f11 (f10 a) ; does not expand
                     b2)))
  :hints (("Goal" :in-theory (<a href="ACL2____DISABLE.html">disable</a> f10))))</pre> 
 
 <p>This inherent sequentiality of matching is important for soundness, as is 
 illustrated by examples using the function <span class="v">some-consp</span> in the 
 aforementioned community book, <span class="tt">demos/patterned-congruences.lisp</span>.</p> 
 
 <p>The example above illustrates the following point: as the rewriter dives 
 into a term, then when matching is attempted using a patterned congruence 
 rule, rewriting has already taken place to the left of the current subterm. 
 By contrast, note that this pass through the rewriter will not yet have 
 completed rewriting of terms to the right of the current subterm when matching 
 a patterned congruence rule.</p> 
 
 <p>Patterned congruence rules are used primarily during the process of 
 <i>rewriting</i>.  In particular, unlike classic congruence rules, they are 
 <i>not</i> used to do equality substitution at the goal level or in <a href="ACL2____PROOF-BUILDER.html">proof-builder</a> commands such as <span class="v">=</span> and <span class="v">equiv</span>.  The simplest way to 
 understand this point may be with the following trivial example.</p> 
 
 <pre class="code">(<a href="ACL2____DEFSTUB.html">defstub</a> foo (x y z) t)

(<a href="ACL2____THM.html">thm</a> (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> u (<a href="COMMON-LISP_____A2.html">*</a> a b))
              (foo u u b)))</pre> 
 
 <p>The theorem fails, of course, but what is interesting is that ACL2 
 simplifies it by replacing the variable <span class="v">u</span> by the term <span class="v">(<a href="COMMON-LISP_____A2.html">*</a> a b)</span> 
 throughout the goal and then dropping the equality, to produce the following 
 goal.</p> 
 
 <pre class="code">(FOO (<a href="COMMON-LISP_____A2.html">*</a> A B) (<a href="COMMON-LISP_____A2.html">*</a> A B) B)</pre> 
 
 <p>This sort of substitution can also be made when <span class="v">equal</span> is replaced by a 
 known equivalence relation, if a classic congruence rule for <span class="v">foo</span> 
 justifies the substitution.  But that is not the case for our implementation 
 of patterned congruence rules.</p> 
 
 <p>The discussion above is intended to suffice for effective use of patterned 
 congruence rules.  If you are interested in their <i>implementation</i>, we 
 invite you to read the long comment entitled ``Essay on Patterned Congruences 
 and Equivalences'' in ACL2 source file <span class="tt">rewrite.lisp</span>.</p>
</body>
</html>
