<html>
<head>
<meta charset="UTF-8">
<title>Vl-hidindex-datatype-resolve-dims</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=VL2014____VL-HIDINDEX-DATATYPE-RESOLVE-DIMS">Click for Vl-hidindex-datatype-resolve-dims in the Full Manual</a></h3>

<p>Given a hidindex expression, e.g. foo[5][3], and the datatype and 
unpacked dimensions corresponding to foo, return the datatype and unpacked 
dimensions corresponding to the whole expression.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(vl-hidindex-datatype-resolve-dims x type) 
   
(mv warning type1)</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">x</span>  <font color="#606060">Guard <span class="v">(<a href="VL2014____VL-EXPR-P.html">vl-expr-p</a> x)</span>.</font>
</dd> 
  <dd>
<span class="tt">type</span>  <font color="#606060">Guard <span class="v">(<a href="VL2014____VL-DATATYPE-P.html">vl-datatype-p</a> type)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">warning</span>  <font color="#606060">Type <span class="v">(<a href="ACL2____IFF.html">iff</a> (<a href="VL2014____VL-WARNING-P.html">vl-warning-p</a> warning) warning)</span>.</font>
</dd> 
<dd>
<span class="tt">type1</span>  <font color="#606060">Type <span class="v">(<a href="ACL2____IFF.html">iff</a> (<a href="VL2014____VL-DATATYPE-P.html">vl-datatype-p</a> type1) (<a href="COMMON-LISP____NOT.html">not</a> warning))</span>.</font>
</dd> 
 
</dl></div> 
<p>Note: we don't check whether indices are in bounds or anything, 
just whether the number of indices is less than or equal the number of 
total (unpacked plus packed) dimensions.</p> 
 
<p>We produce a non-fatal warning because we're not sure in what contexts this 
will be used.</p> 
 
<p>Example: Suppose our datatype is from a typedef</p> 
 
<pre class="code">typedef bit [3:0] [4:2] foo [0:6] [0:8];</pre> 
 
<p>that is, it has one unpacked dimension <span class="v">[0:6]</span> and two packed dimensions. 
Suppose our expression is <span class="v">bar[5][7][2]</span>, where bar is of type foo.  Then we 
should return <span class="v">bit[4:2]</span> as our resolved datatype, with no unpacked 
dimensions, because the first two indices correspond to the unpacked dimension 
and the second to the first packed dimension.  On the other hand if we had 
<span class="v">bar[5]</span>, we should return <span class="v">bit</span> with packed dimensions <span class="v">[3:0][4:2]</span> 
and unpacked dimension <span class="v">[0:8]</span>.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>vl-hidindex-datatype-resolve-dims</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 vl-hidindex-datatype-resolve-dims
 (x type)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="VL2014____VL-EXPR-P.html">vl-expr-p</a> x)
                             (<a href="VL2014____VL-DATATYPE-P.html">vl-datatype-p</a> type))))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="VL2014____VL-HIDINDEX-P.html">vl-hidindex-p</a> x)))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((__function__ 'vl-hidindex-datatype-resolve-dims))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
  (<a href="ACL2____B_A2.html">b*</a>
   ((idxcount (<a href="VL2014____VL-HIDINDEX-COUNT-INDICES.html">vl-hidindex-count-indices</a> x))
    (<a href="COMMON-LISP____TYPE.html">type</a> (<a href="VL2014____VL-DATATYPE-FIX.html">vl-datatype-fix</a> type))
    (x (<a href="VL2014____VL-EXPR-FIX.html">vl-expr-fix</a> x))
    (unpacked-dims (<a href="VL2014____VL-DATATYPE-_E3UDIMS.html">vl-datatype-&gt;udims</a> type))
    (packed-dims (<a href="VL2014____VL-DATATYPE-_E3PDIMS.html">vl-datatype-&gt;pdims</a> type))
    (nunpacked (<a href="ACL2____LEN.html">len</a> unpacked-dims))
    ((when (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> idxcount nunpacked))
     (<a href="ACL2____MV.html">mv</a> nil
         (<a href="VL2014____VL-DATATYPE-UPDATE-UDIMS.html">vl-datatype-update-udims</a>
              (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> idxcount (<a href="ACL2____LIST-FIX.html">list-fix</a> unpacked-dims))
              type)))
    (remaining-idxcount (<a href="COMMON-LISP____-.html">-</a> idxcount nunpacked))
    ((unless (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> remaining-idxcount (<a href="ACL2____LEN.html">len</a> packed-dims)))
     (<a href="ACL2____MV.html">mv</a>
      (<a href="VL2014____MAKE-VL-WARNING.html">make-vl-warning</a>
       :type :vl-too-many-indices
       :msg
       "Too many indices on expression ~a0 ~
                                   relative to dimensions of type ~a1 (with ~
                                   ~x2 additional unpacked dimensions)."
       :args (<a href="COMMON-LISP____LIST.html">list</a> x type (<a href="ACL2____LEN.html">len</a> unpacked-dims))
       :fn __function__)
      nil))
    (<a href="COMMON-LISP____TYPE.html">type</a> (<a href="VL2014____VL-DATATYPE-UPDATE-DIMS.html">vl-datatype-update-dims</a> (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> remaining-idxcount
                                           (<a href="ACL2____LIST-FIX.html">list-fix</a> packed-dims))
                                   nil type)))
   (<a href="ACL2____MV.html">mv</a> nil type))))</pre> 
<p><b>Theorem: </b>return-type-of-vl-hidindex-datatype-resolve-dims.warning</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> return-type-of-vl-hidindex-datatype-resolve-dims.warning
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> common-lisp::?warning ?type1)
              (<a href="VL2014____VL-HIDINDEX-DATATYPE-RESOLVE-DIMS.html">vl-hidindex-datatype-resolve-dims</a> x type)))
            (<a href="ACL2____IFF.html">iff</a> (<a href="VL2014____VL-WARNING-P.html">vl-warning-p</a> warning) warning))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>return-type-of-vl-hidindex-datatype-resolve-dims.type1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> return-type-of-vl-hidindex-datatype-resolve-dims.type1
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> common-lisp::?warning ?type1)
              (<a href="VL2014____VL-HIDINDEX-DATATYPE-RESOLVE-DIMS.html">vl-hidindex-datatype-resolve-dims</a> x type)))
            (<a href="ACL2____IFF.html">iff</a> (<a href="VL2014____VL-DATATYPE-P.html">vl-datatype-p</a> type1)
                 (<a href="COMMON-LISP____NOT.html">not</a> warning)))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>vl-hidindex-datatype-resolve-dims-of-vl-expr-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> vl-hidindex-datatype-resolve-dims-of-vl-expr-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="VL2014____VL-HIDINDEX-DATATYPE-RESOLVE-DIMS.html">vl-hidindex-datatype-resolve-dims</a> (<a href="VL2014____VL-EXPR-FIX.html">vl-expr-fix</a> x)
                                                  type)
               (<a href="VL2014____VL-HIDINDEX-DATATYPE-RESOLVE-DIMS.html">vl-hidindex-datatype-resolve-dims</a> x type)))</pre> 
<p><b>Theorem: </b>vl-hidindex-datatype-resolve-dims-vl-expr-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  vl-hidindex-datatype-resolve-dims-vl-expr-equiv-congruence-on-x
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="VL2014____VL-EXPR-EQUIV.html">vl-expr-equiv</a> x x-equiv)
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="VL2014____VL-HIDINDEX-DATATYPE-RESOLVE-DIMS.html">vl-hidindex-datatype-resolve-dims</a> x type)
                  (<a href="VL2014____VL-HIDINDEX-DATATYPE-RESOLVE-DIMS.html">vl-hidindex-datatype-resolve-dims</a> x-equiv type)))
  :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>vl-hidindex-datatype-resolve-dims-of-vl-datatype-fix-type</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 vl-hidindex-datatype-resolve-dims-of-vl-datatype-fix-type
 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="VL2014____VL-HIDINDEX-DATATYPE-RESOLVE-DIMS.html">vl-hidindex-datatype-resolve-dims</a> x (<a href="VL2014____VL-DATATYPE-FIX.html">vl-datatype-fix</a> type))
        (<a href="VL2014____VL-HIDINDEX-DATATYPE-RESOLVE-DIMS.html">vl-hidindex-datatype-resolve-dims</a> x type)))</pre> 
<p><b>Theorem: </b>vl-hidindex-datatype-resolve-dims-vl-datatype-equiv-congruence-on-type</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 vl-hidindex-datatype-resolve-dims-vl-datatype-equiv-congruence-on-type
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="VL2014____VL-DATATYPE-EQUIV.html">vl-datatype-equiv</a> type type-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="VL2014____VL-HIDINDEX-DATATYPE-RESOLVE-DIMS.html">vl-hidindex-datatype-resolve-dims</a> x type)
                 (<a href="VL2014____VL-HIDINDEX-DATATYPE-RESOLVE-DIMS.html">vl-hidindex-datatype-resolve-dims</a> x type-equiv)))
 :rule-classes :congruence)</pre> 

</body>
</html>
