<html>
<head>
<meta charset="UTF-8">
<title>Simplify-defun</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=APT____SIMPLIFY-DEFUN">Click for Simplify-defun in the Full Manual</a></h3>

<p>Simplify the definition of a given function.</p><p>This macro is an interface to the <span class="tt"><a href="APT____SIMPLIFY.html">simplify</a></span> transformation 
 for function symbols that the user (or a tool) introduces with <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span>. 
 When successful, it creates a new <span class="v">defun</span> form by simplifying the body of 
 the definition of such a function symbol.</p> 
 
 <h3>Introduction</h3> 
 
 <p>See <a href="APT____SIMPLIFY-DEFUN-EXAMPLES.html">simplify-defun-examples</a> for an introductory tutorial for 
 <span class="v">simplify-defun</span>, which presents an extensive series of examples.</p> 
 
 <p>Evaluation of the form <span class="v">(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> FN)</span> will attempt to define a 
 new function, say, <span class="v">FN$1</span>, that is logically equivalent to the definition 
 of <span class="v">FN</span> but is simpler.  In the rest of this documentation page, 
 <span class="v">FN</span> will denote the input function symbol and <span class="v">NEW</span> will generally 
 denote the new function symbol.</p> 
 
 <p>Note that <span class="v">simplify-defun</span> transforms definitions made using <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> or macros such as <span class="tt"><a href="ACL2____DEFUND.html">defund</a></span> that expand to calls of <span class="v">defun</span>, or 
 the application of <span class="tt"><a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a></span> to such forms.  See <a href="APT____SIMPLIFY-DEFUN-SK.html">simplify-defun-sk</a> for an analogous utility for which the input function 
 symbol was originally defined with <span class="tt"><a href="ACL2____DEFUN-SK.html">defun-sk</a></span> rather than <span class="v">defun</span>. 
 Also see <a href="APT____SIMPLIFY-DEFUN_B2.html">simplify-defun+</a> for a variant of <span class="v">simplify-defun</span>, and see 
 <span class="v">transform-and-propagate</span> for a utility that can apply 
 <span class="v">simplify-defun</span> to several function symbols after applying an indicated 
 transformation.</p> 
 
 <p>A <span class="v">simplify-defun</span> call causes an error if the proof obligations fail to 
 be met or, by default, if no simplification takes place.  The implementation 
 has been carefully orchestrated so that the proof obligations will generally 
 succeed.  When this is not the case, you may invoke <span class="v">show-simplify-defun</span> 
 with the same arguments in order to obtain the form that failed to be 
 admitted, so that you can modify it manually.  Or equivalently, simply add 
 keyword argument <span class="v">:show-only t</span> in your <span class="v">simplify-defun</span> call.</p> 
 
 <h3>General Form</h3> 
 
 <p>The following form shows all the keyword arguments in alphabetical order, 
 together with their default values (i.e., when the keyword is omitted).  No 
 argument is evaluated, except that if an argument is of the form <span class="v">(:eval
 x)</span>, then the actual argument is the result of evaluating <span class="v">x</span>.  Note that 
 <span class="v">FN</span> should be a function symbol previously defined with <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span>; 
 thus, <span class="v">simplify-defun</span> may be replaced by <span class="tt"><a href="APT____SIMPLIFY.html">simplify</a></span> to obtain an 
 essentially equivalent call.</p> 
 
 <pre class="code">(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> FN
                &amp;key
                :assumptions        ; default nil
                :disable            ; default :none
                :enable             ; default :none
                :equiv              ; default nil
                :expand             ; default nil
                :hints              ; default nil
                :new-enable         ; default :auto
                :new-name           ; default :auto
                :guard-hints        ; default :auto
                :hyp-fn             ; default nil
                :measure            ; default :auto
                :measure-hints      ; default :auto
                :must-simplify      ; default (:body t :measure nil :guard nil)
                :non-executable     ; default :auto
                :print              ; default :result
                :show-only          ; default nil
                :simplify-body      ; default t
                :simplify-guard     ; default nil
                :simplify-measure   ; default nil
                :thm-enable         ; default t
                :thm-name           ; default :auto
                :theory             ; default :none
                :untranslate        ; default :nice
                :verify-guards      ; default :auto
                )</pre> 
 
 <h3>Inputs</h3> 
 
 <p><b>Special Note on keyword arguments in the case of <span class="tt"><a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a></span>.</b> If <span class="v">FN</span> was defined with <span class="v">mutual-recursion</span>, then 
 normally all keyword arguments are applied to the simplification of all 
 definitions that were introduced in that same <span class="v">mutual-recursion</span> event. 
 However, every keyword argument except <span class="v">:non-executable</span>, <span class="v">:print</span>, 
 <span class="v">:verify-guards</span>, and <span class="v">:show-only</span> can direct different values to be 
 applied to different definitions, by supplying a keyword argument of the form 
 <span class="v">(:map (fn1 val1) ... (fnk valk))</span>, where <span class="v">(fn1 ... fnk)</span> is the 
 <i>clique</i> introduced by that <span class="v">mutual-recursion</span>.  To get that clique, 
 evaluate the form <span class="v">(get-clique 'FN (<a href="ACL2____W.html">w</a> state))</span>.  Every member of the clique 
 must be specified, but in any order.  Moreover, entries can be combined in a 
 way inspired by <span class="tt"><a href="COMMON-LISP____CASE.html">case</a></span>: the key may be a list of functions, i.e., 
 <span class="v">(:map ... ((f g ... h) val) ... )</span> which is equivalent to <span class="v">(:map ... (f
 val) (g val) ... (h val) ... )</span>; and an optional final entry of the form 
 <span class="v">(:otherwise val)</span> specifies that all remaining clique members should be 
 assigned <span class="v">val</span>.  End of Special Note.</p> 
 
 <p> 
 <span class="v">FN</span> 
 </p> 
 <blockquote> 
 
 <p>Denotes the target function to transform.</p> 
 
 <p>Evaluation of <span class="v">(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> FN ...)</span> assumes that the input symbol, 
 <span class="v">FN</span>, is a <span class="v">:</span><span class="tt"><a href="ACL2____LOGIC.html">logic</a></span> mode function symbol, defined with <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> or with a macro expanding to a call of <span class="v">defun</span> (such as <span class="tt"><a href="ACL2____DEFUND.html">defund</a></span>).  Successful evaluation admits a new <span class="v">defun</span>, with the same 
 formals as <span class="v">FN</span>, and a theorem equating <span class="v">FN</span> with the newly-defined 
 function symbol, <span class="v">NEW</span>.  Details, such as whether or not to perform guard 
 verification, may be controlled by keyword parameters as described below.</p> 
 
 </blockquote> 
 
 <p> 
 <span class="v">:assumptions</span> — default <span class="v">nil</span> 
 </p> 
 <blockquote> 
 
 <p>Determines the assumptions for simplification.</p> 
 
 <p>The value of <span class="v">:assumptions</span> is generally a list of terms (not 
 necessarily translated; see <a href="ACL2____TERM.html">ACL2::term</a>) that only reference variables 
 among the formal parameters of <span class="v">FN</span>.  However, <span class="v">:assumptions</span> may be 
 <span class="v">:guard</span>, which is equivalent to <span class="v">:assumptions (G)</span> where <span class="v">G</span> is the 
 <a href="ACL2____GUARD.html">guard</a> of <span class="v">FN</span>; and for <span class="v">:assumptions (A1 ... :guard ... An)</span>, 
 <span class="v">:guard</span> is similarly replaced by <span class="v">G</span>.  Below we imagine that 
 <span class="v">:guard</span> has been replaced in these ways; let us assume below that the 
 value of <span class="v">:assumptions</span> is a list that does not contain <span class="v">:guard</span>.</p> 
 
 <p>When <span class="v">:assumptions H</span> is supplied, all simplification will be performed 
 assuming the conjunction of <span class="v">H'</span>, where <span class="v">H'</span> is the result of 
 simplifying each term in the list <span class="v">H</span>.  For another way to specify 
 assumptions, see the discussion of <span class="v">:hyp-fn</span>, below.</p> 
 
 <p>If <span class="v">FN</span> is defined recursively and <span class="v">:assumptions</span> is specified, there 
 will generally be a formula, called an ``applicability condition,'' that must 
 be a theorem in order for the transformation to succeed.  Any transformation 
 might have applicability conditions, each of which has a label; in the case of 
 <span class="v">simplify-defun</span>, the sole label is <span class="v">:assumptions-preserved</span>.  This 
 particular condition is that the assumptions must be preserved by recursive 
 calls of the function.</p> 
 
 </blockquote> 
 
 <p> 
 <span class="v">:disable</span> — default <span class="v">:none</span><br> 
 <span class="v">:enable</span> — default <span class="v">:none</span> 
 </p> 
 <blockquote> 
 
 <p>Determine the theory for simplification.</p> 
 
 <p>If <span class="v">:disable D</span> and <span class="v">:enable E</span> are supplied, then simplification 
 will be performed in the theory <span class="v">(<a href="ACL2____E_F2D_A2.html">e/d*</a> E D</span>'), where <span class="v">D'</span> is the result 
 of adding to <span class="v">D</span> the <a href="ACL2____RUNE.html">ACL2::rune</a>s that were introduced with the given 
 function, <span class="v">FN</span>.  The same holds if <span class="v">:disable</span> is omitted, in which case 
 <span class="v">D</span> is treated as <span class="v">nil</span>.  Similarly, if only <span class="v">:disable</span> is supplied, 
 then the theory will be <span class="v">(<a href="ACL2____DISABLE_A2.html">disable*</a> D</span>').  If either of these keywords is 
 supplied, then it is illegal to supply <span class="v">:theory</span>.  Also see the discussion 
 below of the <span class="v">:theory</span> argument.  Note that <span class="v">:disable</span> may be useful for 
 preserving calls of <span class="tt"><a href="ACL2____PROG2_42.html">prog2$</a></span>, <span class="tt"><a href="ACL2____EC-CALL.html">ec-call</a></span>, <span class="tt"><a href="ACL2____TIME_42.html">time$</a></span>, and other 
 such operators that provide special behavior; see <a href="ACL2____RETURN-LAST-BLOCKERS.html">ACL2::return-last-blockers</a>.</p> 
 
 </blockquote> 
 
 <p> 
 <span class="v">:equiv</span> — default <span class="v">nil</span> 
 </p> 
 <blockquote> 
 
 <p>Determine the equivalence relation to preserve when simplifying.</p> 
 
 <p>By specifying <span class="v">:equiv EQV</span> <span class="v">simplify-defun</span> attempts to simplify the 
 body to one that is equivalent, in the sense of the equivalence relation, 
 <span class="v">EQV</span>.  If <span class="v">:equiv</span> is <span class="v">nil</span> or not specified, then the equivalence 
 relation used is <span class="v">EQUAL</span>.  For example, the successful application of 
 <span class="v">simplify-defun</span> with argument <span class="v">:equiv iff</span> will result in a body that 
 is Boolean-equivalent to the original body.</p> 
 
 </blockquote> 
 
 <p> 
 <span class="v">:expand</span> — default <span class="v">nil</span> 
 </p> 
 <blockquote> 
 
 <p>Give an <span class="v">:</span><span class="tt"><a href="ACL2____EXPAND.html">ACL2::expand</a></span> hint to the simplifier.</p> 
 
 <p>When <span class="v">:expand E</span> is supplied, simplification will take place as though 
 the hint <span class="v">:expand E</span> is given to the top-level goal in the theorem prover. 
 NOTE however that when <span class="v">simplify-defun</span> is applied to a function defined 
 using recursion, any such directive to expand a call of that function will be 
 ignored.</p> 
 
 </blockquote> 
 
 <p> 
 <span class="v">:hints</span> — default <span class="v">nil</span><br> 
 </p> 
 <blockquote> 
 
 <p>Specifies the <a href="ACL2____HINTS.html">ACL2::hints</a> for proving that assumptions are preserved 
 by recursive calls.</p> 
 
 <p>If <span class="v">:hints</span> is omitted or has value <span class="v">nil</span>, then the <a href="ACL2____DEFINITION.html">ACL2::definition</a>, <a href="ACL2____EXECUTABLE-COUNTERPART.html">ACL2::executable-counterpart</a>, and <a href="ACL2____TYPE-PRESCRIPTION.html">ACL2::type-prescription</a> <a href="ACL2____RUNE.html">ACL2::rune</a>s for the given function symbol will 
 all be disabled.  If moreover that symbol is introduced with <span class="tt"><a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a></span>, then these runes will be disabled for all function symbols 
 in its clique, i.e., all function symbols that were introduced with that 
 symbol.</p> 
 
 <p>If <span class="v">:hints</span> has a non-<span class="v">nil</span> value, then that value should be a legal 
 hints-specifier for the single applicability condition, 
 <span class="v">:assumptions-preserved</span>; see <a href="APT____HINTS-SPECIFIER.html">hints-specifier</a>.</p> 
 
 <p>NOTE: If you supply <span class="v">:hints</span> with a value other than <span class="v">nil</span>, then you 
 may find it helpful to specify that the runes mentioned above are all 
 disabled: <span class="v">FN</span>, <span class="v">(:e FN)</span>, and <span class="v">(:t FN)</span> (see <a href="ACL2____RUNE.html">ACL2::rune</a>).  If 
 you are simplifying a <span class="tt"><a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a></span> form then you may find it 
 helpful to disable these for every <span class="v">FN</span> in the clique of functions being 
 introduced.</p> 
 
 </blockquote> 
 
 <p> 
 <span class="v">:guard-hints</span> — default <span class="v">:auto</span> 
 </p> 
 <blockquote> 
 
 <p>Provides <a href="ACL2____HINTS.html">ACL2::hints</a> for verifying <a href="ACL2____GUARD.html">guard</a>s of the generated 
 function.  If this argument is supplied with value other than its default of 
 <span class="v">:auto</span>, then that value becomes the <span class="v">:hints</span> of a <span class="tt"><a href="ACL2____VERIFY-GUARDS.html">verify-guards</a></span> 
 event.  Otherwise such hints are generated automatically.  See the discussion 
 of <span class="v">:verify-guards</span> below for a discussion of guard verification and its 
 automatically-generated hints.</p> 
 
 </blockquote> 
 
 <p> 
 <span class="v">:new-enable</span> — default <span class="v">:auto</span> 
 </p> 
 <blockquote> 
 
 <p>Determines whether the new function is enabled.</p> 
 
 <p>If this keyword has value <span class="v">t</span> or <span class="v">nil</span>, then the new function symbol 
 will be enabled or disabled, respectively.  Otherwise its value should be the 
 keyword <span class="v">:auto</span>, and the new function symbol will be enabled or disabled 
 according to whether the input function symbol is disabled or enabled, 
 respectively.</p> 
 
 </blockquote> 
 
 <p> 
 <span class="v">:hyp-fn</span> — default <span class="v">nil</span> 
 </p> 
 <blockquote> 
 
 <p>Determines the assumptions for simplification.</p> 
 
 <p>If the list of formals of the given function symbol, <span class="v">FN</span>, is <span class="v">(X1
 ... Xk)</span>, then specifying <span class="v">:hyp-fn h</span> for <span class="v">h</span> not <span class="v">nil</span> is 
 equivalent to specifying <span class="v">:assumptions ((h X1 ... Xk))</span>.  It is illegal to 
 provide non-<span class="v">nil</span> values for both <span class="v">:hyp-fn</span> and <span class="v">:assumptions</span>.</p> 
 
 </blockquote> 
 
 <p> 
 <span class="v">:measure</span> — default <span class="v">:auto</span> 
 </p> 
 <blockquote> 
 
 <p>Provides the measure for the generated function.</p> 
 
 <p>The default is <span class="v">:auto</span>, in which case: when there is a measure <span class="v">M_FN</span> 
 associated with the input function symbol, <span class="v">FN</span> (because the definition of 
 <span class="v">FN</span> is recursive), then <span class="v">:measure M_FN</span> is included in the <span class="v">xargs</span> 
 of the new definition.  Otherwise <span class="v">:measure M</span> has been supplied for some 
 <span class="v">M</span> that is not <span class="v">:auto</span>; then <span class="v">:measure M</span> is included in the 
 <span class="v">xargs</span> of the new definition unless <span class="v">M</span> is <span class="v">nil</span>.</p> 
 
 </blockquote> 
 
 <p> 
 <span class="v">:measure-hints</span> — default <span class="v">:auto</span> 
 </p> 
 <blockquote> 
 
 <p>Provides the measure <a href="ACL2____HINTS.html">ACL2::hints</a> for the generated function.</p> 
 
 <p>The <span class="v">:measure-hints</span> option is used as the <span class="tt"><a href="ACL2____XARGS.html">xargs</a></span> <span class="v">:hints</span> 
 value in the generated definition.  A special value <span class="v">:auto</span>, which is the 
 default, creates <span class="v">:hints</span> for the termination proof that use the input 
 function symbol's <a href="ACL2____TERMINATION-THEOREM.html">termination-theorem</a> as well as suitable theory 
 modification if any of <span class="v">:disable</span>, <span class="v">:enable</span>, or <span class="v">:theory</span> have value 
 other than their default of <span class="v">:none</span>.</p> 
 
 </blockquote> 
 
 <p> 
 <span class="v">:must-simplify</span> — default <span class="v">t</span> 
 </p> 
 <blockquote> 
 
 <p>Determine where simplification must make a change.</p> 
 
 <p>This keyword specifies whether each of the body, measure, and guard of the 
 input definition is required to be simplified.  Its value is a <span class="tt"><a href="ACL2____KEYWORD-VALUE-LISTP.html">keyword-value-listp</a></span>, except that <span class="v">t</span> represents the value <span class="v">(:body
 t :measure nil :guard nil)</span>.  Thus each key is one of <span class="v">:body</span>, 
 <span class="v">:measure</span>, or <span class="v">:guard</span>, and each value is <span class="v">t</span> or <span class="v">nil</span>, where 
 <span class="v">nil</span> is the implicit value if the key is omitted.  So by default: the body 
 must simplify to a result different from the original body, or an error 
 occurs; but no such requirement is made for simplification of the measure or 
 the guard.  Note that the respective value for keyword argument <span class="v">:body</span>, 
 <span class="v">:measure</span>, or <span class="v">:guard</span> is ignored when, for the <span class="v">:must-simplify</span> 
 keyword argument, the value of keyword <span class="v">:simplify-body</span>, 
 <span class="v">:simplify-measure</span>, or <span class="v">:simplify-guard</span> is <span class="v">nil</span>.  Note that the 
 value <span class="v">nil</span> for <span class="v">:must-simplify</span> is equivalent to the value <span class="v">(:body
 nil :measure nil :guard nil)</span>, since the three keywords do not occur in the 
 empty keyword-value-list.</p> 
 
 <p><b>NOTE</b> for the case that option <span class="v">:simplify-body</span> specifies a 
 pattern.  In that case, <i>every</i> subterm targeted for simplification by 
 the pattern must simplify to a result different from the subterm.  When there 
 are <span class="v">LET</span>-bindings above the subterm, the requirement is a bit more subtle: 
 the simplification of the subterm under those bindings must differ from the 
 result of substituting the bindings into the subterm.</p> 
 
 </blockquote> 
 
 <p> 
 <span class="v">:new-enable</span> — default <span class="v">:auto</span> 
 </p> 
 <blockquote> 
 
 <p>Determines whether the new function is enabled.</p> 
 
 <p>If this keyword has value <span class="v">t</span> or <span class="v">nil</span>, then the new function symbol 
 will be enabled or disabled, respectively.  Otherwise its value should be the 
 keyword <span class="v">:auto</span>, and the new function symbol will be enabled or disabled 
 according to whether the input function symbol is disabled or enabled, 
 respectively.</p> 
 
 </blockquote> 
 
 <p> 
 <span class="v">:new-name</span> — default <span class="v">:auto</span> 
 </p> 
 <blockquote> 
 
 <p>Determines the name of the generated function.</p> 
 
 <p>This value, if provided, becomes the function symbol of the generated 
 definition.  Otherwise the generated function symbol is obtained by adding a 
 suffix <span class="v">"$n"</span> to the input function symbol's name, for the least natural 
 number <span class="v">n</span> that results in a new function symbol.  Note: the value <span class="v">nil</span> 
 is treated the same as <span class="v">:auto</span>, and in the case that <span class="v">FN</span> was introduced 
 with <span class="tt"><a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a></span>, only these two values and a value of the form 
 <span class="v">(:map ...)</span> (as described above) are legal for <span class="v">:new-name</span>.</p> 
 
 </blockquote> 
 
 <p> 
 <span class="v">:non-executable</span> — default <span class="v">:auto</span> 
 </p> 
 <blockquote> 
 
 <p>Specify non-executability of the new function.</p> 
 
 <p>When this keyword has value <span class="v">t</span>, the generated definition is a call of 
 <span class="tt"><a href="ACL2____DEFUN-NX.html">defun-nx</a></span> or <span class="tt"><a href="ACL2____DEFUND-NX.html">defund-nx</a></span>; if the value is <span class="v">nil</span>, then the 
 generated definition is a call of <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> or <span class="tt"><a href="ACL2____DEFUND.html">defund</a></span>.  The 
 default is <span class="v">:auto</span>, which is equivalent to <span class="v">t</span> if the original 
 definition is non-executable (defined with <span class="v">defun-nx</span> or <span class="v">defund-nx</span> or, 
 more generally, with <span class="tt"><a href="ACL2____XARGS.html">xargs</a></span> keyword <span class="v">:non-executable t</span>), else 
 <span class="v">nil</span>.  This option is useful when simplification transforms the definition 
 into one that violates syntactic rules for executability, such as taking the 
 <span class="v">CAR</span> of a function call that returns multiple values.</p> 
 
 <p>Note that the body of the generated definition may depend on the value of 
 <span class="v">:non-executable</span>.  Specifically, if the value is <span class="v">nil</span>, then the 
 simplified body may be adjusted in an attempt to make it executable, for 
 example by inserting a call of <span class="tt"><a href="ACL2____MV-LIST.html">mv-list</a></span> in a context where a single 
 value is expected but multiple values are supplied.</p> 
 
 </blockquote> 
 
 <p> 
 <span class="v">:print</span> — default <span class="v">:result</span> 
 </p> 
 <blockquote> 
 
 <p>Specify what to print.</p> 
 
 <p>By default, only the resulting definition and theorem are printed.  In 
 general, the value is a print specifier <a href="APT____PRINT-SPECIFIER.html">print-specifier</a> that 
 controls the output.</p> 
 
 </blockquote> 
 
 <p> 
 <span class="v">:show-only</span> — default <span class="v">nil</span> 
 </p> 
 <blockquote> 
 
 <p>Determines whether the events generated by the macro should be 
 submitted (the default) or only shown on the screen.  Note that if 
 <span class="v">:show-only</span> is <span class="v">t</span>, then <span class="v">:print</span> is ignored.</p> 
 
 <p> 
 Note that if <span class="v">:show-only</span> is <span class="v">t</span>, then <span class="v">:print</span> is ignored. 
 </p> 
 
 <ul> 
 
   <li> 
   <span class="v">nil</span>, to submit the events (the default). 
   </li> 
 
   <li> 
   <span class="v">t</span>, to only show the events. 
   </li> 
 
 </ul> 
 
 </blockquote> 
 
 <p> 
 <span class="v">:simplify-body</span> — default <span class="v">t</span> 
 </p> 
 <blockquote> 
 
 <p>Specify whether to simplify the body and (optionally) if so, which 
 subterms.</p> 
 
 <p>This keyword indicates whether to simplify the body of the input function 
 symbol.  Simplification is to be attempted when the value is not <span class="v">nil</span>, in 
 which case it is an error if simplification leaves the body unchanged.</p> 
 
 <p>Other than <span class="v">t</span> or <span class="v">nil</span>, the value can be a <i>pattern</i>, which 
 must have at least one occurrence of a variable whose first character is an 
 atsign (<span class="v">@</span>) or a call of the form <span class="v">(:@ term)</span>; these variables and 
 calls are to be matched with subterms to be simplified, according to the 
 following process.</p> 
 
 <ol> 
 
 <li>First, each variable reference <span class="v">var</span> whose first character is an 
 atsign (<span class="v">@</span>) is replaced by a call <span class="v">(:@ _var)</span>, where <span class="v">_var</span> denotes 
 the variable <span class="v">_</span> (in the ACL2 package) if the <span class="tt"><a href="COMMON-LISP____SYMBOL-NAME.html">symbol-name</a></span> of 
 <span class="v">var</span> contains just the single atsign character, and otherwise <span class="v">_var</span> 
 denotes the result of prefixing an underscore character to the 
 <span class="v">symbol-name</span> of <span class="v">var</span>, without changing its <span class="tt"><a href="ACL2____SYMBOL-PACKAGE-NAME.html">symbol-package-name</a></span>.  Note that the result must have at least one call of 
 <span class="v">:@</span>, but no nested such calls.  This replacement is done directly on the 
 supplied pattern, using obvious heuristics to determine what is a variable 
 reference; for example, <span class="v">@</span> is a variable reference in <span class="v">(foo @)</span> and 
 <span class="v">(<a href="COMMON-LISP____LET.html">let</a> ((x @)) _)</span> but not in <span class="v">(<a href="ACL2_____04.html">@</a> x)</span> or <span class="v">(<a href="COMMON-LISP____LET.html">let</a> ((<a href="ACL2_____04.html">@</a> x)) _)</span>.</li> 
 
 <li>The resulting pattern is then replaced by its translation to an ACL2 
 term (see <a href="ACL2____TERMP.html">termp</a>), which involves macroexpansion and removal of 
 abbreviations; for example, the pattern <span class="v">(<a href="COMMON-LISP_____B2.html">+</a> (:@ _) 17)</span> is translated to 
 <span class="v">(<a href="ACL2____BINARY-_B2.html">BINARY-+</a> (:@ _) '17)</span>.  Note that for this purpose, <span class="v">:@</span> is treated as 
 a unary function symbol.</li> 
 
 <li>The resulting pattern <span class="v">P</span> gives rise to a new pattern <span class="v">P'</span> by 
 expanding away calls of <span class="v">:@</span> as though it were the identity macro, that is, 
 by replacing each call of the form <span class="v">(:@ u)</span> by <span class="v">u</span>.  Then <span class="v">P'</span> is 
 matched against the definition body <span class="v">B</span> in a left-to-right depth-first 
 traversal to find the first subterm <span class="v">B'</span> of <span class="v">B</span> that is an instance of 
 <span class="v">P'</span> in which only variables whose name starts with the underscore 
 character (<span class="v">_</span>) are instantiated, in the following generous sense: for a 
 variable whose <span class="tt"><a href="COMMON-LISP____SYMBOL-NAME.html">symbol-name</a></span> is exactly <span class="v">"_"</span> each occurrence is 
 allowed to match a different term.  If no subterm <span class="v">B'</span> exists as described 
 above, then an error occurs.</li> 
 
 <li>The terms to be simplified are those subterms of <span class="v">B'</span> that correspond 
 to subterms of <span class="v">P'</span> that were originally (that is, in <span class="v">P</span>) calls of 
 <span class="v">:@</span>.</li> 
 
 <li>Each subterm is simplified with respect to the governing <span class="v">IF</span> tests (or 
 negated tests, as appropriate) in <span class="v">B</span> as well the simplifications of any 
 <span class="v">:assumptions</span> provided.  If any such simplification yields an unchanged 
 subterm, then the call of <span class="v">simplify-defun</span> fails.  Note that any dive into 
 the body of a <span class="v">LET</span> expression takes into account its bindings.</li> 
 
 </ol> 
 
 <p>Note: Because of how patterns are handled, you may find it safest to avoid 
 variables <span class="v">@</span> and <span class="v">_</span> in favor of their subscripted versions (e.g., 
 <span class="v">@3</span> or <span class="v">_4</span>), if you use macros — in particular, <span class="tt"><a href="COMMON-LISP____OR.html">or</a></span> 
 — and are surprised by how patterns are matched.  Consider the following 
 example.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (x y)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> (<a href="COMMON-LISP____CONS.html">cons</a> 3 x))
      (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____EQL.html">eql</a> (<a href="COMMON-LISP____LENGTH.html">length</a> x) 17) y)
    'dont-care))</pre> 
 
 <p>Then the following log may seem surprising at first, since the pattern 
 might seem to specify only the call of <span class="v">foo</span> in the body of the 
 definition.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> foo :simplify-body (<a href="COMMON-LISP____OR.html">or</a> @ _))
 (<a href="COMMON-LISP____DEFUN.html">DEFUN</a> FOO$1 (X Y)
        (<a href="COMMON-LISP____DECLARE.html">DECLARE</a> (<a href="ACL2____XARGS.html">XARGS</a> :GUARD T
                        :VERIFY-GUARDS NIL))
        (<a href="COMMON-LISP____IF.html">IF</a> (<a href="ACL2____TRUE-LISTP.html">TRUE-LISTP</a> X)
            (<a href="COMMON-LISP____OR.html">OR</a> (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="ACL2____LEN.html">LEN</a> X) 17) Y)
            'DONT-CARE))
ACL2 !&gt;</pre> 
 
 <p>But the pattern <span class="v">(<a href="COMMON-LISP____OR.html">or</a> @ _)</span> translates to <span class="v">(<a href="COMMON-LISP____IF.html">if</a> @ @ _)</span>, which matches 
 the entire body; hence both the test of the top-level <span class="v">IF</span> call and its 
 true branch were simplified.  If instead we provide a subscript as shown 
 below, the result is what we might reasonably expect: the match this time is 
 on the <span class="v">OR</span> call in the body, since <span class="v">(<a href="COMMON-LISP____IF.html">if</a> @1 @1 _)</span> only matches when the 
 test and true branch of the <span class="v">IF</span> call are the same.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> foo :simplify-body (<a href="COMMON-LISP____OR.html">or</a> @1 _))
 (<a href="COMMON-LISP____DEFUN.html">DEFUN</a> FOO$1 (X Y)
        (<a href="COMMON-LISP____DECLARE.html">DECLARE</a> (<a href="ACL2____XARGS.html">XARGS</a> :GUARD T
                        :VERIFY-GUARDS NIL))
        (<a href="COMMON-LISP____IF.html">IF</a> (<a href="ACL2____TRUE-LISTP.html">TRUE-LISTP</a> (<a href="COMMON-LISP____CONS.html">CONS</a> 3 X))
            (<a href="COMMON-LISP____OR.html">OR</a> (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="ACL2____LEN.html">LEN</a> X) 17) Y)
            'DONT-CARE))
ACL2 !&gt;</pre> 
 
 </blockquote> 
 
 <p> 
 <span class="v">:simplify-guard</span> — default <span class="v">nil</span><br> 
 <span class="v">:simplify-measure</span> — default <span class="v">nil</span> 
 </p> 
 <blockquote> 
 
 <p>Determine whether to simplify the guard or the measure of the input 
 function symbol, respectively.</p> 
 
 <p>A non-<span class="v">nil</span> value indicates that simplification is to be attempted.</p> 
 
 </blockquote> 
 
 <p> 
 <span class="v">:thm-enable</span> — default <span class="v">t</span><br> 
 <span class="v">:thm-name</span> — default <span class="v">:auto</span> 
 </p> 
 <blockquote> 
 
 <p>Determines the name and enabled status of the new theorem.</p> 
 
 <p>If <span class="v">:thm-enable</span> has value <span class="v">nil</span>, then the generated theorem that 
 equates the old function symbol <span class="v">FN</span> with the new, <span class="v">NEW</span>, will be a call 
 of <span class="v">defthmd</span>.  Otherwise, <span class="v">defthm</span> will be used.  In either case: if 
 <span class="v">:thm-name</span> is missing or is <span class="v">:auto</span> or <span class="v">nil</span>, then the name of the 
 theorem will be <span class="v">OLD-becomes-NEW</span>; otherwise, the name of the theorem will 
 be the value of <span class="v">:thm-name</span>, but note that in this case, if <span class="v">FN</span> was 
 introduced with <span class="tt"><a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a></span> then a value of the form <span class="v">(:map ...)</span> 
 (as described above) must be used.</p> 
 
 </blockquote> 
 
 <p> 
 <span class="v">:theory</span> — default <span class="v">:none</span> 
 </p> 
 <blockquote> 
 
 <p>Specify the theory under which simplification is performed.</p> 
 
 <p>If <span class="v">:theory EXPR</span> is supplied, then simplification will be performed in 
 the theory given by <span class="v">EXPR</span>, that is, as though the event <span class="v">(<a href="ACL2____IN-THEORY.html">in-theory</a>
 EXPR)</span> were first evaluated.  If either the <span class="v">:disable</span> or <span class="v">:enable</span> 
 keyword is supplied, then it is illegal to supply <span class="v">:theory</span>.  Note that if 
 <span class="v">:theory</span> is omitted (or <span class="v">:none</span>), then the <a href="ACL2____DEFINITION.html">ACL2::definition</a>, 
 <a href="ACL2____EXECUTABLE-COUNTERPART.html">ACL2::executable-counterpart</a>, and <a href="ACL2____TYPE-PRESCRIPTION.html">ACL2::type-prescription</a> <a href="ACL2____RUNE.html">ACL2::rune</a>s for the given function symbol, <span class="v">FN</span>, will all be added 
 automatically to the <span class="v">:disable</span> argument.  Note also that some disabling 
 may be useful if it is desired to preserve certain operators with special 
 behavior such as <span class="tt"><a href="ACL2____PROG2_42.html">prog2$</a></span>, <span class="tt"><a href="ACL2____EC-CALL.html">ec-call</a></span>, and <span class="tt"><a href="ACL2____TIME_42.html">time$</a></span>; see <a href="ACL2____RETURN-LAST-BLOCKERS.html">ACL2::return-last-blockers</a>.</p> 
 
 </blockquote> 
 
 <p> 
 <span class="v">:untranslate</span> — default <span class="v">:nice</span> 
 </p> 
 <blockquote> 
 
 <p>Specify how to create a user-level term from the simplified body.</p> 
 
 <p>See <a href="APT____UNTRANSLATE-SPECIFIER.html">untranslate-specifier</a>.</p> 
 
 </blockquote> 
 
 <p> 
 <span class="v">:verify-guards</span> — default <span class="v">:auto</span> 
 </p> 
 <blockquote> 
 
 <p>Specify whether to verify guards for the new function.</p> 
 
 <p>By default, guard verification is performed for the new function symbol if 
 and only if the input function symbol is guard-verified.  This default 
 behavior is overridden by a Boolean value <span class="v">V</span> of <span class="v">:verify-guards</span>: guard 
 verification is done if <span class="v">V</span> is <span class="v">t</span>, else is not done.</p> 
 
 <p>When guard verification is performed, it is attempted after several other 
 events are admitted, including the new definition and the <span class="v">OLD-becomes-NEW</span> 
 theorem (see above), by calling <span class="tt"><a href="ACL2____VERIFY-GUARDS.html">verify-guards</a></span> on the new function 
 symbol.  The <span class="v">:guard-hints</span> are utilized, if supplied (and not <span class="v">:auto</span>). 
 Otherwise, a <span class="v">:guard-hints</span> value is generated that specifies the theory 
 used for simplification (see the discussion of <span class="v">:theory</span>) augmented by the 
 <span class="v">OLD-becomes-NEW</span> theorem (see above); also, if the old function symbol is 
 guard-verified, the hints apply its guard theorem with a <span class="v">:use</span> hint.  This 
 generated <span class="v">:guard-hints</span> value can cause  up to three different proof 
 attempts, each somewhat different from the others, when necessary.  (For 
 details use <span class="v">:show-only t</span>.)</p> 
 
 </blockquote> 
 
 <h3>Generated Definition and Theorem</h3> 
 
 <p>The generated definition has the same formals as the definition of <span class="v">FN</span>, 
 and has the form</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> NEW (...)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> ...)
  NEW-BODY)</pre> 
 
 <p>where <span class="v">NEW-BODY</span> is the result of simplifying the body of <span class="v">FN</span> unless 
 keyword option <span class="v">:simplify-body</span> has value <span class="v">nil</span>.  See above for how that 
 option controls simplification of the body, measure, and guard.  The <a href="COMMON-LISP____DECLARE.html">declare</a> form, if any, in the generated definition is generally consistent 
 with the declarations in the definition of <span class="v">FN</span>, except when overridden by 
 arguments to the <span class="v">simplify</span> (or <span class="v">simplify-defun</span>) call.  For example, by 
 default: the generated definition includes a <span class="v">:verify-guards</span> xarg that 
 reflects the guard-verified status of <span class="v">FN</span>, and it includes a declaration 
 of the form <span class="v">(<a href="ACL2____XARGS.html">xargs</a> ... :normalize ...)</span>  if and only if there is such a 
 declaration in the definition of <span class="v">FN</span>.</p> 
 
 <p>The generated theorem generally has the form</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> FN-becomes-NEW
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (FN ...) (NEW ...)))</pre> 
 
 <p>where the calls of <span class="v">FN</span> and <span class="v">NEW</span> are on the formals of <span class="v">FN</span>, and 
 where <span class="v">equal</span> will be replaced by an equivalence relation if specified by 
 keyword argument <span class="v">:equiv</span>.  However, if either keyword argument 
 <span class="v">:assumptions</span> or <span class="v">:hyp-fn</span> specifies assumptions <span class="v">A1</span>, ... <span class="v">An</span>, 
 then the generated theorem has the following form (with <span class="v">equal</span> possibly 
 replaced by an equivalence relation as explained above).</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> FN-becomes-NEW
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> A1 A2 ... An)
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (FN ...) (NEW ...))))</pre> 
 
 <p>In both cases, the name of the new theorem shown is the default but may be 
 specified with keyword option <span class="v">:thm-name</span>.</p> 
 
</body>
</html>
