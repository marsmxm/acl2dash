<html>
<head>
<meta charset="UTF-8">
<title>Simplify-defun-examples</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=APT____SIMPLIFY-DEFUN-EXAMPLES">Click for Simplify-defun-examples in the Full Manual</a></h3>

<p>Examples illustrating <span class="tt"><a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a></span>.</p><p>See <a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> for relevant background.  The examples 
 below are deliberately simple, in order to make clear how <span class="tt"><a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a></span> behaves with various keyword arguments.</p> 
 
 <h3>Example Set 1: Basics</h3> 
 
 <p>We start with the following basic example.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> bar (x)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :measure (<a href="ACL2____NFIX.html">nfix</a> x)))
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> x) 0 (<a href="COMMON-LISP_____B2.html">+</a> 1 1 (bar (<a href="COMMON-LISP_____B2.html">+</a> -1 x)))))
(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "kestrel/apt/simplify" :dir :system)
(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> bar
                :new-name bar-simp
                :thm-name bar-simplified
                :new-enable nil
                :thm-enable t)</pre> 
 
 <p>ACL2 responds to this call of <span class="v">simplify-defun</span> by creating the following 
 <span class="v">DEFUN</span> form among others, silently submitting the created forms, and then 
 returning the new <span class="v">DEFUN</span> form (as the value component of an <a href="ACL2____ERROR-TRIPLE.html">ACL2::error-triple</a>).  The new function is named <span class="v">bar-simp</span> because that is 
 what we specified with the <span class="v">:new-name</span> argument above.</p> 
 
 <pre class="code">(<a href="ACL2____DEFUND.html">DEFUND</a> BAR-SIMP (X)
        (<a href="COMMON-LISP____DECLARE.html">DECLARE</a> (<a href="ACL2____XARGS.html">XARGS</a> :GUARD T
                        :MEASURE (<a href="ACL2____NFIX.html">NFIX</a> X)
                        :VERIFY-GUARDS NIL ; would be T if BAR were guard-verified
                        :HINTS (("Goal" :USE (:TERMINATION-THEOREM BAR))
                                '(:IN-THEORY (<a href="ACL2____DISABLE_A2.html">DISABLE*</a> BAR (:E BAR) (:T BAR))))))
        (<a href="COMMON-LISP____IF.html">IF</a> (<a href="ACL2____ZP.html">ZP</a> X) 0 (<a href="COMMON-LISP_____B2.html">+</a> 2 (BAR-SIMP (<a href="COMMON-LISP_____B2.html">+</a> -1 X)))))</pre> 
 
 <p>Notice that the guard and measure are the same as for <span class="v">BAR</span>, but the 
 subterm <span class="v">(<a href="COMMON-LISP_____B2.html">+</a> 1 1 (bar (<a href="COMMON-LISP_____B2.html">+</a> -1 x)))</span> of the body of <span class="v">bar</span> has been replaced 
 by the simpler term <span class="v">(<a href="COMMON-LISP_____B2.html">+</a> 2 (BAR-SIMP (<a href="COMMON-LISP_____B2.html">+</a> -1 X)))</span> in the body of 
 <span class="v">bar-simp</span>, with the recursive call appropriately replaced.</p> 
 
 <p>Adding <span class="v">:verbose t</span> shows simplified non-trivial <span class="v">:assumptions</span>, 
 followed by the proposed simplified definition, and then prover output from 
 evaluating the generated <a href="ACL2____EVENTS.html">ACL2::events</a>.</p> 
 
 <p>To see the full expansion produced by the call of <span class="v">simplify-defun</span> 
 above, we can use <span class="v">show-simplify-defun</span> instead of <span class="v">simplify-defun</span>, on 
 the same arguments (or, simply add keyword argument <span class="v">:show-only t</span> to your 
 <span class="v">simplify-defun</span> call).  The result is as follows (elided somewhat).</p> 
 
 <pre class="code">(<a href="ACL2____ENCAPSULATE.html">ENCAPSULATE</a>
 NIL
 ... ; helpful stuff local to the encapsulate
 (<a href="ACL2____DEFUND.html">DEFUND</a> BAR-SIMP (X) ...) ; as shown above
 (<a href="ACL2____LOCAL.html">LOCAL</a> ; helper events, not shown here
  ...)
 (<a href="ACL2____DEFTHM.html">DEFTHM</a> BAR-SIMPLIFIED ; the value of keyword argument :thm-name
   (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (BAR X) (BAR-SIMP X))
   :HINTS ...))</pre> 
 
 <p>On the other hand, if you want less output, not more, use 
 <span class="v">simplify-defun</span> with <span class="v">:print nil</span>.  For example:</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> bar
                       :new-name bar-simp
                       :thm-name bar-simplified
                       :new-enable nil
                       :thm-enable t
                       :print nil)
 T
ACL2 !&gt;:pe bar-simp
   d       3:x(<a href="APT____SIMPLIFY-DEFUN.html">SIMPLIFY-DEFUN</a> BAR :NEW-NAME ...)
              
&gt;L d           (<a href="COMMON-LISP____DEFUN.html">DEFUN</a>
                BAR-SIMP (X)
                (<a href="COMMON-LISP____DECLARE.html">DECLARE</a>
                    (<a href="ACL2____XARGS.html">XARGS</a> :GUARD T
                           :MEASURE (<a href="ACL2____NFIX.html">NFIX</a> X)
                           :VERIFY-GUARDS NIL
                           :HINTS (("Goal" :USE (:TERMINATION-THEOREM BAR)))))
                (<a href="COMMON-LISP____IF.html">IF</a> (<a href="ACL2____ZP.html">ZP</a> X) 0 (<a href="COMMON-LISP_____B2.html">+</a> 2 (BAR-SIMP (<a href="COMMON-LISP_____B2.html">+</a> -1 X)))))
ACL2 !&gt;</pre> 
 
 <p>Notice the calls of <span class="tt"><a href="ACL2____DEFUND.html">defund</a></span> and <span class="tt"><a href="ACL2____DEFTHM.html">defthm</a></span>, which respect 
 keyword arguments supplied to <span class="v">simplify-defun</span>, <span class="v">:new-enable nil</span> 
 and <span class="v">:thm-enable t</span>, respectively.</p> 
 
 <h3>Example Set 2: Assumptions</h3> 
 
 <p>The following trivial example illustrates the use of assumptions.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (x)
  (<a href="ACL2____IFIX.html">ifix</a> x))
(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> foo :assumptions ((<a href="COMMON-LISP____INTEGERP.html">integerp</a> x)))</pre> 
 
 <p>If you want to evaluate the <span class="v">:assumptions</span> argument, or indeed any 
 argument <span class="v">A</span> of <span class="v">simplify-defun</span>, simply replace <span class="v">A</span> by <span class="v">(:eval
 A)</span>.  The <span class="v">simplify-defun</span> call displayed just above is thus equivalent to 
 the following.</p> 
 
 <pre class="code">(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> foo :assumptions (:eval '((<a href="COMMON-LISP____INTEGERP.html">integerp</a> x))))</pre> 
 
 <p>Here is the result (either way).  Notice that since we did not specify 
 <span class="v">:new-name</span>, the generated function name is obtained by adding a suffix 
 <span class="v">"$1"</span> to the given function symbol's name.  In general, the least 
 natural number <span class="v">n</span> will be used that results in a new function symbol when 
 adding the suffix <span class="v">"$n"</span>.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">DEFUN</a> FOO$1 (X)
       (<a href="COMMON-LISP____DECLARE.html">DECLARE</a> (<a href="ACL2____XARGS.html">XARGS</a> :GUARD T
                       :VERIFY-GUARDS NIL))
       X)</pre> 
 
 <p>Notice that the body was simplified under the given assumption that <span class="v">x</span> 
 is an integer; without any such assumption, simplification to <span class="v">x</span> would not 
 have taken place.</p> 
 
 <p>The <span class="v">:hints</span> argument allows you to supply <a href="ACL2____HINTS.html">ACL2::hints</a> for the 
 key lemma that specifies preservation of the assumptions on recursive calls. 
 The following example illustrates how that works, based on this 
 definition.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (x)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____TRUE-LISTP.html">true-listp</a> x)))
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x)
      (foo (<a href="COMMON-LISP____CDR.html">cdr</a> x))
    x))</pre> 
 
 <p>In this example we specify <span class="v">:assumptions :guard</span>, which means that the 
 <span class="v">:assumptions</span> value is taken to be the given function's guard.</p> 
 
 <pre class="code">(<a href="APT____SHOW-SIMPLIFY-DEFUN.html">show-simplify-defun</a> foo
                     :assumptions :guard
                     :hints
                     (:assumptions-preserved ; the sole applicability condition
                      (("Goal" :in-theory (<a href="ACL2____E_F2D.html">e/d</a> (<a href="COMMON-LISP____APPEND.html">append</a>) (<a href="ACL2____UNION-EQ.html">union-eq</a>))))))</pre> 
 
 <p>The command above generates the following key lemma.  Note that the local 
 function <span class="v">FOO-HYPS</span> is defined above with the same formals as the given 
 function symbol, and with a body that represents the <span class="v">:assumptions</span> 
 argument, which in this example specifies the guard of <span class="v">foo</span>.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">DEFTHM</a> FOO-HYPS-PRESERVED-FOR-FOO-LEMMA
  (<a href="COMMON-LISP____FLET.html">FLET</a> ((FOO-HYPS (X)
                   (<a href="COMMON-LISP____DECLARE.html">DECLARE</a> (<a href="COMMON-LISP____IGNORABLE.html">IGNORABLE</a> X))
                   (<a href="ACL2____TRUE-LISTP.html">TRUE-LISTP</a> X)))
        (<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____AND.html">AND</a> (FOO-HYPS X) (<a href="COMMON-LISP____CONSP.html">CONSP</a> X))
                 (FOO-HYPS (<a href="COMMON-LISP____CDR.html">CDR</a> X))))
  :HINTS (("Goal" :IN-THEORY (<a href="ACL2____E_F2D.html">E/D</a> (<a href="COMMON-LISP____APPEND.html">APPEND</a>) (<a href="ACL2____UNION-EQ.html">UNION-EQ</a>)))
          '(:USE (:GUARD-THEOREM FOO)))
  :RULE-CLASSES NIL)</pre> 
 
 <p>Since the original body is <span class="v">(<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x) (foo$1 (<a href="COMMON-LISP____CDR.html">cdr</a> x)) x)</span>, we see 
 that <span class="v">x</span> has been simplified to <span class="v">nil</span> under the combination of the 
 top-level assumption of <span class="v">(<a href="ACL2____TRUE-LISTP.html">true-listp</a> x)</span>, from <span class="v">:assumptions :guard</span>, 
 and the governing <span class="v">IF</span> test of <span class="v">(<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x))</span>.</p> 
 
 <h3>Example Set 3: Simplifying the Guard and Measure</h3> 
 
 <p>The examples above all pertain to simplifying the body of a definition. 
 The following example shows how to simplify the guard and/or measure of a 
 definition.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (x)
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> x)
                                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)))
                          :measure (<a href="ACL2____FIX.html">fix</a> (<a href="ACL2____LEN.html">len</a> x))))
          (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x))
              (foo (<a href="COMMON-LISP____APPEND.html">append</a> nil (<a href="COMMON-LISP____CDR.html">cdr</a> x)))
            x))
...
 FOO
ACL2 !&gt;(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> foo
                       :simplify-body nil
                       :simplify-guard t
                       :simplify-measure t)
 (<a href="COMMON-LISP____DEFUN.html">DEFUN</a> FOO$1 (X)
        (<a href="COMMON-LISP____DECLARE.html">DECLARE</a> (<a href="ACL2____XARGS.html">XARGS</a> :GUARD (<a href="COMMON-LISP____AND.html">AND</a> (<a href="ACL2____TRUE-LISTP.html">TRUE-LISTP</a> X) (<a href="COMMON-LISP____CONSP.html">CONSP</a> X))
                        :MEASURE (<a href="ACL2____LEN.html">LEN</a> X)
                        :VERIFY-GUARDS T
                        :GUARD-HINTS ... ; uses (:GUARD-THEOREM FOO)
                        :HINTS ... ; uses (:GUARD-THEOREM FOO)
                        ))
        (<a href="COMMON-LISP____IF.html">IF</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> (<a href="COMMON-LISP____CDR.html">CDR</a> X))
            (FOO$1 (<a href="COMMON-LISP____APPEND.html">APPEND</a> NIL (<a href="COMMON-LISP____CDR.html">CDR</a> X)))
            X))
ACL2 !&gt;</pre> 
 
 <p>Clearly the values of both the <span class="v">:guard</span> and the <span class="v">:measure</span> have been 
 simplified.</p> 
 
 <p>Notice that the body has not been simplified, even though ACL2 could easily 
 simplify <span class="v">(<a href="COMMON-LISP____APPEND.html">APPEND</a> NIL (<a href="COMMON-LISP____CDR.html">CDR</a> X))</span> to <span class="v">(<a href="COMMON-LISP____CDR.html">CDR</a> X)</span>, because of the argument 
 <span class="v">:simplify-body nil</span>.  To simplify the body as well, we can omit 
 <span class="v">:simplify-body</span> so that its value defaults to <span class="v">t</span>, or we can specify 
 <span class="v">:simplify-body t</span> explicitly.</p> 
 
 <h3>Example Set 4: Guard and Measure Hints</h3> 
 
 <p><span class="v">Simplify-defun</span> provides keywords <span class="v">:guard-hints</span> and 
 <span class="v">:measure-hints</span> for the guard verification and termination proofs of the 
 simplified function that is generated.  To see how these work, we can add such 
 hints to the <span class="v">simplify-defun</span> form displayed in the section just above. 
 Recall that the default hints generated for the guard and termination proofs 
 use the guard and termination theorems, respectively, for the function whose 
 definition is being simplified.  Suppose now that we add our own hints, for 
 example rather nonsensical <span class="v">:guard-hints</span> and <span class="v">:measure-hints</span> as 
 follows.</p> 
 
 <pre class="code">(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> foo
                :simplify-body nil
                :simplify-guard t
                :simplify-measure t
                :guard-hints (("Goal" :use car-cons))
                :measure-hints (("Goal" :in-theory (<a href="ACL2____ENABLE.html">enable</a> nth))))</pre> 
 
 <p>This time our own hints show up in the resulting definition of <span class="v">FOO$1</span> 
 in place of those that are generated by default.</p> 
 
 <pre class="code">:GUARD-HINTS (("Goal" :USE CAR-CONS))
:HINTS (("Goal" :IN-THEORY (<a href="ACL2____ENABLE.html">ENABLE</a> NTH)))</pre> 
 
 <h3>Example Set 5: Controlling the Theory for Simplification</h3> 
 
 <p>By default, simplification done on behalf of <span class="v">simplify-defun</span>  
 whether for the body, guard, or measure of a <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> form  is 
 carried out in the current theory (see <a href="ACL2____CURRENT-THEORY.html">current-theory</a>).  However, the 
 <span class="v">:theory</span> keyword allows control over that theory without changing the 
 current theory globally.  Consider the following example.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (x)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____NATP.html">natp</a> x)))
  (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP_____B2.html">+</a> x x) 3)))
(<a href="ACL2____DEFTHMD.html">defthmd</a> double ; disabled globally
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP_____B2.html">+</a> x x) (<a href="COMMON-LISP_____A2.html">*</a> 2 x)))
(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> foo
                :theory '(double natp)
                :simplify-body t ; default
                :simplify-guard t)</pre> 
 
 <p>The resulting <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> form contains simplifications for both the 
 guard and the body.  The rewrite rule <span class="v">double</span> and the definition of 
 <span class="v">natp</span> were applied during the simplification, in spite of being globally 
 disabled, because of the specified <span class="v">:theory</span> for simplification.  Note 
 that this theory works its way into the generated <span class="v">:guard-hints</span> for the 
 generated function.</p> 
 
 <p>For convenience, <span class="v">:enable</span> and/or <span class="v">:disable</span> keywords are available, 
 provided that they are not used when <span class="v">:theory</span> is used.  For example, 
 specifying <span class="v">:enable (double natp)</span> instead of the <span class="v">:theory</span> hint above 
 gives the following result.  Notice that the body is further simplified 
 because the built-in rewrite rule <span class="v">car-cons</span> is available this time, 
 because the theory is constructed by enabling <span class="v">double</span> and <span class="v">natp</span>, 
 rather than consisting of <i>exactly</i> those two rules.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">DEFUN</a> FOO$1 (X)
       (<a href="COMMON-LISP____DECLARE.html">DECLARE</a> (<a href="ACL2____XARGS.html">XARGS</a> :GUARD (<a href="COMMON-LISP____AND.html">AND</a> (<a href="COMMON-LISP____INTEGERP.html">INTEGERP</a> X) (<a href="COMMON-LISP____NOT.html">NOT</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> X 0)))
                       :VERIFY-GUARDS T
                       :GUARD-HINTS ...))
       (<a href="COMMON-LISP_____A2.html">*</a> 2 X))</pre> 
 
 <p>At this point let us mention the one keyword argument not yet mentioned: 
 <span class="v">:verify-guards</span>.  By default, the value of this keyword is <span class="v">:auto</span>, 
 meaning that the value of <span class="v">:verify-guards</span> in the generated <span class="v">defun</span> is 
 <span class="v">t</span> if the input function symbol is guard-verified, and otherwise is 
 <span class="v">nil</span>.  If you supply <span class="v">:verify-guards nil</span> explicitly in your 
 <span class="v">simplify-defun</span> call, however, then <span class="v">nil</span> will be used instead.  For 
 example, that would change the <span class="v">defun</span> for <span class="v">FOO$1</span> displayed just above 
 to include</p> 
 
 <pre class="code">:VERIFY-GUARDS NIL</pre> 
 
 <p>instead of what it has currently, namely the following.</p> 
 
 <pre class="code">:VERIFY-GUARDS T</pre> 
 
 <h3>Example Set 6: Simplifying a Subterm</h3> 
 
 <p>Examples above illustrate Boolean values for the <span class="v">:simplify-body</span> 
 keyword (default <span class="v">t</span>).  However, <span class="v">:simplify-body</span> can specify a pattern, 
 to indicate one or more specific subterms to be simplified.  Consider the 
 following example.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (x) x)
(<a href="COMMON-LISP____DEFUN.html">defun</a> bar (x) (<a href="COMMON-LISP____IF.html">if</a> x (<a href="COMMON-LISP____CONS.html">cons</a> x x) 17))
(<a href="COMMON-LISP____DEFUN.html">defun</a> f (x y z)
  (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____IF.html">if</a> (foo x) (bar x) z)
        (<a href="COMMON-LISP____IF.html">if</a> (foo x) (foo y) z)))
(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> f
                :simplify-body (<a href="COMMON-LISP____IF.html">if</a> (foo x) @ z))</pre> 
 
 <p>In a left-to-right depth-first traversal of the body of <span class="v">f</span>, the first 
 subterm that matches the pattern  where <span class="v">@</span> is allowed to be 
 instantiated  is the subterm <span class="v">(<a href="COMMON-LISP____IF.html">if</a> (foo x) (bar x) z)</span>.  For that 
 match, the appropriate instantiation of <span class="v">@</span> is <span class="v">(bar x)</span>.  Therefore, 
 the value of <span class="v">:simplify-body</span> above instructs <span class="v">simplify-defun</span> to 
 simplify not the entire body of <span class="v">f</span>, but only the subterm <span class="v">(bar x)</span>. 
 That simplification is to be performed under the result of simplifying the 
 conjunction of the <span class="v">:assumptions</span> (simply <span class="v">t</span> in this case) with the 
 <i>governors</i> of the subterm, formed from the superior IF-tests.  In this 
 case, <span class="v">(bar x)</span> is governed by <span class="v">(foo x)</span>, so the subterm <span class="v">(bar x)</span> is 
 simplified under the simplification of <span class="v">(foo x)</span>, i.e., under the 
 assumption of <span class="v">x</span> (i.e., that <span class="v">x</span> is non-<span class="v">nil</span>).  Under that 
 assumption, <span class="v">(bar x)</span> simplifies to <span class="v">(<a href="COMMON-LISP____CONS.html">cons</a> x x)</span>, which explains how the 
 new body below is derived from the body of the input function symbol, <span class="v">f</span>. 
 Notice that no other part of the body has changed.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> f
                 :simplify-body (<a href="COMMON-LISP____IF.html">if</a> (foo x) @ z))
 (<a href="COMMON-LISP____DEFUN.html">DEFUN</a> F$1 (X Y Z)
        (<a href="COMMON-LISP____DECLARE.html">DECLARE</a> (<a href="ACL2____XARGS.html">XARGS</a> :GUARD T
                        :VERIFY-GUARDS NIL))
        (<a href="COMMON-LISP____CONS.html">CONS</a> (<a href="COMMON-LISP____IF.html">IF</a> (FOO X) (<a href="COMMON-LISP____CONS.html">CONS</a> X X) Z)
              (<a href="COMMON-LISP____IF.html">IF</a> (FOO X) (FOO Y) Z)))
ACL2 !&gt;</pre> 
 
 <p>Any variable whose name begins with an atsign (<span class="v">@</span>) gets this special 
 treatment, that is, indicating a simplification site.  We call such variables 
 ``@-vars''.  Variables whose name starts with the underscore 
 character (<span class="v">_</span>), called ``_-vars'', also get special treatment: like 
 @-vars, they can be instantiated to match a subterm of the body, but unlike 
 @-vars, they do not indicate simplification sites.  For the definitions of 
 <span class="v">foo</span>, <span class="v">bar</span>, and <span class="v">f</span> as above, consider the following form.</p> 
 
 <pre class="code">(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> f
                :simplify-body (<a href="COMMON-LISP____IF.html">if</a> (foo a) @ z))</pre> 
 
 <p>The specified pattern does not match the subterm <span class="v">(<a href="COMMON-LISP____IF.html">IF</a> (FOO X) (<a href="COMMON-LISP____CONS.html">CONS</a> X X)
 Z)</span>, because the variable <span class="v">A</span> differs from the variable <span class="v">X</span>.  But we 
 can fix this by adding an underscore to the front of <span class="v">A</span>, since the pattern 
 matches that subterm by instantiating <span class="v">_A</span> to <span class="v">X</span>.</p> 
 
 <pre class="code">(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> f
                :simplify-body (<a href="COMMON-LISP____IF.html">if</a> (foo _a) @ z))</pre> 
 
 <p>For that matter, we can even replace <span class="v">Z</span> in the pattern by any variable 
 whose name starts with an underscore, for example as follows.</p> 
 
 <pre class="code">(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> f
                :simplify-body (<a href="COMMON-LISP____IF.html">if</a> (foo _a) @ _b))</pre> 
 
 <p>Both of the <span class="v">simplify-defun</span> calls just above give rise to the same 
 definition of <span class="v">F$1</span> as before (i.e., as displayed above.).</p> 
 
 <p>On the other hand, the following call fails because the variable <span class="v">_a</span> 
 would need to be instantiated both to <span class="v">X</span> and to <span class="v">Z</span>.</p> 
 
 <pre class="code">(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> f
                :simplify-body (<a href="COMMON-LISP____IF.html">if</a> (foo _a) @ _a))</pre> 
 
 <p>The _-var, <span class="v">_</span>  that is the variable in the <span class="v">"ACL2"</span> package 
 whose <span class="tt"><a href="COMMON-LISP____SYMBOL-NAME.html">symbol-name</a></span>, <span class="v">"_"</span>, consists of just a single underscore 
 character  gets special treatment.  It is allowed to match different 
 subterms, so this succeeds:</p> 
 
 <pre class="code">(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> f
                :simplify-body (<a href="COMMON-LISP____IF.html">if</a> (foo _) @ _))</pre> 
 
 <p>See <a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> (specifically, the section on the 
 <span class="v">:simplify-body</span> argument) for a precise explanation of the sense in which 
 the variable <span class="v">_</span> gets special treatment by allowing matches to more than 
 one subterm.</p> 
 
 <p>We have seen that the language of patterns allows variables <span class="v">@</span> and 
 <span class="v">@XX</span> to represent simplification sites, as well as variables <span class="v">_</span> and 
 <span class="v">_XX</span> that also match arbitrary subterms; here <span class="v">XX</span> denotes an arbitrary 
 non-empty suffix, and the symbol's package is arbitrary.  But an additional 
 construct can be used to represent simplification sites: <span class="v">(:@ u)</span>, where 
 <span class="v">u</span> is a term and the keyword <span class="v">:@</span> is used as a unary function symbol. 
 When a pattern is matched against a term, <span class="v">(:@ u)</span> indicates not only that 
 <span class="v">u</span> is to be matched, but also that we have a simplification site.  Indeed, 
 <span class="v">@</span> is an abbreviation for <span class="v">(:@ _)</span> and <span class="v">@XX</span> is an abbreviation for 
 <span class="v">(:@ _@XX)</span>.  The <span class="v">simplify-defun</span> call immediately above could thus be 
 written equivalently as follows.</p> 
 
 <pre class="code">(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> f
                :simplify-body (<a href="COMMON-LISP____IF.html">if</a> (foo _) (:@ _) _))</pre> 
 
 <p>Let's look at another example of the use of <span class="v">:@</span>, starting with the 
 following (contrived) definition.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> g (x y)
  (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP____NTH.html">nth</a> 0 x) 3)
        (<a href="COMMON-LISP_____A2.html">*</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CONS.html">cons</a> y y)) 4)
        (<a href="COMMON-LISP_____A2.html">*</a> (<a href="COMMON-LISP____NTH.html">nth</a> 0 x) 5)))</pre> 
 
 <p>Suppose we want to simplify just the second call of <span class="v">nth</span> above.  Here's 
 a nice way to accomplish that.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> g :simplify-body (<a href="COMMON-LISP_____A2.html">*</a> (:@ (<a href="COMMON-LISP____NTH.html">nth</a> 0 x)) _))
 (<a href="COMMON-LISP____DEFUN.html">DEFUN</a> G$1 (X Y)
        (<a href="COMMON-LISP____DECLARE.html">DECLARE</a> (<a href="ACL2____XARGS.html">XARGS</a> :GUARD T
                        :VERIFY-GUARDS NIL))
        (<a href="COMMON-LISP____LIST.html">LIST</a> (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP____NTH.html">NTH</a> 0 X) 3)
              (<a href="COMMON-LISP_____A2.html">*</a> (<a href="COMMON-LISP____CAR.html">CAR</a> (<a href="COMMON-LISP____CONS.html">CONS</a> Y Y)) 4)
              (<a href="COMMON-LISP_____A2.html">*</a> (<a href="COMMON-LISP____AND.html">AND</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> X) (<a href="COMMON-LISP____CAR.html">CAR</a> X)) 5)))
ACL2 !&gt;</pre> 
 
 <p>Notice that neither of the following alternatives would produce the result 
 above.</p> 
 
 <pre class="code">; Would simplifythe first occurrence of (<a href="COMMON-LISP____NTH.html">nth</a> 0 x) instead:
(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> g :simplify-body (:@ (<a href="COMMON-LISP____NTH.html">nth</a> 0 x)))

; Would simplify (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CONS.html">cons</a> y y)) instead.
(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> g :simplify-body (<a href="COMMON-LISP_____A2.html">*</a> @ _))</pre> 
 
 <p>Here is an example that specifies more than one subterm to be simplified. 
 Consider:</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (x y)
  (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____LIST.html">list</a>
               (<a href="COMMON-LISP_____A2.html">*</a> 3 (<a href="COMMON-LISP_____B2.html">+</a> 1 (<a href="COMMON-LISP_____B2.html">+</a> 1 x)))
               (<a href="COMMON-LISP_____A2.html">*</a> 3 (<a href="COMMON-LISP_____B2.html">+</a> 1 (<a href="COMMON-LISP_____B2.html">+</a> 1 x)))
               (<a href="COMMON-LISP_____A2.html">*</a> 4 5 (<a href="COMMON-LISP_____B2.html">+</a> 1 (<a href="COMMON-LISP_____B2.html">+</a> 1 y)))))))</pre> 
 
 <p>Then the indicated pattern below matches the subterm</p> 
 
 <pre class="code">(<a href="COMMON-LISP____LIST.html">list</a>
 (<a href="COMMON-LISP_____A2.html">*</a> 3 (<a href="COMMON-LISP_____B2.html">+</a> 1 (<a href="COMMON-LISP_____B2.html">+</a> 1 x)))
 (<a href="COMMON-LISP_____A2.html">*</a> 3 (<a href="COMMON-LISP_____B2.html">+</a> 1 (<a href="COMMON-LISP_____B2.html">+</a> 1 x)))
 (<a href="COMMON-LISP_____A2.html">*</a> 4 5 (<a href="COMMON-LISP_____B2.html">+</a> 1 (<a href="COMMON-LISP_____B2.html">+</a> 1 y))))</pre> 
 
 <p>with the @-var <span class="v">@1</span> bound to the subterm <span class="v">(<a href="COMMON-LISP_____A2.html">*</a> 3 (<a href="COMMON-LISP_____B2.html">+</a> 1 (<a href="COMMON-LISP_____B2.html">+</a> 1 x)))</span> and 
 the @-var <span class="v">@2</span> bound to the subterm <span class="v">(<a href="COMMON-LISP_____B2.html">+</a> 1 (<a href="COMMON-LISP_____B2.html">+</a> 1 y))</span>, so that those two 
 subterms are simplified.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> foo
                       :simplify-body (<a href="COMMON-LISP____LIST.html">list</a> @1 ; equivalently, (:@ _@1)
                                            _
                                            (<a href="COMMON-LISP_____A2.html">*</a> _ 5 @2)))
 (<a href="COMMON-LISP____DEFUN.html">DEFUN</a> FOO$1 (X Y)
        (<a href="COMMON-LISP____DECLARE.html">DECLARE</a> (<a href="ACL2____XARGS.html">XARGS</a> :GUARD T
                        :VERIFY-GUARDS NIL))
        (<a href="COMMON-LISP____LIST.html">LIST</a> (<a href="COMMON-LISP____LIST.html">LIST</a> (<a href="COMMON-LISP____LIST.html">LIST</a> (<a href="COMMON-LISP_____B2.html">+</a> 6 (<a href="COMMON-LISP_____A2.html">*</a> 3 X))
                          (<a href="COMMON-LISP_____A2.html">*</a> 3 (<a href="COMMON-LISP_____B2.html">+</a> 1 (<a href="COMMON-LISP_____B2.html">+</a> 1 X)))
                          (<a href="COMMON-LISP_____A2.html">*</a> 4 5 (<a href="COMMON-LISP_____B2.html">+</a> 2 Y))))))
ACL2 !&gt;</pre> 
 
 <p>Actually, it suffices simply to use only the special @-var, <span class="v">@</span>  
 or equivalently, <span class="v">(:@ _)</span>  to produce the same result, as follows. 
 See <a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> (specifically, the section on the 
 <span class="v">:simplify-body</span> argument) for a precise explanation of the sense in which 
 the variables <span class="v">_</span> and <span class="v">@</span> get special treatment by allowing matches to 
 more than one subterm.</p> 
 
 <pre class="code">(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> foo
                :simplify-body (<a href="COMMON-LISP____LIST.html">list</a> @
                                     _
                                     (<a href="COMMON-LISP_____A2.html">*</a> _ 5 @)))
(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> foo
                :simplify-body (<a href="COMMON-LISP____LIST.html">list</a> (:@ _)
                                     _
                                     (<a href="COMMON-LISP_____A2.html">*</a> _ 5 (:@ _))))</pre> 
 
 <p>It is also possible to specify simplification inside <span class="tt"><a href="COMMON-LISP____LET.html">let</a></span> 
 and <span class="tt"><a href="COMMON-LISP____LET_A2.html">let*</a></span> expressions.  Let's look at two examples based on the 
 following definition.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> let-test (x y)
  (<a href="COMMON-LISP____LET_A2.html">let*</a> ((<a href="ACL2____U.html">u</a> (<a href="COMMON-LISP____CONS.html">cons</a> x x))
         (v (<a href="COMMON-LISP____CAR.html">car</a> u)))
    (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CONS.html">cons</a> v y))))</pre> 
 
 <p>First we simplify one of the bindings.</p> 
 
 <pre class="code">(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> let-test :simplify-body (:@ (<a href="COMMON-LISP____CAR.html">car</a> _)))</pre> 
 
 <p>The new definition body results from simplifying the binding of <span class="v">v</span>. 
 Notice that the binding of <span class="v">u</span> is dropped, since <span class="v">u</span> is now unusued. 
 Also notice that only the binding of <span class="v">v</span> is simplified; the body of the 
 <span class="v">let*</span> is left alone.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____LET.html">LET</a> ((V X))
     (<a href="COMMON-LISP____CAR.html">CAR</a> (<a href="COMMON-LISP____CONS.html">CONS</a> V Y)))</pre> 
 
 <p>This time, let us simplify just the body of the definition.  What do you 
 think the result will be?  It might surprise you.</p> 
 
 <pre class="code">(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> let-test :simplify-body (:@ (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CONS.html">cons</a> _ _))))</pre> 
 
 <p>You might have expected that the new body is obtained simply by replacing 
 <span class="v">(<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CONS.html">cons</a> v y))</span> by <span class="v">v</span> in the body.  However, the new body is 
 simply:</p> 
 
 <pre class="code">X</pre> 
 
 <p>To see why, consider how <span class="v">simplify-defun</span> performs the simplification. 
 It actually simplifies <span class="v">(<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CONS.html">cons</a> v y))</span> with respect to the bindings 
 above it; with that in mind, the result is obviously <span class="v">X</span>.  Since the term 
 <span class="v">(<a href="COMMON-LISP____CAR.html">car</a> u)</span> does not appear in the result, the binding of <span class="v">v</span> is 
 discarded, as is the binding of <span class="v">u</span> as before.  We are left simply with 
 <span class="v">X</span>.</p> 
 
 <h3>Example Set 7: Specifying an equivalence relation</h3> 
 
 <p>By default, the simplified body is equal to the original body, under the 
 given assumptions (if any).  But you may specify that the two bodies should 
 merely be equivalent, with respect to a specified known equivalence relation. 
 Here is an example showing how that works.  We start with the following 
 events.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> fix-true-listp (lst)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> lst)
      (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> lst)
            (fix-true-listp (<a href="COMMON-LISP____CDR.html">cdr</a> lst)))
    nil))

(<a href="ACL2____DEFTHM.html">defthm</a> member-fix-true-listp
  (<a href="ACL2____IFF.html">iff</a> (<a href="COMMON-LISP____MEMBER.html">member</a> a (fix-true-listp lst))
       (<a href="COMMON-LISP____MEMBER.html">member</a> a lst)))

(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (e x)
  (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> e (fix-true-listp x)))</pre> 
 
 <p>We would like to eliminate the call of <span class="v">fix-true-listp</span>, but the 
 resulting call of <span class="v">member-equal</span> is only Boolean-equivalent to the original 
 call, not equal to it (see <span class="v">member-fix-true-listp</span> above).  Thus, if we try 
 evaluating <span class="v">(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> foo)</span> here, it will fail because no 
 simplification takes place.  Instead, we can specify that the <span class="v">:equiv</span> is 
 <span class="v">iff</span>.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> foo :equiv iff)
 (<a href="COMMON-LISP____DEFUN.html">DEFUN</a> FOO$1 (E X)
        (<a href="COMMON-LISP____DECLARE.html">DECLARE</a> (<a href="ACL2____XARGS.html">XARGS</a> :GUARD T
                        :VERIFY-GUARDS NIL))
        (<a href="ACL2____MEMBER-EQUAL.html">MEMBER-EQUAL</a> E X))
ACL2 !&gt;</pre> 
 
 <h3>Example Set 8: Mutual-recursion</h3> 
 
 <p>If <span class="v">(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> FN ...)</span> is called where <span class="v">FN</span> is defined using 
 <span class="tt"><a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a></span>, then every function defined with <span class="v">FN</span> will be 
 processed.  Consider the following example.</p> 
 
 <pre class="code">(<a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a>
 (<a href="COMMON-LISP____DEFUN.html">defun</a> foo (x)
   (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)
       (<a href="COMMON-LISP_____B2.html">+</a> 1 1)
     (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="ACL2____FFN-SYMB.html">ffn-symb</a> x) (foo-lst (<a href="COMMON-LISP____REST.html">rest</a> x)))))
 (<a href="COMMON-LISP____DEFUN.html">defun</a> foo-lst (x)
   (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)
       nil
     (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP_____B2.html">+</a> 1 2 (foo (<a href="COMMON-LISP____FIRST.html">first</a> x)))
           (foo-lst (<a href="COMMON-LISP____REST.html">rest</a> x))))))
(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> foo)</pre> 
 
 <p>The result is the introduction of a new <span class="v">mutual-recursion</span> with 
 simplified bodies, as follows.</p> 
 
 <pre class="code">(<a href="ACL2____MUTUAL-RECURSION.html">MUTUAL-RECURSION</a>
 (<a href="COMMON-LISP____DEFUN.html">DEFUN</a> FOO$1 (X)
   (<a href="COMMON-LISP____DECLARE.html">DECLARE</a> (<a href="ACL2____XARGS.html">XARGS</a> ...))
   (<a href="COMMON-LISP____IF.html">IF</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> X)
       (<a href="COMMON-LISP____CONS.html">CONS</a> (<a href="COMMON-LISP____CAR.html">CAR</a> X) (FOO-LST$1 (<a href="COMMON-LISP____CDR.html">CDR</a> X)))
       2))
 (<a href="COMMON-LISP____DEFUN.html">DEFUN</a> FOO-LST$1 (X)
   (<a href="COMMON-LISP____DECLARE.html">DECLARE</a> (<a href="ACL2____XARGS.html">XARGS</a> ...))
   (<a href="COMMON-LISP____IF.html">IF</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> X)
       (<a href="COMMON-LISP____CONS.html">CONS</a> (<a href="COMMON-LISP_____B2.html">+</a> 3 (FOO$1 (<a href="COMMON-LISP____CAR.html">CAR</a> X)))
             (FOO-LST$1 (<a href="COMMON-LISP____CDR.html">CDR</a> X)))
       NIL)))</pre> 
 
 <p>Moreover, keyword arguments are handled in a special way (except for 
 <span class="v">:non-executable</span>, <span class="v">:print</span>, <span class="v">:verify-guards</span>, and <span class="v">:show-only</span>, 
 which we ignore in this example).  Normally keyword arguments will be applied 
 to every function that is defined by the <span class="v">mutual-recursion</span>.  For example, 
 the <span class="v">simplify-defun</span> call above is equivalent to <span class="v">(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a>
 foo :simplify-body t)</span>, which directs simplification of the body not only for 
 <span class="v">foo</span> but also for <span class="v">foo-lst</span>  that is, for every member of the 
 <i>clique</i> of functions introduced by the <span class="v">mutual-recursion</span>.  A special 
 construct, <span class="v">:map</span>, allows different values of a keyword argument for 
 different members of that clique.  For the given <span class="v">mutual-recursion</span> above, 
 suppose that instead of the <span class="v">simplify-defun</span> call above, we invoke:</p> 
 
 <pre class="code">(<a href="APT____SIMPLIFY-DEFUN.html">simplify-defun</a> foo :simplify-body (:map (foo t) (foo-lst nil)))</pre> 
 
 <p>Then, as specified, only the definition of <span class="v">foo</span> is simplified in the 
 result.</p> 
 
 <pre class="code">(<a href="ACL2____MUTUAL-RECURSION.html">MUTUAL-RECURSION</a>
 (<a href="COMMON-LISP____DEFUN.html">DEFUN</a> FOO$1 (X)
   (<a href="COMMON-LISP____DECLARE.html">DECLARE</a> (<a href="ACL2____XARGS.html">XARGS</a> ...))
   (<a href="COMMON-LISP____IF.html">IF</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> X)
       (<a href="COMMON-LISP____CONS.html">CONS</a> (<a href="COMMON-LISP____CAR.html">CAR</a> X) (FOO-LST$1 (<a href="COMMON-LISP____CDR.html">CDR</a> X)))
       2))
 (<a href="COMMON-LISP____DEFUN.html">DEFUN</a> FOO-LST$1 (X)
   (<a href="COMMON-LISP____DECLARE.html">DECLARE</a> (<a href="ACL2____XARGS.html">XARGS</a> ...))
   (<a href="COMMON-LISP____IF.html">IF</a> (<a href="COMMON-LISP____ATOM.html">ATOM</a> X)
       NIL
       (<a href="COMMON-LISP____CONS.html">CONS</a> (<a href="COMMON-LISP_____B2.html">+</a> 1 2 (FOO$1 (<a href="COMMON-LISP____FIRST.html">FIRST</a> X)))
             (FOO-LST$1 (<a href="COMMON-LISP____REST.html">REST</a> X))))))</pre> 
 

</body>
</html>
