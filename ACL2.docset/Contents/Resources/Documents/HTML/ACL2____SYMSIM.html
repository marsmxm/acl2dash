<html>
<head>
<meta charset="UTF-8">
<title>Symsim</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____SYMSIM">Click for Symsim in the Full Manual</a></h3>

<p>Simplify given term and hypotheses.</p><p>Example:</p> 
 
<pre class="code">(<a href="ACL2____SYMSIM.html">symsim</a> (<a href="COMMON-LISP____APPEND.html">append</a> x y)
        ((<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)) (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x)))
        :hints (("Goal" :expand
                 ((<a href="ACL2____TRUE-LISTP.html">true-listp</a> x)
                  (<a href="ACL2____TRUE-LISTP.html">true-listp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x))
                  (<a href="COMMON-LISP____APPEND.html">append</a> x y)))))</pre> 
 
<p>yields</p> 
 
<pre class="code">Simplified term:
  (<a href="COMMON-LISP____CONS.html">CONS</a> (<a href="COMMON-LISP____CAR.html">CAR</a> X) Y)
Simplified hyps:
 ((<a href="COMMON-LISP____CONSP.html">CONSP</a> X) (<a href="COMMON-LISP____NOT.html">NOT</a> (<a href="COMMON-LISP____CDR.html">CDR</a> X)))~/

General Form:
(<a href="ACL2____SYMSIM.html">symsim</a> term hyps
        :hints             hints
        :inhibit-output    inhibit-flg ; t, :prove, :all, or nil, default t
        :prove-assumptions prove-flg   ; t, nil, or (<a href="ACL2____DEFAULT.html">default</a>) any other value
        :print-flg         print-flg   ; t or nil, default nil
        :simplify-hyps-p   flg         ; t, nil, or :no-split; default t
)</pre> 
 
<p>where <span class="v">term</span> is a term to be simplified assuming that each <span class="v">hyp</span> in 
the list <span class="v">hyps</span> is true, and <a href="ACL2____HINTS.html">hints</a> is as described in its <a href="COMMON-LISP____DOCUMENTATION.html">documentation</a>.  The keyword arguments above are all optional, and behave as 
you might expect.  In particular, set <span class="v">:simplify-hyps-p</span> to <span class="v">nil</span> if you 
do not want the <span class="v">hyps</span> to be simplified; otherwise, case splitting may occur 
in the course of their simplification.</p> 
 
<p>Prover output is inhibited if <span class="v">:inhibit-output</span> is <span class="v">t</span> (the default). 
Only proof output is inhibited if <span class="v">:inhibit-output</span> is <span class="v">:prove</span> (so for 
example, summaries and warnings are printed), and all prover output is shown or 
inhibited if <span class="v">:inhibit-output</span> is <span class="v">nil</span> or <span class="v">:all</span>, respectively.</p> 
 
<p>See <a href="ACL2____REWRITE_42.html">rewrite$</a> for a flexible, convenient interface to the ACL2 
rewriter that can be called programmatically.  Also see <a href="ACL2____DEFTHM_F3.html">defthm?</a>, which 
is related to <span class="v">symsim</span> and is a bit more thoroughly documented.  Here are 
some examples that should help give an idea of how <span class="v">symsim</span> works.  (The 
name, by the way, is short for "symbolically simulate".)  Try these, as well 
as the examples shown above.</p> 
 
  <pre class="code">(<a href="ACL2____SYMSIM.html">symsim</a> (<a href="COMMON-LISP____APPEND.html">append</a> x y)
        nil
        :hints (("Goal" :expand
                 ((<a href="ACL2____TRUE-LISTP.html">true-listp</a> x)
                  (<a href="COMMON-LISP____APPEND.html">append</a> x y)
                  (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x) y)))))

; Generates three cases:
(<a href="ACL2____SYMSIM.html">symsim</a> (<a href="COMMON-LISP____APPEND.html">append</a> x y)
        ((<a href="ACL2____TRUE-LISTP.html">true-listp</a> x))
        :hints (("Goal" :expand
                 ((<a href="ACL2____TRUE-LISTP.html">true-listp</a> x)
                  (<a href="ACL2____TRUE-LISTP.html">true-listp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x))
                  (<a href="COMMON-LISP____APPEND.html">append</a> x y)
                  (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x) y)))))

; Let's illustrate the role of FORCE.  The following rule
; forces append to open up, and comes into play below.
(<a href="ACL2____DEFTHM.html">defthm</a> true-listp-expand-append
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____FORCE.html">force</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> x))
                x)
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____APPEND.html">append</a> x y)
                  (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> x) (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x) y)))))

; Generates assumption forced by preceding rule.
(<a href="ACL2____SYMSIM.html">symsim</a> (<a href="COMMON-LISP____APPEND.html">append</a> x y)
        ((<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x))))

; But now we fail; but why?  See next form.
(<a href="ACL2____SYMSIM.html">symsim</a> (<a href="COMMON-LISP____APPEND.html">append</a> x y)
        ((<a href="COMMON-LISP____CONSP.html">consp</a> x))
        :prove-assumptions t)

; Let's not inhibit output.  Then we can see the failed forcing round.
(<a href="ACL2____SYMSIM.html">symsim</a> (<a href="COMMON-LISP____APPEND.html">append</a> x y)
        ((<a href="COMMON-LISP____CONSP.html">consp</a> x))
        :prove-assumptions t
        :inhibit-output nil)

; As above, but doesn't deal with generated forced assumptions at all (just
; drops them on the floor).
(<a href="ACL2____SYMSIM.html">symsim</a> (<a href="COMMON-LISP____APPEND.html">append</a> x y)
        ((<a href="COMMON-LISP____CONSP.html">consp</a> x))
        :prove-assumptions nil)</pre>
</body>
</html>
