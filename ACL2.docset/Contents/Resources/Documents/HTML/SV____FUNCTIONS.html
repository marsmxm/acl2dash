<html>
<head>
<meta charset="UTF-8">
<title>Functions</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=SV____FUNCTIONS">Click for Functions in the Full Manual</a></h3>

<p>Our expressions may involve the application of a fixed set of 
known functions.  There are functions available for modeling many bit-vector 
operations like bitwise and, plus, less-than, and other kinds of hardware 
operations like resolving multiple drivers, etc.</p><p>SVEX has a fixed language of known functions.  The following 
table shows the function symbols (all in the SV package) and their 
meanings.</p> 
 
<p>We make no attempt to have a minimal set of functions.  Generally speaking, 
the incremental cost in complexity of supporting more functions is relatively 
low.  Our tools for rewriting and symbolically evaluating expressions can be 
proven correct, so there is little risk that adding new operations to the 
backend could cause any problems.</p> 
 
<p>On the other hand, the correct translation from languages like Verilog into 
SV expressions is a serious concern, and we have no way to prove it is correct. 
Where possible, then, it seems best to add new operators to the backend to make 
the translation from Verilog as simple as possible.</p> 
 
<table class="xtable"> 
<tr>
<th>SVEX form</th>
<th>4vec function</th>
<th>Description</th>
</tr> 
<tr>
<td><span class="v">(ID X)</span></td>
<td><a href="SV____4VEC-FIX.html">4vec-fix</a></td>
<td>identity function</td>
</tr> 
<tr>
<td><span class="v">(BITSEL INDEX X)</span></td>
<td><a href="SV____4VEC-BIT-EXTRACT.html">4vec-bit-extract</a></td>
<td>bit select</td>
</tr> 
<tr>
<td><span class="v">(UNFLOAT X)</span></td>
<td><a href="SV____3VEC-FIX.html">3vec-fix</a></td>
<td>change Z bits to Xes</td>
</tr> 
<tr>
<td><span class="v">(BITNOT X)</span></td>
<td><a href="SV____4VEC-BITNOT.html">4vec-bitnot</a></td>
<td>bitwise negation</td>
</tr> 
<tr>
<td><span class="v">(BITAND X Y)</span></td>
<td><a href="SV____4VEC-BITAND.html">4vec-bitand</a></td>
<td>bitwise AND</td>
</tr> 
<tr>
<td><span class="v">(BITOR X Y)</span></td>
<td><a href="SV____4VEC-BITOR.html">4vec-bitor</a></td>
<td>bitwise OR</td>
</tr> 
<tr>
<td><span class="v">(BITXOR X Y)</span></td>
<td><a href="SV____4VEC-BITXOR.html">4vec-bitxor</a></td>
<td>bitwise XOR</td>
</tr> 
<tr>
<td><span class="v">(RES X Y)</span></td>
<td><a href="SV____4VEC-RES.html">4vec-res</a></td>
<td>resolve (short together)</td>
</tr> 
<tr>
<td><span class="v">(RESAND X Y)</span></td>
<td><a href="SV____4VEC-RESAND.html">4vec-resand</a></td>
<td>resolve wired AND</td>
</tr> 
<tr>
<td><span class="v">(RESOR X Y)</span></td>
<td><a href="SV____4VEC-RESOR.html">4vec-resor</a></td>
<td>resolve wired OR</td>
</tr> 
<tr>
<td><span class="v">(OVERRIDE X Y)</span></td>
<td><a href="SV____4VEC-OVERRIDE.html">4vec-override</a></td>
<td>resolve different strengths</td>
</tr> 
<tr>
<td><span class="v">(ONP X)</span></td>
<td><a href="SV____4VEC-ONSET.html">4vec-onset</a></td>
<td>identity, except Z becomes 0</td>
</tr> 
<tr>
<td><span class="v">(OFFP X)</span></td>
<td><a href="SV____4VEC-OFFSET.html">4vec-offset</a></td>
<td>negation, except Z becomes 0</td>
</tr> 
<tr>
<td><span class="v">(UAND X)</span></td>
<td><a href="SV____4VEC-REDUCTION-AND.html">4vec-reduction-and</a></td>
<td>unary (reduction) AND</td>
</tr> 
<tr>
<td><span class="v">(UOR X)</span></td>
<td><a href="SV____4VEC-REDUCTION-OR.html">4vec-reduction-or</a></td>
<td>unary (reduction) OR</td>
</tr> 
<tr>
<td><span class="v">(UXOR X)</span></td>
<td><a href="SV____4VEC-PARITY.html">4vec-parity</a></td>
<td>reduction XOR, i.e. parity</td>
</tr> 
<tr>
<td><span class="v">(ZEROX WIDTH X)</span></td>
<td><a href="SV____4VEC-ZERO-EXT.html">4vec-zero-ext</a></td>
<td>zero extend</td>
</tr> 
<tr>
<td><span class="v">(SIGNX WIDTH X)</span></td>
<td><a href="SV____4VEC-SIGN-EXT.html">4vec-sign-ext</a></td>
<td>sign extend</td>
</tr> 
<tr>
<td><span class="v">(CONCAT WIDTH X Y)</span></td>
<td><a href="SV____4VEC-CONCAT.html">4vec-concat</a></td>
<td>concatenate at a given bit width</td>
</tr> 
<tr>
<td><span class="v">(BLKREV WIDTH BSZ X)</span></td>
<td><a href="SV____4VEC-REV-BLOCKS.html">4vec-rev-blocks</a></td>
<td>reverse order of blocks</td>
</tr> 
<tr>
<td><span class="v">(RSH SHIFT X)</span></td>
<td><a href="SV____4VEC-RSH.html">4vec-rsh</a></td>
<td>right shift</td>
</tr> 
<tr>
<td><span class="v">(LSH SHIFT X)</span></td>
<td><a href="SV____4VEC-LSH.html">4vec-lsh</a></td>
<td>left shift</td>
</tr> 
<tr>
<td><span class="v">(<a href="COMMON-LISP_____B2.html">+</a> X Y)</span></td>
<td><a href="SV____4VEC-PLUS.html">4vec-plus</a></td>
<td>addition</td>
</tr> 
<tr>
<td><span class="v">(B- X Y)</span></td>
<td><a href="SV____4VEC-MINUS.html">4vec-minus</a></td>
<td>subtraction</td>
</tr> 
<tr>
<td><span class="v">(U- X)</span></td>
<td><a href="SV____4VEC-UMINUS.html">4vec-uminus</a></td>
<td>unary minus</td>
</tr> 
<tr>
<td><span class="v">(<a href="COMMON-LISP_____A2.html">*</a> X Y)</span></td>
<td><a href="SV____4VEC-TIMES.html">4vec-times</a></td>
<td>multiplication</td>
</tr> 
<tr>
<td><span class="v">(<a href="COMMON-LISP_____F2.html">/</a> X Y)</span></td>
<td><a href="SV____4VEC-QUOTIENT.html">4vec-quotient</a></td>
<td>division</td>
</tr> 
<tr>
<td><span class="v">(% X Y)</span></td>
<td><a href="SV____4VEC-REMAINDER.html">4vec-remainder</a></td>
<td>modulus</td>
</tr> 
<tr>
<td><span class="v">(XDET X)</span></td>
<td><a href="SV____4VEC-XDET.html">4vec-xdet</a></td>
<td>identity on binary vectors, else X</td>
</tr> 
<tr>
<td><span class="v">(COUNTONES X)</span></td>
<td><a href="SV____4VEC-COUNTONES.html">4vec-countones</a></td>
<td>count of 1-bits</td>
</tr> 
<tr>
<td><span class="v">(ONEHOT X)</span></td>
<td><a href="SV____4VEC-ONEHOT.html">4vec-onehot</a></td>
<td>one-hot check</td>
</tr> 
<tr>
<td><span class="v">(ONEHOT0 X)</span></td>
<td><a href="SV____4VEC-ONEHOT0.html">4vec-onehot0</a></td>
<td>one-hot check (0-hot allowed)</td>
</tr> 
<tr>
<td><span class="v">(<a href="COMMON-LISP_____C3.html">&lt;</a> X Y)</span></td>
<td><a href="SV____4VEC-_C3.html">4vec-&lt;</a></td>
<td>less than</td>
</tr> 
<tr>
<td><span class="v">(== X Y)</span></td>
<td><a href="SV____4VEC-_D3_D3.html">4vec-==</a></td>
<td>equality</td>
</tr> 
<tr>
<td><span class="v">(=== X Y)</span></td>
<td><a href="SV____4VEC-_D3_D3_D3.html">4vec-===</a></td>
<td>case equality (scary verilog semantics)</td>
</tr> 
<tr>
<td><span class="v">(===* X Y)</span></td>
<td><a href="SV____4VEC-_D3_D3_D3_A2.html">4vec-===*</a></td>
<td>modified case equality (x-monotonic if y is constant)</td>
</tr> 
<tr>
<td><span class="v">(==? X Y)</span></td>
<td><a href="SV____4VEC-WILDEQ.html">4vec-wildeq</a></td>
<td>wildcard equality (scary verilog semantics)</td>
</tr> 
<tr>
<td><span class="v">(SAFER-==? X Y)</span></td>
<td><a href="SV____4VEC-WILDEQ-SAFE.html">4vec-wildeq-safe</a></td>
<td>wildcard equality (X-monotonic version)</td>
</tr> 
<tr>
<td><span class="v">(==?? X Y)</span></td>
<td><a href="SV____4VEC-SYMWILDEQ.html">4vec-symwildeq</a></td>
<td>wildcard equality for casez</td>
</tr> 
<tr>
<td><span class="v">(CLOG2 X)</span></td>
<td><a href="SV____4VEC-CLOG2.html">4vec-clog2</a></td>
<td>ceiling of log2</td>
</tr> 
<tr>
<td><span class="v">(POW X Y)</span></td>
<td><a href="SV____4VEC-POW.html">4vec-pow</a></td>
<td>exponentiation</td>
</tr> 
<tr>
<td><span class="v">(? TEST THEN ELSE)</span></td>
<td><a href="SV____4VEC-_F3.html">4vec-?</a></td>
<td>if-then-else</td>
</tr> 
<tr>
<td><span class="v">(?* TEST THEN ELSE)</span></td>
<td><a href="SV____4VEC-_F3_A2.html">4vec-?*</a></td>
<td>if-then-else (for statements)</td>
</tr> 
<tr>
<td><span class="v">(BIT? TEST THEN ELSE)</span></td>
<td><a href="SV____4VEC-BIT_F3.html">4vec-bit?</a></td>
<td>bitwise if-then-else</td>
</tr> 
<tr>
<td><span class="v">(BIT?! TEST THEN ELSE)</span></td>
<td><a href="SV____4VEC-BIT_F3_12.html">4vec-bit?!</a></td>
<td>bitwise if-then-else, only chooses then[i] when test[i]===1</td>
</tr> 
<tr>
<td><span class="v">(?! TEST THEN ELSE)</span></td>
<td><a href="SV____4VEC-_F3_12.html">4vec-?!</a></td>
<td>procedural if-then-else, only chooses then when test has a definite 1 bit</td>
</tr> 
<tr>
<td><span class="v">(PARTSEL LSB WIDTH IN)</span></td>
<td><a href="SV____4VEC-PART-SELECT.html">4vec-part-select</a></td>
<td>part select</td>
</tr> 
<tr>
<td><span class="v">(PARTINST LSB WIDTH IN VAL)</span></td>
<td><a href="SV____4VEC-PART-INSTALL.html">4vec-part-install</a></td>
<td>part install</td>
</tr> 
</table>
</body>
</html>
