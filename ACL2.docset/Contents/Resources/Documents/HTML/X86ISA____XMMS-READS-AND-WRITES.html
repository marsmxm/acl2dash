<html>
<head>
<meta charset="UTF-8">
<title>Xmms-reads-and-writes</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=X86ISA____XMMS-READS-AND-WRITES">Click for Xmms-reads-and-writes in the Full Manual</a></h3>

<p>Functions to read/write 32/64/128 bits into the XMM 
  registers (to be used by non-VEX encoded 128-bit SIMD instructions)</p> <p>These functions are meant to be used by instructions that 
  do not use a VEX or EVEX prefix --- these functions preserve the 
  upper bits of ZMM registers.  For instructions that use these 
  prefixes and zero out these bits instead, see <a href="X86ISA____ZMMS-READS-AND-WRITES.html">ZMMs-Reads-and-Writes</a>.</p> 
 
  <p>Note that the index for accessing the XMM registers is 4-bits 
  wide (as opposed to the 5-bit index for ZMM registers --- see <a href="X86ISA____ZMMS-READS-AND-WRITES.html">ZMMs-Reads-and-Writes</a>) because only 16 XMM registers were supported 
  initially in the 64-bit mode (and 8 in the 32-bit mode).</p> 
 
 <p>Source: Intel Vol. 2, Section 2.3.10 --- AVX Instructions 
  and Upper 128-bits of YMM registers:</p> 
 
  <blockquote>If an instruction with a destination XMM register is 
  encoded with a VEX prefix, the processor zeroes the upper 
  bits (above bit 128) of the equivalent YMM register. Legacy SSE 
  instructions without VEX preserve the upper bits.</blockquote> 
 
 <p>Functions <a href="X86ISA____RX32.html">rx32</a>, <a href="X86ISA____RX64.html">rx64</a>, and <a href="X86ISA____RX128.html">rx128</a> will read the 
 contents of the XMMs (i.e., low 128 bits of ZMMs) as natural 
 numbers.</p> 
 
 <p>Similarly, functions <a href="X86ISA____WX32.html">wx32</a>, <a href="X86ISA____WX64.html">wx64</a>, and <a href="X86ISA____WX128.html">wx128</a> 
 are used to write natural numbers into the XMMs (and preserve the 
 upper bits of ZMMs).</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>rx32$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> rx32$inline (reg x86)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (x86)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 4) reg))
       (<a href="X86ISA____RZ32.html">rz32</a> reg x86))</pre> 
<p><b>Function: </b>rx64$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> rx64$inline (reg x86)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (x86)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 4) reg))
       (<a href="X86ISA____RZ64.html">rz64</a> reg x86))</pre> 
<p><b>Function: </b>rx128$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> rx128$inline (reg x86)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (x86)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 4) reg))
       (<a href="X86ISA____RZ128.html">rz128</a> reg x86))</pre> 
<p><b>Function: </b>wx32$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> wx32$inline (reg val x86)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (x86)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 4) reg)
                (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 32) val))
       (<a href="X86ISA____WZ32.html">wz32</a> reg val x86 :regtype 1))</pre> 
<p><b>Function: </b>wx64$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> wx64$inline (reg val x86)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (x86)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 4) reg)
                (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 64) val))
       (<a href="X86ISA____WZ64.html">wz64</a> reg val x86 :regtype 1))</pre> 
<p><b>Function: </b>wx128$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> wx128$inline (reg val x86)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (x86)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 4) reg)
                (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 128) val))
       (<a href="X86ISA____WZ128.html">wz128</a> reg val x86 :regtype 1))</pre> 
<p><b>Function: </b>xmmi-size$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> xmmi-size$inline (nbytes index x86)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (x86)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 5) nbytes)
                (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 4) index))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____MEMBER.html">member</a> nbytes '(4 8 16))))
       (<a href="COMMON-LISP____CASE.html">case</a> nbytes (4 (<a href="X86ISA____RX32.html">rx32</a> index x86))
             (8 (<a href="X86ISA____RX64.html">rx64</a> index x86))
             (16 (<a href="X86ISA____RX128.html">rx128</a> index x86))
             (otherwise 0)))</pre> 
<p><b>Theorem: </b>natp-of-xmmi-size</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> natp-of-xmmi-size
        (<a href="ACL2____B_A2.html">b*</a> ((val (xmmi-size$inline nbytes index x86)))
            (<a href="ACL2____NATP.html">natp</a> val))
        :rule-classes :type-prescription)</pre> 
<p><b>Function: </b>!xmmi-size$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 !xmmi-size$inline (nbytes index val x86)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (x86)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 5) nbytes)
          (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 4) index)
          (<a href="COMMON-LISP____TYPE.html">type</a> integer val))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____MEMBER.html">member</a> nbytes '(4 8 16))
                             (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> (<a href="COMMON-LISP____ASH.html">ash</a> nbytes 3) val))))
 (<a href="COMMON-LISP____CASE.html">case</a> nbytes (4 (<a href="X86ISA____WX32.html">wx32</a> index val x86))
       (8 (<a href="X86ISA____WX64.html">wx64</a> index val x86))
       (16 (<a href="X86ISA____WX128.html">wx128</a> index val x86))
       (otherwise x86)))</pre> 
<p><b>Theorem: </b>x86p-of-!xmmi-size</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     x86p-of-!xmmi-size
     (<a href="ACL2____IMPLIES.html">implies</a> (x86p x86)
              (<a href="ACL2____B_A2.html">b*</a> ((x86 (!xmmi-size$inline nbytes index val x86)))
                  (x86p x86)))
     :rule-classes :rewrite)</pre> 

</body>
</html>
