<html>
<head>
<meta charset="UTF-8">
<title>Generalizing-key-checkpoints</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____GENERALIZING-KEY-CHECKPOINTS">Click for Generalizing-key-checkpoints in the Full Manual</a></h3>

<p>Getting rid of unnecessary specificity</p><p>Suppose <span class="v">MEMBER</span> determines whether its first argument is a 
 member of its second, and <span class="v">SUBSETP</span> determines whether every element of its 
 first argument is a member of its second.  Suppose that you're trying to prove 
 some Main Theorem and are told the formula below is a key checkpoint.  What 
 should you do?</p> 
 
 <pre class="code">Key Checkpoint:
(<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____AND.html">AND</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> A)
              (<a href="COMMON-LISP____INTEGERP.html">INTEGERP</a> (<a href="COMMON-LISP____CAR.html">CAR</a> A))
              (<a href="COMMON-LISP____MEMBER.html">MEMBER</a> (<a href="COMMON-LISP____CAR.html">CAR</a> A) B)
              (<a href="COMMON-LISP____SUBSETP.html">SUBSETP</a> (<a href="COMMON-LISP____CDR.html">CDR</a> A) B)
              (<a href="COMMON-LISP____NOT.html">NOT</a> (<a href="COMMON-LISP____SUBSETP.html">SUBSETP</a> (<a href="COMMON-LISP____CDR.html">CDR</a> A) (<a href="COMMON-LISP____APPEND.html">APPEND</a> B C))))
         (<a href="COMMON-LISP____MEMBER.html">MEMBER</a> (<a href="COMMON-LISP____CAR.html">CAR</a> A) C))</pre> 
 
 <p>The key observation is that the fourth hypothesis implies the negation of 
 the fifth.  Writing it in the contrapositive:</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____AND.html">AND</a> ...
              (<a href="COMMON-LISP____SUBSETP.html">SUBSETP</a> (<a href="COMMON-LISP____CDR.html">CDR</a> A) B)
              ...)
         (<a href="COMMON-LISP____SUBSETP.html">SUBSETP</a> (<a href="COMMON-LISP____CDR.html">CDR</a> A) (<a href="COMMON-LISP____APPEND.html">APPEND</a> B C)))</pre> 
 
 <p>In fact, that is more complicated than it needs to be.  A ``correct'' 
 response to the key checkpoint above is to prove</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> subsetp-append
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____SUBSETP.html">subsetp</a> a b)
           (<a href="COMMON-LISP____SUBSETP.html">subsetp</a> a (<a href="COMMON-LISP____APPEND.html">append</a> b c)))).</pre> 
 
 <p>A still better response is to prove this:</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> subsetp-append-2
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____SUBSETP.html">subsetp</a> a b)
               (<a href="COMMON-LISP____SUBSETP.html">subsetp</a> a c))
           (<a href="COMMON-LISP____SUBSETP.html">subsetp</a> a (<a href="COMMON-LISP____APPEND.html">append</a> b c)))).</pre> 
 
 <p>This version is better because it handles both of the possibilities 
 regarding whether <span class="v">a</span> is a subset of the arguments of the <span class="v">append</span>.</p> 
 
 <p>It would be nice if we could think of a ``strong'' version, one in which 
 <span class="v">(<a href="COMMON-LISP____SUBSETP.html">SUBSETP</a> a (<a href="COMMON-LISP____APPEND.html">APPEND</a> b c))</span> is rewritten to some clearly simpler term, but 
 nothing comes to mind.</p> 
 
 <p>In any case, if you cannot see any obvious simplification of the individual 
 terms in the Key Checkpoint, you should ask yourself whether there are 
 connections between the various propositional parts (as here, with the fourth 
 and fifth hypotheses).  It is a good heuristic to look for relations between 
 parts with the same top-level function symbol (as here, with <span class="v">SUBSETP</span>). 
 It is also a good heuristic to throw out parts of the formula that seem 
 disconnected (as here, with the terms involving <span class="v">(<a href="COMMON-LISP____CAR.html">CAR</a> A)</span>).</p> 
 
 <p>This discussion suggests several ``modes'' of looking at key checkpoints 
 and the idea of trying the modes in sequence:</p> 
 
 <p>(1) look for simplifiable combinations of function symbols within 
 propositional components,</p> 
 
 <p>(2) look for relations between propositional components, and</p> 
 
 <p>(3) throw out irrelevant or weakly connected components.</p> 
 
 <p>In all cases you are bringing to bear your intuitions about the 
 <i>semantics</i> of the terms.  That is, you're not just slinging symbols. 
 You should be looking out for obvious truths about individual parts of the 
 checkpoints...  truths that are obvious to you but not to ACL2!</p> 
 
 <p>Ultimately the three ``modes'' are the same and we do not really recommend 
 adhering to the given sequence.  You're just looking for simpler theorems 
 that, in combination, imply the checkpoint.  Keeping the ``modes'' in mind may 
 help focus your attention so you consider all the plausible possibilities. 
 After a little experience you'll find yourself looking for all these things 
 simultaneously as part ``cleaning up'' the checkpoints.</p> 
 
 <p>When your main goal theorems are harder than these, your main concern will 
 be looking at a Key Checkpoint and asking yourself ``why is this true?''  But 
 you don't want to do that until you've cleaned it up ``locally'' as much as 
 possible and sometimes  more often than you might think  local 
 considerations can prove many of your checkpoints.</p> 
 
 <p>If you have been working your way through the tutorial introduction to the 
 theorem prover, use your browser's <b>Back Button</b> now to return to <a href="ACL2____INTRODUCTION-TO-KEY-CHECKPOINTS.html">introduction-to-key-checkpoints</a>.</p>
</body>
</html>
