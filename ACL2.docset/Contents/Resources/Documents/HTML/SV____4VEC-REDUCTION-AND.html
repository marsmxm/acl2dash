<html>
<head>
<meta charset="UTF-8">
<title>4vec-reduction-and</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=SV____4VEC-REDUCTION-AND">Click for 4vec-reduction-and in the Full Manual</a></h3>

<p>Reduction logical AND of a <a href="SV____4VEC.html">4vec</a>.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(4vec-reduction-and x) → and-x</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">x</span> — <font color="#606060">Guard <span class="v">(<a href="SV____4VEC-P.html">4vec-p</a> x)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">and-x</span> — <font color="#606060">Type <span class="v">(<a href="SV____3VEC-P_12.html">3vec-p!</a> and-x)</span>.</font>
</dd> 
 
</dl></div> 
<p>ANDs together all of the bits in a 4vec.  Following the <a href="SV____BOOLEAN-CONVENTION.html">boolean-convention</a>, we return:</p> 
 
<ul> 
<li>True (all 1s) if all of the (infinite) bits are 1, i.e., if X is -1,</li> 
<li>False (all 0s) if there is any bit that is 0, or</li> 
<li>All Xes otherwise.</li> 
</ul> 
 
<p><b>Subtle</b>.  Since <a href="SV____4VEC.html">4vec</a>s are ``infinite width,'' reduction 
operations are a bit unusual.  For reduction AND in particular, when 
translating from Verilog or other languages where your vectors are only some 
fixed width, you will typically need to <i>always sign-extend the input 
vector</i>, regardless of whether it is signed or unsigned.</p> 
 
<p>That is, say you start with a unsigned 5-bit vector whose value is 
<span class="v">11111</span>.  If you create your (infinite width) 4vec for this by zero 
extension, you'll end up with infinitely many leading 0s, which will cause the 
reduction AND of your vector to be 0!</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>4vec-reduction-and</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> 4vec-reduction-and (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SV____4VEC-P.html">4vec-p</a> x)))
       (<a href="COMMON-LISP____LET.html">let</a> ((__function__ '4vec-reduction-and))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
            (<a href="SV____3VEC-REDUCTION-AND.html">3vec-reduction-and</a> (<a href="SV____3VEC-FIX.html">3vec-fix</a> x))))</pre> 
<p><b>Theorem: </b>3vec-p!-of-4vec-reduction-and</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> 3vec-p!-of-4vec-reduction-and
        (<a href="ACL2____B_A2.html">b*</a> ((and-x (<a href="SV____4VEC-REDUCTION-AND.html">4vec-reduction-and</a> x)))
            (<a href="SV____3VEC-P_12.html">3vec-p!</a> and-x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>4vec-reduction-and-recursive</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 4vec-reduction-and-recursive
 (<a href="COMMON-LISP____EQUAL.html">equal</a>
  (<a href="SV____4VEC-REDUCTION-AND.html">4vec-reduction-and</a> x)
  (<a href="ACL2____B_A2.html">b*</a>
   (((<a href="SV____4VEC.html">4vec</a> x))
    ((when (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____OR.html">or</a> (<a href="ACL2____ZIP.html">zip</a> x.upper) (<a href="COMMON-LISP____EQL.html">eql</a> x.upper -1))
                (<a href="COMMON-LISP____OR.html">or</a> (<a href="ACL2____ZIP.html">zip</a> x.lower) (<a href="COMMON-LISP____EQL.html">eql</a> x.lower -1))))
     (<a href="SV____3VEC-FIX.html">3vec-fix</a> x))
    (<a href="COMMON-LISP____FIRST.html">first</a> (<a href="SV____4VEC-IDX-_E34V.html">4vec-idx-&gt;4v</a> 0 x))
    (and-rest
       (<a href="SV____4VEC-IDX-_E34V.html">4vec-idx-&gt;4v</a> 0
                     (<a href="SV____4VEC-REDUCTION-AND.html">4vec-reduction-and</a> (<a href="SV____4VEC.html">4vec</a> (<a href="ACL2____LOGCDR.html">logcdr</a> x.upper)
                                               (<a href="ACL2____LOGCDR.html">logcdr</a> x.lower))))))
   (<a href="SV____4V-_E34VEC-BIT.html">4v-&gt;4vec-bit</a> (<a href="ACL2____4V-AND.html">acl2::4v-and</a> first and-rest))))
 :rule-classes
 ((:definition :install-body nil
               :clique (<a href="SV____4VEC-REDUCTION-AND.html">4vec-reduction-and</a>)
               :controller-alist ((<a href="SV____4VEC-REDUCTION-AND.html">4vec-reduction-and</a> t)))))</pre> 
<p><b>Theorem: </b>4vec-reduction-and-of-3vec-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> 4vec-reduction-and-of-3vec-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SV____4VEC-REDUCTION-AND.html">4vec-reduction-and</a> (<a href="SV____3VEC-FIX.html">3vec-fix</a> x))
               (<a href="SV____4VEC-REDUCTION-AND.html">4vec-reduction-and</a> x)))</pre> 
<p><b>Theorem: </b>4vec-reduction-and-3vec-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> 4vec-reduction-and-3vec-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SV____3VEC-EQUIV.html">3vec-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SV____4VEC-REDUCTION-AND.html">4vec-reduction-and</a> x)
                        (<a href="SV____4VEC-REDUCTION-AND.html">4vec-reduction-and</a> x-equiv)))
        :rule-classes :congruence)</pre> 

</body>
</html>
