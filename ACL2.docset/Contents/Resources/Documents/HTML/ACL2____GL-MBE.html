<html>
<head>
<meta charset="UTF-8">
<title>Gl-mbe</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____GL-MBE">Click for Gl-mbe in the Full Manual</a></h3>

<p>Assert that a particular symbolic object is equivalent to a second 
form, and use the second in place of the first.</p><p><span class="tt">(gl-mbe spec impl)</span> is defined to simply check whether its two arguments 
<span class="v">spec</span> and <span class="v">impl</span> are equal, throwing an error if not, and return 
<span class="v">spec</span>.</p> 
 
<p>However, when <span class="v">gl-mbe</span> is symbolically executed, the equality of the two 
arguments is checked symbolically.  If it can be proved (e.g., via a BDD 
equality or SAT check) that they are always equal, then <span class="v">impl</span> is returned 
instead of <span class="v">spec</span>, otherwise an error is produced.</p> 
 
<p>This is most useful when symbolically executing in AIG mode.  For example, 
suppose that through a series of shifting operations, the symbolic 
representation of some numeric operand X is expanded to thousands of bits. 
However, the user knows that only the bottom 25 bits may be non-zero.  Then the 
following form may speed up the rest of the computation involving X by cutting 
off all the upper bits, which are known to be zero:</p> 
 
<pre class="code">(<a href="COMMON-LISP____LET.html">let</a> ((x-chop (<a href="ACL2____GL-MBE.html">gl-mbe</a> x (<a href="COMMON-LISP____LOGAND.html">logand</a> (<a href="COMMON-LISP____1-.html">1-</a> (<a href="COMMON-LISP____ASH.html">ash</a> 1 25)) x))))
   ...)</pre> 
 
<p>When GL symbolically executes this, it tries to prove that <span class="v">x</span> and the 
<a href="COMMON-LISP____LOGAND.html">logand</a> expression are equivalent, that is, their symbolic 
representations evaluate to the same concrete values under all environments. 
If this can be proved, <span class="v">x-chop</span> is bound to the <a href="COMMON-LISP____LOGAND.html">logand</a> result, which 
cuts off the upper bits of <span class="v">x</span>, which may improve symbolic execution 
performance.  However, logically <span class="v">gl-mbe</span> just binds <span class="v">x-chop</span> to <span class="v">x</span>, 
so this <span class="v">logand</span> term does not complicate reasoning about the 
specification.</p> 
 
<p>See also <a href="GL____GL-MBE-FAST.html">gl-mbe-fast</a>.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>gl-mbe-fn</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 gl-mbe-fn
 (spec impl spec-form impl-form)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="ACL2____MBE.html">mbe</a>
  :logic spec
  :exec
  (<a href="ACL2____PROG2_42.html">prog2$</a>
   (<a href="COMMON-LISP____OR.html">or</a>
    (<a href="COMMON-LISP____EQUAL.html">equal</a> spec impl)
    (<a href="ACL2____ER.html">er</a>
     hard? 'gl-mbe
     "GL-MBE failure: ~x0 and ~x1 unequal.~% ~
                                Values: ~x2 versus ~x3."
     spec-form impl-form spec impl))
   spec)))</pre> 
<p><b>Theorem: </b>gl-mbe-gl-def</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 gl-mbe-gl-def
 (<a href="COMMON-LISP____EQUAL.html">equal</a>
     (gl-mbe-fn spec impl spec-form impl-form)
     (<a href="COMMON-LISP____IF.html">if</a> (<a href="GL____GL-ASSERT.html">gl-assert</a> (<a href="ACL2____ALWAYS-EQUAL.html">acl2::always-equal</a> spec impl)
                    :msg (<a href="ACL2____MSG.html">msg</a> "GL-MBE failure: ~x0 and ~x1 unequal."
                              spec-form impl-form))
         impl spec))
 :rule-classes ((:definition :install-body nil)))</pre> 

</body>
</html>
