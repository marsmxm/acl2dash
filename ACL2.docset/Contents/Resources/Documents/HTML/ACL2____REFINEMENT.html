<html>
<head>
<meta charset="UTF-8">
<title>Refinement</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____REFINEMENT">Click for Refinement in the Full Manual</a></h3>

<p>Record that one equivalence relation refines another</p><p>See <a href="ACL2____RULE-CLASSES.html">rule-classes</a> for a general discussion of rule classes, 
 including how they are used to build rules from formulas and a discussion of 
 the various keywords in a rule class description.</p> 
 
 <pre class="code">Example:
(<a href="ACL2____DEFTHM.html">defthm</a> bag-equal-refines-set-equal
  (<a href="ACL2____IMPLIES.html">implies</a> (bag-equal x y)
           (set-equal y x))
  :rule-classes :refinement)</pre> 
 
 <p>Also see <a href="ACL2____DEFREFINEMENT.html">defrefinement</a>.</p> 
 
 <pre class="code">General Form:
(<a href="ACL2____IMPLIES.html">implies</a> (equiv1 x y) (equiv2 x y))</pre> 
 
 <p><span class="v">Equiv1</span> and <span class="v">equiv2</span> must be known equivalence relations.  The 
 effect of such a rule is to record that <span class="v">equiv1</span> is a refinement of 
 <span class="v">equiv2</span>.  This means that <span class="v">equiv1</span> <span class="v">:</span><span class="tt"><a href="ACL2____REWRITE.html">rewrite</a></span> rules may be 
 used while trying to maintain <span class="v">equiv2</span>.  See <a href="ACL2____EQUIVALENCE.html">equivalence</a> for a 
 general discussion of the issues.</p> 
 
 <p>The macro form <span class="v">(<a href="ACL2____DEFREFINEMENT.html">defrefinement</a> equiv1 equiv2)</span> is an abbreviation for a 
 <span class="tt"><a href="ACL2____DEFTHM.html">defthm</a></span> of rule-class <span class="v">:refinement</span> that establishes that 
 <span class="v">equiv1</span> is a refinement of <span class="v">equiv2</span>.  See <a href="ACL2____DEFREFINEMENT.html">defrefinement</a>.</p> 
 
 <p>Suppose we have the <span class="v">:</span><span class="tt"><a href="ACL2____REWRITE.html">rewrite</a></span> rule</p> 
 
 <pre class="code">(bag-equal (<a href="COMMON-LISP____APPEND.html">append</a> a b) (<a href="COMMON-LISP____APPEND.html">append</a> b a))</pre> 
 
 <p>which states that <span class="tt"><a href="COMMON-LISP____APPEND.html">append</a></span> is commutative modulo bag-equality. 
 Suppose further we have established that bag-equality refines set-equality. 
 Then when we are simplifying <span class="tt"><a href="COMMON-LISP____APPEND.html">append</a></span> expressions while maintaining 
 set-equality we use <span class="tt"><a href="COMMON-LISP____APPEND.html">append</a></span>'s commutativity property, even though it 
 was proved for bag-equality.</p> 
 
 <p>Equality is known to be a refinement of all equivalence relations.  The 
 transitive closure of the refinement relation is maintained, so if 
 <span class="v">set-equality</span>, say, is shown to be a refinement of some third sense of 
 equivalence, then <span class="v">bag-equality</span> will automatically be known as a refinement 
 of that third equivalence.</p> 
 
 <p><span class="v">:refinement</span> lemmas cannot be disabled.  That is, once one equivalence 
 relation has been shown to be a refinement of another, there is no way to 
 prevent the system from using that information.  Of course, individual 
 <span class="v">:</span><span class="tt"><a href="ACL2____REWRITE.html">rewrite</a></span> rules can be disabled.</p> 
 
 <p>More will be written about this as we develop the techniques.</p>
</body>
</html>
