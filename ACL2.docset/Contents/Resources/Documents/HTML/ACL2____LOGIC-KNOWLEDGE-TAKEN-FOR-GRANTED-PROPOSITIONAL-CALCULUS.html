<html>
<head>
<meta charset="UTF-8">
<title>Logic-knowledge-taken-for-granted-propositional-calculus</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____LOGIC-KNOWLEDGE-TAKEN-FOR-GRANTED-PROPOSITIONAL-CALCULUS">Click for Logic-knowledge-taken-for-granted-propositional-calculus in the Full Manual</a></h3>

<p>A brief explanation of propositional calculus</p><p>It is impossible in this short introduction to teach you 
 propositional calculus if you don't already know it!</p> 
 
 <p>A typical use of propositional calculus is to observe that</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____ENDP.html">endp</a> z)
         (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> z)
                  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____REV.html">rev</a> (<a href="ACL2____REV.html">rev</a> z)) z)))</pre> 
 
 <p>is equivalent to:</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____ENDP.html">endp</a> z)
              (<a href="ACL2____TRUE-LISTP.html">true-listp</a> z))
         (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____REV.html">rev</a> (<a href="ACL2____REV.html">rev</a> z)) z))</pre> 
 
 <p>If this is surprising and you know propositional calculus, then the problem 
 might be our notation.  We're exploiting the tautology</p> 
 
 <pre class="code"><i>(p ---&gt; (q ---&gt; r)) &lt;---&gt; ((p &amp; q) ---&gt; r)</i> 
</pre> 
 
 <p>where <i>---&gt;</i> and <i>&lt;---&gt;</i> are meant to be the traditional 
 arrows denoting logical implication and logical equivalence.</p> 
 
 <p>If you don't know propositional calculus, we'll say just a few things to 
 help ease your journey.</p> 
 
 <p>A <i>propositional formula</i>, in ACL2, is any formula written entirely in 
 terms of variable symbols, <span class="v">T</span>, <span class="v">NIL</span>, and the propositional functions 
 <span class="v">AND</span>, <span class="v">OR</span>, <span class="v">NOT</span>, <span class="v">IMPLIES</span>, and <span class="v">IFF</span>.  The ``tautology'' 
 above in traditional notation is this propositional formula in ACL2:</p> 
 
 <pre class="code">(<a href="ACL2____IFF.html">IFF</a> (<a href="ACL2____IMPLIES.html">IMPLIES</a> P (<a href="ACL2____IMPLIES.html">IMPLIES</a> Q R))
     (<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____AND.html">AND</a> P Q) R)).</pre> 
 
 <p>If you have a formula like</p> 
 
 <pre class="code">(implies <i>hyp</i> 
         <i>concl</i>) 
</pre> 
 
 <p>then we say that formula is an <i>implication</i>, that <i>hyp</i> is the 
 <i>hypothesis</i>, and that <i>concl</i> is the conclusion.  If the hypothesis 
 is an <span class="v">and</span> expression, as in</p> 
 
 <pre class="code">(implies (and <i>hyp1</i> 
              <i>hyp2</i> 
              ...) 
         <i>concl</i>) 
</pre> 
 
 <p>then we call <i>hyp1</i> is the <i>first hypothesis</i>, <i>hyp2</i> is the 
 <i>second hypothesis</i>, etc.</p> 
 
 <p>If a term is of the form</p> 
 
 <pre class="code">(and <i>term1</i> <i>term2</i> ...) 
</pre> 
 
 <p>we say it is a <i>conjunction</i> and that <i>term1</i> is the <i>first 
 conjunct</i>, <i>term2</i> is the <i>second conjunct</i>, etc.  We treat an 
 <span class="v">or</span>-term analogously but call it a <i>disjunction</i> and its arguments 
 are <i>disjuncts</i>.</p> 
 
 <p>A <i>tautology</i> is any propositional formula that can be proved by 
 testing it under all combinations of Boolean assignments to its variables.  We 
 give an example of such a <i>truth-table proof</i> below, but hasten to add 
 that ACL2 does not generally use truth tables to recognize tautologies.  It 
 primarily uses <a href="ACL2____NORMALIZATION.html">normalization</a> and BDDs to recognize tautologies, which 
 can be seen as a mix of symbolic manipulation and case analysis.</p> 
 
 <p>Many tautologies have names, but ACL2 doesn't refer to them by name because 
 it derives them from first principles.  We list a few here because we 
 sometimes use the names in our documentation; more importantly, you should 
 look at these formulas and convince yourself that they're always true for all 
 Boolean values of the variables:</p> 
 
 <pre class="code"><i>Double Negation</i>: 
(iff (not (not p)) p) 
 
<i>DeMorgan</i>: 
(iff (not (and p q)) 
     (or (not p) (not q))) 
 
<i>Distributivity</i>: 
(iff (and p (or q r)) 
     (or (and p q) 
         (and p r))) 
 
<i>Promotion</i>: 
(iff (implies p (implies q r)) 
     (implies (and p q) r)) 
 
<i>Implicative Disjunction</i>: 
(iff (implies p q) 
     (or (not p) q)) 
 
<i>Contrapositive</i>: 
(iff (implies p q) 
     (implies (not q) (not p))) 
 
<i>Generalized Contrapositive</i>: 
(iff (implies (and p r) q) 
     (implies (and p (not q)) (not r))) 
 
</pre> 
 
 <p>There are, of course, many others, even with these same names!  For 
 example, there is a dual version of DeMorgan showing how <span class="v">not</span> distributes 
 over <span class="v">or</span>, a dual version of Distributivity for <span class="v">or</span> over <span class="v">and</span>, 
 etc.</p> 
 
 <p>Dealing with propositional calculus will not generally be a problem for you 
 because it is decidable and ACL2 has procedures that decide propositional 
 formulas.  However, propositional calculus can lead to exponential explosion 
 and can thus explain why ACL2 has ``gone out to lunch.''  In addition, 
 sometimes if you are curious as to <i>why</i> ACL2 is working on a certain 
 subgoal the reason can be traced back to propositional calculus.</p> 
 
 <p>The most common example of this is that to prove a formula of the form</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____IMPLIES.html">implies</a> p1 q1)
         (<a href="ACL2____IMPLIES.html">implies</a> p2 q2))</pre> 
 
 <p>propositional calculus will convert it to</p> 
 
 <pre class="code">(<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> p2 (<a href="COMMON-LISP____NOT.html">not</a> p1)) q2)
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> p2 q1) q2))</pre> 
 
 <p>Many users are surprised that the first conjunct above does not have 
 <span class="v">q1</span> as a hypothesis.  If you ever stare at an ACL2 goal and say to 
 yourself ``A hypothesis is missing!'' the chances are that propositional 
 calculus is ``to blame.''  In particular, if you are trying to prove that 
 <span class="v">(<a href="ACL2____IMPLIES.html">implies</a> p1 q1)</span> implies something, you must deal with the case that 
 <span class="v">(<a href="ACL2____IMPLIES.html">implies</a> p1 q1)</span> is true because <span class="v">p1</span> is false.  Think about it.</p> 
 
 <p>Now we illustrate the truth table method for deciding tautologies, even 
 though that is not what ACL2 generally uses.  Consider the formula called 
 Promotion above:</p> 
 
 <pre class="code">(<a href="ACL2____IFF.html">IFF</a> (<a href="ACL2____IMPLIES.html">IMPLIES</a> P (<a href="ACL2____IMPLIES.html">IMPLIES</a> Q R))
     (<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____AND.html">AND</a> P Q) R))</pre> 
 
 <p>The formula above is a tautology.  It contains three variables, <span class="v">P</span>, 
 <span class="v">Q</span>, and <span class="v">R</span>, and so there are 8 combinations of Boolean assignments to 
 them.  If we let</p> 
 
 <pre class="code"><i>formula1</i>:  (IMPLIES P (IMPLIES Q R)) 
<i>formula2</i>:  (IMPLIES (AND P Q) R) 
</pre> 
 
 <p>then we wish to test the formula <span class="v">(<a href="ACL2____IFF.html">IFF</a> </span><i>formula1 
 formula2</i><span class="v">)</span>:</p> 
 
 <pre class="code">P   Q   R       <i>formula1</i>   <i>formula2</i>   (IFF <i>formula1</i> <i>formula2</i>) 
--------- 
T   T   T            T         T       T 
T   T   NIL          NIL       NIL     T 
T   NIL T            T         T       T 
T   NIL NIL          T         T       T 
NIL T   T            T         T       T 
NIL T   NIL          T         T       T 
NIL NIL T            T         T       T 
NIL NIL NIL          T         T       T 
</pre> 
 
 <p>So we see that the formula always returns <span class="v">T</span> and is thus a 
 tautology.</p> 
 
 <p>Recall that in the original example at the top of this page we were trying 
 to prove the formula</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____ENDP.html">endp</a> z)
         (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> z)
                  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____REV.html">rev</a> (<a href="ACL2____REV.html">rev</a> z)) z)))</pre> 
 
 <p>This formula is an <a href="ACL2____LOGIC-KNOWLEDGE-TAKEN-FOR-GRANTED-INSTANCE.html">instance</a> of</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> p (<a href="ACL2____IMPLIES.html">implies</a> q r)).</pre> 
 
 <p>The substitution required by the match is</p> 
 
 <pre class="code"><i>sigma</i>: 
((p    (endp z)) 
 (q    (true-listp z)) 
 (r    (equal (rev (rev z)) z))) 
</pre> 
 
 <p>Since we know the tautology:</p> 
 
 <pre class="code">(<a href="ACL2____IFF.html">iff</a> (<a href="ACL2____IMPLIES.html">implies</a> p (<a href="ACL2____IMPLIES.html">implies</a> q r))
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> p q) r)).</pre> 
 
 <p>is always true no matter what Boolean values <span class="v">p</span>, <span class="v">q</span>, and <span class="v">r</span> 
 have, then we know this instance of it (obtained by applying the substitution 
 <i>sigma</i> above) is always true:</p> 
 
 <pre class="code">(iff (implies (endp z)                            <i>formula1'</i> 
              (implies (true-listp z) 
                       (equal (rev (rev z)) z))) 
     (implies (and (endp z)                       <i>formula2'</i> 
                   (true-listp z)) 
              (equal (rev (rev z)) z))). 
</pre> 
 
 <p>Thus, if we're trying to prove <i>formula1'</i> it is permitted to try to 
 to prove <i>formula2'</i> instead, because they return the same 
 truthvalue.</p> 
 
 <p>This sketch of propositional reasoning in ACL2 is a little suspect because 
 we didn't address the possibility that the substitution might replace the 
 propositional variables by non-propositional terms.  But the tautology was 
 verified only on Boolean values for those variables.  This actually works out 
 because in ACL2 all propositional testing is done against <span class="v">nil</span> and any 
 non-<span class="v">nil</span> value, including <span class="v">t</span>, is as good as another.  However, the 
 tautology allows us to replace one formula by the other only in contexts in 
 which we just care about propositional truth, i.e., whether the formula is 
 <span class="v">nil</span> or not.  When we prove a formula in ACL2 we are really establishing 
 that it never returns <span class="v">nil</span>, i.e., no matter what the values of the 
 variables, the value of the formula is non-<span class="v">nil</span>.</p> 
 
 <p>A very simple example of this is with Double Negation.</p> 
 
 <pre class="code">(<a href="ACL2____IFF.html">iff</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____NOT.html">not</a> p)) p)</pre> 
 
 <p>is a tautology.  This means that if we were trying to prove</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____NOT.html">not</a> p)) ...)</pre> 
 
 <p>we could transform it to</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> p ...).</pre> 
 
 <p>But if we were trying to prove:</p> 
 
 <pre class="code">(<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____NOT.html">not</a> p)) p)</pre> 
 
 <p>we could not prove it by using Double Negation!  The formula above claims 
 that <span class="v">(<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____NOT.html">not</a> p))</span> and <span class="v">p</span> have identical values.  They do not!  For 
 example, <span class="v">(<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____NOT.html">not</a> 3))</span> is <span class="v">t</span>, not <span class="v">3</span>.  However, <span class="v">(<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____NOT.html">not</a>
 3))</span> and <span class="v">t</span> are propositionally equivalent (i.e., satisfy <span class="v">iff</span>) 
 because one is as good as the other in a test.  <i>That</i> is what Double 
 Negation says.</p> 
 
 <p>As long as you only use propositional formulas in propositional places this 
 aspect of ACL2 should not affect you.</p> 
 
 <p>Now please use your browser's <b>Back Button</b> to return to the example 
 proof in <a href="ACL2____LOGIC-KNOWLEDGE-TAKEN-FOR-GRANTED.html">logic-knowledge-taken-for-granted</a>.</p>
</body>
</html>
