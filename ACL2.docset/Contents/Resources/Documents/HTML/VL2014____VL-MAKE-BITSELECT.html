<html>
<head>
<meta charset="UTF-8">
<title>Vl-make-bitselect</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=VL2014____VL-MAKE-BITSELECT">Click for Vl-make-bitselect in the Full Manual</a></h3>

<p>Safely create the bit-select <span class="v">expr[n]</span>.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(vl-make-bitselect expr n) → expr[n]</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">expr</span> — Should be an sized identifier.<br>    <font color="#606060">Guard <span class="v">(<a href="VL2014____VL-EXPR-P.html">vl-expr-p</a> expr)</span>.</font>
</dd> 
  <dd>
<span class="tt">n</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____NATP.html">natp</a> n)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">expr[n]</span> — <font color="#606060">Type <span class="v">(<a href="VL2014____VL-EXPR-P.html">vl-expr-p</a> expr[n])</span>.</font>
</dd> 
 
</dl></div> 
<p>Historic note.  We used to (incorrectly) check whether N was less 
than the final-width of the expression, and also optimize so that when FOO had 
width 1, we would create FOO instead of FOO[0].  This did not cause problems 
since this function was only used in occform (where the wires we were 
generating always started at index 0), but is more generally incorrect since a 
wire's finalwidth need not be related to the valid bits that can be selected 
from it, e.g., wire [7:5] w; should allow us to select w[7], w[6], and w[5], 
but the width of w is only 2.</p> 
 
<p>We no longer try to do any bounds-checking here, since it is really not 
possible to do it correctly without knowing the bounds of the wire, which is 
not available to us here.  You can hence use this function to create an invalid 
expression like foo[n]; garbage in, garbage out.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>vl-make-bitselect</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 vl-make-bitselect (expr n)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="VL2014____VL-EXPR-P.html">vl-expr-p</a> expr) (<a href="ACL2____NATP.html">natp</a> n))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((__function__ 'vl-make-bitselect))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
  (<a href="ACL2____B_A2.html">b*</a>
     (((unless (vl-fast-atom-p expr))
       (<a href="ACL2____RAISE.html">raise</a> "Trying to select from non-atom: ~x0."
              expr)
       |*sized-1'b0*|)
      ((unless (<a href="ACL2____POSP.html">posp</a> (<a href="VL2014____VL-EXPR-_E3FINALWIDTH.html">vl-expr-&gt;finalwidth</a> expr)))
       (<a href="ACL2____RAISE.html">raise</a> "Trying to select from unwidthed expr: ~x0"
              expr)
       |*sized-1'b0*|)
      (guts (<a href="VL2014____VL-ATOM-_E3GUTS.html">vl-atom-&gt;guts</a> expr))
      ((unless (<a href="VL2014____VL-ID-P.html">vl-id-p</a> guts))
       (<a href="ACL2____RAISE.html">raise</a> "Not implemented: bitselect from ~x0."
              (<a href="ACL2____TAG.html">tag</a> guts))
       |*sized-1'b0*|))
     (<a href="ACL2____HONS-COPY.html">hons-copy</a>
          (<a href="VL2014____MAKE-VL-NONATOM.html">make-vl-nonatom</a> :op :vl-bitselect
                           :args (acl2::hons-list (<a href="VL2014____VL-EXPR-FIX.html">vl-expr-fix</a> expr)
                                                  (<a href="VL2014____VL-MAKE-INDEX.html">vl-make-index</a> n))
                           :finalwidth 1
                           :finaltype :vl-unsigned)))))</pre> 
<p><b>Theorem: </b>vl-expr-p-of-vl-make-bitselect</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> vl-expr-p-of-vl-make-bitselect
        (<a href="ACL2____B_A2.html">b*</a> ((expr[n] (<a href="VL2014____VL-MAKE-BITSELECT.html">vl-make-bitselect</a> expr n)))
            (<a href="VL2014____VL-EXPR-P.html">vl-expr-p</a> expr[n]))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>vl-expr-&gt;finalwidth-of-vl-make-bitselect</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> vl-expr-&gt;finalwidth-of-vl-make-bitselect
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="VL2014____VL-EXPR-_E3FINALWIDTH.html">vl-expr-&gt;finalwidth</a> (<a href="VL2014____VL-MAKE-BITSELECT.html">vl-make-bitselect</a> expr n))
               1))</pre> 
<p><b>Theorem: </b>vl-expr-&gt;finaltype-of-vl-make-bitselect</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> vl-expr-&gt;finaltype-of-vl-make-bitselect
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="VL2014____VL-EXPR-_E3FINALTYPE.html">vl-expr-&gt;finaltype</a> (<a href="VL2014____VL-MAKE-BITSELECT.html">vl-make-bitselect</a> expr n))
               :vl-unsigned))</pre> 
<p><b>Theorem: </b>vl-make-bitselect-of-vl-expr-fix-expr</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> vl-make-bitselect-of-vl-expr-fix-expr
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="VL2014____VL-MAKE-BITSELECT.html">vl-make-bitselect</a> (<a href="VL2014____VL-EXPR-FIX.html">vl-expr-fix</a> expr) n)
               (<a href="VL2014____VL-MAKE-BITSELECT.html">vl-make-bitselect</a> expr n)))</pre> 
<p><b>Theorem: </b>vl-make-bitselect-vl-expr-equiv-congruence-on-expr</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> vl-make-bitselect-vl-expr-equiv-congruence-on-expr
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="VL2014____VL-EXPR-EQUIV.html">vl-expr-equiv</a> expr expr-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="VL2014____VL-MAKE-BITSELECT.html">vl-make-bitselect</a> expr n)
                        (<a href="VL2014____VL-MAKE-BITSELECT.html">vl-make-bitselect</a> expr-equiv n)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>vl-make-bitselect-of-nfix-n</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> vl-make-bitselect-of-nfix-n
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="VL2014____VL-MAKE-BITSELECT.html">vl-make-bitselect</a> expr (<a href="ACL2____NFIX.html">nfix</a> n))
               (<a href="VL2014____VL-MAKE-BITSELECT.html">vl-make-bitselect</a> expr n)))</pre> 
<p><b>Theorem: </b>vl-make-bitselect-nat-equiv-congruence-on-n</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> vl-make-bitselect-nat-equiv-congruence-on-n
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____NAT-EQUIV.html">acl2::nat-equiv</a> n n-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="VL2014____VL-MAKE-BITSELECT.html">vl-make-bitselect</a> expr n)
                        (<a href="VL2014____VL-MAKE-BITSELECT.html">vl-make-bitselect</a> expr n-equiv)))
        :rule-classes :congruence)</pre> 

</body>
</html>
