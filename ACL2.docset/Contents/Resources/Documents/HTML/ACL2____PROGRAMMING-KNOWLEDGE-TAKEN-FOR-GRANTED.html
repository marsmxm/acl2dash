<html>
<head>
<meta charset="UTF-8">
<title>Programming-knowledge-taken-for-granted</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____PROGRAMMING-KNOWLEDGE-TAKEN-FOR-GRANTED">Click for Programming-knowledge-taken-for-granted in the Full Manual</a></h3>

<p>Background knowledge in ACL2 programming for theorem prover tutorial</p><p>This brief review of the programming language is presented as a 
 sequence of questions and answers meant to test your knowledge of the ACL2 
 programming language.  If you want a gentle introduction to the programming 
 language, see <a href="http://www.cs.utexas.edu/users/moore/publications/gentle-intro-to-acl2-programming.html" target="_blank"><nobr>http://www.cs.utexas.edu/users/moore/publications/gentle-intro-to-acl2-programming.html<img src="../Icon_External_Link.png" title="External link to http://www.cs.utexas.edu/users/moore/publications/gentle-intro-to-acl2-programming.html"></nobr></a>.</p> 
 
 <p>Before we get started with the programming drill, let us remind you that 
 all we're interested in here is the language, not the ``program development 
 environment.''  It's impossible to program in ACL2 or any other language 
 without a decent environment, one that at the very least includes a way to 
 prepare and edit files of programs.  The two most popular program development 
 environments among ACL2 users are <a href="ACL2____EMACS.html">Emacs</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a> and 
 the Eclipse-based <a href="ACL2____ACL2-SEDAN.html">ACL2-Sedan</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a>. 
 The Sedan provides the most support for the new user, including real-time 
 syntax checking and a facility for testing among many other features.  But in 
 this drill we're not interested in the program development environment, we're 
 interested in your understanding of the ACL2 language.</p> 
 
 <p><b>Q</b>: What do you think this command does?</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> rev (x)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ENDP.html">endp</a> x)
      nil
      (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="ACL2____REV.html">rev</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x)) (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CAR.html">car</a> x)))))</pre> 
 
 <p><b>A</b>: It defines a function named <span class="v">rev</span> that takes one argument, 
 treats it like a list, and reverses the order of the elements in that list. 
 To figure this out from the definition, you have to know that <span class="v">append</span> 
 concatenates two lists.  Logically speaking, the <span class="v">defun</span> of <span class="v">rev</span> adds 
 the axiom:</p> 
 
 <pre class="code">(<a href="ACL2____REV.html">rev</a> x)
=
(<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ENDP.html">endp</a> x)
    nil
    (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="ACL2____REV.html">rev</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x)) (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CAR.html">car</a> x)))),</pre> 
 
 <p>implicitly quantified for all <span class="v">x</span>.</p> 
 
 <p><b>Q</b>: Given the <span class="v">defun</span> of <span class="v">rev</span> above, what are the <i>formal 
 parameters</i>?  What is the <i>body</i> of the definition?  Write down a 
 <i>call</i> of <i>append</i> that occurs in the body of <span class="v">rev</span>.  What are 
 the <i>actuals</i> of that call?  <b>A</b>: The <i>formals</i> of <span class="v">rev</span> is 
 the list of variables after the first <span class="v">rev</span> in the <span class="v">defun</span>, namely 
 <span class="v">(x)</span>.  We say <span class="v">x</span> is the first (and only) <i>formal</i> here.  The 
 <i>body</i> of <span class="v">rev</span> is the entire <span class="v">if</span>-expression.  The only 
 <i>call</i> of <span class="v">append</span> in the body is</p> 
 
 <pre class="code">(<a href="COMMON-LISP____APPEND.html">append</a> (<a href="ACL2____REV.html">rev</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x)) (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CAR.html">car</a> x)))</pre> 
 
 <p>and the <i>actuals</i> of that call are, respectively, <span class="v">(<a href="ACL2____REV.html">rev</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x))</span> 
 and <span class="v">(<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CAR.html">car</a> x))</span>.</p> 
 
 <p><b>Q</b>: What do you get if you evaluate <span class="v">(<a href="ACL2____REV.html">rev</a> '(a b c d))</span>?  <b>A</b>: 
 <span class="v">(D C B A)</span>.</p> 
 
 <p><b>Q</b>: How did <span class="v">rev</span> change the case of the elements, e.g., lowercase 
 <span class="v">a</span> was in the input list but uppercase <span class="v">A</span> was in the output? 
 <b>A</b>: This is a trick question.  <span class="v">Rev</span> doesn't change the case of the 
 elements.  ACL2 is case-insensitive when dealing with symbols.  The symbol 
 <span class="v">a</span> is read in as the symbol <span class="v">A</span>.  Thus, when writing function names, 
 for example, we can write <span class="v">rev</span>, <span class="v">Rev</span>, <span class="v">REV</span>, or even <span class="v">ReV</span> and 
 always be referring to the function <span class="v">REV</span>.  By default, ACL2 prints symbols 
 in uppercase.</p> 
 
 <p><b>Q</b>: What does <span class="v">(<a href="ACL2____REV.html">rev</a> '((a b c) "Abc" "a" b #\c))</span> return? 
 <b>A</b>: <span class="v">(#\c B "a" "Abc" (A B C))</span>.  If you thought the answer was 
 either of these, then you need to think or read more carefully:</p> 
 
 <pre class="code">(#\C B "A" "ABC" (A B C))

(#\c B "a" "Abc" (C B A))</pre> 
 
 <p>The first wrong answer above is wrong because Lisp is ``case insensitive'' 
 only for symbols, not for character objects like <span class="v">#\c</span> (the lowercase 
 character c) or for strings.  Furthermore, <span class="v">"A"</span> is a string, not a 
 symbol; it is different from <span class="v">A</span>.  The second wrong answer above is wrong 
 because <span class="v">rev</span> does not go into the individual elements of the list, it just 
 reverses the order of the elements.  So it doesn't change the element <span class="v">(A B
 C)</span> to <span class="v">(C B A)</span>.</p> 
 
 <p><b>Q</b>: In the question about what <span class="v">(<a href="ACL2____REV.html">rev</a> '(a b c d))</span> returns, we put 
 a quote mark before the <span class="v">(a b c d)</span> but not before the answer, <span class="v">(D C B
 A)</span>.  Why?  <b>A</b>: The phrase ``<i>x</i> evaluates to <i>y</i>'' treats 
 <i>x</i> as a <i>term</i> to be evaluated and <i>y</i> as an <i>object</i>. 
 <span class="v">(<a href="ACL2____REV.html">Rev</a> '(a b c d))</span> is a term to be evaluated and denotes a call of the 
 function <span class="v">rev</span> on the value of the argument term <span class="v">'(a b c d)</span>.  The 
 value of that argument term is the object <span class="v">(a b c d)</span>.  The value of the 
 call of <span class="v">rev</span> is the object <span class="v">(d c b a)</span>.  If you have an object, 
 <i>obj</i>, and you wish to create a term whose value is <i>obj</i>, then you 
 put a quote mark in front of it, <i>'obj</i>.</p> 
 
 <p><b>Q</b>: Can <span class="v">rev</span> be applied to something other than a list? 
 <b>A</b>: Yes, every ACL2 function can be applied to any object.  ACL2 is an 
 untyped programming language: every variable ranges over the entire universe 
 of objects.  In normal usage, <span class="v">rev</span> is applied to lists but there is 
 nothing about the syntax of the language that prevents it being applied to 
 non-lists.</p> 
 
 <p><b>Q</b>: So what does <span class="v">(<a href="ACL2____REV.html">rev</a> 23)</span> evaluate to?  <b>A</b>: <span class="v">Nil</span>.</p> 
 
 <p><b>Q</b>: Why?  <b>A</b>: Because <span class="v">(<a href="COMMON-LISP____ENDP.html">endp</a> 23)</span> is <span class="v">t</span>, because 
 <span class="v">endp</span> is defined:</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> endp (x) (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x)))</pre> 
 
 <p>Thus, if <span class="v">rev</span> is applied to anything that is not a cons, it returns 
 <span class="v">nil</span>.</p> 
 
 <p><b>Q</b>: So what does <span class="v">(<a href="ACL2____REV.html">rev</a> '(a b c . d))</span> evaluate to?  <b>A</b>: 
 <span class="v">(c b a)</span>.  To explain why requires demonstrating that you know what <span class="v">(a
 b c . d)</span> means.  It is the object computed by evaluating:</p> 
 
 <pre class="code">(<a href="COMMON-LISP____CONS.html">cons</a> 'a
      (<a href="COMMON-LISP____CONS.html">cons</a> 'b
            (<a href="COMMON-LISP____CONS.html">cons</a> 'c
                  'd))).</pre> 
 
 <p>That is, it is a list whose ``terminal marker'' is the atom <span class="v">D</span>. 
 <span class="v">Rev</span> treats that list exactly as it treats the <span class="v">nil</span>-terminated list of 
 the same elements, <span class="v">(a b c)</span>, because <span class="v">(<a href="COMMON-LISP____ENDP.html">endp</a> 'D)</span> = <span class="v">(<a href="COMMON-LISP____ENDP.html">endp</a> nil)</span> = 
 <span class="v">t</span>.</p> 
 
 <p><b>Q</b>: What does <span class="v">(<a href="ACL2____REV.html">rev</a> 1 2 3)</span> evaluate to?  <b>A</b>: That's a trick 
 question.  <span class="v">Rev</span> takes one argument, not three.  So <span class="v">(<a href="ACL2____REV.html">rev</a> 1 2 3)</span> is an 
 ill-formed term.</p> 
 
 <p><b>Q</b>: What does <span class="v">(<a href="ACL2____REV.html">rev</a> '(a b c . d . nil))</span> evaluate to?  <b>A</b>: 
 That is a trick question.  There is no such object.  In Lisp's ``dot 
 notation'' every dot must be followed by a well-formed object and then a close 
 parenthesis.  Usually that ``well-formed object'' is an atom.  If it is not an 
 atom, i.e., if it is a cons, then the entire expression could have been 
 written without that dot.  For example, <span class="v">(a b c . (d e))</span> is an object, but 
 it could be written <span class="v">(a b c d e)</span>.</p> 
 
 <p><b>Q</b>: Do <span class="v">(<a href="ACL2____REV.html">rev</a> (<a href="ACL2____REV.html">rev</a> x))</span> and <span class="v">x</span> always evaluate to the same 
 object?  <b>A</b>: No.  <span class="v">(<a href="ACL2____REV.html">Rev</a> (<a href="ACL2____REV.html">rev</a> 23))</span> evaluates to <span class="v">nil</span>, not 
 <span class="v">23</span>.</p> 
 
 <p><b>Q</b>: Do <span class="v">(<a href="ACL2____REV.html">rev</a> (<a href="ACL2____REV.html">rev</a> x))</span> and <span class="v">x</span> always evaluate to the same 
 object when <span class="v">x</span> is a cons?  <b>A</b>: No.  <span class="v">(<a href="ACL2____REV.html">rev</a> (<a href="ACL2____REV.html">rev</a> '(a b c . d)))</span> 
 evaluates to <span class="v">(a b c)</span>, not <span class="v">(a b c . d)</span>.</p> 
 
 <p><b>Q</b>: When are <span class="v">(<a href="ACL2____REV.html">rev</a> (<a href="ACL2____REV.html">rev</a> x))</span> and <span class="v">x</span> equal?  <b>A</b>: When the 
 terminal marker of <span class="v">x</span> is <span class="v">nil</span>.</p> 
 
 <p><b>Q</b>: Can you define a Lisp function that recognizes 
 <span class="v">nil</span>-terminated lists?  <b>A</b>: Yes, but it is not necessary for the 
 user to define that concept because Common Lisp provides such a function which 
 is logically defined as follows:</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> true-listp (x)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x)
      (<a href="ACL2____TRUE-LISTP.html">true-listp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x))
      (<a href="COMMON-LISP____EQUAL.html">equal</a> x nil))).</pre> 
 
 <p>This can be paraphrased: <span class="v">(<a href="ACL2____TRUE-LISTP.html">true-listp</a> x)</span> means that if <span class="v">x</span> is a 
 <span class="v">cons</span>, its <span class="v">cdr</span> is a <span class="v">true-listp</span> and if <span class="v">x</span> is not a <span class="v">cons</span>, 
 it must be <span class="v">nil</span>.  Thus, <span class="v">(<a href="ACL2____TRUE-LISTP.html">true-listp</a> '(a b c))</span> is <span class="v">t</span> and 
 <span class="v">(<a href="ACL2____TRUE-LISTP.html">true-listp</a> '(a b c . d))</span> is <span class="v">nil</span>.</p> 
 
 <p><b>Q</b>: Can you write a Lisp formula that says ``If <span class="v">z</span> is a 
 <span class="v">nil</span>-terminated list then reversing the result of reversing <span class="v">z</span> is 
 <span class="v">z</span>''?</p> 
 
 <p><b>A</b>: Yes:</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> z)
         (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____REV.html">rev</a> (<a href="ACL2____REV.html">rev</a> z)) z)).</pre> 
 
 <p><b>Q</b>: Is this all there is to ACL2 programming?  <b>A</b>: No!  ACL2 
 provides many other features.  For a full list of all the primitive functions 
 in ACL2 see <a href="ACL2____PROGRAMMING.html">programming</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a>. 
 Some highlights for the beginner are mentioned below, but all of the links 
 below ought to be tagged with the <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a> 
 sign.</p> 
 
 <p>* <span class="tt"><a href="COMMON-LISP____LIST.html">list</a></span>: build a <span class="v">nil</span>-terminated list from the values of 
 <i>n</i> terms, e.g., <span class="v">(<a href="COMMON-LISP____LIST.html">list</a> x (<a href="COMMON-LISP_____B2.html">+</a> 1 x) (<a href="COMMON-LISP_____B2.html">+</a> 2 x))</span> returns <span class="v">(3 4 5)</span> if 
 <span class="v">x</span> is <span class="v">3</span>.</p> 
 
 <p>* <a href="COMMON-LISP____LIST_A2.html">list*</a>: build a non-<span class="v">nil</span> terminated list of <i>n</i> objects 
 from the values of <i>n+1</i> terms, e.g., <span class="v">(<a href="COMMON-LISP____LIST_A2.html">list*</a> x (<a href="COMMON-LISP_____B2.html">+</a> 1 x) (<a href="COMMON-LISP_____B2.html">+</a> 2 x) (<a href="COMMON-LISP_____A2.html">*</a> -1
 x))</span> returns the list <span class="v">(3 4 5 . -3)</span> if <span class="v">x</span> is <span class="v">3</span>.</p> 
 
 <p>* <span class="tt"><a href="COMMON-LISP____AND.html">and</a></span>, <span class="tt"><a href="COMMON-LISP____OR.html">or</a></span>, <span class="tt"><a href="COMMON-LISP____NOT.html">not</a></span>, <span class="tt"><a href="ACL2____IMPLIES.html">implies</a></span>, <span class="tt"><a href="ACL2____IFF.html">iff</a></span>: The 
 propositional connectives.  <span class="v">And</span> and <span class="v">or</span> are allowed to take a varying 
 number of arguments, e.g., <span class="v">(<a href="COMMON-LISP____AND.html">and</a> p q r)</span> is just an abbreviation for 
 <span class="v">(<a href="COMMON-LISP____AND.html">and</a> p (<a href="COMMON-LISP____AND.html">and</a> q r))</span>.  In Lisp, <span class="v">and</span> returns <span class="v">nil</span> if any of its 
 arguments evaluates to <span class="v">nil</span>; otherwise it returns the value of the last 
 argument!  Thus, <span class="v">(<a href="COMMON-LISP____AND.html">and</a> t t 3)</span> returns <span class="v">3</span>!  If you object to the idea 
 that <span class="v">and</span> is not Boolean, don't give it non-Boolean arguments!  Similarly, 
 <span class="v">or</span> returns the value of the first argument that evaluates to 
 non-<span class="v">nil</span>, or <span class="v">nil</span> if they all evaluate to <span class="v">nil</span>.  Both <span class="v">and</span> and 
 <span class="v">or</span> can be thought of as ``lazy'' in that they don't always have to 
 evaluate all their arguments.  This is really accomplished by treating 
 <span class="v">and</span> and <span class="v">or</span> as abbreviations for <span class="v">if</span> nests.</p> 
 
 <p>* <span class="tt"><a href="COMMON-LISP_____B2.html">+</a></span>, <span class="tt"><a href="COMMON-LISP_____A2.html">*</a></span>, <span class="tt"><a href="COMMON-LISP____-.html">-</a></span>, <span class="tt"><a href="COMMON-LISP_____F2.html">/</a></span>, <span class="tt"><a href="COMMON-LISP____FLOOR.html">floor</a></span>, <span class="tt"><a href="COMMON-LISP____MOD.html">mod</a></span>, 
 <span class="tt"><a href="COMMON-LISP_____C3.html">&lt;</a></span>, <span class="tt"><a href="COMMON-LISP_____C3_D3.html">&lt;=</a></span>, <span class="tt"><a href="COMMON-LISP_____E3_D3.html">&gt;=</a></span>, <span class="tt"><a href="COMMON-LISP_____E3.html">&gt;</a></span>: the Lisp elementary arithmetic 
 operators.  Both <span class="v">+</span> and <span class="v">*</span> allow varying numbers of arguments.  All 
 the arithmetic operators default non-numeric arguments to <span class="v">0</span>.  If you 
 don't like the idea that <span class="v">(<a href="COMMON-LISP_____B2.html">+</a> 1 2 t)</span> is <span class="v">3</span>, don't ask <span class="v">+</span> to add 
 <span class="v">t</span> to something!</p> 
 
 <p>* <span class="tt"><a href="ACL2____NATP.html">natp</a></span>, <span class="tt"><a href="COMMON-LISP____INTEGERP.html">integerp</a></span>, <span class="tt"><a href="COMMON-LISP____RATIONALP.html">rationalp</a></span>, <span class="tt"><a href="COMMON-LISP____CHARACTERP.html">characterp</a></span>, 
 <span class="tt"><a href="COMMON-LISP____STRINGP.html">stringp</a></span>, <span class="tt"><a href="COMMON-LISP____SYMBOLP.html">symbolp</a></span>, <span class="tt"><a href="COMMON-LISP____CONSP.html">consp</a></span>: the recognizers for the 
 primitive data types.  The first three recognize subsets of the ACL2 numeric 
 universe.  The naturals are a subset of the integers, the integers are a 
 subset of the rationals, and the rationals are a subset of the objects 
 recognized by <span class="tt"><a href="ACL2____ACL2-NUMBERP.html">ACL2-numberp</a></span>, which also includes the <span class="tt"><a href="ACL2____COMPLEX-RATIONALP.html">complex-rationalp</a></span>s.  The other recognizers listed above recognize characters, 
 strings, symbols, and conses.</p> 
 
 <p>* <span class="tt"><a href="COMMON-LISP____COND.html">cond</a></span>: a convenient way to write a cascading nest of <span class="v">if</span>s, 
 e.g.,</p> 
 
 <pre class="code">(<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____NATP.html">natp</a> x)) 'non-natural)
      ((<a href="COMMON-LISP____EQUAL.html">equal</a> x 0) 'zero)
      ((<a href="COMMON-LISP____EVENP.html">evenp</a> x) 'positive-even)
      (t 'positive-odd))</pre> 
 
 <p>abbreviates</p> 
 
 <pre class="code">(<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____NATP.html">natp</a> x))
    'non-natural
    (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> x 0)
        'zero
        (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EVENP.html">evenp</a> x)
            'positive-even
            'positive-odd))).</pre> 
 
 <p>* <span class="tt"><a href="COMMON-LISP____CASE.html">case</a></span>: a convenient way to case split on the identity of an 
 object.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____CASE.html">case</a> key
  (non-natural -1)
  (zero 0)
  ((positive-even positive-odd) 'positive-natural)
  (otherwise 'unknown))</pre> 
 
 <p>abbreviates</p> 
 
 <pre class="code">(<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____EQL.html">eql</a> key 'non-natural) -1)
      ((<a href="COMMON-LISP____EQL.html">eql</a> key 'zero) 0)
      ((<a href="COMMON-LISP____MEMBER.html">member</a> key '(positive-even positive-odd))
       'positive-natural)
      (t 'unknown)).</pre> 
 
 <p>* user defined macros: using <span class="tt"><a href="COMMON-LISP____DEFMACRO.html">defmacro</a></span> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a> 
 you can introduce your own abbreviations.  We recommend you not do this until 
 you're good at list processing since macros are functions that build objects 
 representing terms.</p> 
 
 <p>* <span class="tt"><a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a></span>: allows you to define mutually-recursive 
 functions.</p> 
 
 <p>* <span class="tt"><a href="ACL2____MV.html">mv</a></span> and <span class="tt"><a href="ACL2____MV-LET.html">mv-let</a></span>: allow functions to return 
 ``multiple-values''.  In Lisp, such functions return vectors of values, the 
 vectors are represented as lists of values, but the implementations are 
 generally more efficient.  For example, <span class="v">(<a href="ACL2____MV.html">mv</a> x y z)</span> returns a ``vector'' 
 consisting of the values of <span class="v">x</span>, <span class="v">y</span>, and <span class="v">z</span>.</p> 
 
 <pre class="code">(<a href="ACL2____MV-LET.html">mv-let</a> (a b c)
        (foo x)
        (bar a b c x))</pre> 
 
 <p>evaluates <span class="v">(foo x)</span>, treats the result as a vector of three values, 
 binds the variables <span class="v">a</span>, <span class="v">b</span>, and <span class="v">c</span> to those three values, and 
 evaluates and returns <span class="v">(bar a b c x)</span>.</p> 
 
 <p>ACL2 also provides many other features, such as single-threaded objects 
 which may be ``destructively modified'' (see <a href="ACL2____STOBJ.html">stobj</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a>, 
 including a very special single-threaded object that records the <span class="tt"><a href="ACL2____STATE.html">state</a></span> 
 <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a> of the ACL2 system), file input and output (see 
 <a href="ACL2____IO.html">io</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a>), applicative arrays (see <a href="ACL2____ARRAYS.html">arrays</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a>) 
 and property lists (see <a href="ACL2____GETPROP.html">getprop</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a>) 
 and other facilities necessary for it to be a practical programming language. 
 However, we <b>strongly</b> recommend that as a new user you stay away from 
 these features until you are good at proving theorems about elementary list 
 processing!</p> 
 
 <p>If this little drill made sense to you, you know enough of the programming 
 language to get started. Use your browser's <b>Back Button</b> now to return 
 to <a href="ACL2____INTRODUCTION-TO-THE-THEOREM-PROVER.html">introduction-to-the-theorem-prover</a>.</p> 
 
 <p>If you are uncomfortable with ACL2 programming, we recommend that you study 
 <a href="http://www.cs.utexas.edu/users/moore/publications/gentle-intro-to-acl2-programming.html" target="_blank"><nobr>http://www.cs.utexas.edu/users/moore/publications/gentle-intro-to-acl2-programming.html<img src="../Icon_External_Link.png" title="External link to http://www.cs.utexas.edu/users/moore/publications/gentle-intro-to-acl2-programming.html"></nobr></a> 
 and <a href="http://www.cs.utexas.edu/users/moore/publications/acl2-programming-exercises1.html" target="_blank"><nobr>http://www.cs.utexas.edu/users/moore/publications/acl2-programming-exercises1.html<img src="../Icon_External_Link.png" title="External link to http://www.cs.utexas.edu/users/moore/publications/acl2-programming-exercises1.html"></nobr></a>.</p> 
 
 <p>However, we strongly recommend that you first invest in learning either the 
 <a href="ACL2____EMACS.html">Emacs</a> or Eclipse-based <a href="ACL2____ACL2-SEDAN.html">ACL2-Sedan</a> program development 
 environments, since it is foolish to try to learn how to program in a 
 stand-alone read-eval-print loop!</p> 
 
 <p>While getting started, many users find the Hyper-Card a handy index into 
 the documentation for the ACL2 language:</p> 
 
 <p><a href="http://www.cs.utexas.edu/users/moore/publications/hyper-card.html" target="_blank"><nobr>http://www.cs.utexas.edu/users/moore/publications/hyper-card.html<img src="../Icon_External_Link.png" title="External link to http://www.cs.utexas.edu/users/moore/publications/hyper-card.html"></nobr></a></p> 
 
 <p>Once you are comfortable with the ACL2 programming language, use your 
 browser's <b>Back Button</b> to return to <a href="ACL2____INTRODUCTION-TO-THE-THEOREM-PROVER.html">introduction-to-the-theorem-prover</a>.</p>
</body>
</html>
