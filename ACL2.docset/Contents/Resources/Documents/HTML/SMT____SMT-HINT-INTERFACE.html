<html>
<head>
<meta charset="UTF-8">
<title>Smt-hint-interface</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=SMT____SMT-HINT-INTERFACE">Click for Smt-hint-interface in the Full Manual</a></h3>

<p>Define default Smtlink hint interface</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>pseudo-term-fix</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> pseudo-term-fix (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> x)))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'pseudo-term-fix))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> x) x nil)
                 :exec x)))</pre> 
<p><b>Theorem: </b>pseudo-termp-of-pseudo-term-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-termp-of-pseudo-term-fix
        (<a href="ACL2____B_A2.html">b*</a> ((fixed (pseudo-term-fix x)))
            (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> fixed))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>equal-fixed-and-x-of-pseudo-termp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-fixed-and-x-of-pseudo-termp
        (<a href="ACL2____B_A2.html">b*</a> ((fixed (pseudo-term-fix x)))
            (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> x)
                     (<a href="COMMON-LISP____EQUAL.html">equal</a> fixed x)))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>pseudo-term-fix-idempotent-lemma</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-fix-idempotent-lemma
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (pseudo-term-fix (pseudo-term-fix x))
               (pseudo-term-fix x)))</pre> 
<p><b>Function: </b>pseudo-term-equiv$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> pseudo-term-equiv$inline
       (acl2::x acl2::y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> acl2::x)
                                   (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> acl2::y))))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (pseudo-term-fix acl2::x)
              (pseudo-term-fix acl2::y)))</pre> 
<p><b>Theorem: </b>pseudo-term-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (pseudo-term-equiv x y))
             (pseudo-term-equiv x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (pseudo-term-equiv x y)
                      (pseudo-term-equiv y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (pseudo-term-equiv x y)
                           (pseudo-term-equiv y z))
                      (pseudo-term-equiv x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>pseudo-term-equiv-implies-equal-pseudo-term-fix-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-equiv-implies-equal-pseudo-term-fix-1
        (<a href="ACL2____IMPLIES.html">implies</a> (pseudo-term-equiv acl2::x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (pseudo-term-fix acl2::x)
                        (pseudo-term-fix x-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>pseudo-term-fix-under-pseudo-term-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-fix-under-pseudo-term-equiv
        (pseudo-term-equiv (pseudo-term-fix acl2::x)
                           acl2::x)
        :rule-classes (:rewrite :rewrite-quoted-constant))</pre> 
<p><b>Theorem: </b>equal-of-pseudo-term-fix-1-forward-to-pseudo-term-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-pseudo-term-fix-1-forward-to-pseudo-term-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (pseudo-term-fix acl2::x)
                        acl2::y)
                 (pseudo-term-equiv acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>equal-of-pseudo-term-fix-2-forward-to-pseudo-term-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-pseudo-term-fix-2-forward-to-pseudo-term-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> acl2::x (pseudo-term-fix acl2::y))
                 (pseudo-term-equiv acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>pseudo-term-equiv-of-pseudo-term-fix-1-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-equiv-of-pseudo-term-fix-1-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (pseudo-term-equiv (pseudo-term-fix acl2::x)
                                    acl2::y)
                 (pseudo-term-equiv acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>pseudo-term-equiv-of-pseudo-term-fix-2-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     pseudo-term-equiv-of-pseudo-term-fix-2-forward
     (<a href="ACL2____IMPLIES.html">implies</a> (pseudo-term-equiv acl2::x (pseudo-term-fix acl2::y))
              (pseudo-term-equiv acl2::x acl2::y))
     :rule-classes :forward-chaining)</pre> 
<p><b>Function: </b>pseudo-term-list-fix</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> pseudo-term-list-fix (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> x)))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'pseudo-term-list-fix))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x)
                            (<a href="COMMON-LISP____CONS.html">cons</a> (pseudo-term-fix (<a href="COMMON-LISP____CAR.html">car</a> x))
                                  (pseudo-term-list-fix (<a href="COMMON-LISP____CDR.html">cdr</a> x)))
                            nil)
                 :exec x)))</pre> 
<p><b>Theorem: </b>pseudo-term-listp-of-pseudo-term-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-listp-of-pseudo-term-list-fix
        (<a href="ACL2____B_A2.html">b*</a> ((new-x (pseudo-term-list-fix x)))
            (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> new-x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>acl2-count-&lt;=-pseudo-term-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> acl2-count-&lt;=-pseudo-term-list-fix
        (<a href="ACL2____B_A2.html">b*</a> ((new-x (pseudo-term-list-fix x)))
            (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> new-x) (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> x)))
        :rule-classes :linear)</pre> 
<p><b>Theorem: </b>equal-pseudo-term-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-pseudo-term-list-fix
        (<a href="ACL2____B_A2.html">b*</a> ((new-x (pseudo-term-list-fix x)))
            (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> x)
                     (<a href="COMMON-LISP____EQUAL.html">equal</a> new-x x)))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>len-equal-pseudo-term-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> len-equal-pseudo-term-list-fix
        (<a href="ACL2____B_A2.html">b*</a> ((new-x (pseudo-term-list-fix x)))
            (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> x)
                     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> new-x) (<a href="ACL2____LEN.html">len</a> x))))
        :rule-classes :linear)</pre> 
<p><b>Theorem: </b>pseudo-term-list-fix-idempotent-lemma</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-list-fix-idempotent-lemma
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (pseudo-term-list-fix (pseudo-term-list-fix x))
               (pseudo-term-list-fix x)))</pre> 
<p><b>Function: </b>pseudo-term-list-equiv$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> pseudo-term-list-equiv$inline
       (acl2::x acl2::y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> acl2::x)
                                   (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> acl2::y))))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (pseudo-term-list-fix acl2::x)
              (pseudo-term-list-fix acl2::y)))</pre> 
<p><b>Theorem: </b>pseudo-term-list-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-list-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (pseudo-term-list-equiv x y))
             (pseudo-term-list-equiv x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (pseudo-term-list-equiv x y)
                      (pseudo-term-list-equiv y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (pseudo-term-list-equiv x y)
                           (pseudo-term-list-equiv y z))
                      (pseudo-term-list-equiv x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>pseudo-term-list-equiv-implies-equal-pseudo-term-list-fix-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-list-equiv-implies-equal-pseudo-term-list-fix-1
        (<a href="ACL2____IMPLIES.html">implies</a> (pseudo-term-list-equiv acl2::x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (pseudo-term-list-fix acl2::x)
                        (pseudo-term-list-fix x-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>pseudo-term-list-fix-under-pseudo-term-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-list-fix-under-pseudo-term-list-equiv
        (pseudo-term-list-equiv (pseudo-term-list-fix acl2::x)
                                acl2::x)
        :rule-classes (:rewrite :rewrite-quoted-constant))</pre> 
<p><b>Function: </b>pseudo-term-list-list-fix</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     pseudo-term-list-list-fix (x)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (pseudo-term-list-listp x)))
     (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'pseudo-term-list-list-fix))
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
          (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x)
                          (<a href="COMMON-LISP____CONS.html">cons</a> (pseudo-term-list-fix (<a href="COMMON-LISP____CAR.html">car</a> x))
                                (pseudo-term-list-list-fix (<a href="COMMON-LISP____CDR.html">cdr</a> x)))
                          nil)
               :exec x)))</pre> 
<p><b>Theorem: </b>pseudo-term-list-listp-of-pseudo-term-list-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-list-listp-of-pseudo-term-list-list-fix
        (<a href="ACL2____B_A2.html">b*</a> ((fixed (pseudo-term-list-list-fix x)))
            (pseudo-term-list-listp fixed))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>pseudo-term-list-list-fix-idempotent-lemma</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    pseudo-term-list-list-fix-idempotent-lemma
    (<a href="COMMON-LISP____EQUAL.html">equal</a> (pseudo-term-list-list-fix (pseudo-term-list-list-fix x))
           (pseudo-term-list-list-fix x)))</pre> 
<p><b>Function: </b>pseudo-term-list-list-equiv$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     pseudo-term-list-list-equiv$inline
     (acl2::x acl2::y)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (pseudo-term-list-listp acl2::x)
                                 (pseudo-term-list-listp acl2::y))))
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (pseudo-term-list-list-fix acl2::x)
            (pseudo-term-list-list-fix acl2::y)))</pre> 
<p><b>Theorem: </b>pseudo-term-list-list-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-list-list-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (pseudo-term-list-list-equiv x y))
             (pseudo-term-list-list-equiv x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (pseudo-term-list-list-equiv x y)
                      (pseudo-term-list-list-equiv y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (pseudo-term-list-list-equiv x y)
                           (pseudo-term-list-list-equiv y z))
                      (pseudo-term-list-list-equiv x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>pseudo-term-list-list-equiv-implies-equal-pseudo-term-list-list-fix-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 pseudo-term-list-list-equiv-implies-equal-pseudo-term-list-list-fix-1
 (<a href="ACL2____IMPLIES.html">implies</a> (pseudo-term-list-list-equiv acl2::x x-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (pseudo-term-list-list-fix acl2::x)
                 (pseudo-term-list-list-fix x-equiv)))
 :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>pseudo-term-list-list-fix-under-pseudo-term-list-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    pseudo-term-list-list-fix-under-pseudo-term-list-list-equiv
    (pseudo-term-list-list-equiv (pseudo-term-list-list-fix acl2::x)
                                 acl2::x)
    :rule-classes (:rewrite :rewrite-quoted-constant))</pre> 
<p><b>Theorem: </b>equal-of-pseudo-term-list-list-fix-1-forward-to-pseudo-term-list-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 equal-of-pseudo-term-list-list-fix-1-forward-to-pseudo-term-list-list-equiv
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (pseudo-term-list-list-fix acl2::x)
                 acl2::y)
          (pseudo-term-list-list-equiv acl2::x acl2::y))
 :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>equal-of-pseudo-term-list-list-fix-2-forward-to-pseudo-term-list-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 equal-of-pseudo-term-list-list-fix-2-forward-to-pseudo-term-list-list-equiv
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> acl2::x
                 (pseudo-term-list-list-fix acl2::y))
          (pseudo-term-list-list-equiv acl2::x acl2::y))
 :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>pseudo-term-list-list-equiv-of-pseudo-term-list-list-fix-1-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 pseudo-term-list-list-equiv-of-pseudo-term-list-list-fix-1-forward
 (<a href="ACL2____IMPLIES.html">implies</a>
    (pseudo-term-list-list-equiv (pseudo-term-list-list-fix acl2::x)
                                 acl2::y)
    (pseudo-term-list-list-equiv acl2::x acl2::y))
 :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>pseudo-term-list-list-equiv-of-pseudo-term-list-list-fix-2-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 pseudo-term-list-list-equiv-of-pseudo-term-list-list-fix-2-forward
 (<a href="ACL2____IMPLIES.html">implies</a>
   (pseudo-term-list-list-equiv acl2::x
                                (pseudo-term-list-list-fix acl2::y))
   (pseudo-term-list-list-equiv acl2::x acl2::y))
 :rule-classes :forward-chaining)</pre> 
<p><b>Function: </b>pseudo-term-alistp</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> pseudo-term-alistp (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'pseudo-term-alistp))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)
                (<a href="COMMON-LISP____EQ.html">eq</a> x nil)
                (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CAR.html">car</a> x))
                     (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> (<a href="COMMON-LISP____CAAR.html">caar</a> x))
                     (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> (<a href="COMMON-LISP____CDAR.html">cdar</a> x))
                     (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x))))))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-revappend</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-alistp-of-revappend
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="COMMON-LISP____REVAPPEND.html">revappend</a> acl2::x acl2::y))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x))
                    (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-remove</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-alistp-of-remove
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::x)
                 (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="COMMON-LISP____REMOVE.html">remove</a> acl2::a acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-last</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-alistp-of-last
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="COMMON-LISP____LAST.html">last</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-nthcdr</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-alistp-of-nthcdr
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> acl2::n acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-butlast</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-alistp-of-butlast
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="COMMON-LISP____BUTLAST.html">butlast</a> acl2::x acl2::n)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-update-nth</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 pseudo-term-alistp-of-update-nth
 (<a href="ACL2____IMPLIES.html">implies</a>
      (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
      (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="ACL2____UPDATE-NTH.html">update-nth</a> acl2::n acl2::y acl2::x))
           (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::y)
                     (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::y))
                     (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::y)))
                (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____NFIX.html">nfix</a> acl2::n) (<a href="ACL2____LEN.html">len</a> acl2::x))
                    (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> nil)
                         (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> (<a href="COMMON-LISP____CAR.html">car</a> nil))
                         (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> nil)))))))
 :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-repeat</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-alistp-of-repeat
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="ACL2____REPEAT.html">acl2::repeat</a> acl2::n acl2::x))
             (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x)
                      (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::x))
                      (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::x)))
                 (<a href="ACL2____ZP.html">zp</a> acl2::n)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-take</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-alistp-of-take
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="ACL2____TAKE.html">take</a> acl2::n acl2::x))
                      (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> nil)
                               (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> (<a href="COMMON-LISP____CAR.html">car</a> nil))
                               (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> nil)))
                          (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____NFIX.html">nfix</a> acl2::n) (<a href="ACL2____LEN.html">len</a> acl2::x)))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-union-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-alistp-of-union-equal
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="ACL2____UNION-EQUAL.html">union-equal</a> acl2::x acl2::y))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x))
                    (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::y))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-intersection-equal-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 pseudo-term-alistp-of-intersection-equal-2
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::y))
          (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="ACL2____INTERSECTION-EQUAL.html">intersection-equal</a> acl2::x acl2::y)))
 :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-intersection-equal-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 pseudo-term-alistp-of-intersection-equal-1
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
          (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="ACL2____INTERSECTION-EQUAL.html">intersection-equal</a> acl2::x acl2::y)))
 :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-set-difference-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   pseudo-term-alistp-of-set-difference-equal
   (<a href="ACL2____IMPLIES.html">implies</a>
        (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::x)
        (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="ACL2____SET-DIFFERENCE-EQUAL.html">set-difference-equal</a> acl2::x acl2::y)))
   :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-when-subsetp-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-alistp-when-subsetp-equal
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SUBSETP-EQUAL.html">subsetp-equal</a> acl2::x acl2::y)
                           (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::y))
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::x)
                             (<a href="ACL2____TRUE-LISTP.html">true-listp</a> acl2::x)))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::y)
                           (<a href="ACL2____SUBSETP-EQUAL.html">subsetp-equal</a> acl2::x acl2::y))
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::x)
                             (<a href="ACL2____TRUE-LISTP.html">true-listp</a> acl2::x))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-rcons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-alistp-of-rcons
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="ACL2____RCONS.html">acl2::rcons</a> acl2::a acl2::x))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::a)
                       (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::a))
                       (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::a)))
                  (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-append</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-alistp-of-append
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="COMMON-LISP____APPEND.html">append</a> acl2::a acl2::b))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::a))
                    (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::b)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-rev</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-alistp-of-rev
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="ACL2____REV.html">acl2::rev</a> acl2::x))
               (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-duplicated-members</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   pseudo-term-alistp-of-duplicated-members
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::x)
            (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (acl2::duplicated-members acl2::x)))
   :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-difference</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    pseudo-term-alistp-of-difference
    (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::x)
             (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="SET____DIFFERENCE.html">set::difference</a> acl2::x acl2::y)))
    :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-intersect-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     pseudo-term-alistp-of-intersect-2
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::y)
              (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="SET____INTERSECT.html">set::intersect</a> acl2::x acl2::y)))
     :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-intersect-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     pseudo-term-alistp-of-intersect-1
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::x)
              (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="SET____INTERSECT.html">set::intersect</a> acl2::x acl2::y)))
     :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-union</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-alistp-of-union
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="SET____UNION.html">set::union</a> acl2::x acl2::y))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::x))
                  (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::y))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-mergesort</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-alistp-of-mergesort
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="SET____MERGESORT.html">set::mergesort</a> acl2::x))
             (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-delete</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-alistp-of-delete
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::x)
                 (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="SET____DELETE.html">set::delete</a> acl2::k acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-insert</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-alistp-of-insert
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="SET____INSERT.html">set::insert</a> acl2::a acl2::x))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::x))
                  (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::a)
                       (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::a))
                       (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::a)))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-sfix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-alistp-of-sfix
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::x))
             (<a href="COMMON-LISP____OR.html">or</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::x)
                 (<a href="COMMON-LISP____NOT.html">not</a> (<a href="SET____SETP.html">set::setp</a> acl2::x))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-alistp-of-list-fix
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::x)
                 (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>true-listp-when-pseudo-term-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> true-listp-when-pseudo-term-alistp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::x)
                 (<a href="ACL2____TRUE-LISTP.html">true-listp</a> acl2::x))
        :rule-classes :compound-recognizer)</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-when-not-consp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-alistp-when-not-consp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::x)
                        (<a href="COMMON-LISP____NOT.html">not</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-cdr-when-pseudo-term-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-alistp-of-cdr-when-pseudo-term-alistp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-cons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-alistp-of-cons
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::a acl2::x))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::a)
                         (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::a))
                         (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::a)))
                    (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-remove-assoc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  pseudo-term-alistp-of-remove-assoc
  (<a href="ACL2____IMPLIES.html">implies</a>
       (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::x)
       (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="ACL2____REMOVE-ASSOC-EQUAL.html">remove-assoc-equal</a> acl2::name acl2::x)))
  :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-put-assoc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  pseudo-term-alistp-of-put-assoc
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::x))
           (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a>
                     (<a href="ACL2____PUT-ASSOC-EQUAL.html">put-assoc-equal</a> acl2::name acl2::val acl2::x))
                (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> acl2::name)
                     (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> acl2::val))))
  :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-hons-shrink-alist</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  pseudo-term-alistp-of-hons-shrink-alist
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::x)
                (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::y))
           (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="ACL2____HONS-SHRINK-ALIST.html">hons-shrink-alist</a> acl2::x acl2::y)))
  :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-hons-acons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    pseudo-term-alistp-of-hons-acons
    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> (<a href="ACL2____HONS-ACONS.html">hons-acons</a> acl2::a acl2::n acl2::x))
           (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> acl2::a)
                (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> acl2::n)
                (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::x)))
    :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-termp-of-cdr-of-hons-assoc-equal-when-pseudo-term-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   pseudo-termp-of-cdr-of-hons-assoc-equal-when-pseudo-term-alistp
   (<a href="ACL2____IMPLIES.html">implies</a>
        (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::x)
        (<a href="ACL2____IFF.html">iff</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="ACL2____HONS-ASSOC-EQUAL.html">hons-assoc-equal</a> acl2::k acl2::x)))
             (<a href="COMMON-LISP____OR.html">or</a> (<a href="ACL2____HONS-ASSOC-EQUAL.html">hons-assoc-equal</a> acl2::k acl2::x)
                 (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> nil))))
   :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>alistp-when-pseudo-term-alistp-rewrite</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> alistp-when-pseudo-term-alistp-rewrite
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::x)
                 (<a href="ACL2____ALISTP.html">alistp</a> acl2::x))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>alistp-when-pseudo-term-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> alistp-when-pseudo-term-alistp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::x)
                 (<a href="ACL2____ALISTP.html">alistp</a> acl2::x))
        :rule-classes :tau-system)</pre> 
<p><b>Theorem: </b>pseudo-termp-of-cdar-when-pseudo-term-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-termp-of-cdar-when-pseudo-term-alistp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::x)
                 (<a href="ACL2____IFF.html">iff</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> (<a href="COMMON-LISP____CDAR.html">cdar</a> acl2::x))
                      (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x)
                          (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> nil))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>pseudo-termp-of-caar-when-pseudo-term-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-termp-of-caar-when-pseudo-term-alistp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::x)
                 (<a href="ACL2____IFF.html">iff</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> (<a href="COMMON-LISP____CAAR.html">caar</a> acl2::x))
                      (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x)
                          (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> nil))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Function: </b>pseudo-term-alist-fix$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
    pseudo-term-alist-fix$inline (x)
    (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> x)))
    (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'pseudo-term-alist-fix))
         (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
         (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)
                         nil
                         (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CAR.html">car</a> x))
                             (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> (pseudo-term-fix (<a href="COMMON-LISP____CAAR.html">caar</a> x))
                                         (pseudo-term-fix (<a href="COMMON-LISP____CDAR.html">cdar</a> x)))
                                   (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x)))
                             (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x))))
              :exec x)))</pre> 
<p><b>Theorem: </b>pseudo-term-alistp-of-pseudo-term-alist-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-alistp-of-pseudo-term-alist-fix
        (<a href="ACL2____B_A2.html">b*</a> ((fty::newx (pseudo-term-alist-fix$inline x)))
            (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> fty::newx))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>pseudo-term-alist-fix-when-pseudo-term-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-alist-fix-when-pseudo-term-alistp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> x) x)))</pre> 
<p><b>Function: </b>pseudo-term-alist-equiv$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> pseudo-term-alist-equiv$inline
       (acl2::x acl2::y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::x)
                                   (<a href="SMT____PSEUDO-TERM-ALISTP.html">pseudo-term-alistp</a> acl2::y))))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> acl2::x)
              (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> acl2::y)))</pre> 
<p><b>Theorem: </b>pseudo-term-alist-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-alist-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="SMT____PSEUDO-TERM-ALIST-EQUIV.html">pseudo-term-alist-equiv</a> x y))
             (<a href="SMT____PSEUDO-TERM-ALIST-EQUIV.html">pseudo-term-alist-equiv</a> x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____PSEUDO-TERM-ALIST-EQUIV.html">pseudo-term-alist-equiv</a> x y)
                      (<a href="SMT____PSEUDO-TERM-ALIST-EQUIV.html">pseudo-term-alist-equiv</a> y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____PSEUDO-TERM-ALIST-EQUIV.html">pseudo-term-alist-equiv</a> x y)
                           (<a href="SMT____PSEUDO-TERM-ALIST-EQUIV.html">pseudo-term-alist-equiv</a> y z))
                      (<a href="SMT____PSEUDO-TERM-ALIST-EQUIV.html">pseudo-term-alist-equiv</a> x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>pseudo-term-alist-equiv-implies-equal-pseudo-term-alist-fix-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     pseudo-term-alist-equiv-implies-equal-pseudo-term-alist-fix-1
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____PSEUDO-TERM-ALIST-EQUIV.html">pseudo-term-alist-equiv</a> acl2::x x-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> acl2::x)
                     (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> x-equiv)))
     :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>pseudo-term-alist-fix-under-pseudo-term-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-alist-fix-under-pseudo-term-alist-equiv
        (<a href="SMT____PSEUDO-TERM-ALIST-EQUIV.html">pseudo-term-alist-equiv</a> (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> acl2::x)
                                 acl2::x)
        :rule-classes (:rewrite :rewrite-quoted-constant))</pre> 
<p><b>Theorem: </b>equal-of-pseudo-term-alist-fix-1-forward-to-pseudo-term-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 equal-of-pseudo-term-alist-fix-1-forward-to-pseudo-term-alist-equiv
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> acl2::x)
                 acl2::y)
          (<a href="SMT____PSEUDO-TERM-ALIST-EQUIV.html">pseudo-term-alist-equiv</a> acl2::x acl2::y))
 :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>equal-of-pseudo-term-alist-fix-2-forward-to-pseudo-term-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 equal-of-pseudo-term-alist-fix-2-forward-to-pseudo-term-alist-equiv
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> acl2::x (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> acl2::y))
          (<a href="SMT____PSEUDO-TERM-ALIST-EQUIV.html">pseudo-term-alist-equiv</a> acl2::x acl2::y))
 :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>pseudo-term-alist-equiv-of-pseudo-term-alist-fix-1-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   pseudo-term-alist-equiv-of-pseudo-term-alist-fix-1-forward
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____PSEUDO-TERM-ALIST-EQUIV.html">pseudo-term-alist-equiv</a> (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> acl2::x)
                                     acl2::y)
            (<a href="SMT____PSEUDO-TERM-ALIST-EQUIV.html">pseudo-term-alist-equiv</a> acl2::x acl2::y))
   :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>pseudo-term-alist-equiv-of-pseudo-term-alist-fix-2-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 pseudo-term-alist-equiv-of-pseudo-term-alist-fix-2-forward
 (<a href="ACL2____IMPLIES.html">implies</a>
   (<a href="SMT____PSEUDO-TERM-ALIST-EQUIV.html">pseudo-term-alist-equiv</a> acl2::x (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> acl2::y))
   (<a href="SMT____PSEUDO-TERM-ALIST-EQUIV.html">pseudo-term-alist-equiv</a> acl2::x acl2::y))
 :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>cons-of-pseudo-term-fix-k-under-pseudo-term-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> cons-of-pseudo-term-fix-k-under-pseudo-term-alist-equiv
        (<a href="SMT____PSEUDO-TERM-ALIST-EQUIV.html">pseudo-term-alist-equiv</a>
             (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> (pseudo-term-fix acl2::k) acl2::v)
                   acl2::x)
             (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::k acl2::v) acl2::x)))</pre> 
<p><b>Theorem: </b>cons-pseudo-term-equiv-congruence-on-k-under-pseudo-term-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 cons-pseudo-term-equiv-congruence-on-k-under-pseudo-term-alist-equiv
 (<a href="ACL2____IMPLIES.html">implies</a>
    (pseudo-term-equiv acl2::k k-equiv)
    (<a href="SMT____PSEUDO-TERM-ALIST-EQUIV.html">pseudo-term-alist-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::k acl2::v) acl2::x)
                             (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> k-equiv acl2::v) acl2::x)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>cons-of-pseudo-term-fix-v-under-pseudo-term-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> cons-of-pseudo-term-fix-v-under-pseudo-term-alist-equiv
        (<a href="SMT____PSEUDO-TERM-ALIST-EQUIV.html">pseudo-term-alist-equiv</a>
             (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::k (pseudo-term-fix acl2::v))
                   acl2::x)
             (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::k acl2::v) acl2::x)))</pre> 
<p><b>Theorem: </b>cons-pseudo-term-equiv-congruence-on-v-under-pseudo-term-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 cons-pseudo-term-equiv-congruence-on-v-under-pseudo-term-alist-equiv
 (<a href="ACL2____IMPLIES.html">implies</a>
    (pseudo-term-equiv acl2::v v-equiv)
    (<a href="SMT____PSEUDO-TERM-ALIST-EQUIV.html">pseudo-term-alist-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::k acl2::v) acl2::x)
                             (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::k v-equiv) acl2::x)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>cons-of-pseudo-term-alist-fix-y-under-pseudo-term-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     cons-of-pseudo-term-alist-fix-y-under-pseudo-term-alist-equiv
     (<a href="SMT____PSEUDO-TERM-ALIST-EQUIV.html">pseudo-term-alist-equiv</a>
          (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> acl2::y))
          (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y)))</pre> 
<p><b>Theorem: </b>cons-pseudo-term-alist-equiv-congruence-on-y-under-pseudo-term-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 cons-pseudo-term-alist-equiv-congruence-on-y-under-pseudo-term-alist-equiv
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____PSEUDO-TERM-ALIST-EQUIV.html">pseudo-term-alist-equiv</a> acl2::y y-equiv)
          (<a href="SMT____PSEUDO-TERM-ALIST-EQUIV.html">pseudo-term-alist-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y)
                                   (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x y-equiv)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>pseudo-term-alist-fix-of-acons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     pseudo-term-alist-fix-of-acons
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::a acl2::b) x))
            (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> (pseudo-term-fix acl2::a)
                        (pseudo-term-fix acl2::b))
                  (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> x))))</pre> 
<p><b>Theorem: </b>pseudo-term-alist-fix-of-append</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-alist-fix-of-append
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> (<a href="COMMON-LISP____APPEND.html">append</a> std::a std::b))
               (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> std::a)
                       (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> std::b))))</pre> 
<p><b>Theorem: </b>consp-car-of-pseudo-term-alist-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> consp-car-of-pseudo-term-alist-fix
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> x)))
               (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____PSEUDO-TERM-ALIST-FIX.html">pseudo-term-alist-fix</a> x))))</pre> 
<p><b>Function: </b>true-list-fix</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> true-list-fix (lst)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____TRUE-LISTP.html">true-listp</a> lst)))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'true-list-fix))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> lst)
                            (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> lst)
                                  (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> lst)))
                            nil)
                 :exec lst)))</pre> 
<p><b>Theorem: </b>true-listp-of-true-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> true-listp-of-true-list-fix
        (<a href="ACL2____B_A2.html">b*</a> ((fixed-lst (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> lst)))
            (<a href="ACL2____TRUE-LISTP.html">true-listp</a> fixed-lst))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>true-list-fix-idempotent-lemma</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> true-list-fix-idempotent-lemma
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> x))
               (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> x)))</pre> 
<p><b>Theorem: </b>true-list-fix-preserve-length</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> true-list-fix-preserve-length
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> x)) (<a href="ACL2____LEN.html">len</a> x)))</pre> 
<p><b>Function: </b>true-list-equiv$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> true-list-equiv$inline (acl2::x acl2::y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> acl2::x)
                                   (<a href="ACL2____TRUE-LISTP.html">true-listp</a> acl2::y))))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> acl2::x)
              (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> acl2::y)))</pre> 
<p><b>Theorem: </b>true-list-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> true-list-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (true-list-equiv x y))
             (true-list-equiv x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (true-list-equiv x y)
                      (true-list-equiv y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (true-list-equiv x y)
                           (true-list-equiv y z))
                      (true-list-equiv x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>true-list-equiv-implies-equal-true-list-fix-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> true-list-equiv-implies-equal-true-list-fix-1
        (<a href="ACL2____IMPLIES.html">implies</a> (true-list-equiv acl2::x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> acl2::x)
                        (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> x-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>true-list-fix-under-true-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> true-list-fix-under-true-list-equiv
        (true-list-equiv (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> acl2::x)
                         acl2::x)
        :rule-classes (:rewrite :rewrite-quoted-constant))</pre> 
<p><b>Theorem: </b>equal-of-true-list-fix-1-forward-to-true-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-true-list-fix-1-forward-to-true-list-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> acl2::x) acl2::y)
                 (true-list-equiv acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>equal-of-true-list-fix-2-forward-to-true-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-true-list-fix-2-forward-to-true-list-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> acl2::x (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> acl2::y))
                 (true-list-equiv acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>true-list-equiv-of-true-list-fix-1-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> true-list-equiv-of-true-list-fix-1-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (true-list-equiv (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> acl2::x)
                                  acl2::y)
                 (true-list-equiv acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>true-list-equiv-of-true-list-fix-2-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> true-list-equiv-of-true-list-fix-2-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (true-list-equiv acl2::x (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> acl2::y))
                 (true-list-equiv acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Function: </b>hint-pair-p</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     hint-pair-p (x)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
     (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'hint-pair-p))
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
          (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____ALISTP.html">alistp</a> x)
                                (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____STRIP-CARS.html">strip-cars</a> x) '(<a href="ACL2____THM.html">thm</a> hints)))
                    :exec (fty::alist-with-carsp x '(<a href="ACL2____THM.html">thm</a> hints)))
               (<a href="ACL2____B_A2.html">b*</a> ((<a href="ACL2____THM.html">thm</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x)))
                    (hints (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x))))
                   (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> thm)
                        (<a href="ACL2____TRUE-LISTP.html">true-listp</a> hints))))))</pre> 
<p><b>Theorem: </b>consp-when-hint-pair-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> consp-when-hint-pair-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> x) (<a href="COMMON-LISP____CONSP.html">consp</a> x))
        :rule-classes :compound-recognizer)</pre> 
<p><b>Function: </b>hint-pair-fix$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 hint-pair-fix$inline (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> x)))
 (<a href="COMMON-LISP____LET.html">let</a>
   ((acl2::__function__ 'hint-pair-fix))
   (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
   (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((<a href="ACL2____THM.html">thm</a> (pseudo-term-fix (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x))))
                    (hints (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x)))))
                   (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'thm thm)
                         (<a href="COMMON-LISP____CONS.html">cons</a> 'hints hints)))
        :exec x)))</pre> 
<p><b>Theorem: </b>hint-pair-p-of-hint-pair-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-p-of-hint-pair-fix
        (<a href="ACL2____B_A2.html">b*</a> ((new-x (hint-pair-fix$inline x)))
            (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> new-x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>hint-pair-fix-when-hint-pair-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-fix-when-hint-pair-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> x) x)))</pre> 
<p><b>Function: </b>hint-pair-equiv$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> hint-pair-equiv$inline (acl2::x acl2::y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> acl2::x)
                                   (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> acl2::y))))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> acl2::x)
              (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> acl2::y)))</pre> 
<p><b>Theorem: </b>hint-pair-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="SMT____HINT-PAIR-EQUIV.html">hint-pair-equiv</a> x y))
             (<a href="SMT____HINT-PAIR-EQUIV.html">hint-pair-equiv</a> x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-EQUIV.html">hint-pair-equiv</a> x y)
                      (<a href="SMT____HINT-PAIR-EQUIV.html">hint-pair-equiv</a> y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____HINT-PAIR-EQUIV.html">hint-pair-equiv</a> x y)
                           (<a href="SMT____HINT-PAIR-EQUIV.html">hint-pair-equiv</a> y z))
                      (<a href="SMT____HINT-PAIR-EQUIV.html">hint-pair-equiv</a> x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>hint-pair-equiv-implies-equal-hint-pair-fix-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-equiv-implies-equal-hint-pair-fix-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-EQUIV.html">hint-pair-equiv</a> acl2::x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> acl2::x)
                        (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> x-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>hint-pair-fix-under-hint-pair-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-fix-under-hint-pair-equiv
        (<a href="SMT____HINT-PAIR-EQUIV.html">hint-pair-equiv</a> (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> acl2::x)
                         acl2::x)
        :rule-classes (:rewrite :rewrite-quoted-constant))</pre> 
<p><b>Theorem: </b>equal-of-hint-pair-fix-1-forward-to-hint-pair-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-hint-pair-fix-1-forward-to-hint-pair-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> acl2::x) acl2::y)
                 (<a href="SMT____HINT-PAIR-EQUIV.html">hint-pair-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>equal-of-hint-pair-fix-2-forward-to-hint-pair-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-hint-pair-fix-2-forward-to-hint-pair-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> acl2::x (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> acl2::y))
                 (<a href="SMT____HINT-PAIR-EQUIV.html">hint-pair-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>hint-pair-equiv-of-hint-pair-fix-1-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-equiv-of-hint-pair-fix-1-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-EQUIV.html">hint-pair-equiv</a> (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> acl2::x)
                                  acl2::y)
                 (<a href="SMT____HINT-PAIR-EQUIV.html">hint-pair-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>hint-pair-equiv-of-hint-pair-fix-2-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-equiv-of-hint-pair-fix-2-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-EQUIV.html">hint-pair-equiv</a> acl2::x (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> acl2::y))
                 (<a href="SMT____HINT-PAIR-EQUIV.html">hint-pair-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Function: </b>hint-pair-&gt;thm$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     hint-pair-&gt;thm$inline (x)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> x)))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
     (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'hint-pair-&gt;thm))
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
          (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                          (pseudo-term-fix (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x))))
               :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x)))))</pre> 
<p><b>Theorem: </b>pseudo-termp-of-hint-pair-&gt;thm</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-termp-of-hint-pair-&gt;thm
        (<a href="ACL2____B_A2.html">b*</a> ((<a href="ACL2____THM.html">thm</a> (hint-pair-&gt;thm$inline x)))
            (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> thm))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>hint-pair-&gt;thm$inline-of-hint-pair-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-&gt;thm$inline-of-hint-pair-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (hint-pair-&gt;thm$inline (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> x))
               (hint-pair-&gt;thm$inline x)))</pre> 
<p><b>Theorem: </b>hint-pair-&gt;thm$inline-hint-pair-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-&gt;thm$inline-hint-pair-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-EQUIV.html">hint-pair-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (hint-pair-&gt;thm$inline x)
                        (hint-pair-&gt;thm$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>hint-pair-&gt;hints$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> hint-pair-&gt;hints$inline (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> x)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'hint-pair-&gt;hints))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                            (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x))))
                 :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x)))))</pre> 
<p><b>Theorem: </b>true-listp-of-hint-pair-&gt;hints</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> true-listp-of-hint-pair-&gt;hints
        (<a href="ACL2____B_A2.html">b*</a> ((hints (hint-pair-&gt;hints$inline x)))
            (<a href="ACL2____TRUE-LISTP.html">true-listp</a> hints))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>hint-pair-&gt;hints$inline-of-hint-pair-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-&gt;hints$inline-of-hint-pair-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (hint-pair-&gt;hints$inline (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> x))
               (hint-pair-&gt;hints$inline x)))</pre> 
<p><b>Theorem: </b>hint-pair-&gt;hints$inline-hint-pair-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-&gt;hints$inline-hint-pair-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-EQUIV.html">hint-pair-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (hint-pair-&gt;hints$inline x)
                        (hint-pair-&gt;hints$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>hint-pair</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> hint-pair (<a href="ACL2____THM.html">thm</a> hints)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> thm)
                                   (<a href="ACL2____TRUE-LISTP.html">true-listp</a> hints))))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'hint-pair))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____B_A2.html">b*</a> ((<a href="ACL2____THM.html">thm</a> (<a href="ACL2____MBE.html">mbe</a> :logic (pseudo-term-fix thm)
                           :exec thm))
                 (hints (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> hints)
                             :exec hints)))
                (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'thm thm)
                      (<a href="COMMON-LISP____CONS.html">cons</a> 'hints hints)))))</pre> 
<p><b>Theorem: </b>hint-pair-p-of-hint-pair</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-p-of-hint-pair
        (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="SMT____HINT-PAIR.html">hint-pair</a> thm hints)))
            (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>hint-pair-&gt;thm-of-hint-pair</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-&gt;thm-of-hint-pair
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR-_E3THM.html">hint-pair-&gt;thm</a> (<a href="SMT____HINT-PAIR.html">hint-pair</a> thm hints))
               (pseudo-term-fix thm)))</pre> 
<p><b>Theorem: </b>hint-pair-&gt;hints-of-hint-pair</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-&gt;hints-of-hint-pair
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR-_E3HINTS.html">hint-pair-&gt;hints</a> (<a href="SMT____HINT-PAIR.html">hint-pair</a> thm hints))
               (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> hints)))</pre> 
<p><b>Theorem: </b>hint-pair-of-fields</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-of-fields
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR.html">hint-pair</a> (<a href="SMT____HINT-PAIR-_E3THM.html">hint-pair-&gt;thm</a> x)
                          (<a href="SMT____HINT-PAIR-_E3HINTS.html">hint-pair-&gt;hints</a> x))
               (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> x)))</pre> 
<p><b>Theorem: </b>hint-pair-fix-when-hint-pair</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-fix-when-hint-pair
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> x)
               (<a href="SMT____HINT-PAIR.html">hint-pair</a> (<a href="SMT____HINT-PAIR-_E3THM.html">hint-pair-&gt;thm</a> x)
                          (<a href="SMT____HINT-PAIR-_E3HINTS.html">hint-pair-&gt;hints</a> x))))</pre> 
<p><b>Theorem: </b>equal-of-hint-pair</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-hint-pair
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR.html">hint-pair</a> thm hints) x)
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> x)
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR-_E3THM.html">hint-pair-&gt;thm</a> x)
                           (pseudo-term-fix thm))
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR-_E3HINTS.html">hint-pair-&gt;hints</a> x)
                           (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> hints)))))</pre> 
<p><b>Theorem: </b>hint-pair-of-pseudo-term-fix-thm</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-of-pseudo-term-fix-thm
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR.html">hint-pair</a> (pseudo-term-fix thm) hints)
               (<a href="SMT____HINT-PAIR.html">hint-pair</a> thm hints)))</pre> 
<p><b>Theorem: </b>hint-pair-pseudo-term-equiv-congruence-on-thm</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-pseudo-term-equiv-congruence-on-thm
        (<a href="ACL2____IMPLIES.html">implies</a> (pseudo-term-equiv thm thm-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR.html">hint-pair</a> thm hints)
                        (<a href="SMT____HINT-PAIR.html">hint-pair</a> thm-equiv hints)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>hint-pair-of-true-list-fix-hints</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-of-true-list-fix-hints
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR.html">hint-pair</a> thm (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> hints))
               (<a href="SMT____HINT-PAIR.html">hint-pair</a> thm hints)))</pre> 
<p><b>Theorem: </b>hint-pair-true-list-equiv-congruence-on-hints</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-true-list-equiv-congruence-on-hints
        (<a href="ACL2____IMPLIES.html">implies</a> (true-list-equiv hints hints-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR.html">hint-pair</a> thm hints)
                        (<a href="SMT____HINT-PAIR.html">hint-pair</a> thm hints-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>hint-pair-fix-redef</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-fix-redef
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> x)
               (<a href="SMT____HINT-PAIR.html">hint-pair</a> (<a href="SMT____HINT-PAIR-_E3THM.html">hint-pair-&gt;thm</a> x)
                          (<a href="SMT____HINT-PAIR-_E3HINTS.html">hint-pair-&gt;hints</a> x)))
        :rule-classes :definition)</pre> 
<p><b>Function: </b>hint-pair-listp</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> hint-pair-listp (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'hint-pair-listp))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)
                (<a href="COMMON-LISP____EQ.html">eq</a> x nil)
                (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> (<a href="COMMON-LISP____CAR.html">car</a> x))
                     (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x))))))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-cons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-cons
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::a acl2::x))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> acl2::a)
                    (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-cdr-when-hint-pair-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-cdr-when-hint-pair-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-listp-when-not-consp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-when-not-consp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> acl2::x)
                        (<a href="COMMON-LISP____NOT.html">not</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-p-of-car-when-hint-pair-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-p-of-car-when-hint-pair-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> acl2::x)
                 (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::x))
                      (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x) (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> nil))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>true-listp-when-hint-pair-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> true-listp-when-hint-pair-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> acl2::x)
                 (<a href="ACL2____TRUE-LISTP.html">true-listp</a> acl2::x))
        :rule-classes :compound-recognizer)</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-list-fix
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> acl2::x)
                 (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-sfix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-sfix
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::x))
             (<a href="COMMON-LISP____OR.html">or</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> acl2::x)
                 (<a href="COMMON-LISP____NOT.html">not</a> (<a href="SET____SETP.html">set::setp</a> acl2::x))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-insert</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-insert
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="SET____INSERT.html">set::insert</a> acl2::a acl2::x))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::x))
                  (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> acl2::a)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-delete</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-delete
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> acl2::x)
                 (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="SET____DELETE.html">set::delete</a> acl2::k acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-mergesort</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-mergesort
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="SET____MERGESORT.html">set::mergesort</a> acl2::x))
             (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-union</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-union
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="SET____UNION.html">set::union</a> acl2::x acl2::y))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::x))
                  (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::y))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-intersect-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-intersect-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> acl2::x)
                 (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="SET____INTERSECT.html">set::intersect</a> acl2::x acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-intersect-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-intersect-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> acl2::y)
                 (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="SET____INTERSECT.html">set::intersect</a> acl2::x acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-difference</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     hint-pair-listp-of-difference
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> acl2::x)
              (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="SET____DIFFERENCE.html">set::difference</a> acl2::x acl2::y)))
     :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-duplicated-members</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     hint-pair-listp-of-duplicated-members
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> acl2::x)
              (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (acl2::duplicated-members acl2::x)))
     :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-rev</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-rev
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="ACL2____REV.html">acl2::rev</a> acl2::x))
               (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-append</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-append
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="COMMON-LISP____APPEND.html">append</a> acl2::a acl2::b))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::a))
                    (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> acl2::b)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-rcons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-rcons
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="ACL2____RCONS.html">acl2::rcons</a> acl2::a acl2::x))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> acl2::a)
                  (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-p-when-member-equal-of-hint-pair-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-p-when-member-equal-of-hint-pair-listp
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> acl2::a acl2::x)
                           (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> acl2::x))
                      (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> acl2::a))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> acl2::x)
                           (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> acl2::a acl2::x))
                      (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> acl2::a)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-listp-when-subsetp-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-when-subsetp-equal
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SUBSETP-EQUAL.html">subsetp-equal</a> acl2::x acl2::y)
                           (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> acl2::y))
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> acl2::x)
                             (<a href="ACL2____TRUE-LISTP.html">true-listp</a> acl2::x)))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> acl2::y)
                           (<a href="ACL2____SUBSETP-EQUAL.html">subsetp-equal</a> acl2::x acl2::y))
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> acl2::x)
                             (<a href="ACL2____TRUE-LISTP.html">true-listp</a> acl2::x))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-set-difference-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  hint-pair-listp-of-set-difference-equal
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> acl2::x)
           (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="ACL2____SET-DIFFERENCE-EQUAL.html">set-difference-equal</a> acl2::x acl2::y)))
  :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-intersection-equal-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    hint-pair-listp-of-intersection-equal-1
    (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
             (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="ACL2____INTERSECTION-EQUAL.html">intersection-equal</a> acl2::x acl2::y)))
    :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-intersection-equal-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    hint-pair-listp-of-intersection-equal-2
    (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::y))
             (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="ACL2____INTERSECTION-EQUAL.html">intersection-equal</a> acl2::x acl2::y)))
    :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-union-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-union-equal
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="ACL2____UNION-EQUAL.html">union-equal</a> acl2::x acl2::y))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x))
                    (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::y))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-take</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-take
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="ACL2____TAKE.html">take</a> acl2::n acl2::x))
                      (<a href="COMMON-LISP____OR.html">or</a> (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> nil)
                          (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____NFIX.html">nfix</a> acl2::n) (<a href="ACL2____LEN.html">len</a> acl2::x)))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-repeat</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-repeat
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="ACL2____REPEAT.html">acl2::repeat</a> acl2::n acl2::x))
             (<a href="COMMON-LISP____OR.html">or</a> (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> acl2::x) (<a href="ACL2____ZP.html">zp</a> acl2::n)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-p-of-nth-when-hint-pair-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-p-of-nth-when-hint-pair-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> acl2::x)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____NFIX.html">nfix</a> acl2::n) (<a href="ACL2____LEN.html">len</a> acl2::x)))
                 (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> (<a href="COMMON-LISP____NTH.html">nth</a> acl2::n acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-update-nth</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    hint-pair-listp-of-update-nth
    (<a href="ACL2____IMPLIES.html">implies</a>
         (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
         (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="ACL2____UPDATE-NTH.html">update-nth</a> acl2::n acl2::y acl2::x))
              (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> acl2::y)
                   (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____NFIX.html">nfix</a> acl2::n) (<a href="ACL2____LEN.html">len</a> acl2::x))
                       (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> nil)))))
    :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-butlast</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-butlast
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="COMMON-LISP____BUTLAST.html">butlast</a> acl2::x acl2::n)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-nthcdr</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-nthcdr
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> acl2::n acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-last</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-last
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="COMMON-LISP____LAST.html">last</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-remove</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-remove
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> acl2::x)
                 (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="COMMON-LISP____REMOVE.html">remove</a> acl2::a acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-revappend</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-revappend
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="COMMON-LISP____REVAPPEND.html">revappend</a> acl2::x acl2::y))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x))
                    (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Function: </b>hint-pair-list-fix$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> hint-pair-list-fix$inline (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> x)))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'hint-pair-list-fix))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)
                            nil
                            (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> (<a href="COMMON-LISP____CAR.html">car</a> x))
                                  (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x))))
                 :exec x)))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-hint-pair-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-hint-pair-list-fix
        (<a href="ACL2____B_A2.html">b*</a> ((fty::newx (hint-pair-list-fix$inline x)))
            (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> fty::newx))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>hint-pair-list-fix-when-hint-pair-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-list-fix-when-hint-pair-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> x) x)))</pre> 
<p><b>Function: </b>hint-pair-list-equiv$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> hint-pair-list-equiv$inline
       (acl2::x acl2::y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> acl2::x)
                                   (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> acl2::y))))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> acl2::x)
              (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> acl2::y)))</pre> 
<p><b>Theorem: </b>hint-pair-list-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-list-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> x y))
             (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> x y)
                      (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> x y)
                           (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> y z))
                      (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>hint-pair-list-equiv-implies-equal-hint-pair-list-fix-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-list-equiv-implies-equal-hint-pair-list-fix-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> acl2::x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> acl2::x)
                        (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> x-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>hint-pair-list-fix-under-hint-pair-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-list-fix-under-hint-pair-list-equiv
        (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> acl2::x)
                              acl2::x)
        :rule-classes (:rewrite :rewrite-quoted-constant))</pre> 
<p><b>Theorem: </b>equal-of-hint-pair-list-fix-1-forward-to-hint-pair-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     equal-of-hint-pair-list-fix-1-forward-to-hint-pair-list-equiv
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> acl2::x)
                     acl2::y)
              (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> acl2::x acl2::y))
     :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>equal-of-hint-pair-list-fix-2-forward-to-hint-pair-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     equal-of-hint-pair-list-fix-2-forward-to-hint-pair-list-equiv
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> acl2::x (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> acl2::y))
              (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> acl2::x acl2::y))
     :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>hint-pair-list-equiv-of-hint-pair-list-fix-1-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-list-equiv-of-hint-pair-list-fix-1-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> acl2::x)
                                       acl2::y)
                 (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>hint-pair-list-equiv-of-hint-pair-list-fix-2-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    hint-pair-list-equiv-of-hint-pair-list-fix-2-forward
    (<a href="ACL2____IMPLIES.html">implies</a>
         (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> acl2::x (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> acl2::y))
         (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> acl2::x acl2::y))
    :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>car-of-hint-pair-list-fix-x-under-hint-pair-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> car-of-hint-pair-list-fix-x-under-hint-pair-equiv
        (<a href="SMT____HINT-PAIR-EQUIV.html">hint-pair-equiv</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> acl2::x))
                         (<a href="COMMON-LISP____CAR.html">car</a> acl2::x)))</pre> 
<p><b>Theorem: </b>car-hint-pair-list-equiv-congruence-on-x-under-hint-pair-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     car-hint-pair-list-equiv-congruence-on-x-under-hint-pair-equiv
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> acl2::x x-equiv)
              (<a href="SMT____HINT-PAIR-EQUIV.html">hint-pair-equiv</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::x)
                               (<a href="COMMON-LISP____CAR.html">car</a> x-equiv)))
     :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>cdr-of-hint-pair-list-fix-x-under-hint-pair-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> cdr-of-hint-pair-list-fix-x-under-hint-pair-list-equiv
        (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> acl2::x))
                              (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::x)))</pre> 
<p><b>Theorem: </b>cdr-hint-pair-list-equiv-congruence-on-x-under-hint-pair-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 cdr-hint-pair-list-equiv-congruence-on-x-under-hint-pair-list-equiv
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> acl2::x x-equiv)
          (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::x)
                                (<a href="COMMON-LISP____CDR.html">cdr</a> x-equiv)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>cons-of-hint-pair-fix-x-under-hint-pair-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> cons-of-hint-pair-fix-x-under-hint-pair-list-equiv
        (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> acl2::x) acl2::y)
                              (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y)))</pre> 
<p><b>Theorem: </b>cons-hint-pair-equiv-congruence-on-x-under-hint-pair-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     cons-hint-pair-equiv-congruence-on-x-under-hint-pair-list-equiv
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-EQUIV.html">hint-pair-equiv</a> acl2::x x-equiv)
              (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y)
                                    (<a href="COMMON-LISP____CONS.html">cons</a> x-equiv acl2::y)))
     :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>cons-of-hint-pair-list-fix-y-under-hint-pair-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   cons-of-hint-pair-list-fix-y-under-hint-pair-list-equiv
   (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> acl2::y))
                         (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y)))</pre> 
<p><b>Theorem: </b>cons-hint-pair-list-equiv-congruence-on-y-under-hint-pair-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 cons-hint-pair-list-equiv-congruence-on-y-under-hint-pair-list-equiv
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> acl2::y y-equiv)
          (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y)
                                (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x y-equiv)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>consp-of-hint-pair-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> consp-of-hint-pair-list-fix
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> acl2::x))
               (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x)))</pre> 
<p><b>Theorem: </b>hint-pair-list-fix-under-iff</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-list-fix-under-iff
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> acl2::x)
             (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x)))</pre> 
<p><b>Theorem: </b>hint-pair-list-fix-of-cons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-list-fix-of-cons
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> (<a href="COMMON-LISP____CONS.html">cons</a> a x))
               (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> a)
                     (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> x))))</pre> 
<p><b>Theorem: </b>len-of-hint-pair-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> len-of-hint-pair-list-fix
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> acl2::x))
               (<a href="ACL2____LEN.html">len</a> acl2::x)))</pre> 
<p><b>Theorem: </b>hint-pair-list-fix-of-append</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-list-fix-of-append
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> (<a href="COMMON-LISP____APPEND.html">append</a> std::a std::b))
               (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> std::a)
                       (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> std::b))))</pre> 
<p><b>Theorem: </b>hint-pair-list-fix-of-repeat</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-list-fix-of-repeat
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> (<a href="ACL2____REPEAT.html">acl2::repeat</a> acl2::n acl2::x))
               (<a href="ACL2____REPEAT.html">acl2::repeat</a> acl2::n (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> acl2::x))))</pre> 
<p><b>Theorem: </b>list-equiv-refines-hint-pair-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> list-equiv-refines-hint-pair-list-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____LIST-EQUIV.html">acl2::list-equiv</a> acl2::x acl2::y)
                 (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> acl2::x acl2::y))
        :rule-classes :refinement)</pre> 
<p><b>Theorem: </b>nth-of-hint-pair-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nth-of-hint-pair-list-fix
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTH.html">nth</a> acl2::n (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> acl2::x))
               (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____NFIX.html">nfix</a> acl2::n) (<a href="ACL2____LEN.html">len</a> acl2::x))
                   (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> (<a href="COMMON-LISP____NTH.html">nth</a> acl2::n acl2::x))
                   nil)))</pre> 
<p><b>Theorem: </b>hint-pair-list-equiv-implies-hint-pair-list-equiv-append-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     hint-pair-list-equiv-implies-hint-pair-list-equiv-append-1
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> acl2::x fty::x-equiv)
              (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> (<a href="COMMON-LISP____APPEND.html">append</a> acl2::x acl2::y)
                                    (<a href="COMMON-LISP____APPEND.html">append</a> fty::x-equiv acl2::y)))
     :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>hint-pair-list-equiv-implies-hint-pair-list-equiv-append-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     hint-pair-list-equiv-implies-hint-pair-list-equiv-append-2
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> acl2::y fty::y-equiv)
              (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> (<a href="COMMON-LISP____APPEND.html">append</a> acl2::x acl2::y)
                                    (<a href="COMMON-LISP____APPEND.html">append</a> acl2::x fty::y-equiv)))
     :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>hint-pair-list-equiv-implies-hint-pair-list-equiv-nthcdr-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-list-equiv-implies-hint-pair-list-equiv-nthcdr-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> acl2::l l-equiv)
                 (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> acl2::n acl2::l)
                                       (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> acl2::n l-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>hint-pair-list-equiv-implies-hint-pair-list-equiv-take-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-list-equiv-implies-hint-pair-list-equiv-take-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> acl2::l l-equiv)
                 (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> (<a href="ACL2____TAKE.html">take</a> acl2::n acl2::l)
                                       (<a href="ACL2____TAKE.html">take</a> acl2::n l-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Function: </b>decl-&gt;type-reqfix</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> decl-&gt;type-reqfix (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> x)))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'decl-&gt;type-reqfix))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> x))
                 (<a href="ACL2____THM.html">thm</a> (<a href="SMT____HINT-PAIR-_E3THM.html">hint-pair-&gt;thm</a> x))
                 (hints (<a href="SMT____HINT-PAIR-_E3HINTS.html">hint-pair-&gt;hints</a> x)))
                (<a href="SMT____MAKE-HINT-PAIR.html">make-hint-pair</a> :thm (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> thm) thm nil)
                                :hints (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> hints)))))</pre> 
<p><b>Theorem: </b>hint-pair-p-of-decl-&gt;type-reqfix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-p-of-decl-&gt;type-reqfix
        (<a href="ACL2____B_A2.html">b*</a> ((fixed (decl-&gt;type-reqfix x)))
            (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> fixed))
        :rule-classes :rewrite)</pre> 
<p><b>Function: </b>decl-p</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     decl-p (x)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
     (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'decl-p))
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
          (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____ALISTP.html">alistp</a> x)
                                (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____STRIP-CARS.html">strip-cars</a> x) '(name type)))
                    :exec (fty::alist-with-carsp x '(name type)))
               (<a href="ACL2____B_A2.html">b*</a> ((name (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x)))
                    (<a href="COMMON-LISP____TYPE.html">type</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x))))
                   (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> name)
                        (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> type)
                        (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="SMT____HINT-PAIR-_E3THM.html">hint-pair-&gt;thm</a> type)))))))</pre> 
<p><b>Theorem: </b>consp-when-decl-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> consp-when-decl-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-P.html">decl-p</a> x) (<a href="COMMON-LISP____CONSP.html">consp</a> x))
        :rule-classes :compound-recognizer)</pre> 
<p><b>Function: </b>decl-fix$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 decl-fix$inline (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____DECL-P.html">decl-p</a> x)))
 (<a href="COMMON-LISP____LET.html">let</a>
    ((acl2::__function__ 'decl-fix))
    (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
    (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((name (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x))))
                     (<a href="COMMON-LISP____TYPE.html">type</a> (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x)))))
                    (<a href="COMMON-LISP____LET.html">let</a> ((<a href="COMMON-LISP____TYPE.html">type</a> (decl-&gt;type-reqfix type)))
                         (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'name name)
                               (<a href="COMMON-LISP____CONS.html">cons</a> 'type type))))
         :exec x)))</pre> 
<p><b>Theorem: </b>decl-p-of-decl-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-p-of-decl-fix
        (<a href="ACL2____B_A2.html">b*</a> ((new-x (decl-fix$inline x)))
            (<a href="SMT____DECL-P.html">decl-p</a> new-x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>decl-fix-when-decl-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-fix-when-decl-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-P.html">decl-p</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL-FIX.html">decl-fix</a> x) x)))</pre> 
<p><b>Function: </b>decl-equiv$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> decl-equiv$inline (acl2::x acl2::y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____DECL-P.html">decl-p</a> acl2::x)
                                   (<a href="SMT____DECL-P.html">decl-p</a> acl2::y))))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL-FIX.html">decl-fix</a> acl2::x)
              (<a href="SMT____DECL-FIX.html">decl-fix</a> acl2::y)))</pre> 
<p><b>Theorem: </b>decl-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="SMT____DECL-EQUIV.html">decl-equiv</a> x y))
             (<a href="SMT____DECL-EQUIV.html">decl-equiv</a> x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-EQUIV.html">decl-equiv</a> x y)
                      (<a href="SMT____DECL-EQUIV.html">decl-equiv</a> y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____DECL-EQUIV.html">decl-equiv</a> x y) (<a href="SMT____DECL-EQUIV.html">decl-equiv</a> y z))
                      (<a href="SMT____DECL-EQUIV.html">decl-equiv</a> x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>decl-equiv-implies-equal-decl-fix-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-equiv-implies-equal-decl-fix-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-EQUIV.html">decl-equiv</a> acl2::x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL-FIX.html">decl-fix</a> acl2::x)
                        (<a href="SMT____DECL-FIX.html">decl-fix</a> x-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>decl-fix-under-decl-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-fix-under-decl-equiv
        (<a href="SMT____DECL-EQUIV.html">decl-equiv</a> (<a href="SMT____DECL-FIX.html">decl-fix</a> acl2::x) acl2::x)
        :rule-classes (:rewrite :rewrite-quoted-constant))</pre> 
<p><b>Theorem: </b>equal-of-decl-fix-1-forward-to-decl-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-decl-fix-1-forward-to-decl-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL-FIX.html">decl-fix</a> acl2::x) acl2::y)
                 (<a href="SMT____DECL-EQUIV.html">decl-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>equal-of-decl-fix-2-forward-to-decl-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-decl-fix-2-forward-to-decl-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> acl2::x (<a href="SMT____DECL-FIX.html">decl-fix</a> acl2::y))
                 (<a href="SMT____DECL-EQUIV.html">decl-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>decl-equiv-of-decl-fix-1-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-equiv-of-decl-fix-1-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-EQUIV.html">decl-equiv</a> (<a href="SMT____DECL-FIX.html">decl-fix</a> acl2::x) acl2::y)
                 (<a href="SMT____DECL-EQUIV.html">decl-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>decl-equiv-of-decl-fix-2-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-equiv-of-decl-fix-2-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-EQUIV.html">decl-equiv</a> acl2::x (<a href="SMT____DECL-FIX.html">decl-fix</a> acl2::y))
                 (<a href="SMT____DECL-EQUIV.html">decl-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Function: </b>decl-&gt;name$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> decl-&gt;name$inline (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____DECL-P.html">decl-p</a> x)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'decl-&gt;name))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                            (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x))))
                 :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x)))))</pre> 
<p><b>Theorem: </b>symbolp-of-decl-&gt;name</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbolp-of-decl-&gt;name
        (<a href="ACL2____B_A2.html">b*</a> ((name (decl-&gt;name$inline x)))
            (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> name))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>decl-&gt;name$inline-of-decl-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-&gt;name$inline-of-decl-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (decl-&gt;name$inline (<a href="SMT____DECL-FIX.html">decl-fix</a> x))
               (decl-&gt;name$inline x)))</pre> 
<p><b>Theorem: </b>decl-&gt;name$inline-decl-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-&gt;name$inline-decl-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-EQUIV.html">decl-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (decl-&gt;name$inline x)
                        (decl-&gt;name$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>decl-&gt;type$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 decl-&gt;type$inline (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____DECL-P.html">decl-p</a> x)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
    ((acl2::__function__ 'decl-&gt;type))
    (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
    (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x))
                     (name (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x))))
                     (<a href="COMMON-LISP____TYPE.html">type</a> (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x)))))
                    (decl-&gt;type-reqfix type))
         :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x)))))</pre> 
<p><b>Theorem: </b>hint-pair-p-of-decl-&gt;type</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-p-of-decl-&gt;type
        (<a href="ACL2____B_A2.html">b*</a> ((<a href="COMMON-LISP____TYPE.html">type</a> (decl-&gt;type$inline x)))
            (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> type))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>decl-&gt;type$inline-of-decl-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-&gt;type$inline-of-decl-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (decl-&gt;type$inline (<a href="SMT____DECL-FIX.html">decl-fix</a> x))
               (decl-&gt;type$inline x)))</pre> 
<p><b>Theorem: </b>decl-&gt;type$inline-decl-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-&gt;type$inline-decl-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-EQUIV.html">decl-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (decl-&gt;type$inline x)
                        (decl-&gt;type$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>decl</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> decl (name type)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> name)
                                   (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> type))))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="SMT____HINT-PAIR-_E3THM.html">hint-pair-&gt;thm</a> type))))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'decl))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____B_A2.html">b*</a> ((name (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> name)
                            :exec name))
                 (<a href="COMMON-LISP____TYPE.html">type</a> (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> type)
                            :exec type)))
                (<a href="COMMON-LISP____LET.html">let</a> ((<a href="COMMON-LISP____TYPE.html">type</a> (<a href="ACL2____MBE.html">mbe</a> :logic (decl-&gt;type-reqfix type)
                                 :exec type)))
                     (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'name name)
                           (<a href="COMMON-LISP____CONS.html">cons</a> 'type type))))))</pre> 
<p><b>Theorem: </b>decl-p-of-decl</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-p-of-decl
        (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="SMT____DECL.html">decl</a> name type))) (<a href="SMT____DECL-P.html">decl-p</a> x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>decl-&gt;name-of-decl</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-&gt;name-of-decl
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL-_E3NAME.html">decl-&gt;name</a> (<a href="SMT____DECL.html">decl</a> name type))
               (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> name)))</pre> 
<p><b>Theorem: </b>decl-&gt;type-of-decl</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-&gt;type-of-decl
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL-_E3TYPE.html">decl-&gt;type</a> (<a href="SMT____DECL.html">decl</a> name type))
               (<a href="ACL2____B_A2.html">b*</a> ((?name (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> name))
                    (common-lisp::?type (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> type)))
                   (decl-&gt;type-reqfix type))))</pre> 
<p><b>Theorem: </b>decl-requirements</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-requirements
        (<a href="ACL2____B_A2.html">b*</a> ((?name (<a href="SMT____DECL-_E3NAME.html">decl-&gt;name</a> x))
             (common-lisp::?type (<a href="SMT____DECL-_E3TYPE.html">decl-&gt;type</a> x)))
            (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="SMT____HINT-PAIR-_E3THM.html">hint-pair-&gt;thm</a> type))))</pre> 
<p><b>Theorem: </b>decl-of-fields</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-of-fields
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL.html">decl</a> (<a href="SMT____DECL-_E3NAME.html">decl-&gt;name</a> x) (<a href="SMT____DECL-_E3TYPE.html">decl-&gt;type</a> x))
               (<a href="SMT____DECL-FIX.html">decl-fix</a> x)))</pre> 
<p><b>Theorem: </b>decl-fix-when-decl</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-fix-when-decl
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL-FIX.html">decl-fix</a> x)
               (<a href="SMT____DECL.html">decl</a> (<a href="SMT____DECL-_E3NAME.html">decl-&gt;name</a> x) (<a href="SMT____DECL-_E3TYPE.html">decl-&gt;type</a> x))))</pre> 
<p><b>Theorem: </b>equal-of-decl</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  equal-of-decl
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL.html">decl</a> name type) x)
         (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____DECL-P.html">decl-p</a> x)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL-_E3NAME.html">decl-&gt;name</a> x) (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> name))
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL-_E3TYPE.html">decl-&gt;type</a> x)
                     (<a href="ACL2____B_A2.html">b*</a> ((?name (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> name))
                          (common-lisp::?type (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> type)))
                         (decl-&gt;type-reqfix type))))))</pre> 
<p><b>Theorem: </b>decl-of-symbol-fix-name</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-of-symbol-fix-name
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL.html">decl</a> (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> name) type)
               (<a href="SMT____DECL.html">decl</a> name type)))</pre> 
<p><b>Theorem: </b>decl-symbol-equiv-congruence-on-name</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-symbol-equiv-congruence-on-name
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____SYMBOL-EQUIV.html">acl2::symbol-equiv</a> name name-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL.html">decl</a> name type)
                        (<a href="SMT____DECL.html">decl</a> name-equiv type)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>decl-of-hint-pair-fix-type</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-of-hint-pair-fix-type
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL.html">decl</a> name (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> type))
               (<a href="SMT____DECL.html">decl</a> name type)))</pre> 
<p><b>Theorem: </b>decl-hint-pair-equiv-congruence-on-type</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-hint-pair-equiv-congruence-on-type
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-EQUIV.html">hint-pair-equiv</a> type type-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL.html">decl</a> name type)
                        (<a href="SMT____DECL.html">decl</a> name type-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>decl-fix-redef</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-fix-redef
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL-FIX.html">decl-fix</a> x)
               (<a href="SMT____DECL.html">decl</a> (<a href="SMT____DECL-_E3NAME.html">decl-&gt;name</a> x) (<a href="SMT____DECL-_E3TYPE.html">decl-&gt;type</a> x)))
        :rule-classes :definition)</pre> 
<p><b>Function: </b>decl-listp</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> decl-listp (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'decl-listp))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)
                (<a href="COMMON-LISP____EQ.html">eq</a> x nil)
                (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____DECL-P.html">decl-p</a> (<a href="COMMON-LISP____CAR.html">car</a> x))
                     (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x))))))</pre> 
<p><b>Theorem: </b>decl-listp-of-cons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-of-cons
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::a acl2::x))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____DECL-P.html">decl-p</a> acl2::a)
                    (<a href="SMT____DECL-LISTP.html">decl-listp</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-listp-of-cdr-when-decl-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-of-cdr-when-decl-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-listp-when-not-consp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-when-not-consp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> acl2::x)
                        (<a href="COMMON-LISP____NOT.html">not</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-p-of-car-when-decl-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-p-of-car-when-decl-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> acl2::x)
                 (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____DECL-P.html">decl-p</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::x))
                      (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x) (<a href="SMT____DECL-P.html">decl-p</a> nil))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>true-listp-when-decl-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> true-listp-when-decl-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> acl2::x)
                 (<a href="ACL2____TRUE-LISTP.html">true-listp</a> acl2::x))
        :rule-classes :compound-recognizer)</pre> 
<p><b>Theorem: </b>decl-listp-of-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-of-list-fix
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> acl2::x)
                 (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-listp-of-sfix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-of-sfix
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::x))
             (<a href="COMMON-LISP____OR.html">or</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> acl2::x)
                 (<a href="COMMON-LISP____NOT.html">not</a> (<a href="SET____SETP.html">set::setp</a> acl2::x))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-listp-of-insert</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-of-insert
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="SET____INSERT.html">set::insert</a> acl2::a acl2::x))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::x))
                  (<a href="SMT____DECL-P.html">decl-p</a> acl2::a)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-listp-of-delete</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-of-delete
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> acl2::x)
                 (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="SET____DELETE.html">set::delete</a> acl2::k acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-listp-of-mergesort</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-of-mergesort
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="SET____MERGESORT.html">set::mergesort</a> acl2::x))
             (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-listp-of-union</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-of-union
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="SET____UNION.html">set::union</a> acl2::x acl2::y))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::x))
                  (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::y))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-listp-of-intersect-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-of-intersect-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> acl2::x)
                 (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="SET____INTERSECT.html">set::intersect</a> acl2::x acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-listp-of-intersect-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-of-intersect-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> acl2::y)
                 (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="SET____INTERSECT.html">set::intersect</a> acl2::x acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-listp-of-difference</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-of-difference
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> acl2::x)
                 (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="SET____DIFFERENCE.html">set::difference</a> acl2::x acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-listp-of-duplicated-members</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-of-duplicated-members
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> acl2::x)
                 (<a href="SMT____DECL-LISTP.html">decl-listp</a> (acl2::duplicated-members acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-listp-of-rev</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-of-rev
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="ACL2____REV.html">acl2::rev</a> acl2::x))
               (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-listp-of-append</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-of-append
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="COMMON-LISP____APPEND.html">append</a> acl2::a acl2::b))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::a))
                    (<a href="SMT____DECL-LISTP.html">decl-listp</a> acl2::b)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-listp-of-rcons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-of-rcons
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="ACL2____RCONS.html">acl2::rcons</a> acl2::a acl2::x))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____DECL-P.html">decl-p</a> acl2::a)
                  (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-p-when-member-equal-of-decl-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-p-when-member-equal-of-decl-listp
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> acl2::a acl2::x)
                           (<a href="SMT____DECL-LISTP.html">decl-listp</a> acl2::x))
                      (<a href="SMT____DECL-P.html">decl-p</a> acl2::a))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> acl2::x)
                           (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> acl2::a acl2::x))
                      (<a href="SMT____DECL-P.html">decl-p</a> acl2::a)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-listp-when-subsetp-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-when-subsetp-equal
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SUBSETP-EQUAL.html">subsetp-equal</a> acl2::x acl2::y)
                           (<a href="SMT____DECL-LISTP.html">decl-listp</a> acl2::y))
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> acl2::x)
                             (<a href="ACL2____TRUE-LISTP.html">true-listp</a> acl2::x)))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> acl2::y)
                           (<a href="ACL2____SUBSETP-EQUAL.html">subsetp-equal</a> acl2::x acl2::y))
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> acl2::x)
                             (<a href="ACL2____TRUE-LISTP.html">true-listp</a> acl2::x))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-listp-of-set-difference-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     decl-listp-of-set-difference-equal
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> acl2::x)
              (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="ACL2____SET-DIFFERENCE-EQUAL.html">set-difference-equal</a> acl2::x acl2::y)))
     :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-listp-of-intersection-equal-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-of-intersection-equal-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="ACL2____INTERSECTION-EQUAL.html">intersection-equal</a> acl2::x acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-listp-of-intersection-equal-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-of-intersection-equal-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::y))
                 (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="ACL2____INTERSECTION-EQUAL.html">intersection-equal</a> acl2::x acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-listp-of-union-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-of-union-equal
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="ACL2____UNION-EQUAL.html">union-equal</a> acl2::x acl2::y))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x))
                    (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::y))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-listp-of-take</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-of-take
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="ACL2____TAKE.html">take</a> acl2::n acl2::x))
                      (<a href="COMMON-LISP____OR.html">or</a> (<a href="SMT____DECL-P.html">decl-p</a> nil)
                          (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____NFIX.html">nfix</a> acl2::n) (<a href="ACL2____LEN.html">len</a> acl2::x)))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-listp-of-repeat</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-of-repeat
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="ACL2____REPEAT.html">acl2::repeat</a> acl2::n acl2::x))
             (<a href="COMMON-LISP____OR.html">or</a> (<a href="SMT____DECL-P.html">decl-p</a> acl2::x) (<a href="ACL2____ZP.html">zp</a> acl2::n)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-p-of-nth-when-decl-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-p-of-nth-when-decl-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> acl2::x)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____NFIX.html">nfix</a> acl2::n) (<a href="ACL2____LEN.html">len</a> acl2::x)))
                 (<a href="SMT____DECL-P.html">decl-p</a> (<a href="COMMON-LISP____NTH.html">nth</a> acl2::n acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-listp-of-update-nth</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     decl-listp-of-update-nth
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
              (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="ACL2____UPDATE-NTH.html">update-nth</a> acl2::n acl2::y acl2::x))
                   (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____DECL-P.html">decl-p</a> acl2::y)
                        (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____NFIX.html">nfix</a> acl2::n) (<a href="ACL2____LEN.html">len</a> acl2::x))
                            (<a href="SMT____DECL-P.html">decl-p</a> nil)))))
     :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-listp-of-butlast</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-of-butlast
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="COMMON-LISP____BUTLAST.html">butlast</a> acl2::x acl2::n)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-listp-of-nthcdr</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-of-nthcdr
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> acl2::n acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-listp-of-last</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-of-last
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="COMMON-LISP____LAST.html">last</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-listp-of-remove</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-of-remove
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> acl2::x)
                 (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="COMMON-LISP____REMOVE.html">remove</a> acl2::a acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>decl-listp-of-revappend</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-of-revappend
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="COMMON-LISP____REVAPPEND.html">revappend</a> acl2::x acl2::y))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x))
                    (<a href="SMT____DECL-LISTP.html">decl-listp</a> acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Function: </b>decl-list-fix$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> decl-list-fix$inline (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____DECL-LISTP.html">decl-listp</a> x)))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'decl-list-fix))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)
                            nil
                            (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="SMT____DECL-FIX.html">decl-fix</a> (<a href="COMMON-LISP____CAR.html">car</a> x))
                                  (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x))))
                 :exec x)))</pre> 
<p><b>Theorem: </b>decl-listp-of-decl-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-of-decl-list-fix
        (<a href="ACL2____B_A2.html">b*</a> ((fty::newx (decl-list-fix$inline x)))
            (<a href="SMT____DECL-LISTP.html">decl-listp</a> fty::newx))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>decl-list-fix-when-decl-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-list-fix-when-decl-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> x) x)))</pre> 
<p><b>Function: </b>decl-list-equiv$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> decl-list-equiv$inline (acl2::x acl2::y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> acl2::x)
                                   (<a href="SMT____DECL-LISTP.html">decl-listp</a> acl2::y))))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> acl2::x)
              (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> acl2::y)))</pre> 
<p><b>Theorem: </b>decl-list-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-list-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> x y))
             (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> x y)
                      (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> x y)
                           (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> y z))
                      (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>decl-list-equiv-implies-equal-decl-list-fix-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-list-equiv-implies-equal-decl-list-fix-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> acl2::x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> acl2::x)
                        (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> x-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>decl-list-fix-under-decl-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-list-fix-under-decl-list-equiv
        (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> acl2::x)
                         acl2::x)
        :rule-classes (:rewrite :rewrite-quoted-constant))</pre> 
<p><b>Theorem: </b>equal-of-decl-list-fix-1-forward-to-decl-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-decl-list-fix-1-forward-to-decl-list-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> acl2::x) acl2::y)
                 (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>equal-of-decl-list-fix-2-forward-to-decl-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-decl-list-fix-2-forward-to-decl-list-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> acl2::x (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> acl2::y))
                 (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>decl-list-equiv-of-decl-list-fix-1-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-list-equiv-of-decl-list-fix-1-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> acl2::x)
                                  acl2::y)
                 (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>decl-list-equiv-of-decl-list-fix-2-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-list-equiv-of-decl-list-fix-2-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> acl2::x (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> acl2::y))
                 (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>car-of-decl-list-fix-x-under-decl-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> car-of-decl-list-fix-x-under-decl-equiv
        (<a href="SMT____DECL-EQUIV.html">decl-equiv</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> acl2::x))
                    (<a href="COMMON-LISP____CAR.html">car</a> acl2::x)))</pre> 
<p><b>Theorem: </b>car-decl-list-equiv-congruence-on-x-under-decl-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> car-decl-list-equiv-congruence-on-x-under-decl-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> acl2::x x-equiv)
                 (<a href="SMT____DECL-EQUIV.html">decl-equiv</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::x)
                             (<a href="COMMON-LISP____CAR.html">car</a> x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>cdr-of-decl-list-fix-x-under-decl-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> cdr-of-decl-list-fix-x-under-decl-list-equiv
        (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> acl2::x))
                         (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::x)))</pre> 
<p><b>Theorem: </b>cdr-decl-list-equiv-congruence-on-x-under-decl-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> cdr-decl-list-equiv-congruence-on-x-under-decl-list-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> acl2::x x-equiv)
                 (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::x)
                                  (<a href="COMMON-LISP____CDR.html">cdr</a> x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>cons-of-decl-fix-x-under-decl-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> cons-of-decl-fix-x-under-decl-list-equiv
        (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="SMT____DECL-FIX.html">decl-fix</a> acl2::x) acl2::y)
                         (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y)))</pre> 
<p><b>Theorem: </b>cons-decl-equiv-congruence-on-x-under-decl-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> cons-decl-equiv-congruence-on-x-under-decl-list-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-EQUIV.html">decl-equiv</a> acl2::x x-equiv)
                 (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y)
                                  (<a href="COMMON-LISP____CONS.html">cons</a> x-equiv acl2::y)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>cons-of-decl-list-fix-y-under-decl-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> cons-of-decl-list-fix-y-under-decl-list-equiv
        (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> acl2::y))
                         (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y)))</pre> 
<p><b>Theorem: </b>cons-decl-list-equiv-congruence-on-y-under-decl-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> cons-decl-list-equiv-congruence-on-y-under-decl-list-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> acl2::y y-equiv)
                 (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y)
                                  (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x y-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>consp-of-decl-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> consp-of-decl-list-fix
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> acl2::x))
               (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x)))</pre> 
<p><b>Theorem: </b>decl-list-fix-under-iff</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-list-fix-under-iff
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> acl2::x)
             (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x)))</pre> 
<p><b>Theorem: </b>decl-list-fix-of-cons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-list-fix-of-cons
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> (<a href="COMMON-LISP____CONS.html">cons</a> a x))
               (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="SMT____DECL-FIX.html">decl-fix</a> a) (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> x))))</pre> 
<p><b>Theorem: </b>len-of-decl-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> len-of-decl-list-fix
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> acl2::x))
               (<a href="ACL2____LEN.html">len</a> acl2::x)))</pre> 
<p><b>Theorem: </b>decl-list-fix-of-append</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-list-fix-of-append
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> (<a href="COMMON-LISP____APPEND.html">append</a> std::a std::b))
               (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> std::a)
                       (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> std::b))))</pre> 
<p><b>Theorem: </b>decl-list-fix-of-repeat</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-list-fix-of-repeat
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> (<a href="ACL2____REPEAT.html">acl2::repeat</a> acl2::n acl2::x))
               (<a href="ACL2____REPEAT.html">acl2::repeat</a> acl2::n (<a href="SMT____DECL-FIX.html">decl-fix</a> acl2::x))))</pre> 
<p><b>Theorem: </b>list-equiv-refines-decl-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> list-equiv-refines-decl-list-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____LIST-EQUIV.html">acl2::list-equiv</a> acl2::x acl2::y)
                 (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> acl2::x acl2::y))
        :rule-classes :refinement)</pre> 
<p><b>Theorem: </b>nth-of-decl-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nth-of-decl-list-fix
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTH.html">nth</a> acl2::n (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> acl2::x))
               (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____NFIX.html">nfix</a> acl2::n) (<a href="ACL2____LEN.html">len</a> acl2::x))
                   (<a href="SMT____DECL-FIX.html">decl-fix</a> (<a href="COMMON-LISP____NTH.html">nth</a> acl2::n acl2::x))
                   nil)))</pre> 
<p><b>Theorem: </b>decl-list-equiv-implies-decl-list-equiv-append-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-list-equiv-implies-decl-list-equiv-append-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> acl2::x fty::x-equiv)
                 (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> (<a href="COMMON-LISP____APPEND.html">append</a> acl2::x acl2::y)
                                  (<a href="COMMON-LISP____APPEND.html">append</a> fty::x-equiv acl2::y)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>decl-list-equiv-implies-decl-list-equiv-append-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-list-equiv-implies-decl-list-equiv-append-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> acl2::y fty::y-equiv)
                 (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> (<a href="COMMON-LISP____APPEND.html">append</a> acl2::x acl2::y)
                                  (<a href="COMMON-LISP____APPEND.html">append</a> acl2::x fty::y-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>decl-list-equiv-implies-decl-list-equiv-nthcdr-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-list-equiv-implies-decl-list-equiv-nthcdr-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> acl2::l l-equiv)
                 (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> acl2::n acl2::l)
                                  (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> acl2::n l-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>decl-list-equiv-implies-decl-list-equiv-take-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-list-equiv-implies-decl-list-equiv-take-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> acl2::l l-equiv)
                 (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> (<a href="ACL2____TAKE.html">take</a> acl2::n acl2::l)
                                  (<a href="ACL2____TAKE.html">take</a> acl2::n l-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Function: </b>func-p</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 func-p (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'func-p))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="COMMON-LISP____AND.html">and</a>
   (<a href="ACL2____MBE.html">mbe</a>
    :logic (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____ALISTP.html">alistp</a> x)
                (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____STRIP-CARS.html">strip-cars</a> x)
                       '(name formals guard
                              returns more-returns expansion-depth
                              flattened-formals flattened-returns)))
    :exec (fty::alist-with-carsp
               x
               '(name formals guard
                      returns more-returns expansion-depth
                      flattened-formals flattened-returns)))
   (<a href="ACL2____B_A2.html">b*</a> ((name (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x)))
        (<a href="ACL2____FORMALS.html">formals</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x)))
        (<a href="ACL2____GUARD.html">guard</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 2 x)))
        (returns (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 3 x)))
        (<a href="ACL2____MORE-RETURNS.html">more-returns</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 4 x)))
        (expansion-depth (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 5 x)))
        (flattened-formals (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 6 x)))
        (flattened-returns (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 7 x))))
       (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> name)
            (<a href="SMT____DECL-LISTP.html">decl-listp</a> formals)
            (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> guard)
            (<a href="SMT____DECL-LISTP.html">decl-listp</a> returns)
            (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> more-returns)
            (<a href="ACL2____NATP.html">natp</a> expansion-depth)
            (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> flattened-formals)
            (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> flattened-returns))))))</pre> 
<p><b>Theorem: </b>consp-when-func-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> consp-when-func-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-P.html">func-p</a> x) (<a href="COMMON-LISP____CONSP.html">consp</a> x))
        :rule-classes :compound-recognizer)</pre> 
<p><b>Function: </b>func-fix$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 func-fix$inline (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____FUNC-P.html">func-p</a> x)))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'func-fix))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____MBE.html">mbe</a>
   :logic
   (<a href="ACL2____B_A2.html">b*</a>
     ((name (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x))))
      (<a href="ACL2____FORMALS.html">formals</a> (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x))))
      (<a href="ACL2____GUARD.html">guard</a> (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 2 x))))
      (returns (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 3 x))))
      (<a href="ACL2____MORE-RETURNS.html">more-returns</a> (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 4 x))))
      (expansion-depth (<a href="ACL2____NFIX.html">nfix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 5 x))))
      (flattened-formals (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 6 x))))
      (flattened-returns (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 7 x)))))
     (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'name name)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'formals formals)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'guard guard)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'returns returns)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'more-returns more-returns)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'expansion-depth expansion-depth)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'flattened-formals
                 flattened-formals)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'flattened-returns
                 flattened-returns)))
   :exec x)))</pre> 
<p><b>Theorem: </b>func-p-of-func-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-p-of-func-fix
        (<a href="ACL2____B_A2.html">b*</a> ((new-x (func-fix$inline x)))
            (<a href="SMT____FUNC-P.html">func-p</a> new-x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>func-fix-when-func-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-fix-when-func-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-P.html">func-p</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-FIX.html">func-fix</a> x) x)))</pre> 
<p><b>Function: </b>func-equiv$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> func-equiv$inline (acl2::x acl2::y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-P.html">func-p</a> acl2::x)
                                   (<a href="SMT____FUNC-P.html">func-p</a> acl2::y))))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-FIX.html">func-fix</a> acl2::x)
              (<a href="SMT____FUNC-FIX.html">func-fix</a> acl2::y)))</pre> 
<p><b>Theorem: </b>func-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="SMT____FUNC-EQUIV.html">func-equiv</a> x y))
             (<a href="SMT____FUNC-EQUIV.html">func-equiv</a> x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-EQUIV.html">func-equiv</a> x y)
                      (<a href="SMT____FUNC-EQUIV.html">func-equiv</a> y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-EQUIV.html">func-equiv</a> x y) (<a href="SMT____FUNC-EQUIV.html">func-equiv</a> y z))
                      (<a href="SMT____FUNC-EQUIV.html">func-equiv</a> x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>func-equiv-implies-equal-func-fix-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-equiv-implies-equal-func-fix-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-EQUIV.html">func-equiv</a> acl2::x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-FIX.html">func-fix</a> acl2::x)
                        (<a href="SMT____FUNC-FIX.html">func-fix</a> x-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>func-fix-under-func-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-fix-under-func-equiv
        (<a href="SMT____FUNC-EQUIV.html">func-equiv</a> (<a href="SMT____FUNC-FIX.html">func-fix</a> acl2::x) acl2::x)
        :rule-classes (:rewrite :rewrite-quoted-constant))</pre> 
<p><b>Theorem: </b>equal-of-func-fix-1-forward-to-func-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-func-fix-1-forward-to-func-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-FIX.html">func-fix</a> acl2::x) acl2::y)
                 (<a href="SMT____FUNC-EQUIV.html">func-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>equal-of-func-fix-2-forward-to-func-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-func-fix-2-forward-to-func-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> acl2::x (<a href="SMT____FUNC-FIX.html">func-fix</a> acl2::y))
                 (<a href="SMT____FUNC-EQUIV.html">func-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>func-equiv-of-func-fix-1-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-equiv-of-func-fix-1-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-EQUIV.html">func-equiv</a> (<a href="SMT____FUNC-FIX.html">func-fix</a> acl2::x) acl2::y)
                 (<a href="SMT____FUNC-EQUIV.html">func-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>func-equiv-of-func-fix-2-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-equiv-of-func-fix-2-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-EQUIV.html">func-equiv</a> acl2::x (<a href="SMT____FUNC-FIX.html">func-fix</a> acl2::y))
                 (<a href="SMT____FUNC-EQUIV.html">func-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Function: </b>func-&gt;name$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> func-&gt;name$inline (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____FUNC-P.html">func-p</a> x)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'func-&gt;name))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                            (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x))))
                 :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x)))))</pre> 
<p><b>Theorem: </b>symbolp-of-func-&gt;name</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbolp-of-func-&gt;name
        (<a href="ACL2____B_A2.html">b*</a> ((name (func-&gt;name$inline x)))
            (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> name))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>func-&gt;name$inline-of-func-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-&gt;name$inline-of-func-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (func-&gt;name$inline (<a href="SMT____FUNC-FIX.html">func-fix</a> x))
               (func-&gt;name$inline x)))</pre> 
<p><b>Theorem: </b>func-&gt;name$inline-func-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-&gt;name$inline-func-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-EQUIV.html">func-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (func-&gt;name$inline x)
                        (func-&gt;name$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>func-&gt;formals$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> func-&gt;formals$inline (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____FUNC-P.html">func-p</a> x)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'func-&gt;formals))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                            (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x))))
                 :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x)))))</pre> 
<p><b>Theorem: </b>decl-listp-of-func-&gt;formals</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-of-func-&gt;formals
        (<a href="ACL2____B_A2.html">b*</a> ((<a href="ACL2____FORMALS.html">formals</a> (func-&gt;formals$inline x)))
            (<a href="SMT____DECL-LISTP.html">decl-listp</a> formals))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>func-&gt;formals$inline-of-func-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-&gt;formals$inline-of-func-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (func-&gt;formals$inline (<a href="SMT____FUNC-FIX.html">func-fix</a> x))
               (func-&gt;formals$inline x)))</pre> 
<p><b>Theorem: </b>func-&gt;formals$inline-func-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-&gt;formals$inline-func-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-EQUIV.html">func-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (func-&gt;formals$inline x)
                        (func-&gt;formals$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>func-&gt;guard$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> func-&gt;guard$inline (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____FUNC-P.html">func-p</a> x)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'func-&gt;guard))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                            (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 2 x))))
                 :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 2 x)))))</pre> 
<p><b>Theorem: </b>hint-pair-p-of-func-&gt;guard</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-p-of-func-&gt;guard
        (<a href="ACL2____B_A2.html">b*</a> ((<a href="ACL2____GUARD.html">guard</a> (func-&gt;guard$inline x)))
            (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> guard))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>func-&gt;guard$inline-of-func-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-&gt;guard$inline-of-func-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (func-&gt;guard$inline (<a href="SMT____FUNC-FIX.html">func-fix</a> x))
               (func-&gt;guard$inline x)))</pre> 
<p><b>Theorem: </b>func-&gt;guard$inline-func-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-&gt;guard$inline-func-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-EQUIV.html">func-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (func-&gt;guard$inline x)
                        (func-&gt;guard$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>func-&gt;returns$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> func-&gt;returns$inline (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____FUNC-P.html">func-p</a> x)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'func-&gt;returns))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                            (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 3 x))))
                 :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 3 x)))))</pre> 
<p><b>Theorem: </b>decl-listp-of-func-&gt;returns</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> decl-listp-of-func-&gt;returns
        (<a href="ACL2____B_A2.html">b*</a> ((returns (func-&gt;returns$inline x)))
            (<a href="SMT____DECL-LISTP.html">decl-listp</a> returns))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>func-&gt;returns$inline-of-func-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-&gt;returns$inline-of-func-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (func-&gt;returns$inline (<a href="SMT____FUNC-FIX.html">func-fix</a> x))
               (func-&gt;returns$inline x)))</pre> 
<p><b>Theorem: </b>func-&gt;returns$inline-func-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-&gt;returns$inline-func-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-EQUIV.html">func-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (func-&gt;returns$inline x)
                        (func-&gt;returns$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>func-&gt;more-returns$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
  func-&gt;more-returns$inline (x)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____FUNC-P.html">func-p</a> x)))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
  (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'func-&gt;more-returns))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
       (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                       (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 4 x))))
            :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 4 x)))))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-func-&gt;more-returns</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-func-&gt;more-returns
        (<a href="ACL2____B_A2.html">b*</a> ((<a href="ACL2____MORE-RETURNS.html">more-returns</a> (func-&gt;more-returns$inline x)))
            (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> more-returns))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>func-&gt;more-returns$inline-of-func-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-&gt;more-returns$inline-of-func-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (func-&gt;more-returns$inline (<a href="SMT____FUNC-FIX.html">func-fix</a> x))
               (func-&gt;more-returns$inline x)))</pre> 
<p><b>Theorem: </b>func-&gt;more-returns$inline-func-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-&gt;more-returns$inline-func-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-EQUIV.html">func-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (func-&gt;more-returns$inline x)
                        (func-&gt;more-returns$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>func-&gt;expansion-depth$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> func-&gt;expansion-depth$inline (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____FUNC-P.html">func-p</a> x)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'func-&gt;expansion-depth))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                            (<a href="ACL2____NFIX.html">nfix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 5 x))))
                 :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 5 x)))))</pre> 
<p><b>Theorem: </b>natp-of-func-&gt;expansion-depth</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> natp-of-func-&gt;expansion-depth
        (<a href="ACL2____B_A2.html">b*</a> ((expansion-depth (func-&gt;expansion-depth$inline x)))
            (<a href="ACL2____NATP.html">natp</a> expansion-depth))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>func-&gt;expansion-depth$inline-of-func-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-&gt;expansion-depth$inline-of-func-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (func-&gt;expansion-depth$inline (<a href="SMT____FUNC-FIX.html">func-fix</a> x))
               (func-&gt;expansion-depth$inline x)))</pre> 
<p><b>Theorem: </b>func-&gt;expansion-depth$inline-func-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-&gt;expansion-depth$inline-func-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-EQUIV.html">func-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (func-&gt;expansion-depth$inline x)
                        (func-&gt;expansion-depth$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>func-&gt;flattened-formals$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     func-&gt;flattened-formals$inline (x)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____FUNC-P.html">func-p</a> x)))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
     (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'func-&gt;flattened-formals))
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
          (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                          (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 6 x))))
               :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 6 x)))))</pre> 
<p><b>Theorem: </b>symbol-listp-of-func-&gt;flattened-formals</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-listp-of-func-&gt;flattened-formals
        (<a href="ACL2____B_A2.html">b*</a> ((flattened-formals (func-&gt;flattened-formals$inline x)))
            (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> flattened-formals))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>func-&gt;flattened-formals$inline-of-func-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-&gt;flattened-formals$inline-of-func-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (func-&gt;flattened-formals$inline (<a href="SMT____FUNC-FIX.html">func-fix</a> x))
               (func-&gt;flattened-formals$inline x)))</pre> 
<p><b>Theorem: </b>func-&gt;flattened-formals$inline-func-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-&gt;flattened-formals$inline-func-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-EQUIV.html">func-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (func-&gt;flattened-formals$inline x)
                        (func-&gt;flattened-formals$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>func-&gt;flattened-returns$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     func-&gt;flattened-returns$inline (x)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____FUNC-P.html">func-p</a> x)))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
     (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'func-&gt;flattened-returns))
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
          (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                          (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 7 x))))
               :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 7 x)))))</pre> 
<p><b>Theorem: </b>symbol-listp-of-func-&gt;flattened-returns</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-listp-of-func-&gt;flattened-returns
        (<a href="ACL2____B_A2.html">b*</a> ((flattened-returns (func-&gt;flattened-returns$inline x)))
            (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> flattened-returns))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>func-&gt;flattened-returns$inline-of-func-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-&gt;flattened-returns$inline-of-func-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (func-&gt;flattened-returns$inline (<a href="SMT____FUNC-FIX.html">func-fix</a> x))
               (func-&gt;flattened-returns$inline x)))</pre> 
<p><b>Theorem: </b>func-&gt;flattened-returns$inline-func-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-&gt;flattened-returns$inline-func-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-EQUIV.html">func-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (func-&gt;flattened-returns$inline x)
                        (func-&gt;flattened-returns$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>func</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 func
 (name formals guard
       returns more-returns expansion-depth
       flattened-formals flattened-returns)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> name)
                             (<a href="SMT____DECL-LISTP.html">decl-listp</a> formals)
                             (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> guard)
                             (<a href="SMT____DECL-LISTP.html">decl-listp</a> returns)
                             (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> more-returns)
                             (<a href="ACL2____NATP.html">natp</a> expansion-depth)
                             (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> flattened-formals)
                             (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> flattened-returns))))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
    ((acl2::__function__ 'func))
    (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
    (<a href="ACL2____B_A2.html">b*</a> ((name (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> name)
                    :exec name))
         (<a href="ACL2____FORMALS.html">formals</a> (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> formals)
                       :exec formals))
         (<a href="ACL2____GUARD.html">guard</a> (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> guard)
                     :exec guard))
         (returns (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> returns)
                       :exec returns))
         (<a href="ACL2____MORE-RETURNS.html">more-returns</a> (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> more-returns)
                            :exec more-returns))
         (expansion-depth (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____NFIX.html">nfix</a> expansion-depth)
                               :exec expansion-depth))
         (flattened-formals
              (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> flattened-formals)
                   :exec flattened-formals))
         (flattened-returns
              (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> flattened-returns)
                   :exec flattened-returns)))
        (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'name name)
              (<a href="COMMON-LISP____CONS.html">cons</a> 'formals formals)
              (<a href="COMMON-LISP____CONS.html">cons</a> 'guard guard)
              (<a href="COMMON-LISP____CONS.html">cons</a> 'returns returns)
              (<a href="COMMON-LISP____CONS.html">cons</a> 'more-returns more-returns)
              (<a href="COMMON-LISP____CONS.html">cons</a> 'expansion-depth expansion-depth)
              (<a href="COMMON-LISP____CONS.html">cons</a> 'flattened-formals
                    flattened-formals)
              (<a href="COMMON-LISP____CONS.html">cons</a> 'flattened-returns
                    flattened-returns)))))</pre> 
<p><b>Theorem: </b>func-p-of-func</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-p-of-func
        (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="SMT____FUNC.html">func</a> name formals guard
                      returns more-returns expansion-depth
                      flattened-formals flattened-returns)))
            (<a href="SMT____FUNC-P.html">func-p</a> x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>func-&gt;name-of-func</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     func-&gt;name-of-func
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-_E3NAME.html">func-&gt;name</a> (<a href="SMT____FUNC.html">func</a> name formals guard
                              returns more-returns expansion-depth
                              flattened-formals flattened-returns))
            (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> name)))</pre> 
<p><b>Theorem: </b>func-&gt;formals-of-func</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   func-&gt;formals-of-func
   (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-_E3FORMALS.html">func-&gt;formals</a> (<a href="SMT____FUNC.html">func</a> name formals guard
                               returns more-returns expansion-depth
                               flattened-formals flattened-returns))
          (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> formals)))</pre> 
<p><b>Theorem: </b>func-&gt;guard-of-func</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     func-&gt;guard-of-func
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-_E3GUARD.html">func-&gt;guard</a> (<a href="SMT____FUNC.html">func</a> name formals guard
                               returns more-returns expansion-depth
                               flattened-formals flattened-returns))
            (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> guard)))</pre> 
<p><b>Theorem: </b>func-&gt;returns-of-func</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   func-&gt;returns-of-func
   (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-_E3RETURNS.html">func-&gt;returns</a> (<a href="SMT____FUNC.html">func</a> name formals guard
                               returns more-returns expansion-depth
                               flattened-formals flattened-returns))
          (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> returns)))</pre> 
<p><b>Theorem: </b>func-&gt;more-returns-of-func</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 func-&gt;more-returns-of-func
 (<a href="COMMON-LISP____EQUAL.html">equal</a>
     (<a href="SMT____FUNC-_E3MORE-RETURNS.html">func-&gt;more-returns</a> (<a href="SMT____FUNC.html">func</a> name formals guard
                               returns more-returns expansion-depth
                               flattened-formals flattened-returns))
     (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> more-returns)))</pre> 
<p><b>Theorem: </b>func-&gt;expansion-depth-of-func</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 func-&gt;expansion-depth-of-func
 (<a href="COMMON-LISP____EQUAL.html">equal</a>
  (<a href="SMT____FUNC-_E3EXPANSION-DEPTH.html">func-&gt;expansion-depth</a> (<a href="SMT____FUNC.html">func</a> name formals guard
                               returns more-returns expansion-depth
                               flattened-formals flattened-returns))
  (<a href="ACL2____NFIX.html">nfix</a> expansion-depth)))</pre> 
<p><b>Theorem: </b>func-&gt;flattened-formals-of-func</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-&gt;flattened-formals-of-func
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-_E3FLATTENED-FORMALS.html">func-&gt;flattened-formals</a>
                    (<a href="SMT____FUNC.html">func</a> name formals guard
                          returns more-returns expansion-depth
                          flattened-formals flattened-returns))
               (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> flattened-formals)))</pre> 
<p><b>Theorem: </b>func-&gt;flattened-returns-of-func</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-&gt;flattened-returns-of-func
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-_E3FLATTENED-RETURNS.html">func-&gt;flattened-returns</a>
                    (<a href="SMT____FUNC.html">func</a> name formals guard
                          returns more-returns expansion-depth
                          flattened-formals flattened-returns))
               (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> flattened-returns)))</pre> 
<p><b>Theorem: </b>func-of-fields</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-of-fields
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC.html">func</a> (<a href="SMT____FUNC-_E3NAME.html">func-&gt;name</a> x)
                     (<a href="SMT____FUNC-_E3FORMALS.html">func-&gt;formals</a> x)
                     (<a href="SMT____FUNC-_E3GUARD.html">func-&gt;guard</a> x)
                     (<a href="SMT____FUNC-_E3RETURNS.html">func-&gt;returns</a> x)
                     (<a href="SMT____FUNC-_E3MORE-RETURNS.html">func-&gt;more-returns</a> x)
                     (<a href="SMT____FUNC-_E3EXPANSION-DEPTH.html">func-&gt;expansion-depth</a> x)
                     (<a href="SMT____FUNC-_E3FLATTENED-FORMALS.html">func-&gt;flattened-formals</a> x)
                     (<a href="SMT____FUNC-_E3FLATTENED-RETURNS.html">func-&gt;flattened-returns</a> x))
               (<a href="SMT____FUNC-FIX.html">func-fix</a> x)))</pre> 
<p><b>Theorem: </b>func-fix-when-func</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-fix-when-func
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-FIX.html">func-fix</a> x)
               (<a href="SMT____FUNC.html">func</a> (<a href="SMT____FUNC-_E3NAME.html">func-&gt;name</a> x)
                     (<a href="SMT____FUNC-_E3FORMALS.html">func-&gt;formals</a> x)
                     (<a href="SMT____FUNC-_E3GUARD.html">func-&gt;guard</a> x)
                     (<a href="SMT____FUNC-_E3RETURNS.html">func-&gt;returns</a> x)
                     (<a href="SMT____FUNC-_E3MORE-RETURNS.html">func-&gt;more-returns</a> x)
                     (<a href="SMT____FUNC-_E3EXPANSION-DEPTH.html">func-&gt;expansion-depth</a> x)
                     (<a href="SMT____FUNC-_E3FLATTENED-FORMALS.html">func-&gt;flattened-formals</a> x)
                     (<a href="SMT____FUNC-_E3FLATTENED-RETURNS.html">func-&gt;flattened-returns</a> x))))</pre> 
<p><b>Theorem: </b>equal-of-func</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-func
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC.html">func</a> name formals guard
                            returns more-returns expansion-depth
                            flattened-formals flattened-returns)
                      x)
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-P.html">func-p</a> x)
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-_E3NAME.html">func-&gt;name</a> x) (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> name))
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-_E3FORMALS.html">func-&gt;formals</a> x)
                           (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> formals))
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-_E3GUARD.html">func-&gt;guard</a> x)
                           (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> guard))
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-_E3RETURNS.html">func-&gt;returns</a> x)
                           (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> returns))
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-_E3MORE-RETURNS.html">func-&gt;more-returns</a> x)
                           (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> more-returns))
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-_E3EXPANSION-DEPTH.html">func-&gt;expansion-depth</a> x)
                           (<a href="ACL2____NFIX.html">nfix</a> expansion-depth))
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-_E3FLATTENED-FORMALS.html">func-&gt;flattened-formals</a> x)
                           (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> flattened-formals))
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-_E3FLATTENED-RETURNS.html">func-&gt;flattened-returns</a> x)
                           (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> flattened-returns)))))</pre> 
<p><b>Theorem: </b>func-of-symbol-fix-name</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-of-symbol-fix-name
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC.html">func</a> (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> name)
                     formals guard
                     returns more-returns expansion-depth
                     flattened-formals flattened-returns)
               (<a href="SMT____FUNC.html">func</a> name formals guard
                     returns more-returns expansion-depth
                     flattened-formals flattened-returns)))</pre> 
<p><b>Theorem: </b>func-symbol-equiv-congruence-on-name</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-symbol-equiv-congruence-on-name
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____SYMBOL-EQUIV.html">acl2::symbol-equiv</a> name name-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC.html">func</a> name formals guard
                              returns more-returns expansion-depth
                              flattened-formals flattened-returns)
                        (<a href="SMT____FUNC.html">func</a> name-equiv formals guard
                              returns more-returns expansion-depth
                              flattened-formals flattened-returns)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>func-of-decl-list-fix-formals</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-of-decl-list-fix-formals
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC.html">func</a> name (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> formals)
                     guard
                     returns more-returns expansion-depth
                     flattened-formals flattened-returns)
               (<a href="SMT____FUNC.html">func</a> name formals guard
                     returns more-returns expansion-depth
                     flattened-formals flattened-returns)))</pre> 
<p><b>Theorem: </b>func-decl-list-equiv-congruence-on-formals</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-decl-list-equiv-congruence-on-formals
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> formals formals-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC.html">func</a> name formals guard
                              returns more-returns expansion-depth
                              flattened-formals flattened-returns)
                        (<a href="SMT____FUNC.html">func</a> name formals-equiv guard
                              returns more-returns expansion-depth
                              flattened-formals flattened-returns)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>func-of-hint-pair-fix-guard</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-of-hint-pair-fix-guard
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC.html">func</a> name formals (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> guard)
                     returns more-returns expansion-depth
                     flattened-formals flattened-returns)
               (<a href="SMT____FUNC.html">func</a> name formals guard
                     returns more-returns expansion-depth
                     flattened-formals flattened-returns)))</pre> 
<p><b>Theorem: </b>func-hint-pair-equiv-congruence-on-guard</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-hint-pair-equiv-congruence-on-guard
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-EQUIV.html">hint-pair-equiv</a> guard guard-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC.html">func</a> name formals guard
                              returns more-returns expansion-depth
                              flattened-formals flattened-returns)
                        (<a href="SMT____FUNC.html">func</a> name formals guard-equiv
                              returns more-returns expansion-depth
                              flattened-formals flattened-returns)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>func-of-decl-list-fix-returns</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-of-decl-list-fix-returns
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC.html">func</a> name
                     formals guard (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> returns)
                     more-returns expansion-depth
                     flattened-formals flattened-returns)
               (<a href="SMT____FUNC.html">func</a> name formals guard
                     returns more-returns expansion-depth
                     flattened-formals flattened-returns)))</pre> 
<p><b>Theorem: </b>func-decl-list-equiv-congruence-on-returns</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-decl-list-equiv-congruence-on-returns
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____DECL-LIST-EQUIV.html">decl-list-equiv</a> returns returns-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC.html">func</a> name formals guard
                              returns more-returns expansion-depth
                              flattened-formals flattened-returns)
                        (<a href="SMT____FUNC.html">func</a> name formals guard returns-equiv
                              more-returns expansion-depth
                              flattened-formals flattened-returns)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>func-of-hint-pair-list-fix-more-returns</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-of-hint-pair-list-fix-more-returns
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC.html">func</a> name formals guard returns
                     (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> more-returns)
                     expansion-depth
                     flattened-formals flattened-returns)
               (<a href="SMT____FUNC.html">func</a> name formals guard
                     returns more-returns expansion-depth
                     flattened-formals flattened-returns)))</pre> 
<p><b>Theorem: </b>func-hint-pair-list-equiv-congruence-on-more-returns</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     func-hint-pair-list-equiv-congruence-on-more-returns
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> more-returns more-returns-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC.html">func</a> name formals guard
                           returns more-returns expansion-depth
                           flattened-formals flattened-returns)
                     (<a href="SMT____FUNC.html">func</a> name formals guard returns
                           more-returns-equiv expansion-depth
                           flattened-formals flattened-returns)))
     :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>func-of-nfix-expansion-depth</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-of-nfix-expansion-depth
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC.html">func</a> name formals guard returns
                     more-returns (<a href="ACL2____NFIX.html">nfix</a> expansion-depth)
                     flattened-formals flattened-returns)
               (<a href="SMT____FUNC.html">func</a> name formals guard
                     returns more-returns expansion-depth
                     flattened-formals flattened-returns)))</pre> 
<p><b>Theorem: </b>func-nat-equiv-congruence-on-expansion-depth</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    func-nat-equiv-congruence-on-expansion-depth
    (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____NAT-EQUIV.html">acl2::nat-equiv</a> expansion-depth expansion-depth-equiv)
             (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC.html">func</a> name formals guard
                          returns more-returns expansion-depth
                          flattened-formals flattened-returns)
                    (<a href="SMT____FUNC.html">func</a> name formals guard returns
                          more-returns expansion-depth-equiv
                          flattened-formals flattened-returns)))
    :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>func-of-symbol-list-fix-flattened-formals</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-of-symbol-list-fix-flattened-formals
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC.html">func</a> name formals guard
                     returns more-returns expansion-depth
                     (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> flattened-formals)
                     flattened-returns)
               (<a href="SMT____FUNC.html">func</a> name formals guard
                     returns more-returns expansion-depth
                     flattened-formals flattened-returns)))</pre> 
<p><b>Theorem: </b>func-symbol-list-equiv-congruence-on-flattened-formals</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     func-symbol-list-equiv-congruence-on-flattened-formals
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____SYMBOL-LIST-EQUIV.html">acl2::symbol-list-equiv</a> flattened-formals
                                       flattened-formals-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC.html">func</a> name formals guard
                           returns more-returns expansion-depth
                           flattened-formals flattened-returns)
                     (<a href="SMT____FUNC.html">func</a> name formals guard returns more-returns
                           expansion-depth flattened-formals-equiv
                           flattened-returns)))
     :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>func-of-symbol-list-fix-flattened-returns</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-of-symbol-list-fix-flattened-returns
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC.html">func</a> name formals guard returns more-returns
                     expansion-depth flattened-formals
                     (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> flattened-returns))
               (<a href="SMT____FUNC.html">func</a> name formals guard
                     returns more-returns expansion-depth
                     flattened-formals flattened-returns)))</pre> 
<p><b>Theorem: </b>func-symbol-list-equiv-congruence-on-flattened-returns</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     func-symbol-list-equiv-congruence-on-flattened-returns
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____SYMBOL-LIST-EQUIV.html">acl2::symbol-list-equiv</a> flattened-returns
                                       flattened-returns-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC.html">func</a> name formals guard
                           returns more-returns expansion-depth
                           flattened-formals flattened-returns)
                     (<a href="SMT____FUNC.html">func</a> name formals guard returns more-returns
                           expansion-depth flattened-formals
                           flattened-returns-equiv)))
     :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>func-fix-redef</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-fix-redef
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-FIX.html">func-fix</a> x)
               (<a href="SMT____FUNC.html">func</a> (<a href="SMT____FUNC-_E3NAME.html">func-&gt;name</a> x)
                     (<a href="SMT____FUNC-_E3FORMALS.html">func-&gt;formals</a> x)
                     (<a href="SMT____FUNC-_E3GUARD.html">func-&gt;guard</a> x)
                     (<a href="SMT____FUNC-_E3RETURNS.html">func-&gt;returns</a> x)
                     (<a href="SMT____FUNC-_E3MORE-RETURNS.html">func-&gt;more-returns</a> x)
                     (<a href="SMT____FUNC-_E3EXPANSION-DEPTH.html">func-&gt;expansion-depth</a> x)
                     (<a href="SMT____FUNC-_E3FLATTENED-FORMALS.html">func-&gt;flattened-formals</a> x)
                     (<a href="SMT____FUNC-_E3FLATTENED-RETURNS.html">func-&gt;flattened-returns</a> x)))
        :rule-classes :definition)</pre> 
<p><b>Function: </b>func-listp</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> func-listp (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'func-listp))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)
                (<a href="COMMON-LISP____EQ.html">eq</a> x nil)
                (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-P.html">func-p</a> (<a href="COMMON-LISP____CAR.html">car</a> x))
                     (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x))))))</pre> 
<p><b>Theorem: </b>func-listp-of-cons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-listp-of-cons
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::a acl2::x))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-P.html">func-p</a> acl2::a)
                    (<a href="SMT____FUNC-LISTP.html">func-listp</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-listp-of-cdr-when-func-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-listp-of-cdr-when-func-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-listp-when-not-consp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-listp-when-not-consp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> acl2::x)
                        (<a href="COMMON-LISP____NOT.html">not</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-p-of-car-when-func-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-p-of-car-when-func-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> acl2::x)
                 (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____FUNC-P.html">func-p</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::x))
                      (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x) (<a href="SMT____FUNC-P.html">func-p</a> nil))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>true-listp-when-func-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> true-listp-when-func-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> acl2::x)
                 (<a href="ACL2____TRUE-LISTP.html">true-listp</a> acl2::x))
        :rule-classes :compound-recognizer)</pre> 
<p><b>Theorem: </b>func-listp-of-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-listp-of-list-fix
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> acl2::x)
                 (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-listp-of-sfix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-listp-of-sfix
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::x))
             (<a href="COMMON-LISP____OR.html">or</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> acl2::x)
                 (<a href="COMMON-LISP____NOT.html">not</a> (<a href="SET____SETP.html">set::setp</a> acl2::x))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-listp-of-insert</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-listp-of-insert
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="SET____INSERT.html">set::insert</a> acl2::a acl2::x))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::x))
                  (<a href="SMT____FUNC-P.html">func-p</a> acl2::a)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-listp-of-delete</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-listp-of-delete
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> acl2::x)
                 (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="SET____DELETE.html">set::delete</a> acl2::k acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-listp-of-mergesort</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-listp-of-mergesort
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="SET____MERGESORT.html">set::mergesort</a> acl2::x))
             (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-listp-of-union</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-listp-of-union
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="SET____UNION.html">set::union</a> acl2::x acl2::y))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::x))
                  (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::y))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-listp-of-intersect-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-listp-of-intersect-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> acl2::x)
                 (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="SET____INTERSECT.html">set::intersect</a> acl2::x acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-listp-of-intersect-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-listp-of-intersect-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> acl2::y)
                 (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="SET____INTERSECT.html">set::intersect</a> acl2::x acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-listp-of-difference</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-listp-of-difference
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> acl2::x)
                 (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="SET____DIFFERENCE.html">set::difference</a> acl2::x acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-listp-of-duplicated-members</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-listp-of-duplicated-members
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> acl2::x)
                 (<a href="SMT____FUNC-LISTP.html">func-listp</a> (acl2::duplicated-members acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-listp-of-rev</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-listp-of-rev
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="ACL2____REV.html">acl2::rev</a> acl2::x))
               (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-listp-of-append</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-listp-of-append
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="COMMON-LISP____APPEND.html">append</a> acl2::a acl2::b))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::a))
                    (<a href="SMT____FUNC-LISTP.html">func-listp</a> acl2::b)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-listp-of-rcons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-listp-of-rcons
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="ACL2____RCONS.html">acl2::rcons</a> acl2::a acl2::x))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-P.html">func-p</a> acl2::a)
                  (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-p-when-member-equal-of-func-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-p-when-member-equal-of-func-listp
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> acl2::a acl2::x)
                           (<a href="SMT____FUNC-LISTP.html">func-listp</a> acl2::x))
                      (<a href="SMT____FUNC-P.html">func-p</a> acl2::a))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> acl2::x)
                           (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> acl2::a acl2::x))
                      (<a href="SMT____FUNC-P.html">func-p</a> acl2::a)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-listp-when-subsetp-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-listp-when-subsetp-equal
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SUBSETP-EQUAL.html">subsetp-equal</a> acl2::x acl2::y)
                           (<a href="SMT____FUNC-LISTP.html">func-listp</a> acl2::y))
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> acl2::x)
                             (<a href="ACL2____TRUE-LISTP.html">true-listp</a> acl2::x)))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> acl2::y)
                           (<a href="ACL2____SUBSETP-EQUAL.html">subsetp-equal</a> acl2::x acl2::y))
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> acl2::x)
                             (<a href="ACL2____TRUE-LISTP.html">true-listp</a> acl2::x))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-listp-of-set-difference-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     func-listp-of-set-difference-equal
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> acl2::x)
              (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="ACL2____SET-DIFFERENCE-EQUAL.html">set-difference-equal</a> acl2::x acl2::y)))
     :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-listp-of-intersection-equal-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-listp-of-intersection-equal-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="ACL2____INTERSECTION-EQUAL.html">intersection-equal</a> acl2::x acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-listp-of-intersection-equal-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-listp-of-intersection-equal-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::y))
                 (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="ACL2____INTERSECTION-EQUAL.html">intersection-equal</a> acl2::x acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-listp-of-union-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-listp-of-union-equal
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="ACL2____UNION-EQUAL.html">union-equal</a> acl2::x acl2::y))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x))
                    (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::y))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-listp-of-take</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-listp-of-take
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="ACL2____TAKE.html">take</a> acl2::n acl2::x))
                      (<a href="COMMON-LISP____OR.html">or</a> (<a href="SMT____FUNC-P.html">func-p</a> nil)
                          (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____NFIX.html">nfix</a> acl2::n) (<a href="ACL2____LEN.html">len</a> acl2::x)))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-listp-of-repeat</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-listp-of-repeat
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="ACL2____REPEAT.html">acl2::repeat</a> acl2::n acl2::x))
             (<a href="COMMON-LISP____OR.html">or</a> (<a href="SMT____FUNC-P.html">func-p</a> acl2::x) (<a href="ACL2____ZP.html">zp</a> acl2::n)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-p-of-nth-when-func-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-p-of-nth-when-func-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> acl2::x)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____NFIX.html">nfix</a> acl2::n) (<a href="ACL2____LEN.html">len</a> acl2::x)))
                 (<a href="SMT____FUNC-P.html">func-p</a> (<a href="COMMON-LISP____NTH.html">nth</a> acl2::n acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-listp-of-update-nth</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     func-listp-of-update-nth
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
              (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="ACL2____UPDATE-NTH.html">update-nth</a> acl2::n acl2::y acl2::x))
                   (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-P.html">func-p</a> acl2::y)
                        (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____NFIX.html">nfix</a> acl2::n) (<a href="ACL2____LEN.html">len</a> acl2::x))
                            (<a href="SMT____FUNC-P.html">func-p</a> nil)))))
     :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-listp-of-butlast</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-listp-of-butlast
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="COMMON-LISP____BUTLAST.html">butlast</a> acl2::x acl2::n)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-listp-of-nthcdr</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-listp-of-nthcdr
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> acl2::n acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-listp-of-last</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-listp-of-last
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="COMMON-LISP____LAST.html">last</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-listp-of-remove</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-listp-of-remove
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> acl2::x)
                 (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="COMMON-LISP____REMOVE.html">remove</a> acl2::a acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-listp-of-revappend</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-listp-of-revappend
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="COMMON-LISP____REVAPPEND.html">revappend</a> acl2::x acl2::y))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x))
                    (<a href="SMT____FUNC-LISTP.html">func-listp</a> acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Function: </b>func-list-fix$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> func-list-fix$inline (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____FUNC-LISTP.html">func-listp</a> x)))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'func-list-fix))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)
                            nil
                            (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="SMT____FUNC-FIX.html">func-fix</a> (<a href="COMMON-LISP____CAR.html">car</a> x))
                                  (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x))))
                 :exec x)))</pre> 
<p><b>Theorem: </b>func-listp-of-func-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-listp-of-func-list-fix
        (<a href="ACL2____B_A2.html">b*</a> ((fty::newx (func-list-fix$inline x)))
            (<a href="SMT____FUNC-LISTP.html">func-listp</a> fty::newx))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>func-list-fix-when-func-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-list-fix-when-func-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> x) x)))</pre> 
<p><b>Function: </b>func-list-equiv$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> func-list-equiv$inline (acl2::x acl2::y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> acl2::x)
                                   (<a href="SMT____FUNC-LISTP.html">func-listp</a> acl2::y))))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> acl2::x)
              (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> acl2::y)))</pre> 
<p><b>Theorem: </b>func-list-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-list-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> x y))
             (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> x y)
                      (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> x y)
                           (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> y z))
                      (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>func-list-equiv-implies-equal-func-list-fix-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-list-equiv-implies-equal-func-list-fix-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> acl2::x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> acl2::x)
                        (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> x-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>func-list-fix-under-func-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-list-fix-under-func-list-equiv
        (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> acl2::x)
                         acl2::x)
        :rule-classes (:rewrite :rewrite-quoted-constant))</pre> 
<p><b>Theorem: </b>equal-of-func-list-fix-1-forward-to-func-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-func-list-fix-1-forward-to-func-list-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> acl2::x) acl2::y)
                 (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>equal-of-func-list-fix-2-forward-to-func-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-func-list-fix-2-forward-to-func-list-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> acl2::x (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> acl2::y))
                 (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>func-list-equiv-of-func-list-fix-1-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-list-equiv-of-func-list-fix-1-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> acl2::x)
                                  acl2::y)
                 (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>func-list-equiv-of-func-list-fix-2-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-list-equiv-of-func-list-fix-2-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> acl2::x (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> acl2::y))
                 (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>car-of-func-list-fix-x-under-func-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> car-of-func-list-fix-x-under-func-equiv
        (<a href="SMT____FUNC-EQUIV.html">func-equiv</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> acl2::x))
                    (<a href="COMMON-LISP____CAR.html">car</a> acl2::x)))</pre> 
<p><b>Theorem: </b>car-func-list-equiv-congruence-on-x-under-func-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> car-func-list-equiv-congruence-on-x-under-func-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> acl2::x x-equiv)
                 (<a href="SMT____FUNC-EQUIV.html">func-equiv</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::x)
                             (<a href="COMMON-LISP____CAR.html">car</a> x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>cdr-of-func-list-fix-x-under-func-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> cdr-of-func-list-fix-x-under-func-list-equiv
        (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> acl2::x))
                         (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::x)))</pre> 
<p><b>Theorem: </b>cdr-func-list-equiv-congruence-on-x-under-func-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> cdr-func-list-equiv-congruence-on-x-under-func-list-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> acl2::x x-equiv)
                 (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::x)
                                  (<a href="COMMON-LISP____CDR.html">cdr</a> x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>cons-of-func-fix-x-under-func-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> cons-of-func-fix-x-under-func-list-equiv
        (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="SMT____FUNC-FIX.html">func-fix</a> acl2::x) acl2::y)
                         (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y)))</pre> 
<p><b>Theorem: </b>cons-func-equiv-congruence-on-x-under-func-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> cons-func-equiv-congruence-on-x-under-func-list-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-EQUIV.html">func-equiv</a> acl2::x x-equiv)
                 (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y)
                                  (<a href="COMMON-LISP____CONS.html">cons</a> x-equiv acl2::y)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>cons-of-func-list-fix-y-under-func-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> cons-of-func-list-fix-y-under-func-list-equiv
        (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> acl2::y))
                         (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y)))</pre> 
<p><b>Theorem: </b>cons-func-list-equiv-congruence-on-y-under-func-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> cons-func-list-equiv-congruence-on-y-under-func-list-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> acl2::y y-equiv)
                 (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y)
                                  (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x y-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>consp-of-func-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> consp-of-func-list-fix
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> acl2::x))
               (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x)))</pre> 
<p><b>Theorem: </b>func-list-fix-under-iff</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-list-fix-under-iff
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> acl2::x)
             (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x)))</pre> 
<p><b>Theorem: </b>func-list-fix-of-cons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-list-fix-of-cons
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> (<a href="COMMON-LISP____CONS.html">cons</a> a x))
               (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="SMT____FUNC-FIX.html">func-fix</a> a) (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> x))))</pre> 
<p><b>Theorem: </b>len-of-func-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> len-of-func-list-fix
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> acl2::x))
               (<a href="ACL2____LEN.html">len</a> acl2::x)))</pre> 
<p><b>Theorem: </b>func-list-fix-of-append</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-list-fix-of-append
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> (<a href="COMMON-LISP____APPEND.html">append</a> std::a std::b))
               (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> std::a)
                       (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> std::b))))</pre> 
<p><b>Theorem: </b>func-list-fix-of-repeat</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-list-fix-of-repeat
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> (<a href="ACL2____REPEAT.html">acl2::repeat</a> acl2::n acl2::x))
               (<a href="ACL2____REPEAT.html">acl2::repeat</a> acl2::n (<a href="SMT____FUNC-FIX.html">func-fix</a> acl2::x))))</pre> 
<p><b>Theorem: </b>list-equiv-refines-func-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> list-equiv-refines-func-list-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____LIST-EQUIV.html">acl2::list-equiv</a> acl2::x acl2::y)
                 (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> acl2::x acl2::y))
        :rule-classes :refinement)</pre> 
<p><b>Theorem: </b>nth-of-func-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nth-of-func-list-fix
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTH.html">nth</a> acl2::n (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> acl2::x))
               (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____NFIX.html">nfix</a> acl2::n) (<a href="ACL2____LEN.html">len</a> acl2::x))
                   (<a href="SMT____FUNC-FIX.html">func-fix</a> (<a href="COMMON-LISP____NTH.html">nth</a> acl2::n acl2::x))
                   nil)))</pre> 
<p><b>Theorem: </b>func-list-equiv-implies-func-list-equiv-append-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-list-equiv-implies-func-list-equiv-append-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> acl2::x fty::x-equiv)
                 (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> (<a href="COMMON-LISP____APPEND.html">append</a> acl2::x acl2::y)
                                  (<a href="COMMON-LISP____APPEND.html">append</a> fty::x-equiv acl2::y)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>func-list-equiv-implies-func-list-equiv-append-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-list-equiv-implies-func-list-equiv-append-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> acl2::y fty::y-equiv)
                 (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> (<a href="COMMON-LISP____APPEND.html">append</a> acl2::x acl2::y)
                                  (<a href="COMMON-LISP____APPEND.html">append</a> acl2::x fty::y-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>func-list-equiv-implies-func-list-equiv-nthcdr-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-list-equiv-implies-func-list-equiv-nthcdr-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> acl2::l l-equiv)
                 (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> acl2::n acl2::l)
                                  (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> acl2::n l-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>func-list-equiv-implies-func-list-equiv-take-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-list-equiv-implies-func-list-equiv-take-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> acl2::l l-equiv)
                 (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> (<a href="ACL2____TAKE.html">take</a> acl2::n acl2::l)
                                  (<a href="ACL2____TAKE.html">take</a> acl2::n l-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Function: </b>func-alistp</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> func-alistp (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'func-alistp))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)
                (<a href="COMMON-LISP____EQ.html">eq</a> x nil)
                (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CAR.html">car</a> x))
                     (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAAR.html">caar</a> x))
                     (<a href="SMT____FUNC-P.html">func-p</a> (<a href="COMMON-LISP____CDAR.html">cdar</a> x))
                     (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x))))))</pre> 
<p><b>Theorem: </b>func-alistp-of-revappend</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-revappend
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="COMMON-LISP____REVAPPEND.html">revappend</a> acl2::x acl2::y))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x))
                    (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-remove</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-remove
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::x)
                 (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="COMMON-LISP____REMOVE.html">remove</a> acl2::a acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-last</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-last
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="COMMON-LISP____LAST.html">last</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-nthcdr</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-nthcdr
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> acl2::n acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-butlast</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-butlast
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="COMMON-LISP____BUTLAST.html">butlast</a> acl2::x acl2::n)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-update-nth</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    func-alistp-of-update-nth
    (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
             (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="ACL2____UPDATE-NTH.html">update-nth</a> acl2::n acl2::y acl2::x))
                  (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::y)
                            (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::y))
                            (<a href="SMT____FUNC-P.html">func-p</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::y)))
                       (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____NFIX.html">nfix</a> acl2::n) (<a href="ACL2____LEN.html">len</a> acl2::x))
                           (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> nil)
                                (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> nil))
                                (<a href="SMT____FUNC-P.html">func-p</a> (<a href="COMMON-LISP____CDR.html">cdr</a> nil)))))))
    :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-repeat</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-repeat
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="ACL2____REPEAT.html">acl2::repeat</a> acl2::n acl2::x))
             (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x)
                      (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::x))
                      (<a href="SMT____FUNC-P.html">func-p</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::x)))
                 (<a href="ACL2____ZP.html">zp</a> acl2::n)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-take</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-take
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="ACL2____TAKE.html">take</a> acl2::n acl2::x))
                      (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> nil)
                               (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> nil))
                               (<a href="SMT____FUNC-P.html">func-p</a> (<a href="COMMON-LISP____CDR.html">cdr</a> nil)))
                          (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____NFIX.html">nfix</a> acl2::n) (<a href="ACL2____LEN.html">len</a> acl2::x)))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-union-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-union-equal
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="ACL2____UNION-EQUAL.html">union-equal</a> acl2::x acl2::y))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x))
                    (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::y))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-intersection-equal-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-intersection-equal-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::y))
                 (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="ACL2____INTERSECTION-EQUAL.html">intersection-equal</a> acl2::x acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-intersection-equal-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-intersection-equal-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="ACL2____INTERSECTION-EQUAL.html">intersection-equal</a> acl2::x acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-set-difference-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     func-alistp-of-set-difference-equal
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::x)
              (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="ACL2____SET-DIFFERENCE-EQUAL.html">set-difference-equal</a> acl2::x acl2::y)))
     :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-when-subsetp-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-when-subsetp-equal
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SUBSETP-EQUAL.html">subsetp-equal</a> acl2::x acl2::y)
                           (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::y))
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::x)
                             (<a href="ACL2____TRUE-LISTP.html">true-listp</a> acl2::x)))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::y)
                           (<a href="ACL2____SUBSETP-EQUAL.html">subsetp-equal</a> acl2::x acl2::y))
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::x)
                             (<a href="ACL2____TRUE-LISTP.html">true-listp</a> acl2::x))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-rcons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-rcons
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="ACL2____RCONS.html">acl2::rcons</a> acl2::a acl2::x))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::a)
                       (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::a))
                       (<a href="SMT____FUNC-P.html">func-p</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::a)))
                  (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-append</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-append
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="COMMON-LISP____APPEND.html">append</a> acl2::a acl2::b))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::a))
                    (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::b)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-rev</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-rev
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="ACL2____REV.html">acl2::rev</a> acl2::x))
               (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-duplicated-members</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-duplicated-members
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::x)
                 (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (acl2::duplicated-members acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-difference</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-difference
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::x)
                 (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="SET____DIFFERENCE.html">set::difference</a> acl2::x acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-intersect-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-intersect-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::y)
                 (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="SET____INTERSECT.html">set::intersect</a> acl2::x acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-intersect-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-intersect-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::x)
                 (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="SET____INTERSECT.html">set::intersect</a> acl2::x acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-union</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-union
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="SET____UNION.html">set::union</a> acl2::x acl2::y))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::x))
                  (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::y))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-mergesort</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-mergesort
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="SET____MERGESORT.html">set::mergesort</a> acl2::x))
             (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-delete</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-delete
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::x)
                 (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="SET____DELETE.html">set::delete</a> acl2::k acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-insert</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-insert
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="SET____INSERT.html">set::insert</a> acl2::a acl2::x))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::x))
                  (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::a)
                       (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::a))
                       (<a href="SMT____FUNC-P.html">func-p</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::a)))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-sfix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-sfix
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::x))
             (<a href="COMMON-LISP____OR.html">or</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::x)
                 (<a href="COMMON-LISP____NOT.html">not</a> (<a href="SET____SETP.html">set::setp</a> acl2::x))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-list-fix
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::x)
                 (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>true-listp-when-func-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> true-listp-when-func-alistp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::x)
                 (<a href="ACL2____TRUE-LISTP.html">true-listp</a> acl2::x))
        :rule-classes :compound-recognizer)</pre> 
<p><b>Theorem: </b>func-alistp-when-not-consp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-when-not-consp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::x)
                        (<a href="COMMON-LISP____NOT.html">not</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-cdr-when-func-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-cdr-when-func-alistp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-cons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-cons
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::a acl2::x))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::a)
                         (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::a))
                         (<a href="SMT____FUNC-P.html">func-p</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::a)))
                    (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-remove-assoc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     func-alistp-of-remove-assoc
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::x)
              (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="ACL2____REMOVE-ASSOC-EQUAL.html">remove-assoc-equal</a> acl2::name acl2::x)))
     :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-put-assoc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 func-alistp-of-put-assoc
 (<a href="ACL2____IMPLIES.html">implies</a>
   (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::x))
   (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="ACL2____PUT-ASSOC-EQUAL.html">put-assoc-equal</a> acl2::name acl2::val acl2::x))
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> acl2::name)
             (<a href="SMT____FUNC-P.html">func-p</a> acl2::val))))
 :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-hons-shrink-alist</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-hons-shrink-alist
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::x)
                      (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::y))
                 (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="ACL2____HONS-SHRINK-ALIST.html">hons-shrink-alist</a> acl2::x acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-alistp-of-hons-acons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-hons-acons
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> (<a href="ACL2____HONS-ACONS.html">hons-acons</a> acl2::a acl2::n acl2::x))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> acl2::a)
                    (<a href="SMT____FUNC-P.html">func-p</a> acl2::n)
                    (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>func-p-of-cdr-of-hons-assoc-equal-when-func-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     func-p-of-cdr-of-hons-assoc-equal-when-func-alistp
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::x)
              (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____FUNC-P.html">func-p</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="ACL2____HONS-ASSOC-EQUAL.html">hons-assoc-equal</a> acl2::k acl2::x)))
                   (<a href="COMMON-LISP____OR.html">or</a> (<a href="ACL2____HONS-ASSOC-EQUAL.html">hons-assoc-equal</a> acl2::k acl2::x)
                       (<a href="SMT____FUNC-P.html">func-p</a> nil))))
     :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>alistp-when-func-alistp-rewrite</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> alistp-when-func-alistp-rewrite
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::x)
                 (<a href="ACL2____ALISTP.html">alistp</a> acl2::x))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>alistp-when-func-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> alistp-when-func-alistp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::x)
                 (<a href="ACL2____ALISTP.html">alistp</a> acl2::x))
        :rule-classes :tau-system)</pre> 
<p><b>Theorem: </b>func-p-of-cdar-when-func-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-p-of-cdar-when-func-alistp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::x)
                 (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____FUNC-P.html">func-p</a> (<a href="COMMON-LISP____CDAR.html">cdar</a> acl2::x))
                      (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x) (<a href="SMT____FUNC-P.html">func-p</a> nil))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>symbolp-of-caar-when-func-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbolp-of-caar-when-func-alistp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::x)
                 (<a href="ACL2____IFF.html">iff</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAAR.html">caar</a> acl2::x))
                      (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x) (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> nil))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Function: </b>func-alist-fix$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> func-alist-fix$inline (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> x)))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'func-alist-fix))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)
                            nil
                            (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CAR.html">car</a> x))
                                (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> (<a href="COMMON-LISP____CAAR.html">caar</a> x))
                                            (<a href="SMT____FUNC-FIX.html">func-fix</a> (<a href="COMMON-LISP____CDAR.html">cdar</a> x)))
                                      (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x)))
                                (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x))))
                 :exec x)))</pre> 
<p><b>Theorem: </b>func-alistp-of-func-alist-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-func-alist-fix
        (<a href="ACL2____B_A2.html">b*</a> ((fty::newx (func-alist-fix$inline x)))
            (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> fty::newx))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>func-alist-fix-when-func-alistp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alist-fix-when-func-alistp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> x) x)))</pre> 
<p><b>Function: </b>func-alist-equiv$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> func-alist-equiv$inline
       (acl2::x acl2::y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::x)
                                   (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> acl2::y))))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> acl2::x)
              (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> acl2::y)))</pre> 
<p><b>Theorem: </b>func-alist-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alist-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="SMT____FUNC-ALIST-EQUIV.html">func-alist-equiv</a> x y))
             (<a href="SMT____FUNC-ALIST-EQUIV.html">func-alist-equiv</a> x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALIST-EQUIV.html">func-alist-equiv</a> x y)
                      (<a href="SMT____FUNC-ALIST-EQUIV.html">func-alist-equiv</a> y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-ALIST-EQUIV.html">func-alist-equiv</a> x y)
                           (<a href="SMT____FUNC-ALIST-EQUIV.html">func-alist-equiv</a> y z))
                      (<a href="SMT____FUNC-ALIST-EQUIV.html">func-alist-equiv</a> x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>func-alist-equiv-implies-equal-func-alist-fix-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alist-equiv-implies-equal-func-alist-fix-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALIST-EQUIV.html">func-alist-equiv</a> acl2::x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> acl2::x)
                        (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> x-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>func-alist-fix-under-func-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alist-fix-under-func-alist-equiv
        (<a href="SMT____FUNC-ALIST-EQUIV.html">func-alist-equiv</a> (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> acl2::x)
                          acl2::x)
        :rule-classes (:rewrite :rewrite-quoted-constant))</pre> 
<p><b>Theorem: </b>equal-of-func-alist-fix-1-forward-to-func-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-func-alist-fix-1-forward-to-func-alist-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> acl2::x) acl2::y)
                 (<a href="SMT____FUNC-ALIST-EQUIV.html">func-alist-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>equal-of-func-alist-fix-2-forward-to-func-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-func-alist-fix-2-forward-to-func-alist-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> acl2::x (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> acl2::y))
                 (<a href="SMT____FUNC-ALIST-EQUIV.html">func-alist-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>func-alist-equiv-of-func-alist-fix-1-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alist-equiv-of-func-alist-fix-1-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALIST-EQUIV.html">func-alist-equiv</a> (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> acl2::x)
                                   acl2::y)
                 (<a href="SMT____FUNC-ALIST-EQUIV.html">func-alist-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>func-alist-equiv-of-func-alist-fix-2-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alist-equiv-of-func-alist-fix-2-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALIST-EQUIV.html">func-alist-equiv</a> acl2::x (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> acl2::y))
                 (<a href="SMT____FUNC-ALIST-EQUIV.html">func-alist-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>cons-of-symbol-fix-k-under-func-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> cons-of-symbol-fix-k-under-func-alist-equiv
        (<a href="SMT____FUNC-ALIST-EQUIV.html">func-alist-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> acl2::k) acl2::v)
                                acl2::x)
                          (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::k acl2::v) acl2::x)))</pre> 
<p><b>Theorem: </b>cons-symbol-equiv-congruence-on-k-under-func-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  cons-symbol-equiv-congruence-on-k-under-func-alist-equiv
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____SYMBOL-EQUIV.html">acl2::symbol-equiv</a> acl2::k k-equiv)
           (<a href="SMT____FUNC-ALIST-EQUIV.html">func-alist-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::k acl2::v) acl2::x)
                             (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> k-equiv acl2::v) acl2::x)))
  :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>cons-of-func-fix-v-under-func-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> cons-of-func-fix-v-under-func-alist-equiv
        (<a href="SMT____FUNC-ALIST-EQUIV.html">func-alist-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::k (<a href="SMT____FUNC-FIX.html">func-fix</a> acl2::v))
                                acl2::x)
                          (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::k acl2::v) acl2::x)))</pre> 
<p><b>Theorem: </b>cons-func-equiv-congruence-on-v-under-func-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  cons-func-equiv-congruence-on-v-under-func-alist-equiv
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-EQUIV.html">func-equiv</a> acl2::v v-equiv)
           (<a href="SMT____FUNC-ALIST-EQUIV.html">func-alist-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::k acl2::v) acl2::x)
                             (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::k v-equiv) acl2::x)))
  :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>cons-of-func-alist-fix-y-under-func-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> cons-of-func-alist-fix-y-under-func-alist-equiv
        (<a href="SMT____FUNC-ALIST-EQUIV.html">func-alist-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> acl2::y))
                          (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y)))</pre> 
<p><b>Theorem: </b>cons-func-alist-equiv-congruence-on-y-under-func-alist-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> cons-func-alist-equiv-congruence-on-y-under-func-alist-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALIST-EQUIV.html">func-alist-equiv</a> acl2::y y-equiv)
                 (<a href="SMT____FUNC-ALIST-EQUIV.html">func-alist-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y)
                                   (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x y-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>func-alist-fix-of-acons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alist-fix-of-acons
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::a acl2::b) x))
               (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> acl2::a)
                           (<a href="SMT____FUNC-FIX.html">func-fix</a> acl2::b))
                     (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> x))))</pre> 
<p><b>Theorem: </b>func-alist-fix-of-append</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alist-fix-of-append
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> (<a href="COMMON-LISP____APPEND.html">append</a> std::a std::b))
               (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> std::a)
                       (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> std::b))))</pre> 
<p><b>Theorem: </b>consp-car-of-func-alist-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> consp-car-of-func-alist-fix
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> x)))
               (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> x))))</pre> 
<p><b>Function: </b>binding-p</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 binding-p (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'binding-p))
      (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
      (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____ALISTP.html">alistp</a> x)
                            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____STRIP-CARS.html">strip-cars</a> x) '(var expr type)))
                :exec (fty::alist-with-carsp x '(var expr type)))
           (<a href="ACL2____B_A2.html">b*</a> ((var (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x)))
                (expr (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x)))
                (<a href="COMMON-LISP____TYPE.html">type</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 2 x))))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> var)
                    (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> expr)
                    (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> type))))))</pre> 
<p><b>Theorem: </b>consp-when-binding-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> consp-when-binding-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-P.html">binding-p</a> x) (<a href="COMMON-LISP____CONSP.html">consp</a> x))
        :rule-classes :compound-recognizer)</pre> 
<p><b>Function: </b>binding-fix$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 binding-fix$inline (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____BINDING-P.html">binding-p</a> x)))
 (<a href="COMMON-LISP____LET.html">let</a>
   ((acl2::__function__ 'binding-fix))
   (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
   (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((var (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x))))
                    (expr (pseudo-term-fix (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x))))
                    (<a href="COMMON-LISP____TYPE.html">type</a> (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 2 x)))))
                   (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'var var)
                         (<a href="COMMON-LISP____CONS.html">cons</a> 'expr expr)
                         (<a href="COMMON-LISP____CONS.html">cons</a> 'type type)))
        :exec x)))</pre> 
<p><b>Theorem: </b>binding-p-of-binding-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-p-of-binding-fix
        (<a href="ACL2____B_A2.html">b*</a> ((new-x (binding-fix$inline x)))
            (<a href="SMT____BINDING-P.html">binding-p</a> new-x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>binding-fix-when-binding-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-fix-when-binding-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-P.html">binding-p</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING-FIX.html">binding-fix</a> x) x)))</pre> 
<p><b>Function: </b>binding-equiv$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> binding-equiv$inline (acl2::x acl2::y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____BINDING-P.html">binding-p</a> acl2::x)
                                   (<a href="SMT____BINDING-P.html">binding-p</a> acl2::y))))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING-FIX.html">binding-fix</a> acl2::x)
              (<a href="SMT____BINDING-FIX.html">binding-fix</a> acl2::y)))</pre> 
<p><b>Theorem: </b>binding-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="SMT____BINDING-EQUIV.html">binding-equiv</a> x y))
             (<a href="SMT____BINDING-EQUIV.html">binding-equiv</a> x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-EQUIV.html">binding-equiv</a> x y)
                      (<a href="SMT____BINDING-EQUIV.html">binding-equiv</a> y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____BINDING-EQUIV.html">binding-equiv</a> x y)
                           (<a href="SMT____BINDING-EQUIV.html">binding-equiv</a> y z))
                      (<a href="SMT____BINDING-EQUIV.html">binding-equiv</a> x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>binding-equiv-implies-equal-binding-fix-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-equiv-implies-equal-binding-fix-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-EQUIV.html">binding-equiv</a> acl2::x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING-FIX.html">binding-fix</a> acl2::x)
                        (<a href="SMT____BINDING-FIX.html">binding-fix</a> x-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>binding-fix-under-binding-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-fix-under-binding-equiv
        (<a href="SMT____BINDING-EQUIV.html">binding-equiv</a> (<a href="SMT____BINDING-FIX.html">binding-fix</a> acl2::x)
                       acl2::x)
        :rule-classes (:rewrite :rewrite-quoted-constant))</pre> 
<p><b>Theorem: </b>equal-of-binding-fix-1-forward-to-binding-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-binding-fix-1-forward-to-binding-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING-FIX.html">binding-fix</a> acl2::x) acl2::y)
                 (<a href="SMT____BINDING-EQUIV.html">binding-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>equal-of-binding-fix-2-forward-to-binding-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-binding-fix-2-forward-to-binding-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> acl2::x (<a href="SMT____BINDING-FIX.html">binding-fix</a> acl2::y))
                 (<a href="SMT____BINDING-EQUIV.html">binding-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>binding-equiv-of-binding-fix-1-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-equiv-of-binding-fix-1-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-EQUIV.html">binding-equiv</a> (<a href="SMT____BINDING-FIX.html">binding-fix</a> acl2::x)
                                acl2::y)
                 (<a href="SMT____BINDING-EQUIV.html">binding-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>binding-equiv-of-binding-fix-2-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-equiv-of-binding-fix-2-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-EQUIV.html">binding-equiv</a> acl2::x (<a href="SMT____BINDING-FIX.html">binding-fix</a> acl2::y))
                 (<a href="SMT____BINDING-EQUIV.html">binding-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Function: </b>binding-&gt;var$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> binding-&gt;var$inline (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____BINDING-P.html">binding-p</a> x)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'binding-&gt;var))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                            (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x))))
                 :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x)))))</pre> 
<p><b>Theorem: </b>symbolp-of-binding-&gt;var</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbolp-of-binding-&gt;var
        (<a href="ACL2____B_A2.html">b*</a> ((var (binding-&gt;var$inline x)))
            (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> var))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>binding-&gt;var$inline-of-binding-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-&gt;var$inline-of-binding-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (binding-&gt;var$inline (<a href="SMT____BINDING-FIX.html">binding-fix</a> x))
               (binding-&gt;var$inline x)))</pre> 
<p><b>Theorem: </b>binding-&gt;var$inline-binding-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-&gt;var$inline-binding-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-EQUIV.html">binding-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (binding-&gt;var$inline x)
                        (binding-&gt;var$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>binding-&gt;expr$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     binding-&gt;expr$inline (x)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____BINDING-P.html">binding-p</a> x)))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
     (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'binding-&gt;expr))
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
          (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                          (pseudo-term-fix (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x))))
               :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x)))))</pre> 
<p><b>Theorem: </b>pseudo-termp-of-binding-&gt;expr</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-termp-of-binding-&gt;expr
        (<a href="ACL2____B_A2.html">b*</a> ((expr (binding-&gt;expr$inline x)))
            (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> expr))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>binding-&gt;expr$inline-of-binding-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-&gt;expr$inline-of-binding-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (binding-&gt;expr$inline (<a href="SMT____BINDING-FIX.html">binding-fix</a> x))
               (binding-&gt;expr$inline x)))</pre> 
<p><b>Theorem: </b>binding-&gt;expr$inline-binding-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-&gt;expr$inline-binding-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-EQUIV.html">binding-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (binding-&gt;expr$inline x)
                        (binding-&gt;expr$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>binding-&gt;type$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> binding-&gt;type$inline (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____BINDING-P.html">binding-p</a> x)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'binding-&gt;type))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                            (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 2 x))))
                 :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 2 x)))))</pre> 
<p><b>Theorem: </b>symbolp-of-binding-&gt;type</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbolp-of-binding-&gt;type
        (<a href="ACL2____B_A2.html">b*</a> ((<a href="COMMON-LISP____TYPE.html">type</a> (binding-&gt;type$inline x)))
            (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> type))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>binding-&gt;type$inline-of-binding-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-&gt;type$inline-of-binding-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (binding-&gt;type$inline (<a href="SMT____BINDING-FIX.html">binding-fix</a> x))
               (binding-&gt;type$inline x)))</pre> 
<p><b>Theorem: </b>binding-&gt;type$inline-binding-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-&gt;type$inline-binding-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-EQUIV.html">binding-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (binding-&gt;type$inline x)
                        (binding-&gt;type$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>binding</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> binding (var expr type)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> var)
                                   (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> expr)
                                   (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> type))))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'binding))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____B_A2.html">b*</a> ((var (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> var) :exec var))
                 (expr (<a href="ACL2____MBE.html">mbe</a> :logic (pseudo-term-fix expr)
                            :exec expr))
                 (<a href="COMMON-LISP____TYPE.html">type</a> (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> type)
                            :exec type)))
                (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'var var)
                      (<a href="COMMON-LISP____CONS.html">cons</a> 'expr expr)
                      (<a href="COMMON-LISP____CONS.html">cons</a> 'type type)))))</pre> 
<p><b>Theorem: </b>binding-p-of-binding</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-p-of-binding
        (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="SMT____BINDING.html">binding</a> var expr type)))
            (<a href="SMT____BINDING-P.html">binding-p</a> x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>binding-&gt;var-of-binding</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-&gt;var-of-binding
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING-_E3VAR.html">binding-&gt;var</a> (<a href="SMT____BINDING.html">binding</a> var expr type))
               (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> var)))</pre> 
<p><b>Theorem: </b>binding-&gt;expr-of-binding</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-&gt;expr-of-binding
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING-_E3EXPR.html">binding-&gt;expr</a> (<a href="SMT____BINDING.html">binding</a> var expr type))
               (pseudo-term-fix expr)))</pre> 
<p><b>Theorem: </b>binding-&gt;type-of-binding</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-&gt;type-of-binding
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING-_E3TYPE.html">binding-&gt;type</a> (<a href="SMT____BINDING.html">binding</a> var expr type))
               (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> type)))</pre> 
<p><b>Theorem: </b>binding-of-fields</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-of-fields
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING.html">binding</a> (<a href="SMT____BINDING-_E3VAR.html">binding-&gt;var</a> x)
                        (<a href="SMT____BINDING-_E3EXPR.html">binding-&gt;expr</a> x)
                        (<a href="SMT____BINDING-_E3TYPE.html">binding-&gt;type</a> x))
               (<a href="SMT____BINDING-FIX.html">binding-fix</a> x)))</pre> 
<p><b>Theorem: </b>binding-fix-when-binding</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-fix-when-binding
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING-FIX.html">binding-fix</a> x)
               (<a href="SMT____BINDING.html">binding</a> (<a href="SMT____BINDING-_E3VAR.html">binding-&gt;var</a> x)
                        (<a href="SMT____BINDING-_E3EXPR.html">binding-&gt;expr</a> x)
                        (<a href="SMT____BINDING-_E3TYPE.html">binding-&gt;type</a> x))))</pre> 
<p><b>Theorem: </b>equal-of-binding</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-binding
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING.html">binding</a> var expr type) x)
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____BINDING-P.html">binding-p</a> x)
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING-_E3VAR.html">binding-&gt;var</a> x)
                           (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> var))
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING-_E3EXPR.html">binding-&gt;expr</a> x)
                           (pseudo-term-fix expr))
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING-_E3TYPE.html">binding-&gt;type</a> x)
                           (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> type)))))</pre> 
<p><b>Theorem: </b>binding-of-symbol-fix-var</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-of-symbol-fix-var
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING.html">binding</a> (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> var) expr type)
               (<a href="SMT____BINDING.html">binding</a> var expr type)))</pre> 
<p><b>Theorem: </b>binding-symbol-equiv-congruence-on-var</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-symbol-equiv-congruence-on-var
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____SYMBOL-EQUIV.html">acl2::symbol-equiv</a> var var-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING.html">binding</a> var expr type)
                        (<a href="SMT____BINDING.html">binding</a> var-equiv expr type)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>binding-of-pseudo-term-fix-expr</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-of-pseudo-term-fix-expr
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING.html">binding</a> var (pseudo-term-fix expr)
                        type)
               (<a href="SMT____BINDING.html">binding</a> var expr type)))</pre> 
<p><b>Theorem: </b>binding-pseudo-term-equiv-congruence-on-expr</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-pseudo-term-equiv-congruence-on-expr
        (<a href="ACL2____IMPLIES.html">implies</a> (pseudo-term-equiv expr expr-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING.html">binding</a> var expr type)
                        (<a href="SMT____BINDING.html">binding</a> var expr-equiv type)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>binding-of-symbol-fix-type</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-of-symbol-fix-type
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING.html">binding</a> var expr (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> type))
               (<a href="SMT____BINDING.html">binding</a> var expr type)))</pre> 
<p><b>Theorem: </b>binding-symbol-equiv-congruence-on-type</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-symbol-equiv-congruence-on-type
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____SYMBOL-EQUIV.html">acl2::symbol-equiv</a> type type-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING.html">binding</a> var expr type)
                        (<a href="SMT____BINDING.html">binding</a> var expr type-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>binding-fix-redef</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-fix-redef
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING-FIX.html">binding-fix</a> x)
               (<a href="SMT____BINDING.html">binding</a> (<a href="SMT____BINDING-_E3VAR.html">binding-&gt;var</a> x)
                        (<a href="SMT____BINDING-_E3EXPR.html">binding-&gt;expr</a> x)
                        (<a href="SMT____BINDING-_E3TYPE.html">binding-&gt;type</a> x)))
        :rule-classes :definition)</pre> 
<p><b>Function: </b>binding-listp</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> binding-listp (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'binding-listp))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)
                (<a href="COMMON-LISP____EQ.html">eq</a> x nil)
                (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____BINDING-P.html">binding-p</a> (<a href="COMMON-LISP____CAR.html">car</a> x))
                     (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x))))))</pre> 
<p><b>Theorem: </b>binding-listp-of-cons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-listp-of-cons
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::a acl2::x))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____BINDING-P.html">binding-p</a> acl2::a)
                    (<a href="SMT____BINDING-LISTP.html">binding-listp</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-listp-of-cdr-when-binding-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-listp-of-cdr-when-binding-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-listp-when-not-consp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-listp-when-not-consp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> acl2::x)
                        (<a href="COMMON-LISP____NOT.html">not</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-p-of-car-when-binding-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-p-of-car-when-binding-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> acl2::x)
                 (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____BINDING-P.html">binding-p</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::x))
                      (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x) (<a href="SMT____BINDING-P.html">binding-p</a> nil))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>true-listp-when-binding-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> true-listp-when-binding-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> acl2::x)
                 (<a href="ACL2____TRUE-LISTP.html">true-listp</a> acl2::x))
        :rule-classes :compound-recognizer)</pre> 
<p><b>Theorem: </b>binding-listp-of-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-listp-of-list-fix
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> acl2::x)
                 (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-listp-of-sfix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-listp-of-sfix
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::x))
             (<a href="COMMON-LISP____OR.html">or</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> acl2::x)
                 (<a href="COMMON-LISP____NOT.html">not</a> (<a href="SET____SETP.html">set::setp</a> acl2::x))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-listp-of-insert</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-listp-of-insert
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="SET____INSERT.html">set::insert</a> acl2::a acl2::x))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::x))
                  (<a href="SMT____BINDING-P.html">binding-p</a> acl2::a)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-listp-of-delete</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-listp-of-delete
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> acl2::x)
                 (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="SET____DELETE.html">set::delete</a> acl2::k acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-listp-of-mergesort</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-listp-of-mergesort
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="SET____MERGESORT.html">set::mergesort</a> acl2::x))
             (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-listp-of-union</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-listp-of-union
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="SET____UNION.html">set::union</a> acl2::x acl2::y))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::x))
                  (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::y))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-listp-of-intersect-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-listp-of-intersect-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> acl2::x)
                 (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="SET____INTERSECT.html">set::intersect</a> acl2::x acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-listp-of-intersect-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-listp-of-intersect-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> acl2::y)
                 (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="SET____INTERSECT.html">set::intersect</a> acl2::x acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-listp-of-difference</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-listp-of-difference
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> acl2::x)
                 (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="SET____DIFFERENCE.html">set::difference</a> acl2::x acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-listp-of-duplicated-members</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-listp-of-duplicated-members
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> acl2::x)
                 (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (acl2::duplicated-members acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-listp-of-rev</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-listp-of-rev
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="ACL2____REV.html">acl2::rev</a> acl2::x))
               (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-listp-of-append</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-listp-of-append
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="COMMON-LISP____APPEND.html">append</a> acl2::a acl2::b))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::a))
                    (<a href="SMT____BINDING-LISTP.html">binding-listp</a> acl2::b)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-listp-of-rcons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-listp-of-rcons
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="ACL2____RCONS.html">acl2::rcons</a> acl2::a acl2::x))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____BINDING-P.html">binding-p</a> acl2::a)
                  (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-p-when-member-equal-of-binding-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-p-when-member-equal-of-binding-listp
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> acl2::a acl2::x)
                           (<a href="SMT____BINDING-LISTP.html">binding-listp</a> acl2::x))
                      (<a href="SMT____BINDING-P.html">binding-p</a> acl2::a))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> acl2::x)
                           (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> acl2::a acl2::x))
                      (<a href="SMT____BINDING-P.html">binding-p</a> acl2::a)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-listp-when-subsetp-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-listp-when-subsetp-equal
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SUBSETP-EQUAL.html">subsetp-equal</a> acl2::x acl2::y)
                           (<a href="SMT____BINDING-LISTP.html">binding-listp</a> acl2::y))
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> acl2::x)
                             (<a href="ACL2____TRUE-LISTP.html">true-listp</a> acl2::x)))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> acl2::y)
                           (<a href="ACL2____SUBSETP-EQUAL.html">subsetp-equal</a> acl2::x acl2::y))
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> acl2::x)
                             (<a href="ACL2____TRUE-LISTP.html">true-listp</a> acl2::x))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-listp-of-set-difference-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    binding-listp-of-set-difference-equal
    (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> acl2::x)
             (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="ACL2____SET-DIFFERENCE-EQUAL.html">set-difference-equal</a> acl2::x acl2::y)))
    :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-listp-of-intersection-equal-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     binding-listp-of-intersection-equal-1
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
              (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="ACL2____INTERSECTION-EQUAL.html">intersection-equal</a> acl2::x acl2::y)))
     :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-listp-of-intersection-equal-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     binding-listp-of-intersection-equal-2
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::y))
              (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="ACL2____INTERSECTION-EQUAL.html">intersection-equal</a> acl2::x acl2::y)))
     :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-listp-of-union-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-listp-of-union-equal
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="ACL2____UNION-EQUAL.html">union-equal</a> acl2::x acl2::y))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x))
                    (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::y))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-listp-of-take</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-listp-of-take
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="ACL2____TAKE.html">take</a> acl2::n acl2::x))
                      (<a href="COMMON-LISP____OR.html">or</a> (<a href="SMT____BINDING-P.html">binding-p</a> nil)
                          (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____NFIX.html">nfix</a> acl2::n) (<a href="ACL2____LEN.html">len</a> acl2::x)))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-listp-of-repeat</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-listp-of-repeat
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="ACL2____REPEAT.html">acl2::repeat</a> acl2::n acl2::x))
             (<a href="COMMON-LISP____OR.html">or</a> (<a href="SMT____BINDING-P.html">binding-p</a> acl2::x) (<a href="ACL2____ZP.html">zp</a> acl2::n)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-p-of-nth-when-binding-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-p-of-nth-when-binding-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> acl2::x)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____NFIX.html">nfix</a> acl2::n) (<a href="ACL2____LEN.html">len</a> acl2::x)))
                 (<a href="SMT____BINDING-P.html">binding-p</a> (<a href="COMMON-LISP____NTH.html">nth</a> acl2::n acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-listp-of-update-nth</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  binding-listp-of-update-nth
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
           (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="ACL2____UPDATE-NTH.html">update-nth</a> acl2::n acl2::y acl2::x))
                (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____BINDING-P.html">binding-p</a> acl2::y)
                     (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____NFIX.html">nfix</a> acl2::n) (<a href="ACL2____LEN.html">len</a> acl2::x))
                         (<a href="SMT____BINDING-P.html">binding-p</a> nil)))))
  :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-listp-of-butlast</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-listp-of-butlast
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="COMMON-LISP____BUTLAST.html">butlast</a> acl2::x acl2::n)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-listp-of-nthcdr</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-listp-of-nthcdr
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> acl2::n acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-listp-of-last</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-listp-of-last
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="COMMON-LISP____LAST.html">last</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-listp-of-remove</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-listp-of-remove
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> acl2::x)
                 (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="COMMON-LISP____REMOVE.html">remove</a> acl2::a acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>binding-listp-of-revappend</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-listp-of-revappend
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="COMMON-LISP____REVAPPEND.html">revappend</a> acl2::x acl2::y))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x))
                    (<a href="SMT____BINDING-LISTP.html">binding-listp</a> acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Function: </b>binding-list-fix$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> binding-list-fix$inline (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____BINDING-LISTP.html">binding-listp</a> x)))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'binding-list-fix))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)
                            nil
                            (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="SMT____BINDING-FIX.html">binding-fix</a> (<a href="COMMON-LISP____CAR.html">car</a> x))
                                  (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x))))
                 :exec x)))</pre> 
<p><b>Theorem: </b>binding-listp-of-binding-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-listp-of-binding-list-fix
        (<a href="ACL2____B_A2.html">b*</a> ((fty::newx (binding-list-fix$inline x)))
            (<a href="SMT____BINDING-LISTP.html">binding-listp</a> fty::newx))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>binding-list-fix-when-binding-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-list-fix-when-binding-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> x) x)))</pre> 
<p><b>Function: </b>binding-list-equiv$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> binding-list-equiv$inline
       (acl2::x acl2::y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> acl2::x)
                                   (<a href="SMT____BINDING-LISTP.html">binding-listp</a> acl2::y))))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> acl2::x)
              (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> acl2::y)))</pre> 
<p><b>Theorem: </b>binding-list-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-list-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> x y))
             (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> x y)
                      (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> x y)
                           (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> y z))
                      (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>binding-list-equiv-implies-equal-binding-list-fix-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-list-equiv-implies-equal-binding-list-fix-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> acl2::x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> acl2::x)
                        (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> x-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>binding-list-fix-under-binding-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-list-fix-under-binding-list-equiv
        (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> acl2::x)
                            acl2::x)
        :rule-classes (:rewrite :rewrite-quoted-constant))</pre> 
<p><b>Theorem: </b>equal-of-binding-list-fix-1-forward-to-binding-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-binding-list-fix-1-forward-to-binding-list-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> acl2::x)
                        acl2::y)
                 (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>equal-of-binding-list-fix-2-forward-to-binding-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-binding-list-fix-2-forward-to-binding-list-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> acl2::x (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> acl2::y))
                 (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>binding-list-equiv-of-binding-list-fix-1-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-list-equiv-of-binding-list-fix-1-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> acl2::x)
                                     acl2::y)
                 (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>binding-list-equiv-of-binding-list-fix-2-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    binding-list-equiv-of-binding-list-fix-2-forward
    (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> acl2::x (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> acl2::y))
             (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> acl2::x acl2::y))
    :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>car-of-binding-list-fix-x-under-binding-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> car-of-binding-list-fix-x-under-binding-equiv
        (<a href="SMT____BINDING-EQUIV.html">binding-equiv</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> acl2::x))
                       (<a href="COMMON-LISP____CAR.html">car</a> acl2::x)))</pre> 
<p><b>Theorem: </b>car-binding-list-equiv-congruence-on-x-under-binding-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> car-binding-list-equiv-congruence-on-x-under-binding-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> acl2::x x-equiv)
                 (<a href="SMT____BINDING-EQUIV.html">binding-equiv</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::x)
                                (<a href="COMMON-LISP____CAR.html">car</a> x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>cdr-of-binding-list-fix-x-under-binding-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> cdr-of-binding-list-fix-x-under-binding-list-equiv
        (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> acl2::x))
                            (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::x)))</pre> 
<p><b>Theorem: </b>cdr-binding-list-equiv-congruence-on-x-under-binding-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     cdr-binding-list-equiv-congruence-on-x-under-binding-list-equiv
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> acl2::x x-equiv)
              (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::x)
                                  (<a href="COMMON-LISP____CDR.html">cdr</a> x-equiv)))
     :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>cons-of-binding-fix-x-under-binding-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> cons-of-binding-fix-x-under-binding-list-equiv
        (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="SMT____BINDING-FIX.html">binding-fix</a> acl2::x) acl2::y)
                            (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y)))</pre> 
<p><b>Theorem: </b>cons-binding-equiv-congruence-on-x-under-binding-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> cons-binding-equiv-congruence-on-x-under-binding-list-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-EQUIV.html">binding-equiv</a> acl2::x x-equiv)
                 (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y)
                                     (<a href="COMMON-LISP____CONS.html">cons</a> x-equiv acl2::y)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>cons-of-binding-list-fix-y-under-binding-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     cons-of-binding-list-fix-y-under-binding-list-equiv
     (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> acl2::y))
                         (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y)))</pre> 
<p><b>Theorem: </b>cons-binding-list-equiv-congruence-on-y-under-binding-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    cons-binding-list-equiv-congruence-on-y-under-binding-list-equiv
    (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> acl2::y y-equiv)
             (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y)
                                 (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x y-equiv)))
    :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>consp-of-binding-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> consp-of-binding-list-fix
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> acl2::x))
               (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x)))</pre> 
<p><b>Theorem: </b>binding-list-fix-under-iff</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-list-fix-under-iff
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> acl2::x)
             (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x)))</pre> 
<p><b>Theorem: </b>binding-list-fix-of-cons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-list-fix-of-cons
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> (<a href="COMMON-LISP____CONS.html">cons</a> a x))
               (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="SMT____BINDING-FIX.html">binding-fix</a> a)
                     (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> x))))</pre> 
<p><b>Theorem: </b>len-of-binding-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> len-of-binding-list-fix
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> acl2::x))
               (<a href="ACL2____LEN.html">len</a> acl2::x)))</pre> 
<p><b>Theorem: </b>binding-list-fix-of-append</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-list-fix-of-append
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> (<a href="COMMON-LISP____APPEND.html">append</a> std::a std::b))
               (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> std::a)
                       (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> std::b))))</pre> 
<p><b>Theorem: </b>binding-list-fix-of-repeat</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-list-fix-of-repeat
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> (<a href="ACL2____REPEAT.html">acl2::repeat</a> acl2::n acl2::x))
               (<a href="ACL2____REPEAT.html">acl2::repeat</a> acl2::n (<a href="SMT____BINDING-FIX.html">binding-fix</a> acl2::x))))</pre> 
<p><b>Theorem: </b>list-equiv-refines-binding-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> list-equiv-refines-binding-list-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____LIST-EQUIV.html">acl2::list-equiv</a> acl2::x acl2::y)
                 (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> acl2::x acl2::y))
        :rule-classes :refinement)</pre> 
<p><b>Theorem: </b>nth-of-binding-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nth-of-binding-list-fix
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTH.html">nth</a> acl2::n (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> acl2::x))
               (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____NFIX.html">nfix</a> acl2::n) (<a href="ACL2____LEN.html">len</a> acl2::x))
                   (<a href="SMT____BINDING-FIX.html">binding-fix</a> (<a href="COMMON-LISP____NTH.html">nth</a> acl2::n acl2::x))
                   nil)))</pre> 
<p><b>Theorem: </b>binding-list-equiv-implies-binding-list-equiv-append-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-list-equiv-implies-binding-list-equiv-append-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> acl2::x fty::x-equiv)
                 (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> (<a href="COMMON-LISP____APPEND.html">append</a> acl2::x acl2::y)
                                     (<a href="COMMON-LISP____APPEND.html">append</a> fty::x-equiv acl2::y)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>binding-list-equiv-implies-binding-list-equiv-append-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-list-equiv-implies-binding-list-equiv-append-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> acl2::y fty::y-equiv)
                 (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> (<a href="COMMON-LISP____APPEND.html">append</a> acl2::x acl2::y)
                                     (<a href="COMMON-LISP____APPEND.html">append</a> acl2::x fty::y-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>binding-list-equiv-implies-binding-list-equiv-nthcdr-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-list-equiv-implies-binding-list-equiv-nthcdr-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> acl2::l l-equiv)
                 (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> acl2::n acl2::l)
                                     (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> acl2::n l-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>binding-list-equiv-implies-binding-list-equiv-take-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-list-equiv-implies-binding-list-equiv-take-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> acl2::l l-equiv)
                 (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> (<a href="ACL2____TAKE.html">take</a> acl2::n acl2::l)
                                     (<a href="ACL2____TAKE.html">take</a> acl2::n l-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Function: </b>let-binding-p</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 let-binding-p (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
   ((acl2::__function__ 'let-binding-p))
   (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
   (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____ALISTP.html">alistp</a> x)
                         (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____STRIP-CARS.html">strip-cars</a> x)
                                '(bindings hypotheses)))
             :exec (fty::alist-with-carsp x '(bindings hypotheses)))
        (<a href="ACL2____B_A2.html">b*</a> ((bindings (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x)))
             (hypotheses (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x))))
            (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> bindings)
                 (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> hypotheses))))))</pre> 
<p><b>Theorem: </b>consp-when-let-binding-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> consp-when-let-binding-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LET-BINDING-P.html">let-binding-p</a> x) (<a href="COMMON-LISP____CONSP.html">consp</a> x))
        :rule-classes :compound-recognizer)</pre> 
<p><b>Function: </b>let-binding-fix$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 let-binding-fix$inline (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____LET-BINDING-P.html">let-binding-p</a> x)))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'let-binding-fix))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____MBE.html">mbe</a>
     :logic
     (<a href="ACL2____B_A2.html">b*</a> ((bindings (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x))))
          (hypotheses (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x)))))
         (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'bindings bindings)
               (<a href="COMMON-LISP____CONS.html">cons</a> 'hypotheses hypotheses)))
     :exec x)))</pre> 
<p><b>Theorem: </b>let-binding-p-of-let-binding-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> let-binding-p-of-let-binding-fix
        (<a href="ACL2____B_A2.html">b*</a> ((new-x (let-binding-fix$inline x)))
            (<a href="SMT____LET-BINDING-P.html">let-binding-p</a> new-x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>let-binding-fix-when-let-binding-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> let-binding-fix-when-let-binding-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LET-BINDING-P.html">let-binding-p</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LET-BINDING-FIX.html">let-binding-fix</a> x) x)))</pre> 
<p><b>Function: </b>let-binding-equiv$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> let-binding-equiv$inline
       (acl2::x acl2::y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____LET-BINDING-P.html">let-binding-p</a> acl2::x)
                                   (<a href="SMT____LET-BINDING-P.html">let-binding-p</a> acl2::y))))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LET-BINDING-FIX.html">let-binding-fix</a> acl2::x)
              (<a href="SMT____LET-BINDING-FIX.html">let-binding-fix</a> acl2::y)))</pre> 
<p><b>Theorem: </b>let-binding-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> let-binding-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="SMT____LET-BINDING-EQUIV.html">let-binding-equiv</a> x y))
             (<a href="SMT____LET-BINDING-EQUIV.html">let-binding-equiv</a> x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LET-BINDING-EQUIV.html">let-binding-equiv</a> x y)
                      (<a href="SMT____LET-BINDING-EQUIV.html">let-binding-equiv</a> y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____LET-BINDING-EQUIV.html">let-binding-equiv</a> x y)
                           (<a href="SMT____LET-BINDING-EQUIV.html">let-binding-equiv</a> y z))
                      (<a href="SMT____LET-BINDING-EQUIV.html">let-binding-equiv</a> x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>let-binding-equiv-implies-equal-let-binding-fix-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> let-binding-equiv-implies-equal-let-binding-fix-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LET-BINDING-EQUIV.html">let-binding-equiv</a> acl2::x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LET-BINDING-FIX.html">let-binding-fix</a> acl2::x)
                        (<a href="SMT____LET-BINDING-FIX.html">let-binding-fix</a> x-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>let-binding-fix-under-let-binding-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> let-binding-fix-under-let-binding-equiv
        (<a href="SMT____LET-BINDING-EQUIV.html">let-binding-equiv</a> (<a href="SMT____LET-BINDING-FIX.html">let-binding-fix</a> acl2::x)
                           acl2::x)
        :rule-classes (:rewrite :rewrite-quoted-constant))</pre> 
<p><b>Theorem: </b>equal-of-let-binding-fix-1-forward-to-let-binding-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-let-binding-fix-1-forward-to-let-binding-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LET-BINDING-FIX.html">let-binding-fix</a> acl2::x)
                        acl2::y)
                 (<a href="SMT____LET-BINDING-EQUIV.html">let-binding-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>equal-of-let-binding-fix-2-forward-to-let-binding-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-let-binding-fix-2-forward-to-let-binding-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> acl2::x (<a href="SMT____LET-BINDING-FIX.html">let-binding-fix</a> acl2::y))
                 (<a href="SMT____LET-BINDING-EQUIV.html">let-binding-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>let-binding-equiv-of-let-binding-fix-1-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> let-binding-equiv-of-let-binding-fix-1-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LET-BINDING-EQUIV.html">let-binding-equiv</a> (<a href="SMT____LET-BINDING-FIX.html">let-binding-fix</a> acl2::x)
                                    acl2::y)
                 (<a href="SMT____LET-BINDING-EQUIV.html">let-binding-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>let-binding-equiv-of-let-binding-fix-2-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     let-binding-equiv-of-let-binding-fix-2-forward
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LET-BINDING-EQUIV.html">let-binding-equiv</a> acl2::x (<a href="SMT____LET-BINDING-FIX.html">let-binding-fix</a> acl2::y))
              (<a href="SMT____LET-BINDING-EQUIV.html">let-binding-equiv</a> acl2::x acl2::y))
     :rule-classes :forward-chaining)</pre> 
<p><b>Function: </b>let-binding-&gt;bindings$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
    let-binding-&gt;bindings$inline (x)
    (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____LET-BINDING-P.html">let-binding-p</a> x)))
    (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
    (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'let-binding-&gt;bindings))
         (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
         (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                         (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x))))
              :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x)))))</pre> 
<p><b>Theorem: </b>binding-listp-of-let-binding-&gt;bindings</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-listp-of-let-binding-&gt;bindings
        (<a href="ACL2____B_A2.html">b*</a> ((bindings (let-binding-&gt;bindings$inline x)))
            (<a href="SMT____BINDING-LISTP.html">binding-listp</a> bindings))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>let-binding-&gt;bindings$inline-of-let-binding-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> let-binding-&gt;bindings$inline-of-let-binding-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (let-binding-&gt;bindings$inline (<a href="SMT____LET-BINDING-FIX.html">let-binding-fix</a> x))
               (let-binding-&gt;bindings$inline x)))</pre> 
<p><b>Theorem: </b>let-binding-&gt;bindings$inline-let-binding-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     let-binding-&gt;bindings$inline-let-binding-equiv-congruence-on-x
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LET-BINDING-EQUIV.html">let-binding-equiv</a> x x-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (let-binding-&gt;bindings$inline x)
                     (let-binding-&gt;bindings$inline x-equiv)))
     :rule-classes :congruence)</pre> 
<p><b>Function: </b>let-binding-&gt;hypotheses$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
  let-binding-&gt;hypotheses$inline (x)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____LET-BINDING-P.html">let-binding-p</a> x)))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
  (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'let-binding-&gt;hypotheses))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
       (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                       (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x))))
            :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x)))))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-let-binding-&gt;hypotheses</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-let-binding-&gt;hypotheses
        (<a href="ACL2____B_A2.html">b*</a> ((hypotheses (let-binding-&gt;hypotheses$inline x)))
            (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> hypotheses))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>let-binding-&gt;hypotheses$inline-of-let-binding-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> let-binding-&gt;hypotheses$inline-of-let-binding-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (let-binding-&gt;hypotheses$inline (<a href="SMT____LET-BINDING-FIX.html">let-binding-fix</a> x))
               (let-binding-&gt;hypotheses$inline x)))</pre> 
<p><b>Theorem: </b>let-binding-&gt;hypotheses$inline-let-binding-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    let-binding-&gt;hypotheses$inline-let-binding-equiv-congruence-on-x
    (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LET-BINDING-EQUIV.html">let-binding-equiv</a> x x-equiv)
             (<a href="COMMON-LISP____EQUAL.html">equal</a> (let-binding-&gt;hypotheses$inline x)
                    (let-binding-&gt;hypotheses$inline x-equiv)))
    :rule-classes :congruence)</pre> 
<p><b>Function: </b>let-binding</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
   let-binding (bindings hypotheses)
   (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____BINDING-LISTP.html">binding-listp</a> bindings)
                               (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> hypotheses))))
   (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
   (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'let-binding))
        (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
        (<a href="ACL2____B_A2.html">b*</a> ((bindings (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> bindings)
                            :exec bindings))
             (hypotheses (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> hypotheses)
                              :exec hypotheses)))
            (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'bindings bindings)
                  (<a href="COMMON-LISP____CONS.html">cons</a> 'hypotheses hypotheses)))))</pre> 
<p><b>Theorem: </b>let-binding-p-of-let-binding</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> let-binding-p-of-let-binding
        (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="SMT____LET-BINDING.html">let-binding</a> bindings hypotheses)))
            (<a href="SMT____LET-BINDING-P.html">let-binding-p</a> x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>let-binding-&gt;bindings-of-let-binding</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    let-binding-&gt;bindings-of-let-binding
    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LET-BINDING-_E3BINDINGS.html">let-binding-&gt;bindings</a> (<a href="SMT____LET-BINDING.html">let-binding</a> bindings hypotheses))
           (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> bindings)))</pre> 
<p><b>Theorem: </b>let-binding-&gt;hypotheses-of-let-binding</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  let-binding-&gt;hypotheses-of-let-binding
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LET-BINDING-_E3HYPOTHESES.html">let-binding-&gt;hypotheses</a> (<a href="SMT____LET-BINDING.html">let-binding</a> bindings hypotheses))
         (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> hypotheses)))</pre> 
<p><b>Theorem: </b>let-binding-of-fields</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> let-binding-of-fields
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LET-BINDING.html">let-binding</a> (<a href="SMT____LET-BINDING-_E3BINDINGS.html">let-binding-&gt;bindings</a> x)
                            (<a href="SMT____LET-BINDING-_E3HYPOTHESES.html">let-binding-&gt;hypotheses</a> x))
               (<a href="SMT____LET-BINDING-FIX.html">let-binding-fix</a> x)))</pre> 
<p><b>Theorem: </b>let-binding-fix-when-let-binding</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> let-binding-fix-when-let-binding
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LET-BINDING-FIX.html">let-binding-fix</a> x)
               (<a href="SMT____LET-BINDING.html">let-binding</a> (<a href="SMT____LET-BINDING-_E3BINDINGS.html">let-binding-&gt;bindings</a> x)
                            (<a href="SMT____LET-BINDING-_E3HYPOTHESES.html">let-binding-&gt;hypotheses</a> x))))</pre> 
<p><b>Theorem: </b>equal-of-let-binding</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-let-binding
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LET-BINDING.html">let-binding</a> bindings hypotheses)
                      x)
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____LET-BINDING-P.html">let-binding-p</a> x)
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LET-BINDING-_E3BINDINGS.html">let-binding-&gt;bindings</a> x)
                           (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> bindings))
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LET-BINDING-_E3HYPOTHESES.html">let-binding-&gt;hypotheses</a> x)
                           (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> hypotheses)))))</pre> 
<p><b>Theorem: </b>let-binding-of-binding-list-fix-bindings</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> let-binding-of-binding-list-fix-bindings
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LET-BINDING.html">let-binding</a> (<a href="SMT____BINDING-LIST-FIX.html">binding-list-fix</a> bindings)
                            hypotheses)
               (<a href="SMT____LET-BINDING.html">let-binding</a> bindings hypotheses)))</pre> 
<p><b>Theorem: </b>let-binding-binding-list-equiv-congruence-on-bindings</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> let-binding-binding-list-equiv-congruence-on-bindings
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____BINDING-LIST-EQUIV.html">binding-list-equiv</a> bindings bindings-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LET-BINDING.html">let-binding</a> bindings hypotheses)
                        (<a href="SMT____LET-BINDING.html">let-binding</a> bindings-equiv hypotheses)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>let-binding-of-hint-pair-list-fix-hypotheses</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> let-binding-of-hint-pair-list-fix-hypotheses
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LET-BINDING.html">let-binding</a> bindings
                            (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> hypotheses))
               (<a href="SMT____LET-BINDING.html">let-binding</a> bindings hypotheses)))</pre> 
<p><b>Theorem: </b>let-binding-hint-pair-list-equiv-congruence-on-hypotheses</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> let-binding-hint-pair-list-equiv-congruence-on-hypotheses
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> hypotheses hypotheses-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LET-BINDING.html">let-binding</a> bindings hypotheses)
                        (<a href="SMT____LET-BINDING.html">let-binding</a> bindings hypotheses-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>let-binding-fix-redef</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> let-binding-fix-redef
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LET-BINDING-FIX.html">let-binding-fix</a> x)
               (<a href="SMT____LET-BINDING.html">let-binding</a> (<a href="SMT____LET-BINDING-_E3BINDINGS.html">let-binding-&gt;bindings</a> x)
                            (<a href="SMT____LET-BINDING-_E3HYPOTHESES.html">let-binding-&gt;hypotheses</a> x)))
        :rule-classes :definition)</pre> 
<p><b>Function: </b>smtlink-hint-p</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 smtlink-hint-p (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'smtlink-hint-p))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="COMMON-LISP____AND.html">and</a>
   (<a href="ACL2____MBE.html">mbe</a>
    :logic
    (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____ALISTP.html">alistp</a> x)
         (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____STRIP-CARS.html">strip-cars</a> x)
                '(functions hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)))
    :exec (fty::alist-with-carsp
               x
               '(functions hypotheses main-hint let-binding
                           symbols abs fty fty-info fty-types
                           int-to-rat smt-dir rm-file smt-fname
                           smt-params fast-functions type-decl-list
                           expanded-clause-w/-hint expanded-g/type
                           smt-cnf wrld-fn-len custom-p)))
   (<a href="ACL2____B_A2.html">b*</a> ((functions (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x)))
        (hypotheses (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x)))
        (main-hint (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 2 x)))
        (<a href="SMT____LET-BINDING.html">let-binding</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 3 x)))
        (symbols (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 4 x)))
        (<a href="COMMON-LISP____ABS.html">abs</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 5 x)))
        (fty (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 6 x)))
        (<a href="SMT____FTY-INFO.html">fty-info</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 7 x)))
        (<a href="SMT____FTY-TYPES.html">fty-types</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 8 x)))
        (int-to-rat (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 9 x)))
        (smt-dir (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 10 x)))
        (rm-file (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 11 x)))
        (smt-fname (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 12 x)))
        (smt-params (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 13 x)))
        (fast-functions (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 14 x)))
        (type-decl-list (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 15 x)))
        (expanded-clause-w/-hint (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 16 x)))
        (expanded-g/type (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 17 x)))
        (smt-cnf (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 18 x)))
        (<a href="SMT____WRLD-FN-LEN.html">wrld-fn-len</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 19 x)))
        (custom-p (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 20 x))))
       (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> functions)
            (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> hypotheses)
            (<a href="ACL2____TRUE-LISTP.html">true-listp</a> main-hint)
            (<a href="SMT____LET-BINDING-P.html">let-binding-p</a> let-binding)
            (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> symbols)
            (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> abs)
            (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> fty)
            (<a href="SMT____FTY-INFO-ALIST-P.html">fty-info-alist-p</a> fty-info)
            (<a href="SMT____FTY-TYPES-P.html">fty-types-p</a> fty-types)
            (<a href="ACL2____BOOLEANP.html">booleanp</a> int-to-rat)
            (<a href="COMMON-LISP____STRINGP.html">stringp</a> smt-dir)
            (<a href="ACL2____BOOLEANP.html">booleanp</a> rm-file)
            (<a href="COMMON-LISP____STRINGP.html">stringp</a> smt-fname)
            (<a href="ACL2____TRUE-LISTP.html">true-listp</a> smt-params)
            (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> fast-functions)
            (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> type-decl-list)
            (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> expanded-clause-w/-hint)
            (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> expanded-g/type)
            (<a href="SMT____SMTLINK-CONFIG-P.html">smtlink-config-p</a> smt-cnf)
            (<a href="ACL2____NATP.html">natp</a> wrld-fn-len)
            (<a href="ACL2____BOOLEANP.html">booleanp</a> custom-p))))))</pre> 
<p><b>Theorem: </b>consp-when-smtlink-hint-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> consp-when-smtlink-hint-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> x) (<a href="COMMON-LISP____CONSP.html">consp</a> x))
        :rule-classes :compound-recognizer)</pre> 
<p><b>Function: </b>smtlink-hint-fix$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 smtlink-hint-fix$inline (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> x)))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'smtlink-hint-fix))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____MBE.html">mbe</a>
   :logic
   (<a href="ACL2____B_A2.html">b*</a> ((functions (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x))))
        (hypotheses (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x))))
        (main-hint (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 2 x))))
        (<a href="SMT____LET-BINDING.html">let-binding</a> (<a href="SMT____LET-BINDING-FIX.html">let-binding-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 3 x))))
        (symbols (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 4 x))))
        (<a href="COMMON-LISP____ABS.html">abs</a> (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 5 x))))
        (fty (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 6 x))))
        (<a href="SMT____FTY-INFO.html">fty-info</a> (<a href="SMT____FTY-INFO-ALIST-FIX.html">fty-info-alist-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 7 x))))
        (<a href="SMT____FTY-TYPES.html">fty-types</a> (<a href="SMT____FTY-TYPES-FIX.html">fty-types-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 8 x))))
        (int-to-rat (<a href="ACL2____BOOL-FIX.html">acl2::bool-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 9 x))))
        (smt-dir (<a href="ACL2____STR-FIX.html">str-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 10 x))))
        (rm-file (<a href="ACL2____BOOL-FIX.html">acl2::bool-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 11 x))))
        (smt-fname (<a href="ACL2____STR-FIX.html">str-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 12 x))))
        (smt-params (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 13 x))))
        (fast-functions (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 14 x))))
        (type-decl-list (pseudo-term-fix (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 15 x))))
        (expanded-clause-w/-hint
             (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 16 x))))
        (expanded-g/type (pseudo-term-fix (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 17 x))))
        (smt-cnf (<a href="SMT____SMTLINK-CONFIG-FIX.html">smtlink-config-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 18 x))))
        (<a href="SMT____WRLD-FN-LEN.html">wrld-fn-len</a> (<a href="ACL2____NFIX.html">nfix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 19 x))))
        (custom-p (<a href="ACL2____BOOL-FIX.html">acl2::bool-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 20 x)))))
       (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'functions functions)
             (<a href="COMMON-LISP____CONS.html">cons</a> 'hypotheses hypotheses)
             (<a href="COMMON-LISP____CONS.html">cons</a> 'main-hint main-hint)
             (<a href="COMMON-LISP____CONS.html">cons</a> 'let-binding let-binding)
             (<a href="COMMON-LISP____CONS.html">cons</a> 'symbols symbols)
             (<a href="COMMON-LISP____CONS.html">cons</a> 'abs abs)
             (<a href="COMMON-LISP____CONS.html">cons</a> 'fty fty)
             (<a href="COMMON-LISP____CONS.html">cons</a> 'fty-info fty-info)
             (<a href="COMMON-LISP____CONS.html">cons</a> 'fty-types fty-types)
             (<a href="COMMON-LISP____CONS.html">cons</a> 'int-to-rat int-to-rat)
             (<a href="COMMON-LISP____CONS.html">cons</a> 'smt-dir smt-dir)
             (<a href="COMMON-LISP____CONS.html">cons</a> 'rm-file rm-file)
             (<a href="COMMON-LISP____CONS.html">cons</a> 'smt-fname smt-fname)
             (<a href="COMMON-LISP____CONS.html">cons</a> 'smt-params smt-params)
             (<a href="COMMON-LISP____CONS.html">cons</a> 'fast-functions fast-functions)
             (<a href="COMMON-LISP____CONS.html">cons</a> 'type-decl-list type-decl-list)
             (<a href="COMMON-LISP____CONS.html">cons</a> 'expanded-clause-w/-hint
                   expanded-clause-w/-hint)
             (<a href="COMMON-LISP____CONS.html">cons</a> 'expanded-g/type expanded-g/type)
             (<a href="COMMON-LISP____CONS.html">cons</a> 'smt-cnf smt-cnf)
             (<a href="COMMON-LISP____CONS.html">cons</a> 'wrld-fn-len wrld-fn-len)
             (<a href="COMMON-LISP____CONS.html">cons</a> 'custom-p custom-p)))
   :exec x)))</pre> 
<p><b>Theorem: </b>smtlink-hint-p-of-smtlink-hint-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> smtlink-hint-p-of-smtlink-hint-fix
        (<a href="ACL2____B_A2.html">b*</a> ((new-x (smtlink-hint-fix$inline x)))
            (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> new-x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>smtlink-hint-fix-when-smtlink-hint-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> smtlink-hint-fix-when-smtlink-hint-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> x) x)))</pre> 
<p><b>Function: </b>smtlink-hint-equiv$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> smtlink-hint-equiv$inline
       (acl2::x acl2::y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> acl2::x)
                                   (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> acl2::y))))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> acl2::x)
              (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> acl2::y)))</pre> 
<p><b>Theorem: </b>smtlink-hint-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> smtlink-hint-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> x y))
             (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> x y)
                      (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> x y)
                           (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> y z))
                      (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>smtlink-hint-equiv-implies-equal-smtlink-hint-fix-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> smtlink-hint-equiv-implies-equal-smtlink-hint-fix-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> acl2::x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> acl2::x)
                        (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> x-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>smtlink-hint-fix-under-smtlink-hint-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> smtlink-hint-fix-under-smtlink-hint-equiv
        (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> acl2::x)
                            acl2::x)
        :rule-classes (:rewrite :rewrite-quoted-constant))</pre> 
<p><b>Theorem: </b>equal-of-smtlink-hint-fix-1-forward-to-smtlink-hint-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-smtlink-hint-fix-1-forward-to-smtlink-hint-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> acl2::x)
                        acl2::y)
                 (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>equal-of-smtlink-hint-fix-2-forward-to-smtlink-hint-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-smtlink-hint-fix-2-forward-to-smtlink-hint-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> acl2::x (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> acl2::y))
                 (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>smtlink-hint-equiv-of-smtlink-hint-fix-1-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> smtlink-hint-equiv-of-smtlink-hint-fix-1-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> acl2::x)
                                     acl2::y)
                 (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>smtlink-hint-equiv-of-smtlink-hint-fix-2-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    smtlink-hint-equiv-of-smtlink-hint-fix-2-forward
    (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> acl2::x (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> acl2::y))
             (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> acl2::x acl2::y))
    :rule-classes :forward-chaining)</pre> 
<p><b>Function: </b>smtlink-hint-&gt;functions$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> smtlink-hint-&gt;functions$inline (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> x)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'smtlink-hint-&gt;functions))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                            (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x))))
                 :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x)))))</pre> 
<p><b>Theorem: </b>func-listp-of-smtlink-hint-&gt;functions</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-listp-of-smtlink-hint-&gt;functions
        (<a href="ACL2____B_A2.html">b*</a> ((functions (smtlink-hint-&gt;functions$inline x)))
            (<a href="SMT____FUNC-LISTP.html">func-listp</a> functions))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;functions$inline-of-smtlink-hint-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> smtlink-hint-&gt;functions$inline-of-smtlink-hint-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;functions$inline (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> x))
               (smtlink-hint-&gt;functions$inline x)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;functions$inline-smtlink-hint-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   smtlink-hint-&gt;functions$inline-smtlink-hint-equiv-congruence-on-x
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> x x-equiv)
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;functions$inline x)
                   (smtlink-hint-&gt;functions$inline x-equiv)))
   :rule-classes :congruence)</pre> 
<p><b>Function: </b>smtlink-hint-&gt;hypotheses$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
  smtlink-hint-&gt;hypotheses$inline (x)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> x)))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
  (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'smtlink-hint-&gt;hypotheses))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
       (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                       (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x))))
            :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x)))))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-smtlink-hint-&gt;hypotheses</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-smtlink-hint-&gt;hypotheses
        (<a href="ACL2____B_A2.html">b*</a> ((hypotheses (smtlink-hint-&gt;hypotheses$inline x)))
            (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> hypotheses))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;hypotheses$inline-of-smtlink-hint-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-&gt;hypotheses$inline-of-smtlink-hint-fix-x
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;hypotheses$inline (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> x))
            (smtlink-hint-&gt;hypotheses$inline x)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;hypotheses$inline-smtlink-hint-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-&gt;hypotheses$inline-smtlink-hint-equiv-congruence-on-x
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> x x-equiv)
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;hypotheses$inline x)
                  (smtlink-hint-&gt;hypotheses$inline x-equiv)))
  :rule-classes :congruence)</pre> 
<p><b>Function: </b>smtlink-hint-&gt;main-hint$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> smtlink-hint-&gt;main-hint$inline (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> x)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'smtlink-hint-&gt;main-hint))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                            (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 2 x))))
                 :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 2 x)))))</pre> 
<p><b>Theorem: </b>true-listp-of-smtlink-hint-&gt;main-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> true-listp-of-smtlink-hint-&gt;main-hint
        (<a href="ACL2____B_A2.html">b*</a> ((main-hint (smtlink-hint-&gt;main-hint$inline x)))
            (<a href="ACL2____TRUE-LISTP.html">true-listp</a> main-hint))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;main-hint$inline-of-smtlink-hint-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> smtlink-hint-&gt;main-hint$inline-of-smtlink-hint-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;main-hint$inline (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> x))
               (smtlink-hint-&gt;main-hint$inline x)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;main-hint$inline-smtlink-hint-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   smtlink-hint-&gt;main-hint$inline-smtlink-hint-equiv-congruence-on-x
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> x x-equiv)
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;main-hint$inline x)
                   (smtlink-hint-&gt;main-hint$inline x-equiv)))
   :rule-classes :congruence)</pre> 
<p><b>Function: </b>smtlink-hint-&gt;let-binding$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     smtlink-hint-&gt;let-binding$inline (x)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> x)))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
     (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'smtlink-hint-&gt;let-binding))
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
          (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                          (<a href="SMT____LET-BINDING-FIX.html">let-binding-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 3 x))))
               :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 3 x)))))</pre> 
<p><b>Theorem: </b>let-binding-p-of-smtlink-hint-&gt;let-binding</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> let-binding-p-of-smtlink-hint-&gt;let-binding
        (<a href="ACL2____B_A2.html">b*</a> ((<a href="SMT____LET-BINDING.html">let-binding</a> (smtlink-hint-&gt;let-binding$inline x)))
            (<a href="SMT____LET-BINDING-P.html">let-binding-p</a> let-binding))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;let-binding$inline-of-smtlink-hint-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-&gt;let-binding$inline-of-smtlink-hint-fix-x
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;let-binding$inline (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> x))
            (smtlink-hint-&gt;let-binding$inline x)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;let-binding$inline-smtlink-hint-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 smtlink-hint-&gt;let-binding$inline-smtlink-hint-equiv-congruence-on-x
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> x x-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;let-binding$inline x)
                 (smtlink-hint-&gt;let-binding$inline x-equiv)))
 :rule-classes :congruence)</pre> 
<p><b>Function: </b>smtlink-hint-&gt;symbols$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     smtlink-hint-&gt;symbols$inline (x)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> x)))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
     (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'smtlink-hint-&gt;symbols))
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
          (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                          (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 4 x))))
               :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 4 x)))))</pre> 
<p><b>Theorem: </b>symbol-listp-of-smtlink-hint-&gt;symbols</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-listp-of-smtlink-hint-&gt;symbols
        (<a href="ACL2____B_A2.html">b*</a> ((symbols (smtlink-hint-&gt;symbols$inline x)))
            (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> symbols))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;symbols$inline-of-smtlink-hint-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> smtlink-hint-&gt;symbols$inline-of-smtlink-hint-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;symbols$inline (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> x))
               (smtlink-hint-&gt;symbols$inline x)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;symbols$inline-smtlink-hint-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-&gt;symbols$inline-smtlink-hint-equiv-congruence-on-x
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> x x-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;symbols$inline x)
                     (smtlink-hint-&gt;symbols$inline x-equiv)))
     :rule-classes :congruence)</pre> 
<p><b>Function: </b>smtlink-hint-&gt;abs$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     smtlink-hint-&gt;abs$inline (x)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> x)))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
     (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'smtlink-hint-&gt;abs))
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
          (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                          (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 5 x))))
               :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 5 x)))))</pre> 
<p><b>Theorem: </b>symbol-listp-of-smtlink-hint-&gt;abs</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-listp-of-smtlink-hint-&gt;abs
        (<a href="ACL2____B_A2.html">b*</a> ((<a href="COMMON-LISP____ABS.html">abs</a> (smtlink-hint-&gt;abs$inline x)))
            (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> abs))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;abs$inline-of-smtlink-hint-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> smtlink-hint-&gt;abs$inline-of-smtlink-hint-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;abs$inline (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> x))
               (smtlink-hint-&gt;abs$inline x)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;abs$inline-smtlink-hint-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> smtlink-hint-&gt;abs$inline-smtlink-hint-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;abs$inline x)
                        (smtlink-hint-&gt;abs$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>smtlink-hint-&gt;fty$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     smtlink-hint-&gt;fty$inline (x)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> x)))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
     (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'smtlink-hint-&gt;fty))
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
          (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                          (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 6 x))))
               :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 6 x)))))</pre> 
<p><b>Theorem: </b>symbol-listp-of-smtlink-hint-&gt;fty</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-listp-of-smtlink-hint-&gt;fty
        (<a href="ACL2____B_A2.html">b*</a> ((fty (smtlink-hint-&gt;fty$inline x)))
            (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> fty))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;fty$inline-of-smtlink-hint-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> smtlink-hint-&gt;fty$inline-of-smtlink-hint-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;fty$inline (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> x))
               (smtlink-hint-&gt;fty$inline x)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;fty$inline-smtlink-hint-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> smtlink-hint-&gt;fty$inline-smtlink-hint-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;fty$inline x)
                        (smtlink-hint-&gt;fty$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>smtlink-hint-&gt;fty-info$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
  smtlink-hint-&gt;fty-info$inline (x)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> x)))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
  (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'smtlink-hint-&gt;fty-info))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
       (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                       (<a href="SMT____FTY-INFO-ALIST-FIX.html">fty-info-alist-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 7 x))))
            :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 7 x)))))</pre> 
<p><b>Theorem: </b>fty-info-alist-p-of-smtlink-hint-&gt;fty-info</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fty-info-alist-p-of-smtlink-hint-&gt;fty-info
        (<a href="ACL2____B_A2.html">b*</a> ((<a href="SMT____FTY-INFO.html">fty-info</a> (smtlink-hint-&gt;fty-info$inline x)))
            (<a href="SMT____FTY-INFO-ALIST-P.html">fty-info-alist-p</a> fty-info))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;fty-info$inline-of-smtlink-hint-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> smtlink-hint-&gt;fty-info$inline-of-smtlink-hint-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;fty-info$inline (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> x))
               (smtlink-hint-&gt;fty-info$inline x)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;fty-info$inline-smtlink-hint-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    smtlink-hint-&gt;fty-info$inline-smtlink-hint-equiv-congruence-on-x
    (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> x x-equiv)
             (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;fty-info$inline x)
                    (smtlink-hint-&gt;fty-info$inline x-equiv)))
    :rule-classes :congruence)</pre> 
<p><b>Function: </b>smtlink-hint-&gt;fty-types$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> smtlink-hint-&gt;fty-types$inline (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> x)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'smtlink-hint-&gt;fty-types))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                            (<a href="SMT____FTY-TYPES-FIX.html">fty-types-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 8 x))))
                 :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 8 x)))))</pre> 
<p><b>Theorem: </b>fty-types-p-of-smtlink-hint-&gt;fty-types</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fty-types-p-of-smtlink-hint-&gt;fty-types
        (<a href="ACL2____B_A2.html">b*</a> ((<a href="SMT____FTY-TYPES.html">fty-types</a> (smtlink-hint-&gt;fty-types$inline x)))
            (<a href="SMT____FTY-TYPES-P.html">fty-types-p</a> fty-types))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;fty-types$inline-of-smtlink-hint-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> smtlink-hint-&gt;fty-types$inline-of-smtlink-hint-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;fty-types$inline (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> x))
               (smtlink-hint-&gt;fty-types$inline x)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;fty-types$inline-smtlink-hint-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   smtlink-hint-&gt;fty-types$inline-smtlink-hint-equiv-congruence-on-x
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> x x-equiv)
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;fty-types$inline x)
                   (smtlink-hint-&gt;fty-types$inline x-equiv)))
   :rule-classes :congruence)</pre> 
<p><b>Function: </b>smtlink-hint-&gt;int-to-rat$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     smtlink-hint-&gt;int-to-rat$inline (x)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> x)))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
     (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'smtlink-hint-&gt;int-to-rat))
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
          (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                          (<a href="ACL2____BOOL-FIX.html">acl2::bool-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 9 x))))
               :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 9 x)))))</pre> 
<p><b>Theorem: </b>booleanp-of-smtlink-hint-&gt;int-to-rat</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> booleanp-of-smtlink-hint-&gt;int-to-rat
        (<a href="ACL2____B_A2.html">b*</a> ((int-to-rat (smtlink-hint-&gt;int-to-rat$inline x)))
            (<a href="ACL2____BOOLEANP.html">booleanp</a> int-to-rat))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;int-to-rat$inline-of-smtlink-hint-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-&gt;int-to-rat$inline-of-smtlink-hint-fix-x
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;int-to-rat$inline (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> x))
            (smtlink-hint-&gt;int-to-rat$inline x)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;int-to-rat$inline-smtlink-hint-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-&gt;int-to-rat$inline-smtlink-hint-equiv-congruence-on-x
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> x x-equiv)
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;int-to-rat$inline x)
                  (smtlink-hint-&gt;int-to-rat$inline x-equiv)))
  :rule-classes :congruence)</pre> 
<p><b>Function: </b>smtlink-hint-&gt;smt-dir$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> smtlink-hint-&gt;smt-dir$inline (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> x)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'smtlink-hint-&gt;smt-dir))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                            (<a href="ACL2____STR-FIX.html">str-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 10 x))))
                 :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 10 x)))))</pre> 
<p><b>Theorem: </b>stringp-of-smtlink-hint-&gt;smt-dir</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> stringp-of-smtlink-hint-&gt;smt-dir
        (<a href="ACL2____B_A2.html">b*</a> ((smt-dir (smtlink-hint-&gt;smt-dir$inline x)))
            (<a href="COMMON-LISP____STRINGP.html">stringp</a> smt-dir))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;smt-dir$inline-of-smtlink-hint-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> smtlink-hint-&gt;smt-dir$inline-of-smtlink-hint-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;smt-dir$inline (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> x))
               (smtlink-hint-&gt;smt-dir$inline x)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;smt-dir$inline-smtlink-hint-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-&gt;smt-dir$inline-smtlink-hint-equiv-congruence-on-x
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> x x-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;smt-dir$inline x)
                     (smtlink-hint-&gt;smt-dir$inline x-equiv)))
     :rule-classes :congruence)</pre> 
<p><b>Function: </b>smtlink-hint-&gt;rm-file$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     smtlink-hint-&gt;rm-file$inline (x)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> x)))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
     (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'smtlink-hint-&gt;rm-file))
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
          (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                          (<a href="ACL2____BOOL-FIX.html">acl2::bool-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 11 x))))
               :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 11 x)))))</pre> 
<p><b>Theorem: </b>booleanp-of-smtlink-hint-&gt;rm-file</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> booleanp-of-smtlink-hint-&gt;rm-file
        (<a href="ACL2____B_A2.html">b*</a> ((rm-file (smtlink-hint-&gt;rm-file$inline x)))
            (<a href="ACL2____BOOLEANP.html">booleanp</a> rm-file))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;rm-file$inline-of-smtlink-hint-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> smtlink-hint-&gt;rm-file$inline-of-smtlink-hint-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;rm-file$inline (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> x))
               (smtlink-hint-&gt;rm-file$inline x)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;rm-file$inline-smtlink-hint-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-&gt;rm-file$inline-smtlink-hint-equiv-congruence-on-x
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> x x-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;rm-file$inline x)
                     (smtlink-hint-&gt;rm-file$inline x-equiv)))
     :rule-classes :congruence)</pre> 
<p><b>Function: </b>smtlink-hint-&gt;smt-fname$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> smtlink-hint-&gt;smt-fname$inline (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> x)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'smtlink-hint-&gt;smt-fname))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                            (<a href="ACL2____STR-FIX.html">str-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 12 x))))
                 :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 12 x)))))</pre> 
<p><b>Theorem: </b>stringp-of-smtlink-hint-&gt;smt-fname</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> stringp-of-smtlink-hint-&gt;smt-fname
        (<a href="ACL2____B_A2.html">b*</a> ((smt-fname (smtlink-hint-&gt;smt-fname$inline x)))
            (<a href="COMMON-LISP____STRINGP.html">stringp</a> smt-fname))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;smt-fname$inline-of-smtlink-hint-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> smtlink-hint-&gt;smt-fname$inline-of-smtlink-hint-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;smt-fname$inline (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> x))
               (smtlink-hint-&gt;smt-fname$inline x)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;smt-fname$inline-smtlink-hint-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   smtlink-hint-&gt;smt-fname$inline-smtlink-hint-equiv-congruence-on-x
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> x x-equiv)
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;smt-fname$inline x)
                   (smtlink-hint-&gt;smt-fname$inline x-equiv)))
   :rule-classes :congruence)</pre> 
<p><b>Function: </b>smtlink-hint-&gt;smt-params$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     smtlink-hint-&gt;smt-params$inline (x)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> x)))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
     (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'smtlink-hint-&gt;smt-params))
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
          (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                          (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 13 x))))
               :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 13 x)))))</pre> 
<p><b>Theorem: </b>true-listp-of-smtlink-hint-&gt;smt-params</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> true-listp-of-smtlink-hint-&gt;smt-params
        (<a href="ACL2____B_A2.html">b*</a> ((smt-params (smtlink-hint-&gt;smt-params$inline x)))
            (<a href="ACL2____TRUE-LISTP.html">true-listp</a> smt-params))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;smt-params$inline-of-smtlink-hint-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-&gt;smt-params$inline-of-smtlink-hint-fix-x
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;smt-params$inline (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> x))
            (smtlink-hint-&gt;smt-params$inline x)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;smt-params$inline-smtlink-hint-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-&gt;smt-params$inline-smtlink-hint-equiv-congruence-on-x
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> x x-equiv)
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;smt-params$inline x)
                  (smtlink-hint-&gt;smt-params$inline x-equiv)))
  :rule-classes :congruence)</pre> 
<p><b>Function: </b>smtlink-hint-&gt;fast-functions$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     smtlink-hint-&gt;fast-functions$inline (x)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> x)))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
     (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'smtlink-hint-&gt;fast-functions))
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
          (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                          (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 14 x))))
               :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 14 x)))))</pre> 
<p><b>Theorem: </b>func-alistp-of-smtlink-hint-&gt;fast-functions</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     func-alistp-of-smtlink-hint-&gt;fast-functions
     (<a href="ACL2____B_A2.html">b*</a> ((fast-functions (smtlink-hint-&gt;fast-functions$inline x)))
         (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> fast-functions))
     :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;fast-functions$inline-of-smtlink-hint-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   smtlink-hint-&gt;fast-functions$inline-of-smtlink-hint-fix-x
   (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;fast-functions$inline (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> x))
          (smtlink-hint-&gt;fast-functions$inline x)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;fast-functions$inline-smtlink-hint-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 smtlink-hint-&gt;fast-functions$inline-smtlink-hint-equiv-congruence-on-x
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> x x-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;fast-functions$inline x)
                 (smtlink-hint-&gt;fast-functions$inline x-equiv)))
 :rule-classes :congruence)</pre> 
<p><b>Function: </b>smtlink-hint-&gt;type-decl-list$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
    smtlink-hint-&gt;type-decl-list$inline (x)
    (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> x)))
    (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
    (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'smtlink-hint-&gt;type-decl-list))
         (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
         (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                         (pseudo-term-fix (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 15 x))))
              :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 15 x)))))</pre> 
<p><b>Theorem: </b>pseudo-termp-of-smtlink-hint-&gt;type-decl-list</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     pseudo-termp-of-smtlink-hint-&gt;type-decl-list
     (<a href="ACL2____B_A2.html">b*</a> ((type-decl-list (smtlink-hint-&gt;type-decl-list$inline x)))
         (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> type-decl-list))
     :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;type-decl-list$inline-of-smtlink-hint-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   smtlink-hint-&gt;type-decl-list$inline-of-smtlink-hint-fix-x
   (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;type-decl-list$inline (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> x))
          (smtlink-hint-&gt;type-decl-list$inline x)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;type-decl-list$inline-smtlink-hint-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 smtlink-hint-&gt;type-decl-list$inline-smtlink-hint-equiv-congruence-on-x
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> x x-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;type-decl-list$inline x)
                 (smtlink-hint-&gt;type-decl-list$inline x-equiv)))
 :rule-classes :congruence)</pre> 
<p><b>Function: </b>smtlink-hint-&gt;expanded-clause-w/-hint$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
  smtlink-hint-&gt;expanded-clause-w/-hint$inline
  (x)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> x)))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
  (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'smtlink-hint-&gt;expanded-clause-w/-hint))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
       (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                       (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 16 x))))
            :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 16 x)))))</pre> 
<p><b>Theorem: </b>hint-pair-p-of-smtlink-hint-&gt;expanded-clause-w/-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-p-of-smtlink-hint-&gt;expanded-clause-w/-hint
        (<a href="ACL2____B_A2.html">b*</a> ((expanded-clause-w/-hint
                  (smtlink-hint-&gt;expanded-clause-w/-hint$inline x)))
            (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> expanded-clause-w/-hint))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;expanded-clause-w/-hint$inline-of-smtlink-hint-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-&gt;expanded-clause-w/-hint$inline-of-smtlink-hint-fix-x
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;expanded-clause-w/-hint$inline
              (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> x))
         (smtlink-hint-&gt;expanded-clause-w/-hint$inline x)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;expanded-clause-w/-hint$inline-smtlink-hint-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 smtlink-hint-&gt;expanded-clause-w/-hint$inline-smtlink-hint-equiv-congruence-on-x
 (<a href="ACL2____IMPLIES.html">implies</a>
     (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> x x-equiv)
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;expanded-clause-w/-hint$inline x)
            (smtlink-hint-&gt;expanded-clause-w/-hint$inline x-equiv)))
 :rule-classes :congruence)</pre> 
<p><b>Function: </b>smtlink-hint-&gt;expanded-g/type$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
    smtlink-hint-&gt;expanded-g/type$inline (x)
    (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> x)))
    (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
    (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'smtlink-hint-&gt;expanded-g/type))
         (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
         (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                         (pseudo-term-fix (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 17 x))))
              :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 17 x)))))</pre> 
<p><b>Theorem: </b>pseudo-termp-of-smtlink-hint-&gt;expanded-g/type</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    pseudo-termp-of-smtlink-hint-&gt;expanded-g/type
    (<a href="ACL2____B_A2.html">b*</a> ((expanded-g/type (smtlink-hint-&gt;expanded-g/type$inline x)))
        (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> expanded-g/type))
    :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;expanded-g/type$inline-of-smtlink-hint-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-&gt;expanded-g/type$inline-of-smtlink-hint-fix-x
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;expanded-g/type$inline (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> x))
         (smtlink-hint-&gt;expanded-g/type$inline x)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;expanded-g/type$inline-smtlink-hint-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 smtlink-hint-&gt;expanded-g/type$inline-smtlink-hint-equiv-congruence-on-x
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> x x-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;expanded-g/type$inline x)
                 (smtlink-hint-&gt;expanded-g/type$inline x-equiv)))
 :rule-classes :congruence)</pre> 
<p><b>Function: </b>smtlink-hint-&gt;smt-cnf$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 smtlink-hint-&gt;smt-cnf$inline (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> x)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'smtlink-hint-&gt;smt-cnf))
      (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
      (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                      (<a href="SMT____SMTLINK-CONFIG-FIX.html">smtlink-config-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 18 x))))
           :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 18 x)))))</pre> 
<p><b>Theorem: </b>smtlink-config-p-of-smtlink-hint-&gt;smt-cnf</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> smtlink-config-p-of-smtlink-hint-&gt;smt-cnf
        (<a href="ACL2____B_A2.html">b*</a> ((smt-cnf (smtlink-hint-&gt;smt-cnf$inline x)))
            (<a href="SMT____SMTLINK-CONFIG-P.html">smtlink-config-p</a> smt-cnf))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;smt-cnf$inline-of-smtlink-hint-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> smtlink-hint-&gt;smt-cnf$inline-of-smtlink-hint-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;smt-cnf$inline (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> x))
               (smtlink-hint-&gt;smt-cnf$inline x)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;smt-cnf$inline-smtlink-hint-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-&gt;smt-cnf$inline-smtlink-hint-equiv-congruence-on-x
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> x x-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;smt-cnf$inline x)
                     (smtlink-hint-&gt;smt-cnf$inline x-equiv)))
     :rule-classes :congruence)</pre> 
<p><b>Function: </b>smtlink-hint-&gt;wrld-fn-len$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> smtlink-hint-&gt;wrld-fn-len$inline (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> x)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'smtlink-hint-&gt;wrld-fn-len))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                            (<a href="ACL2____NFIX.html">nfix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 19 x))))
                 :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 19 x)))))</pre> 
<p><b>Theorem: </b>natp-of-smtlink-hint-&gt;wrld-fn-len</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> natp-of-smtlink-hint-&gt;wrld-fn-len
        (<a href="ACL2____B_A2.html">b*</a> ((<a href="SMT____WRLD-FN-LEN.html">wrld-fn-len</a> (smtlink-hint-&gt;wrld-fn-len$inline x)))
            (<a href="ACL2____NATP.html">natp</a> wrld-fn-len))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;wrld-fn-len$inline-of-smtlink-hint-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-&gt;wrld-fn-len$inline-of-smtlink-hint-fix-x
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;wrld-fn-len$inline (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> x))
            (smtlink-hint-&gt;wrld-fn-len$inline x)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;wrld-fn-len$inline-smtlink-hint-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 smtlink-hint-&gt;wrld-fn-len$inline-smtlink-hint-equiv-congruence-on-x
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> x x-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;wrld-fn-len$inline x)
                 (smtlink-hint-&gt;wrld-fn-len$inline x-equiv)))
 :rule-classes :congruence)</pre> 
<p><b>Function: </b>smtlink-hint-&gt;custom-p$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     smtlink-hint-&gt;custom-p$inline (x)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> x)))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
     (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'smtlink-hint-&gt;custom-p))
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
          (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                          (<a href="ACL2____BOOL-FIX.html">acl2::bool-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 20 x))))
               :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 20 x)))))</pre> 
<p><b>Theorem: </b>booleanp-of-smtlink-hint-&gt;custom-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> booleanp-of-smtlink-hint-&gt;custom-p
        (<a href="ACL2____B_A2.html">b*</a> ((custom-p (smtlink-hint-&gt;custom-p$inline x)))
            (<a href="ACL2____BOOLEANP.html">booleanp</a> custom-p))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;custom-p$inline-of-smtlink-hint-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> smtlink-hint-&gt;custom-p$inline-of-smtlink-hint-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;custom-p$inline (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> x))
               (smtlink-hint-&gt;custom-p$inline x)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;custom-p$inline-smtlink-hint-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    smtlink-hint-&gt;custom-p$inline-smtlink-hint-equiv-congruence-on-x
    (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> x x-equiv)
             (<a href="COMMON-LISP____EQUAL.html">equal</a> (smtlink-hint-&gt;custom-p$inline x)
                    (smtlink-hint-&gt;custom-p$inline x-equiv)))
    :rule-classes :congruence)</pre> 
<p><b>Function: </b>smtlink-hint</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 smtlink-hint
 (functions hypotheses main-hint let-binding
            symbols abs fty fty-info fty-types
            int-to-rat smt-dir rm-file smt-fname
            smt-params fast-functions type-decl-list
            expanded-clause-w/-hint expanded-g/type
            smt-cnf wrld-fn-len custom-p)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-LISTP.html">func-listp</a> functions)
                             (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> hypotheses)
                             (<a href="ACL2____TRUE-LISTP.html">true-listp</a> main-hint)
                             (<a href="SMT____LET-BINDING-P.html">let-binding-p</a> let-binding)
                             (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> symbols)
                             (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> abs)
                             (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> fty)
                             (<a href="SMT____FTY-INFO-ALIST-P.html">fty-info-alist-p</a> fty-info)
                             (<a href="SMT____FTY-TYPES-P.html">fty-types-p</a> fty-types)
                             (<a href="ACL2____BOOLEANP.html">booleanp</a> int-to-rat)
                             (<a href="COMMON-LISP____STRINGP.html">stringp</a> smt-dir)
                             (<a href="ACL2____BOOLEANP.html">booleanp</a> rm-file)
                             (<a href="COMMON-LISP____STRINGP.html">stringp</a> smt-fname)
                             (<a href="ACL2____TRUE-LISTP.html">true-listp</a> smt-params)
                             (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> fast-functions)
                             (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> type-decl-list)
                             (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> expanded-clause-w/-hint)
                             (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> expanded-g/type)
                             (<a href="SMT____SMTLINK-CONFIG-P.html">smtlink-config-p</a> smt-cnf)
                             (<a href="ACL2____NATP.html">natp</a> wrld-fn-len)
                             (<a href="ACL2____BOOLEANP.html">booleanp</a> custom-p))))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'smtlink-hint))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____B_A2.html">b*</a>
     ((functions (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> functions)
                      :exec functions))
      (hypotheses (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> hypotheses)
                       :exec hypotheses))
      (main-hint (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> main-hint)
                      :exec main-hint))
      (<a href="SMT____LET-BINDING.html">let-binding</a> (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____LET-BINDING-FIX.html">let-binding-fix</a> let-binding)
                        :exec let-binding))
      (symbols (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> symbols)
                    :exec symbols))
      (<a href="COMMON-LISP____ABS.html">abs</a> (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> abs)
                :exec abs))
      (fty (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> fty)
                :exec fty))
      (<a href="SMT____FTY-INFO.html">fty-info</a> (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____FTY-INFO-ALIST-FIX.html">fty-info-alist-fix</a> fty-info)
                     :exec fty-info))
      (<a href="SMT____FTY-TYPES.html">fty-types</a> (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____FTY-TYPES-FIX.html">fty-types-fix</a> fty-types)
                      :exec fty-types))
      (int-to-rat (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____BOOL-FIX.html">acl2::bool-fix</a> int-to-rat)
                       :exec int-to-rat))
      (smt-dir (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____STR-FIX.html">str-fix</a> smt-dir)
                    :exec smt-dir))
      (rm-file (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____BOOL-FIX.html">acl2::bool-fix</a> rm-file)
                    :exec rm-file))
      (smt-fname (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____STR-FIX.html">str-fix</a> smt-fname)
                      :exec smt-fname))
      (smt-params (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> smt-params)
                       :exec smt-params))
      (fast-functions (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> fast-functions)
                           :exec fast-functions))
      (type-decl-list (<a href="ACL2____MBE.html">mbe</a> :logic (pseudo-term-fix type-decl-list)
                           :exec type-decl-list))
      (expanded-clause-w/-hint
           (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> expanded-clause-w/-hint)
                :exec expanded-clause-w/-hint))
      (expanded-g/type (<a href="ACL2____MBE.html">mbe</a> :logic (pseudo-term-fix expanded-g/type)
                            :exec expanded-g/type))
      (smt-cnf (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____SMTLINK-CONFIG-FIX.html">smtlink-config-fix</a> smt-cnf)
                    :exec smt-cnf))
      (<a href="SMT____WRLD-FN-LEN.html">wrld-fn-len</a> (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____NFIX.html">nfix</a> wrld-fn-len)
                        :exec wrld-fn-len))
      (custom-p (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____BOOL-FIX.html">acl2::bool-fix</a> custom-p)
                     :exec custom-p)))
     (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'functions functions)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'hypotheses hypotheses)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'main-hint main-hint)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'let-binding let-binding)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'symbols symbols)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'abs abs)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'fty fty)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'fty-info fty-info)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'fty-types fty-types)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'int-to-rat int-to-rat)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'smt-dir smt-dir)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'rm-file rm-file)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'smt-fname smt-fname)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'smt-params smt-params)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'fast-functions fast-functions)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'type-decl-list type-decl-list)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'expanded-clause-w/-hint
                 expanded-clause-w/-hint)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'expanded-g/type expanded-g/type)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'smt-cnf smt-cnf)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'wrld-fn-len wrld-fn-len)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'custom-p custom-p)))))</pre> 
<p><b>Theorem: </b>smtlink-hint-p-of-smtlink-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-p-of-smtlink-hint
     (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                           hypotheses main-hint let-binding
                           symbols abs fty fty-info fty-types
                           int-to-rat smt-dir rm-file smt-fname
                           smt-params fast-functions type-decl-list
                           expanded-clause-w/-hint expanded-g/type
                           smt-cnf wrld-fn-len custom-p)))
         (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> x))
     :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;functions-of-smtlink-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-&gt;functions-of-smtlink-hint
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3FUNCTIONS.html">smtlink-hint-&gt;functions</a>
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p))
         (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> functions)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;hypotheses-of-smtlink-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-&gt;hypotheses-of-smtlink-hint
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3HYPOTHESES.html">smtlink-hint-&gt;hypotheses</a>
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p))
         (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> hypotheses)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;main-hint-of-smtlink-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-&gt;main-hint-of-smtlink-hint
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3MAIN-HINT.html">smtlink-hint-&gt;main-hint</a>
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p))
         (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> main-hint)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;let-binding-of-smtlink-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-&gt;let-binding-of-smtlink-hint
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3LET-BINDING.html">smtlink-hint-&gt;let-binding</a>
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p))
         (<a href="SMT____LET-BINDING-FIX.html">let-binding-fix</a> let-binding)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;symbols-of-smtlink-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-&gt;symbols-of-smtlink-hint
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3SYMBOLS.html">smtlink-hint-&gt;symbols</a>
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p))
         (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> symbols)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;abs-of-smtlink-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-&gt;abs-of-smtlink-hint
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3ABS.html">smtlink-hint-&gt;abs</a>
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p))
         (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> abs)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;fty-of-smtlink-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-&gt;fty-of-smtlink-hint
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3FTY.html">smtlink-hint-&gt;fty</a>
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p))
         (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> fty)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;fty-info-of-smtlink-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-&gt;fty-info-of-smtlink-hint
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3FTY-INFO.html">smtlink-hint-&gt;fty-info</a>
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p))
         (<a href="SMT____FTY-INFO-ALIST-FIX.html">fty-info-alist-fix</a> fty-info)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;fty-types-of-smtlink-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-&gt;fty-types-of-smtlink-hint
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3FTY-TYPES.html">smtlink-hint-&gt;fty-types</a>
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p))
         (<a href="SMT____FTY-TYPES-FIX.html">fty-types-fix</a> fty-types)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;int-to-rat-of-smtlink-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-&gt;int-to-rat-of-smtlink-hint
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3INT-TO-RAT.html">smtlink-hint-&gt;int-to-rat</a>
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p))
         (<a href="ACL2____BOOL-FIX.html">acl2::bool-fix</a> int-to-rat)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;smt-dir-of-smtlink-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-&gt;smt-dir-of-smtlink-hint
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3SMT-DIR.html">smtlink-hint-&gt;smt-dir</a>
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p))
         (<a href="ACL2____STR-FIX.html">str-fix</a> smt-dir)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;rm-file-of-smtlink-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-&gt;rm-file-of-smtlink-hint
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3RM-FILE.html">smtlink-hint-&gt;rm-file</a>
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p))
         (<a href="ACL2____BOOL-FIX.html">acl2::bool-fix</a> rm-file)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;smt-fname-of-smtlink-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-&gt;smt-fname-of-smtlink-hint
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3SMT-FNAME.html">smtlink-hint-&gt;smt-fname</a>
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p))
         (<a href="ACL2____STR-FIX.html">str-fix</a> smt-fname)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;smt-params-of-smtlink-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-&gt;smt-params-of-smtlink-hint
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3SMT-PARAMS.html">smtlink-hint-&gt;smt-params</a>
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p))
         (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> smt-params)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;fast-functions-of-smtlink-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-&gt;fast-functions-of-smtlink-hint
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3FAST-FUNCTIONS.html">smtlink-hint-&gt;fast-functions</a>
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p))
         (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> fast-functions)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;type-decl-list-of-smtlink-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-&gt;type-decl-list-of-smtlink-hint
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3TYPE-DECL-LIST.html">smtlink-hint-&gt;type-decl-list</a>
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p))
         (pseudo-term-fix type-decl-list)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;expanded-clause-w/-hint-of-smtlink-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-&gt;expanded-clause-w/-hint-of-smtlink-hint
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3EXPANDED-CLAUSE-W_F2-HINT.html">smtlink-hint-&gt;expanded-clause-w/-hint</a>
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p))
         (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> expanded-clause-w/-hint)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;expanded-g/type-of-smtlink-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-&gt;expanded-g/type-of-smtlink-hint
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3EXPANDED-G_F2TYPE.html">smtlink-hint-&gt;expanded-g/type</a>
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p))
         (pseudo-term-fix expanded-g/type)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;smt-cnf-of-smtlink-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-&gt;smt-cnf-of-smtlink-hint
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3SMT-CNF.html">smtlink-hint-&gt;smt-cnf</a>
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p))
         (<a href="SMT____SMTLINK-CONFIG-FIX.html">smtlink-config-fix</a> smt-cnf)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;wrld-fn-len-of-smtlink-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-&gt;wrld-fn-len-of-smtlink-hint
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3WRLD-FN-LEN.html">smtlink-hint-&gt;wrld-fn-len</a>
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p))
         (<a href="ACL2____NFIX.html">nfix</a> wrld-fn-len)))</pre> 
<p><b>Theorem: </b>smtlink-hint-&gt;custom-p-of-smtlink-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-&gt;custom-p-of-smtlink-hint
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3CUSTOM-P.html">smtlink-hint-&gt;custom-p</a>
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p))
         (<a href="ACL2____BOOL-FIX.html">acl2::bool-fix</a> custom-p)))</pre> 
<p><b>Theorem: </b>smtlink-hint-of-fields</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-of-fields
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> (<a href="SMT____SMTLINK-HINT-_E3FUNCTIONS.html">smtlink-hint-&gt;functions</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3HYPOTHESES.html">smtlink-hint-&gt;hypotheses</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3MAIN-HINT.html">smtlink-hint-&gt;main-hint</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3LET-BINDING.html">smtlink-hint-&gt;let-binding</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3SYMBOLS.html">smtlink-hint-&gt;symbols</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3ABS.html">smtlink-hint-&gt;abs</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3FTY.html">smtlink-hint-&gt;fty</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3FTY-INFO.html">smtlink-hint-&gt;fty-info</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3FTY-TYPES.html">smtlink-hint-&gt;fty-types</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3INT-TO-RAT.html">smtlink-hint-&gt;int-to-rat</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3SMT-DIR.html">smtlink-hint-&gt;smt-dir</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3RM-FILE.html">smtlink-hint-&gt;rm-file</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3SMT-FNAME.html">smtlink-hint-&gt;smt-fname</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3SMT-PARAMS.html">smtlink-hint-&gt;smt-params</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3FAST-FUNCTIONS.html">smtlink-hint-&gt;fast-functions</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3TYPE-DECL-LIST.html">smtlink-hint-&gt;type-decl-list</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3EXPANDED-CLAUSE-W_F2-HINT.html">smtlink-hint-&gt;expanded-clause-w/-hint</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3EXPANDED-G_F2TYPE.html">smtlink-hint-&gt;expanded-g/type</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3SMT-CNF.html">smtlink-hint-&gt;smt-cnf</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3WRLD-FN-LEN.html">smtlink-hint-&gt;wrld-fn-len</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3CUSTOM-P.html">smtlink-hint-&gt;custom-p</a> x))
            (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> x)))</pre> 
<p><b>Theorem: </b>smtlink-hint-fix-when-smtlink-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-fix-when-smtlink-hint
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> x)
            (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> (<a href="SMT____SMTLINK-HINT-_E3FUNCTIONS.html">smtlink-hint-&gt;functions</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3HYPOTHESES.html">smtlink-hint-&gt;hypotheses</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3MAIN-HINT.html">smtlink-hint-&gt;main-hint</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3LET-BINDING.html">smtlink-hint-&gt;let-binding</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3SYMBOLS.html">smtlink-hint-&gt;symbols</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3ABS.html">smtlink-hint-&gt;abs</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3FTY.html">smtlink-hint-&gt;fty</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3FTY-INFO.html">smtlink-hint-&gt;fty-info</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3FTY-TYPES.html">smtlink-hint-&gt;fty-types</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3INT-TO-RAT.html">smtlink-hint-&gt;int-to-rat</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3SMT-DIR.html">smtlink-hint-&gt;smt-dir</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3RM-FILE.html">smtlink-hint-&gt;rm-file</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3SMT-FNAME.html">smtlink-hint-&gt;smt-fname</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3SMT-PARAMS.html">smtlink-hint-&gt;smt-params</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3FAST-FUNCTIONS.html">smtlink-hint-&gt;fast-functions</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3TYPE-DECL-LIST.html">smtlink-hint-&gt;type-decl-list</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3EXPANDED-CLAUSE-W_F2-HINT.html">smtlink-hint-&gt;expanded-clause-w/-hint</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3EXPANDED-G_F2TYPE.html">smtlink-hint-&gt;expanded-g/type</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3SMT-CNF.html">smtlink-hint-&gt;smt-cnf</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3WRLD-FN-LEN.html">smtlink-hint-&gt;wrld-fn-len</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3CUSTOM-P.html">smtlink-hint-&gt;custom-p</a> x))))</pre> 
<p><b>Theorem: </b>equal-of-smtlink-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  equal-of-smtlink-hint
  (<a href="COMMON-LISP____EQUAL.html">equal</a>
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)
              x)
       (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> x)
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3FUNCTIONS.html">smtlink-hint-&gt;functions</a> x)
                   (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> functions))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3HYPOTHESES.html">smtlink-hint-&gt;hypotheses</a> x)
                   (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> hypotheses))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3MAIN-HINT.html">smtlink-hint-&gt;main-hint</a> x)
                   (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> main-hint))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3LET-BINDING.html">smtlink-hint-&gt;let-binding</a> x)
                   (<a href="SMT____LET-BINDING-FIX.html">let-binding-fix</a> let-binding))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3SYMBOLS.html">smtlink-hint-&gt;symbols</a> x)
                   (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> symbols))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3ABS.html">smtlink-hint-&gt;abs</a> x)
                   (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> abs))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3FTY.html">smtlink-hint-&gt;fty</a> x)
                   (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> fty))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3FTY-INFO.html">smtlink-hint-&gt;fty-info</a> x)
                   (<a href="SMT____FTY-INFO-ALIST-FIX.html">fty-info-alist-fix</a> fty-info))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3FTY-TYPES.html">smtlink-hint-&gt;fty-types</a> x)
                   (<a href="SMT____FTY-TYPES-FIX.html">fty-types-fix</a> fty-types))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3INT-TO-RAT.html">smtlink-hint-&gt;int-to-rat</a> x)
                   (<a href="ACL2____BOOL-FIX.html">acl2::bool-fix</a> int-to-rat))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3SMT-DIR.html">smtlink-hint-&gt;smt-dir</a> x)
                   (<a href="ACL2____STR-FIX.html">str-fix</a> smt-dir))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3RM-FILE.html">smtlink-hint-&gt;rm-file</a> x)
                   (<a href="ACL2____BOOL-FIX.html">acl2::bool-fix</a> rm-file))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3SMT-FNAME.html">smtlink-hint-&gt;smt-fname</a> x)
                   (<a href="ACL2____STR-FIX.html">str-fix</a> smt-fname))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3SMT-PARAMS.html">smtlink-hint-&gt;smt-params</a> x)
                   (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> smt-params))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3FAST-FUNCTIONS.html">smtlink-hint-&gt;fast-functions</a> x)
                   (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> fast-functions))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3TYPE-DECL-LIST.html">smtlink-hint-&gt;type-decl-list</a> x)
                   (pseudo-term-fix type-decl-list))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3EXPANDED-CLAUSE-W_F2-HINT.html">smtlink-hint-&gt;expanded-clause-w/-hint</a> x)
                   (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> expanded-clause-w/-hint))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3EXPANDED-G_F2TYPE.html">smtlink-hint-&gt;expanded-g/type</a> x)
                   (pseudo-term-fix expanded-g/type))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3SMT-CNF.html">smtlink-hint-&gt;smt-cnf</a> x)
                   (<a href="SMT____SMTLINK-CONFIG-FIX.html">smtlink-config-fix</a> smt-cnf))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3WRLD-FN-LEN.html">smtlink-hint-&gt;wrld-fn-len</a> x)
                   (<a href="ACL2____NFIX.html">nfix</a> wrld-fn-len))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-_E3CUSTOM-P.html">smtlink-hint-&gt;custom-p</a> x)
                   (<a href="ACL2____BOOL-FIX.html">acl2::bool-fix</a> custom-p)))))</pre> 
<p><b>Theorem: </b>smtlink-hint-of-func-list-fix-functions</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-of-func-list-fix-functions
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> functions)
                          hypotheses main-hint let-binding
                          symbols abs fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)
            (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding
                          symbols abs fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)))</pre> 
<p><b>Theorem: </b>smtlink-hint-func-list-equiv-congruence-on-functions</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-func-list-equiv-congruence-on-functions
  (<a href="ACL2____IMPLIES.html">implies</a>
       (<a href="SMT____FUNC-LIST-EQUIV.html">func-list-equiv</a> functions functions-equiv)
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions-equiv
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)))
  :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>smtlink-hint-of-hint-pair-list-fix-hypotheses</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-of-hint-pair-list-fix-hypotheses
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> hypotheses)
                          main-hint let-binding
                          symbols abs fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)
            (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding
                          symbols abs fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)))</pre> 
<p><b>Theorem: </b>smtlink-hint-hint-pair-list-equiv-congruence-on-hypotheses</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-hint-pair-list-equiv-congruence-on-hypotheses
  (<a href="ACL2____IMPLIES.html">implies</a>
       (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> hypotheses hypotheses-equiv)
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses-equiv main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)))
  :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>smtlink-hint-of-true-list-fix-main-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-of-true-list-fix-main-hint
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> main-hint)
                          let-binding
                          symbols abs fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)
            (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding
                          symbols abs fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)))</pre> 
<p><b>Theorem: </b>smtlink-hint-true-list-equiv-congruence-on-main-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-true-list-equiv-congruence-on-main-hint
  (<a href="ACL2____IMPLIES.html">implies</a>
       (true-list-equiv main-hint main-hint-equiv)
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint-equiv let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)))
  :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>smtlink-hint-of-let-binding-fix-let-binding</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-of-let-binding-fix-let-binding
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions hypotheses
                          main-hint (<a href="SMT____LET-BINDING-FIX.html">let-binding-fix</a> let-binding)
                          symbols abs fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)
            (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding
                          symbols abs fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)))</pre> 
<p><b>Theorem: </b>smtlink-hint-let-binding-equiv-congruence-on-let-binding</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-let-binding-equiv-congruence-on-let-binding
  (<a href="ACL2____IMPLIES.html">implies</a>
       (<a href="SMT____LET-BINDING-EQUIV.html">let-binding-equiv</a> let-binding let-binding-equiv)
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding-equiv
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)))
  :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>smtlink-hint-of-symbol-list-fix-symbols</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-of-symbol-list-fix-symbols
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions hypotheses main-hint
                          let-binding (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> symbols)
                          abs fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)
            (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding
                          symbols abs fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)))</pre> 
<p><b>Theorem: </b>smtlink-hint-symbol-list-equiv-congruence-on-symbols</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-symbol-list-equiv-congruence-on-symbols
  (<a href="ACL2____IMPLIES.html">implies</a>
       (<a href="ACL2____SYMBOL-LIST-EQUIV.html">acl2::symbol-list-equiv</a> symbols symbols-equiv)
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols-equiv abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)))
  :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>smtlink-hint-of-symbol-list-fix-abs</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-of-symbol-list-fix-abs
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding
                          symbols (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> abs)
                          fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)
            (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding
                          symbols abs fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)))</pre> 
<p><b>Theorem: </b>smtlink-hint-symbol-list-equiv-congruence-on-abs</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-symbol-list-equiv-congruence-on-abs
  (<a href="ACL2____IMPLIES.html">implies</a>
       (<a href="ACL2____SYMBOL-LIST-EQUIV.html">acl2::symbol-list-equiv</a> abs abs-equiv)
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs-equiv fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)))
  :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>smtlink-hint-of-symbol-list-fix-fty</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-of-symbol-list-fix-fty
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding
                          symbols abs (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> fty)
                          fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)
            (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding
                          symbols abs fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)))</pre> 
<p><b>Theorem: </b>smtlink-hint-symbol-list-equiv-congruence-on-fty</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-symbol-list-equiv-congruence-on-fty
  (<a href="ACL2____IMPLIES.html">implies</a>
       (<a href="ACL2____SYMBOL-LIST-EQUIV.html">acl2::symbol-list-equiv</a> fty fty-equiv)
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty-equiv fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)))
  :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>smtlink-hint-of-fty-info-alist-fix-fty-info</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-of-fty-info-alist-fix-fty-info
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding symbols
                          abs fty (<a href="SMT____FTY-INFO-ALIST-FIX.html">fty-info-alist-fix</a> fty-info)
                          fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)
            (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding
                          symbols abs fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)))</pre> 
<p><b>Theorem: </b>smtlink-hint-fty-info-alist-equiv-congruence-on-fty-info</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-fty-info-alist-equiv-congruence-on-fty-info
  (<a href="ACL2____IMPLIES.html">implies</a>
       (<a href="SMT____FTY-INFO-ALIST-EQUIV.html">fty-info-alist-equiv</a> fty-info fty-info-equiv)
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info-equiv fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)))
  :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>smtlink-hint-of-fty-types-fix-fty-types</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-of-fty-types-fix-fty-types
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions hypotheses
                          main-hint let-binding symbols abs
                          fty fty-info (<a href="SMT____FTY-TYPES-FIX.html">fty-types-fix</a> fty-types)
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)
            (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding
                          symbols abs fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)))</pre> 
<p><b>Theorem: </b>smtlink-hint-fty-types-equiv-congruence-on-fty-types</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-fty-types-equiv-congruence-on-fty-types
  (<a href="ACL2____IMPLIES.html">implies</a>
       (<a href="SMT____FTY-TYPES-EQUIV.html">fty-types-equiv</a> fty-types fty-types-equiv)
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types-equiv
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)))
  :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>smtlink-hint-of-bool-fix-int-to-rat</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-of-bool-fix-int-to-rat
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions hypotheses main-hint
                          let-binding symbols abs fty fty-info
                          fty-types (<a href="ACL2____BOOL-FIX.html">acl2::bool-fix</a> int-to-rat)
                          smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)
            (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding
                          symbols abs fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)))</pre> 
<p><b>Theorem: </b>smtlink-hint-iff-congruence-on-int-to-rat</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-iff-congruence-on-int-to-rat
  (<a href="ACL2____IMPLIES.html">implies</a>
       (<a href="ACL2____IFF.html">iff</a> int-to-rat int-to-rat-equiv)
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions hypotheses
                            main-hint let-binding symbols abs
                            fty fty-info fty-types int-to-rat-equiv
                            smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)))
  :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>smtlink-hint-of-str-fix-smt-dir</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-of-str-fix-smt-dir
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions hypotheses main-hint
                          let-binding symbols abs fty fty-info
                          fty-types int-to-rat (<a href="ACL2____STR-FIX.html">str-fix</a> smt-dir)
                          rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)
            (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding
                          symbols abs fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)))</pre> 
<p><b>Theorem: </b>smtlink-hint-streqv-congruence-on-smt-dir</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-streqv-congruence-on-smt-dir
  (<a href="ACL2____IMPLIES.html">implies</a>
       (<a href="ACL2____STREQV.html">acl2::streqv</a> smt-dir smt-dir-equiv)
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding symbols
                            abs fty fty-info fty-types int-to-rat
                            smt-dir-equiv rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)))
  :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>smtlink-hint-of-bool-fix-rm-file</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-of-bool-fix-rm-file
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding symbols
                          abs fty fty-info fty-types int-to-rat
                          smt-dir (<a href="ACL2____BOOL-FIX.html">acl2::bool-fix</a> rm-file)
                          smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)
            (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding
                          symbols abs fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)))</pre> 
<p><b>Theorem: </b>smtlink-hint-iff-congruence-on-rm-file</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-iff-congruence-on-rm-file
  (<a href="ACL2____IMPLIES.html">implies</a>
       (<a href="ACL2____IFF.html">iff</a> rm-file rm-file-equiv)
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding symbols
                            abs fty fty-info fty-types int-to-rat
                            smt-dir rm-file-equiv smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)))
  :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>smtlink-hint-of-str-fix-smt-fname</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-of-str-fix-smt-fname
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding symbols
                          abs fty fty-info fty-types int-to-rat
                          smt-dir rm-file (<a href="ACL2____STR-FIX.html">str-fix</a> smt-fname)
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)
            (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding
                          symbols abs fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)))</pre> 
<p><b>Theorem: </b>smtlink-hint-streqv-congruence-on-smt-fname</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-streqv-congruence-on-smt-fname
  (<a href="ACL2____IMPLIES.html">implies</a>
       (<a href="ACL2____STREQV.html">acl2::streqv</a> smt-fname smt-fname-equiv)
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding symbols
                            abs fty fty-info fty-types int-to-rat
                            smt-dir rm-file smt-fname-equiv
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)))
  :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>smtlink-hint-of-true-list-fix-smt-params</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-of-true-list-fix-smt-params
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions hypotheses main-hint
                          let-binding symbols abs fty fty-info
                          fty-types int-to-rat smt-dir rm-file
                          smt-fname (<a href="SMT____TRUE-LIST-FIX.html">true-list-fix</a> smt-params)
                          fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)
            (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding
                          symbols abs fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)))</pre> 
<p><b>Theorem: </b>smtlink-hint-true-list-equiv-congruence-on-smt-params</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-true-list-equiv-congruence-on-smt-params
  (<a href="ACL2____IMPLIES.html">implies</a>
       (true-list-equiv smt-params smt-params-equiv)
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions hypotheses
                            main-hint let-binding symbols abs fty
                            fty-info fty-types int-to-rat smt-dir
                            rm-file smt-fname smt-params-equiv
                            fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)))
  :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>smtlink-hint-of-func-alist-fix-fast-functions</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-of-func-alist-fix-fast-functions
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding symbols
                          abs fty fty-info fty-types int-to-rat
                          smt-dir rm-file smt-fname smt-params
                          (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> fast-functions)
                          type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)
            (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding
                          symbols abs fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)))</pre> 
<p><b>Theorem: </b>smtlink-hint-func-alist-equiv-congruence-on-fast-functions</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-func-alist-equiv-congruence-on-fast-functions
  (<a href="ACL2____IMPLIES.html">implies</a>
       (<a href="SMT____FUNC-ALIST-EQUIV.html">func-alist-equiv</a> fast-functions fast-functions-equiv)
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding symbols
                            abs fty fty-info fty-types int-to-rat
                            smt-dir rm-file smt-fname smt-params
                            fast-functions-equiv type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)))
  :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>smtlink-hint-of-pseudo-term-fix-type-decl-list</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-of-pseudo-term-fix-type-decl-list
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions hypotheses main-hint
                          let-binding symbols abs fty fty-info
                          fty-types int-to-rat smt-dir rm-file
                          smt-fname smt-params fast-functions
                          (pseudo-term-fix type-decl-list)
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)
            (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding
                          symbols abs fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)))</pre> 
<p><b>Theorem: </b>smtlink-hint-pseudo-term-equiv-congruence-on-type-decl-list</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-pseudo-term-equiv-congruence-on-type-decl-list
  (<a href="ACL2____IMPLIES.html">implies</a>
       (pseudo-term-equiv type-decl-list type-decl-list-equiv)
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding symbols
                            abs fty fty-info fty-types int-to-rat
                            smt-dir rm-file smt-fname smt-params
                            fast-functions type-decl-list-equiv
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)))
  :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>smtlink-hint-of-hint-pair-fix-expanded-clause-w/-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-of-hint-pair-fix-expanded-clause-w/-hint
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding
                          symbols abs fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> expanded-clause-w/-hint)
                          expanded-g/type
                          smt-cnf wrld-fn-len custom-p)
            (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding
                          symbols abs fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)))</pre> 
<p><b>Theorem: </b>smtlink-hint-hint-pair-equiv-congruence-on-expanded-clause-w/-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-hint-pair-equiv-congruence-on-expanded-clause-w/-hint
  (<a href="ACL2____IMPLIES.html">implies</a>
       (<a href="SMT____HINT-PAIR-EQUIV.html">hint-pair-equiv</a> expanded-clause-w/-hint
                        expanded-clause-w/-hint-equiv)
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint-equiv
                            expanded-g/type
                            smt-cnf wrld-fn-len custom-p)))
  :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>smtlink-hint-of-pseudo-term-fix-expanded-g/type</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-of-pseudo-term-fix-expanded-g/type
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions hypotheses main-hint
                          let-binding symbols abs fty fty-info
                          fty-types int-to-rat smt-dir rm-file
                          smt-fname smt-params fast-functions
                          type-decl-list expanded-clause-w/-hint
                          (pseudo-term-fix expanded-g/type)
                          smt-cnf wrld-fn-len custom-p)
            (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding
                          symbols abs fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)))</pre> 
<p><b>Theorem: </b>smtlink-hint-pseudo-term-equiv-congruence-on-expanded-g/type</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-pseudo-term-equiv-congruence-on-expanded-g/type
  (<a href="ACL2____IMPLIES.html">implies</a>
       (pseudo-term-equiv expanded-g/type expanded-g/type-equiv)
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions hypotheses main-hint
                            let-binding symbols abs fty fty-info
                            fty-types int-to-rat smt-dir rm-file
                            smt-fname smt-params fast-functions
                            type-decl-list expanded-clause-w/-hint
                            expanded-g/type-equiv
                            smt-cnf wrld-fn-len custom-p)))
  :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>smtlink-hint-of-smtlink-config-fix-smt-cnf</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-of-smtlink-config-fix-smt-cnf
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding
                          symbols abs fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          (<a href="SMT____SMTLINK-CONFIG-FIX.html">smtlink-config-fix</a> smt-cnf)
                          wrld-fn-len custom-p)
            (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding
                          symbols abs fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)))</pre> 
<p><b>Theorem: </b>smtlink-hint-smtlink-config-equiv-congruence-on-smt-cnf</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-smtlink-config-equiv-congruence-on-smt-cnf
  (<a href="ACL2____IMPLIES.html">implies</a>
       (<a href="SMT____SMTLINK-CONFIG-EQUIV.html">smtlink-config-equiv</a> smt-cnf smt-cnf-equiv)
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf-equiv wrld-fn-len custom-p)))
  :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>smtlink-hint-of-nfix-wrld-fn-len</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-of-nfix-wrld-fn-len
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding
                          symbols abs fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf (<a href="ACL2____NFIX.html">nfix</a> wrld-fn-len)
                          custom-p)
            (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding
                          symbols abs fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)))</pre> 
<p><b>Theorem: </b>smtlink-hint-nat-equiv-congruence-on-wrld-fn-len</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-nat-equiv-congruence-on-wrld-fn-len
  (<a href="ACL2____IMPLIES.html">implies</a>
       (<a href="ACL2____NAT-EQUIV.html">acl2::nat-equiv</a> wrld-fn-len wrld-fn-len-equiv)
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len-equiv custom-p)))
  :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>smtlink-hint-of-bool-fix-custom-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-of-bool-fix-custom-p
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions hypotheses main-hint
                          let-binding symbols abs fty fty-info
                          fty-types int-to-rat smt-dir rm-file
                          smt-fname smt-params fast-functions
                          type-decl-list expanded-clause-w/-hint
                          expanded-g/type smt-cnf
                          wrld-fn-len (<a href="ACL2____BOOL-FIX.html">acl2::bool-fix</a> custom-p))
            (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                          hypotheses main-hint let-binding
                          symbols abs fty fty-info fty-types
                          int-to-rat smt-dir rm-file smt-fname
                          smt-params fast-functions type-decl-list
                          expanded-clause-w/-hint expanded-g/type
                          smt-cnf wrld-fn-len custom-p)))</pre> 
<p><b>Theorem: </b>smtlink-hint-iff-congruence-on-custom-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  smtlink-hint-iff-congruence-on-custom-p
  (<a href="ACL2____IMPLIES.html">implies</a>
       (<a href="ACL2____IFF.html">iff</a> custom-p custom-p-equiv)
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p)
              (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> functions
                            hypotheses main-hint let-binding
                            symbols abs fty fty-info fty-types
                            int-to-rat smt-dir rm-file smt-fname
                            smt-params fast-functions type-decl-list
                            expanded-clause-w/-hint expanded-g/type
                            smt-cnf wrld-fn-len custom-p-equiv)))
  :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>smtlink-hint-fix-redef</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     smtlink-hint-fix-redef
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> x)
            (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> (<a href="SMT____SMTLINK-HINT-_E3FUNCTIONS.html">smtlink-hint-&gt;functions</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3HYPOTHESES.html">smtlink-hint-&gt;hypotheses</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3MAIN-HINT.html">smtlink-hint-&gt;main-hint</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3LET-BINDING.html">smtlink-hint-&gt;let-binding</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3SYMBOLS.html">smtlink-hint-&gt;symbols</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3ABS.html">smtlink-hint-&gt;abs</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3FTY.html">smtlink-hint-&gt;fty</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3FTY-INFO.html">smtlink-hint-&gt;fty-info</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3FTY-TYPES.html">smtlink-hint-&gt;fty-types</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3INT-TO-RAT.html">smtlink-hint-&gt;int-to-rat</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3SMT-DIR.html">smtlink-hint-&gt;smt-dir</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3RM-FILE.html">smtlink-hint-&gt;rm-file</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3SMT-FNAME.html">smtlink-hint-&gt;smt-fname</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3SMT-PARAMS.html">smtlink-hint-&gt;smt-params</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3FAST-FUNCTIONS.html">smtlink-hint-&gt;fast-functions</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3TYPE-DECL-LIST.html">smtlink-hint-&gt;type-decl-list</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3EXPANDED-CLAUSE-W_F2-HINT.html">smtlink-hint-&gt;expanded-clause-w/-hint</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3EXPANDED-G_F2TYPE.html">smtlink-hint-&gt;expanded-g/type</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3SMT-CNF.html">smtlink-hint-&gt;smt-cnf</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3WRLD-FN-LEN.html">smtlink-hint-&gt;wrld-fn-len</a> x)
                          (<a href="SMT____SMTLINK-HINT-_E3CUSTOM-P.html">smtlink-hint-&gt;custom-p</a> x)))
     :rule-classes :definition)</pre> 
<p><b>Function: </b>maybe-smtlink-hint-p</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> maybe-smtlink-hint-p (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'maybe-smtlink-hint-p))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____NOT.html">not</a> x) (<a href="ACL2____B_A2.html">b*</a> nil t))
                  (t (<a href="ACL2____B_A2.html">b*</a> ((fty::val x))
                         (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> fty::val))))))</pre> 
<p><b>Theorem: </b>maybe-smtlink-hint-p-when-smtlink-hint-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> maybe-smtlink-hint-p-when-smtlink-hint-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> x)
                 (<a href="SMT____MAYBE-SMTLINK-HINT-P.html">maybe-smtlink-hint-p</a> x)))</pre> 
<p><b>Theorem: </b>smtlink-hint-p-when-maybe-smtlink-hint-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> smtlink-hint-p-when-maybe-smtlink-hint-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____MAYBE-SMTLINK-HINT-P.html">maybe-smtlink-hint-p</a> x)
                      (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> x))
                 (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> x)))</pre> 
<p><b>Function: </b>maybe-smtlink-hint-fix$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     maybe-smtlink-hint-fix$inline (x)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____MAYBE-SMTLINK-HINT-P.html">maybe-smtlink-hint-p</a> x)))
     (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'maybe-smtlink-hint-fix))
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
          (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____NOT.html">not</a> x) nil)
                            (t (<a href="ACL2____B_A2.html">b*</a> ((fty::val (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> x)))
                                   fty::val)))
               :exec x)))</pre> 
<p><b>Theorem: </b>maybe-smtlink-hint-p-of-maybe-smtlink-hint-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> maybe-smtlink-hint-p-of-maybe-smtlink-hint-fix
        (<a href="ACL2____B_A2.html">b*</a> ((new-x (maybe-smtlink-hint-fix$inline x)))
            (<a href="SMT____MAYBE-SMTLINK-HINT-P.html">maybe-smtlink-hint-p</a> new-x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>maybe-smtlink-hint-fix-when-maybe-smtlink-hint-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> maybe-smtlink-hint-fix-when-maybe-smtlink-hint-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____MAYBE-SMTLINK-HINT-P.html">maybe-smtlink-hint-p</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____MAYBE-SMTLINK-HINT-FIX.html">maybe-smtlink-hint-fix</a> x) x)))</pre> 
<p><b>Function: </b>maybe-smtlink-hint-equiv$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> maybe-smtlink-hint-equiv$inline
       (acl2::x acl2::y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____MAYBE-SMTLINK-HINT-P.html">maybe-smtlink-hint-p</a> acl2::x)
                                   (<a href="SMT____MAYBE-SMTLINK-HINT-P.html">maybe-smtlink-hint-p</a> acl2::y))))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____MAYBE-SMTLINK-HINT-FIX.html">maybe-smtlink-hint-fix</a> acl2::x)
              (<a href="SMT____MAYBE-SMTLINK-HINT-FIX.html">maybe-smtlink-hint-fix</a> acl2::y)))</pre> 
<p><b>Theorem: </b>maybe-smtlink-hint-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> maybe-smtlink-hint-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="SMT____MAYBE-SMTLINK-HINT-EQUIV.html">maybe-smtlink-hint-equiv</a> x y))
             (<a href="SMT____MAYBE-SMTLINK-HINT-EQUIV.html">maybe-smtlink-hint-equiv</a> x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____MAYBE-SMTLINK-HINT-EQUIV.html">maybe-smtlink-hint-equiv</a> x y)
                      (<a href="SMT____MAYBE-SMTLINK-HINT-EQUIV.html">maybe-smtlink-hint-equiv</a> y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____MAYBE-SMTLINK-HINT-EQUIV.html">maybe-smtlink-hint-equiv</a> x y)
                           (<a href="SMT____MAYBE-SMTLINK-HINT-EQUIV.html">maybe-smtlink-hint-equiv</a> y z))
                      (<a href="SMT____MAYBE-SMTLINK-HINT-EQUIV.html">maybe-smtlink-hint-equiv</a> x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>maybe-smtlink-hint-equiv-implies-equal-maybe-smtlink-hint-fix-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     maybe-smtlink-hint-equiv-implies-equal-maybe-smtlink-hint-fix-1
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____MAYBE-SMTLINK-HINT-EQUIV.html">maybe-smtlink-hint-equiv</a> acl2::x x-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____MAYBE-SMTLINK-HINT-FIX.html">maybe-smtlink-hint-fix</a> acl2::x)
                     (<a href="SMT____MAYBE-SMTLINK-HINT-FIX.html">maybe-smtlink-hint-fix</a> x-equiv)))
     :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>maybe-smtlink-hint-fix-under-maybe-smtlink-hint-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> maybe-smtlink-hint-fix-under-maybe-smtlink-hint-equiv
        (<a href="SMT____MAYBE-SMTLINK-HINT-EQUIV.html">maybe-smtlink-hint-equiv</a> (<a href="SMT____MAYBE-SMTLINK-HINT-FIX.html">maybe-smtlink-hint-fix</a> acl2::x)
                                  acl2::x)
        :rule-classes (:rewrite :rewrite-quoted-constant))</pre> 
<p><b>Theorem: </b>equal-of-maybe-smtlink-hint-fix-1-forward-to-maybe-smtlink-hint-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 equal-of-maybe-smtlink-hint-fix-1-forward-to-maybe-smtlink-hint-equiv
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____MAYBE-SMTLINK-HINT-FIX.html">maybe-smtlink-hint-fix</a> acl2::x)
                 acl2::y)
          (<a href="SMT____MAYBE-SMTLINK-HINT-EQUIV.html">maybe-smtlink-hint-equiv</a> acl2::x acl2::y))
 :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>equal-of-maybe-smtlink-hint-fix-2-forward-to-maybe-smtlink-hint-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 equal-of-maybe-smtlink-hint-fix-2-forward-to-maybe-smtlink-hint-equiv
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> acl2::x
                 (<a href="SMT____MAYBE-SMTLINK-HINT-FIX.html">maybe-smtlink-hint-fix</a> acl2::y))
          (<a href="SMT____MAYBE-SMTLINK-HINT-EQUIV.html">maybe-smtlink-hint-equiv</a> acl2::x acl2::y))
 :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>maybe-smtlink-hint-equiv-of-maybe-smtlink-hint-fix-1-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 maybe-smtlink-hint-equiv-of-maybe-smtlink-hint-fix-1-forward
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____MAYBE-SMTLINK-HINT-EQUIV.html">maybe-smtlink-hint-equiv</a> (<a href="SMT____MAYBE-SMTLINK-HINT-FIX.html">maybe-smtlink-hint-fix</a> acl2::x)
                                    acl2::y)
          (<a href="SMT____MAYBE-SMTLINK-HINT-EQUIV.html">maybe-smtlink-hint-equiv</a> acl2::x acl2::y))
 :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>maybe-smtlink-hint-equiv-of-maybe-smtlink-hint-fix-2-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    maybe-smtlink-hint-equiv-of-maybe-smtlink-hint-fix-2-forward
    (<a href="ACL2____IMPLIES.html">implies</a>
         (<a href="SMT____MAYBE-SMTLINK-HINT-EQUIV.html">maybe-smtlink-hint-equiv</a> acl2::x
                                   (<a href="SMT____MAYBE-SMTLINK-HINT-FIX.html">maybe-smtlink-hint-fix</a> acl2::y))
         (<a href="SMT____MAYBE-SMTLINK-HINT-EQUIV.html">maybe-smtlink-hint-equiv</a> acl2::x acl2::y))
    :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>maybe-smtlink-hint-fix-under-iff</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> maybe-smtlink-hint-fix-under-iff
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____MAYBE-SMTLINK-HINT-FIX.html">maybe-smtlink-hint-fix</a> x) x))</pre> 
<p><b>Theorem: </b>maybe-smtlink-hint-equiv-refines-smtlink-hint-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> maybe-smtlink-hint-equiv-refines-smtlink-hint-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____MAYBE-SMTLINK-HINT-EQUIV.html">maybe-smtlink-hint-equiv</a> x y)
                 (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> x y))
        :rule-classes (:refinement))</pre> 
<p><b>Function: </b>maybe-smtlink-hint-none</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> maybe-smtlink-hint-none
       nil (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'maybe-smtlink-hint-none))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            nil))</pre> 
<p><b>Theorem: </b>return-type-of-maybe-smtlink-hint-none</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> return-type-of-maybe-smtlink-hint-none
        (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="SMT____MAYBE-SMTLINK-HINT-NONE.html">maybe-smtlink-hint-none</a>)))
            (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____MAYBE-SMTLINK-HINT-P.html">maybe-smtlink-hint-p</a> x) (<a href="COMMON-LISP____NOT.html">not</a> x)))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>maybe-smtlink-hint-fix-when-none</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> maybe-smtlink-hint-fix-when-none
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____MAYBE-SMTLINK-HINT-FIX.html">maybe-smtlink-hint-fix</a> x)
                        (<a href="SMT____MAYBE-SMTLINK-HINT-NONE.html">maybe-smtlink-hint-none</a>)))
        :rule-classes ((:rewrite :backchain-limit-lst 0)))</pre> 
<p><b>Theorem: </b>equal-of-maybe-smtlink-hint-none</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-maybe-smtlink-hint-none
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____MAYBE-SMTLINK-HINT-NONE.html">maybe-smtlink-hint-none</a>) x)
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____MAYBE-SMTLINK-HINT-P.html">maybe-smtlink-hint-p</a> x) (<a href="COMMON-LISP____NOT.html">not</a> x))))</pre> 
<p><b>Function: </b>maybe-smtlink-hint-some-&gt;val$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> maybe-smtlink-hint-some-&gt;val$inline (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____MAYBE-SMTLINK-HINT-P.html">maybe-smtlink-hint-p</a> x)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard x))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'maybe-smtlink-hint-some-&gt;val))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> x x)))
                            (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> x))
                 :exec x)))</pre> 
<p><b>Theorem: </b>smtlink-hint-p-of-maybe-smtlink-hint-some-&gt;val</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> smtlink-hint-p-of-maybe-smtlink-hint-some-&gt;val
        (<a href="ACL2____B_A2.html">b*</a> ((fty::val (maybe-smtlink-hint-some-&gt;val$inline x)))
            (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> fty::val))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>maybe-smtlink-hint-some-&gt;val$inline-of-maybe-smtlink-hint-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 maybe-smtlink-hint-some-&gt;val$inline-of-maybe-smtlink-hint-fix-x
 (<a href="COMMON-LISP____EQUAL.html">equal</a>
    (maybe-smtlink-hint-some-&gt;val$inline (<a href="SMT____MAYBE-SMTLINK-HINT-FIX.html">maybe-smtlink-hint-fix</a> x))
    (maybe-smtlink-hint-some-&gt;val$inline x)))</pre> 
<p><b>Theorem: </b>maybe-smtlink-hint-some-&gt;val$inline-maybe-smtlink-hint-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 maybe-smtlink-hint-some-&gt;val$inline-maybe-smtlink-hint-equiv-congruence-on-x
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____MAYBE-SMTLINK-HINT-EQUIV.html">maybe-smtlink-hint-equiv</a> x x-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (maybe-smtlink-hint-some-&gt;val$inline x)
                 (maybe-smtlink-hint-some-&gt;val$inline x-equiv)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>maybe-smtlink-hint-some-&gt;val-when-wrong-kind</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> maybe-smtlink-hint-some-&gt;val-when-wrong-kind
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____MAYBE-SMTLINK-HINT-SOME-_E3VAL.html">maybe-smtlink-hint-some-&gt;val</a> x)
                        (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> nil))))</pre> 
<p><b>Function: </b>maybe-smtlink-hint-some</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> maybe-smtlink-hint-some (fty::val)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> fty::val)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'maybe-smtlink-hint-some))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____B_A2.html">b*</a> ((fty::val (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> fty::val)
                                :exec fty::val)))
                fty::val)))</pre> 
<p><b>Theorem: </b>return-type-of-maybe-smtlink-hint-some</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> return-type-of-maybe-smtlink-hint-some
        (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="SMT____MAYBE-SMTLINK-HINT-SOME.html">maybe-smtlink-hint-some</a> fty::val)))
            (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____MAYBE-SMTLINK-HINT-P.html">maybe-smtlink-hint-p</a> x) x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>maybe-smtlink-hint-some-&gt;val-of-maybe-smtlink-hint-some</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 maybe-smtlink-hint-some-&gt;val-of-maybe-smtlink-hint-some
 (<a href="COMMON-LISP____EQUAL.html">equal</a>
   (<a href="SMT____MAYBE-SMTLINK-HINT-SOME-_E3VAL.html">maybe-smtlink-hint-some-&gt;val</a> (<a href="SMT____MAYBE-SMTLINK-HINT-SOME.html">maybe-smtlink-hint-some</a> fty::val))
   (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> fty::val)))</pre> 
<p><b>Theorem: </b>maybe-smtlink-hint-some-of-fields</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 maybe-smtlink-hint-some-of-fields
 (<a href="ACL2____IMPLIES.html">implies</a>
   x
   (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____MAYBE-SMTLINK-HINT-SOME.html">maybe-smtlink-hint-some</a> (<a href="SMT____MAYBE-SMTLINK-HINT-SOME-_E3VAL.html">maybe-smtlink-hint-some-&gt;val</a> x))
          (<a href="SMT____MAYBE-SMTLINK-HINT-FIX.html">maybe-smtlink-hint-fix</a> x))))</pre> 
<p><b>Theorem: </b>maybe-smtlink-hint-fix-when-some</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 maybe-smtlink-hint-fix-when-some
 (<a href="ACL2____IMPLIES.html">implies</a>
   x
   (<a href="COMMON-LISP____EQUAL.html">equal</a>
        (<a href="SMT____MAYBE-SMTLINK-HINT-FIX.html">maybe-smtlink-hint-fix</a> x)
        (<a href="SMT____MAYBE-SMTLINK-HINT-SOME.html">maybe-smtlink-hint-some</a> (<a href="SMT____MAYBE-SMTLINK-HINT-SOME-_E3VAL.html">maybe-smtlink-hint-some-&gt;val</a> x))))
 :rule-classes ((:rewrite :backchain-limit-lst 0)))</pre> 
<p><b>Theorem: </b>equal-of-maybe-smtlink-hint-some</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-maybe-smtlink-hint-some
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____MAYBE-SMTLINK-HINT-SOME.html">maybe-smtlink-hint-some</a> fty::val)
                      x)
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____MAYBE-SMTLINK-HINT-P.html">maybe-smtlink-hint-p</a> x)
                    x
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____MAYBE-SMTLINK-HINT-SOME-_E3VAL.html">maybe-smtlink-hint-some-&gt;val</a> x)
                           (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> fty::val)))))</pre> 
<p><b>Theorem: </b>maybe-smtlink-hint-some-of-smtlink-hint-fix-val</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> maybe-smtlink-hint-some-of-smtlink-hint-fix-val
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____MAYBE-SMTLINK-HINT-SOME.html">maybe-smtlink-hint-some</a> (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> fty::val))
               (<a href="SMT____MAYBE-SMTLINK-HINT-SOME.html">maybe-smtlink-hint-some</a> fty::val)))</pre> 
<p><b>Theorem: </b>maybe-smtlink-hint-some-smtlink-hint-equiv-congruence-on-val</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> maybe-smtlink-hint-some-smtlink-hint-equiv-congruence-on-val
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____SMTLINK-HINT-EQUIV.html">smtlink-hint-equiv</a> fty::val val-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____MAYBE-SMTLINK-HINT-SOME.html">maybe-smtlink-hint-some</a> fty::val)
                        (<a href="SMT____MAYBE-SMTLINK-HINT-SOME.html">maybe-smtlink-hint-some</a> val-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>maybe-smtlink-hint-fix-redef</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 maybe-smtlink-hint-fix-redef
 (<a href="COMMON-LISP____EQUAL.html">equal</a>
  (<a href="SMT____MAYBE-SMTLINK-HINT-FIX.html">maybe-smtlink-hint-fix</a> x)
  (<a href="COMMON-LISP____COND.html">cond</a>
    ((<a href="COMMON-LISP____NOT.html">not</a> x) (<a href="SMT____MAYBE-SMTLINK-HINT-NONE.html">maybe-smtlink-hint-none</a>))
    (t (<a href="SMT____MAYBE-SMTLINK-HINT-SOME.html">maybe-smtlink-hint-some</a> (<a href="SMT____MAYBE-SMTLINK-HINT-SOME-_E3VAL.html">maybe-smtlink-hint-some-&gt;val</a> x)))))
 :rule-classes :definition)</pre> 
<p><b>Function: </b>flatten-formals/returns</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     flatten-formals/returns
     (formal/return-lst)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____DECL-LISTP.html">decl-listp</a> formal/return-lst)))
     (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'flatten-formals/returns))
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
          (<a href="ACL2____B_A2.html">b*</a> ((formal/return-lst (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> formal/return-lst))
               ((<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ENDP.html">endp</a> formal/return-lst)) nil)
               ((<a href="COMMON-LISP____CONS.html">cons</a> first rest) formal/return-lst)
               ((<a href="SMT____DECL.html">decl</a> d) first))
              (<a href="COMMON-LISP____CONS.html">cons</a> d.name
                    (flatten-formals/returns rest)))))</pre> 
<p><b>Theorem: </b>symbol-listp-of-flatten-formals/returns</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   symbol-listp-of-flatten-formals/returns
   (<a href="ACL2____B_A2.html">b*</a> ((flattened-lst (flatten-formals/returns formal/return-lst)))
       (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> flattened-lst))
   :rule-classes :rewrite)</pre> 
<p><b>Function: </b>make-alist-fn-lst</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 make-alist-fn-lst (fn-lst)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____FUNC-LISTP.html">func-listp</a> fn-lst)))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'make-alist-fn-lst))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____B_A2.html">b*</a>
   ((fn-lst (<a href="SMT____FUNC-LIST-FIX.html">func-list-fix</a> fn-lst))
    ((unless (<a href="COMMON-LISP____CONSP.html">consp</a> fn-lst)) nil)
    ((<a href="COMMON-LISP____CONS.html">cons</a> first rest) fn-lst)
    ((<a href="SMT____FUNC.html">func</a> f) first)
    (new-f
      (<a href="SMT____CHANGE-FUNC.html">change-func</a>
           f
           :flattened-formals (flatten-formals/returns f.formals)
           :flattened-returns (flatten-formals/returns f.returns))))
   (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> f.name new-f)
         (<a href="SMT____MAKE-ALIST-FN-LST.html">make-alist-fn-lst</a> rest)))))</pre> 
<p><b>Theorem: </b>func-alistp-of-make-alist-fn-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-make-alist-fn-lst
        (<a href="ACL2____B_A2.html">b*</a> ((fast-fn-lst (<a href="SMT____MAKE-ALIST-FN-LST.html">make-alist-fn-lst</a> fn-lst)))
            (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> fast-fn-lst))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>smtlink-p-of-smt-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> smtlink-p-of-smt-hint
        (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> (<a href="SMT____SMT-HINT.html">smt-hint</a>)))</pre> 
<p><b>Function: </b>default-smtlink-hint</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> default-smtlink-hint
       nil (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'default-smtlink-hint))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="SMT____CHANGE-SMTLINK-HINT.html">change-smtlink-hint</a> *default-smtlink-hint*)))</pre> 

</body>
</html>
