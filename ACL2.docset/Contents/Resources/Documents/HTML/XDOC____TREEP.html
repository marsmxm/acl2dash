<html>
<head>
<meta charset="UTF-8">
<title>Treep</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=XDOC____TREEP">Click for Treep in the Full Manual</a></h3>

<p>Recognize XDOC trees.</p><p>These are the trees produced by the XDOC constructors.</p> 
   <p>These trees have strings at the leaves. 
      A non-leaf node consists of one of the following:</p> 
   <ul> 
     <li>A single keyword. 
         This represents either 
         (i) a preprocessor directive 
         or (ii) a concatenation of subtrees 
         without a surrounding XML tag or preprocessor directive. 
         Examples of (i) are <span class="v">:@def</span> and <span class="v">:@{}</span>. 
         The keyword <span class="v">:&amp;&amp;</span> is used for (ii). 
         The latter is useful to treat sequences of trees as single trees.</li> 
     <li>A <span class="tt"><a href="COMMON-LISP____CONS.html">cons</a></span> pair 
         whose <span class="tt"><a href="COMMON-LISP____CAR.html">car</a></span> is a keyword and 
         whose <span class="tt"><a href="COMMON-LISP____CDR.html">cdr</a></span> is an alist from keywords to subtrees. 
         This represents an XML tag, 
         identified by the keyword at the <span class="tt"><a href="COMMON-LISP____CAR.html">car</a></span>, 
         with the attributes represented by the alist at the <span class="tt"><a href="COMMON-LISP____CDR.html">cdr</a></span>. 
         Examples are <span class="v">(:p)</span> and <span class="v">(:img (:src ...))</span>. 
         The alist may often be <span class="v">nil</span>. 
         The values of the attributes are recursively represented as subtrees, 
         but there may often be a single string subtree per attribute.</li> 
   </ul> 
   <p>In some sense, 
      the semantics of XDOC trees is defined by their conversion to flat strings. 
      See <span class="tt"><a href="XDOC____TREE-TO-STRING.html">tree-to-string</a></span>.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>treep</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> treep (x)
       (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____STRINGP.html">stringp</a> x)
           (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> x)
                (<a href="COMMON-LISP____CONSP.html">consp</a> x)
                (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____KEYWORDP.html">keywordp</a> (<a href="COMMON-LISP____CAR.html">car</a> x))
                    (tree-tagp (<a href="COMMON-LISP____CAR.html">car</a> x)))
                (tree-listp (<a href="COMMON-LISP____CDR.html">cdr</a> x)))))</pre> 
<p><b>Function: </b>tree-listp</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> tree-listp (x)
       (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____ATOM.html">atom</a> x) (<a href="COMMON-LISP____EQ.html">eq</a> x nil))
             (t (<a href="COMMON-LISP____AND.html">and</a> (<a href="XDOC____TREEP.html">treep</a> (<a href="COMMON-LISP____CAR.html">car</a> x))
                     (tree-listp (<a href="COMMON-LISP____CDR.html">cdr</a> x))))))</pre> 
<p><b>Function: </b>tree-tagp</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> tree-tagp (x)
       (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x)
            (<a href="COMMON-LISP____KEYWORDP.html">keywordp</a> (<a href="COMMON-LISP____CAR.html">car</a> x))
            (keyword-tree-alistp (<a href="COMMON-LISP____CDR.html">cdr</a> x))))</pre> 
<p><b>Function: </b>keyword-tree-alistp</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> keyword-tree-alistp (x)
       (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____ATOM.html">atom</a> x) (<a href="COMMON-LISP____EQ.html">eq</a> x nil))
             (t (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CAR.html">car</a> x))
                     (<a href="COMMON-LISP____KEYWORDP.html">keywordp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> x)))
                     (<a href="XDOC____TREEP.html">treep</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="COMMON-LISP____CAR.html">car</a> x)))
                     (keyword-tree-alistp (<a href="COMMON-LISP____CDR.html">cdr</a> x))))))</pre> 
<p><b>Theorem: </b>treep-when-stringp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> treep-when-stringp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____STRINGP.html">stringp</a> x) (<a href="XDOC____TREEP.html">treep</a> x)))</pre> 
<p><b>Theorem: </b>tree-listp-when-string-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> tree-listp-when-string-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____STRING-LISTP.html">string-listp</a> x)
                 (tree-listp x)))</pre> 
<p><b>Theorem: </b>true-listp-when-tree-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> true-listp-when-tree-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (tree-listp x) (<a href="ACL2____TRUE-LISTP.html">true-listp</a> x))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>treep-of-cons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> treep-of-cons
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="XDOC____TREEP.html">treep</a> (<a href="COMMON-LISP____CONS.html">cons</a> x y))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____KEYWORDP.html">keywordp</a> x) (tree-tagp x))
                    (tree-listp y))))</pre> 
<p><b>Theorem: </b>tree-listp-of-cons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> tree-listp-of-cons
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (tree-listp (<a href="COMMON-LISP____CONS.html">cons</a> x y))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="XDOC____TREEP.html">treep</a> x) (tree-listp y))))</pre> 
<p><b>Theorem: </b>tagp-of-cons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> tagp-of-cons
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (tree-tagp (<a href="COMMON-LISP____CONS.html">cons</a> x y))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____KEYWORDP.html">keywordp</a> x)
                    (keyword-tree-alistp y))))</pre> 
<p><b>Theorem: </b>keyword-tree-alistp-of-cons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> keyword-tree-alistp-of-cons
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (keyword-tree-alistp (<a href="COMMON-LISP____CONS.html">cons</a> x y))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x)
                    (<a href="COMMON-LISP____KEYWORDP.html">keywordp</a> (<a href="COMMON-LISP____CAR.html">car</a> x))
                    (<a href="XDOC____TREEP.html">treep</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x))
                    (keyword-tree-alistp y))))</pre> 

</body>
</html>
