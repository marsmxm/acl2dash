<html>
<head>
<meta charset="UTF-8">
<title>Introductory-challenge-problem-4</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____INTRODUCTORY-CHALLENGE-PROBLEM-4">Click for Introductory-challenge-problem-4 in the Full Manual</a></h3>

<p>Challenge problem 4 for the new user of ACL2</p><p>Start in a fresh ACL2, either by restarting your ACL2 image from 
 scratch or executing <span class="v">:ubt! 1</span>.</p> 
 
 <p>This problem is much more open ended than the preceding ones.  The 
 challenge is to define a function that collects exactly one copy of each 
 element of a list and to prove that it returns a subset of the list with no 
 duplications.</p> 
 
 <p>(Is this all that one might want to prove?  It is a good idea to think 
 about that question, for any application; an answer for this example is at the 
 end of this topic.)</p> 
 
 <p><b>Hint</b>: We recommend that you read this hint to align your function 
 names with our solution, to make comparisons easier.  Our answer is shown in 
 see <a href="ACL2____INTRODUCTORY-CHALLENGE-PROBLEM-4-ANSWER.html">introductory-challenge-problem-4-answer</a>.  In that page you'll see a 
 definition of a function <span class="v">collect-once</span> and the proofs of two theorems:</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> main-theorem-1-about-collect-once
  (<a href="COMMON-LISP____SUBSETP.html">subsetp</a> (collect-once x) x))

(<a href="ACL2____DEFTHM.html">defthm</a> main-theorem-2-about-collect-once
  (<a href="COMMON-LISP____NOT.html">not</a> (dupsp (collect-once x))))</pre> 
 
 <p>The function <span class="v">dupsp</span> is as defined in see <a href="ACL2____INTRODUCTORY-CHALLENGE-PROBLEM-3.html">introductory-challenge-problem-3</a>.  This is quite easy.</p> 
 
 <p>Then, we define a tail-recursive version of the method based on the 
 pseudo-code:</p> 
 
 <pre class="code">a = nil;
while (x not empty) {
 a = if (<a href="COMMON-LISP____MEMBER.html">member</a> (<a href="COMMON-LISP____CAR.html">car</a> x) a) then a else (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> x) a);
 x = (<a href="COMMON-LISP____CDR.html">cdr</a> x);
 }
return a;</pre> 
 
 <p>We formalize this with the function <span class="v">while-loop-version</span>, where 
 <span class="v">(while-loop-version x nil)</span> is the ``semantics'' of the code above.  I.e., 
 the function <span class="v">while-loop-version</span> captures the while loop in the 
 pseudo-code above and returns the final value of <span class="v">a</span>, and it should be 
 invoked with the initial value of <span class="v">a</span> being <span class="v">nil</span>.</p> 
 
 <p>We prove <span class="v">(while-loop-version x nil)</span> returns a subset of <span class="v">x</span> that 
 contains no duplications.  Furthermore, we do it two ways: first 
 ``indirectly'' by relating <span class="v">while-loop-version</span> to <span class="v">collect-once</span>, and 
 second (``directly'') without using <span class="v">collect-once</span>.  Both of these proofs 
 are much harder than the <span class="v">collect-once</span> approach, involving about a dozen 
 lemmas each.</p> 
 
 <p>Compare your solutions to ours at see <a href="ACL2____INTRODUCTORY-CHALLENGE-PROBLEM-4-ANSWER.html">introductory-challenge-problem-4-answer</a>.</p> 
 
 <p>Then, use your browser's <b>Back Button</b> to return to <a href="ACL2____INTRODUCTORY-CHALLENGES.html">introductory-challenges</a>.</p> 
 
 <p>We conclude this topic by returning to the question posed earlier above: Is 
 this all that one might want to prove?  Notice that we didn't prove that every 
 element of the given list is indeed an element of the returned list, which 
 could be formalized as follows.</p> 
 
 <pre class="code">(<a href="ACL2____THM.html">thm</a>
  (<a href="COMMON-LISP____SUBSETP.html">subsetp</a> x (collect-once x)))</pre>
</body>
</html>
