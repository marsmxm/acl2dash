<html>
<head>
<meta charset="UTF-8">
<title>Lemma-instance</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____LEMMA-INSTANCE">Click for Lemma-instance in the Full Manual</a></h3>

<p>An object denoting an instance of a theorem</p><p>Lemma instances are the objects one provides via <span class="v">:use</span> and 
 <span class="v">:by</span> <a href="ACL2____HINTS.html">hints</a> to bring to the theorem prover's attention some 
 previously proved or easily provable fact.  A typical use of the <span class="v">:use</span> 
 hint is given below.  The value specified is a list of five lemma 
 instances.</p> 
 
 <pre class="code">:use (reverse-reverse
      (:type-prescription app)
      (:instance assoc-of-app
                 (x a) (y b) (z c))
      (:functional-instance p-f
                            (p consp) (f flatten))
      (:instance (:theorem (<a href="COMMON-LISP____EQUAL.html">equal</a> x x))
                 (x (<a href="ACL2____FLATTEN.html">flatten</a> a))))</pre> 
 
 <p>Observe that an event name can be a lemma instance.  The <span class="v">:use</span> hint 
 allows a single lemma instance to be provided in lieu of a list, as in:</p> 
 
 <pre class="code">:use reverse-reverse</pre> 
 
 <p>or</p> 
 
 <pre class="code">:use (:instance assoc-of-app (x a) (y b) (z c))</pre> 
 
 <p>A lemma instance denotes a formula which is either known to be a theorem or 
 which must be proved to be a theorem before it can be used.  To use a lemma 
 instance in a particular subgoal, the theorem prover adds the formula as a 
 hypothesis to the subgoal before the normal theorem proving heuristics are 
 applied.</p> 
 
 <p>A lemma instance, or <span class="v">lmi</span>, is of one of the following forms:</p> 
 
 <p>(1) <span class="v">name</span>, where <span class="v">name</span> names a previously proved theorem, axiom, or 
 definition and denotes the formula (theorem) of that name.</p> 
 
 <p>(2) <span class="v">rune</span>, where <span class="v">rune</span> is a <a href="ACL2____RUNE.html">rune</a> (see <a href="ACL2____RUNE.html">rune</a>) denoting 
 the <span class="v">:</span><span class="tt"><a href="ACL2____COROLLARY.html">corollary</a></span> justifying the rule named by the <a href="ACL2____RUNE.html">rune</a>.</p> 
 
 <p>(3) <span class="v">(:theorem term)</span>, where <span class="v">term</span> is any term alleged to be a 
 theorem.  Such a lemma instance denotes the formula <span class="v">term</span>.  But before 
 using such a lemma instance the system will undertake to prove <span class="v">term</span>.</p> 
 
 <p>(4) <span class="v">(:instance lmi (v1 t1) ... (vn tn))</span>, where <span class="v">lmi</span> is recursively 
 a lemma instance, the <span class="v">vi</span>'s are distinct variables, and the <span class="v">ti</span>'s are 
 terms.  Such a lemma instance denotes the formula obtained by instantiating 
 the formula <span class="v">F</span> denoted by <span class="v">lmi</span>, normally by replacing each <span class="v">vi</span> by 
 <span class="v">ti</span> in <span class="v">F</span> and requiring that each <span class="v">vi</span> must be bound in <span class="v">F</span>. 
 There are two exceptions.  If the keyword <span class="v">:extra-bindings-ok</span> is inserted 
 immediately after the lemma instance in order to remove that requirement, as 
 follows, then that requirement is ignored: <span class="v">(:instance
 lmi :extra-bindings-ok (v1 t1) ... (vn tn))</span>.  Otherwise there is the 
 following exception pertaining to <a href="ACL2____PACKAGES.html">packages</a>: if one or more variables 
 <span class="v">vi</span> do not occur in <span class="v">F</span>, but for each such <span class="v">vi</span> exactly one variable 
 <span class="v">v</span> with the same <span class="tt"><a href="COMMON-LISP____SYMBOL-NAME.html">symbol-name</a></span> as <span class="v">vi</span> occurs in <span class="v">F</span> and no 
 other <span class="v">vj</span> with the same <span class="v">symbol-name</span> as <span class="v">v</span> is bound in the 
 substitution, then the pair <span class="v">(vi ti)</span> is replaced by the pair <span class="v">(v ti)</span> 
 in the substitution.</p> 
 
 <p>(5) <span class="v">(:functional-instance lmi (f1 g1) ... (fn gn))</span>, where <span class="v">lmi</span> is 
 recursively a lemma instance and each <span class="v">fi</span> is an ``instantiable'' function 
 symbol of arity <span class="v">ni</span> and <span class="v">gi</span> is a function symbol, a macro alias for a 
 function symbol <span class="v">gi'</span> (see <a href="ACL2____MACRO-ALIASES-TABLE.html">macro-aliases-table</a>) in which case we 
 treat <span class="v">gi</span> as <span class="v">gi'</span>, or a pseudo-lambda expression of arity <span class="v">ni</span>.  An 
 instantiable function symbol is any defined or constrained function symbol 
 except the primitives <span class="tt"><a href="COMMON-LISP____NOT.html">not</a></span>, <span class="tt"><a href="COMMON-LISP____MEMBER.html">member</a></span>, <span class="tt"><a href="ACL2____IMPLIES.html">implies</a></span>, and <span class="tt"><a href="ACL2____O_C3.html">o&lt;</a></span>, and a few others, as listed by the constant 
 <span class="v">*non-instantiable-primitives*</span>.  These are built-in in such a way that we 
 cannot recover the <a href="ACL2____CONSTRAINT.html">constraint</a>s on them.  (Special case: a function 
 introduced in the <span class="v">:partial-theory</span> of a dependent clause-processor is not 
 instantiable; see <a href="ACL2____DEFINE-TRUSTED-CLAUSE-PROCESSOR.html">define-trusted-clause-processor</a>.)  A pseudo-lambda 
 expression is an expression of the form <span class="v">(<a href="COMMON-LISP____LAMBDA.html">lambda</a> (v1 ... vn) body)</span> where 
 the <span class="v">vi</span> are distinct variable symbols and <span class="v">body</span> is any term.  No <i>a 
 priori</i> relation is imposed between the <span class="v">vi</span> and the variables of 
 <span class="v">body</span>, i.e., <span class="v">body</span> may ignore some <span class="v">vi</span>'s and may contain ``free'' 
 variables.  However, we do not permit <span class="v">v</span> to occur freely in <span class="v">body</span> if 
 the functional substitution is to be applied to any formula (<span class="v">lmi</span> or the 
 <a href="ACL2____CONSTRAINT.html">constraint</a>s to be satisfied) in a way that inserts <span class="v">v</span> into the 
 scope of a binding of <span class="v">v</span> by <span class="tt"><a href="COMMON-LISP____LET.html">let</a></span> or <span class="tt"><a href="ACL2____MV-LET.html">mv-let</a></span> (or, <span class="tt"><a href="COMMON-LISP____LAMBDA.html">lambda</a></span>).  If you happen to violate this restriction, an informative error 
 message will be printed.  That message will list for you the potentially 
 illegal choices for <span class="v">v</span> in the context in which the functional substitution 
 is offered.  A <span class="v">:functional-instance</span> lemma instance denotes the formula 
 obtained by functionally instantiating the formula denoted by <span class="v">lmi</span>, 
 replacing <span class="v">fi</span> by <span class="v">gi</span>.  However, before such a lemma instance can be 
 used, the system will generate proof obligations arising from the replacement 
 of the <span class="v">fi</span>'s by the <span class="v">gi</span>'s in constraints that ``support'' the lemma to 
 be functionally instantiated; see <a href="ACL2____CONSTRAINT.html">constraint</a>.  One might expect that if 
 the same instantiated constraint were generated on behalf of several events, 
 then each of those instances would have to be proved.  However, for the sake 
 of efficiency, ACL2 stores the fact that such an instantiated constraint has 
 been proved, unless the proof was done inside an <span class="tt"><a href="ACL2____ENCAPSULATE.html">encapsulate</a></span> event 
 that either has a non-empty <a href="ACL2____SIGNATURE.html">signature</a> list or is ``empty'' (stores 
 no events), and then avoids re-proving that constraint in future <a href="ACL2____EVENTS.html">events</a>.</p> 
 
 <p>See <a href="ACL2____FUNCTIONAL-INSTANTIATION-EXAMPLE.html">functional-instantiation-example</a> for an example of the use of 
 <span class="v">:functional-instance</span> (so-called ``functional instantiation'').</p> 
 
 <p>Note that ACL2(r) (see <a href="COMMON-LISP____REAL.html">real</a>) imposes additional requirements for 
 functional instantiation.  See <a href="ACL2____FUNCTIONAL-INSTANTIATION-IN-ACL2R.html">functional-instantiation-in-ACL2r</a>.</p> 
 
 <p>(6) <span class="v">(:termination-theorem name)</span> or <span class="v">(:termination-theorem! name)</span>, 
 where <span class="v">name</span> is a function symbol in <a href="ACL2____LOGIC.html">logic</a> mode.  Such a lemma 
 instance denotes the termination theorem previously proved for <span class="v">name</span>, 
 possibly modified as discussed in the next paragraph.  If no such theorem 
 exists — for example, if the definition of <span class="v">name</span> is not recursive 
 — then the lemma instance is illegal in the case of 
 <span class="v">:termination-theorem</span>, but denotes <span class="v">T</span> in the case of 
 <span class="v">:termination-theorem!</span>.  If <span class="v">name</span> is defined as part of a 
 mutually-recursive clique of definitions (see <a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a>), then 
 the lemma instance refers to the termination theorem proved for the entire 
 clique.  See <a href="ACL2____TERMINATION-THEOREM-EXAMPLE.html">termination-theorem-example</a> and see <a href="ACL2____TTHM.html">tthm</a>.</p> 
 
 <p>Consider the application of <span class="v">:termination-theorem f</span> while attempting to 
 prove the termination theorem for a function, <span class="v">g</span>.  For now suppose that 
 neither <span class="v">f</span> nor <span class="v">g</span> is defined using <span class="tt"><a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a></span>.  Suppose 
 that <span class="v">f</span> and <span class="v">g</span> have the same number of formal parameters.  Then every 
 call of <span class="v">f</span> in the termination theorem for <span class="v">f</span> will be replaced by a 
 call of <span class="v">g</span> on the same arguments (except, recursively, <span class="v">f</span> is also 
 replaced by <span class="v">g</span> in those arguments).  The analogous replacement also takes 
 place for mutually recursive definitions, as follows.  In the case that <span class="v">f</span> 
 was introduced with <span class="v">(<a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a> (<a href="COMMON-LISP____DEFUN.html">defun</a> f1 ...) ... (<a href="COMMON-LISP____DEFUN.html">defun</a> fk ...))</span> 
 and similarly <span class="v">g</span> is being introduced with <span class="v">(<a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a> (<a href="COMMON-LISP____DEFUN.html">defun</a> g1
 ...)  ... (<a href="COMMON-LISP____DEFUN.html">defun</a> gk ...))</span>, where for each <span class="v">i</span> from <span class="v">1</span> to <span class="v">k</span> the 
 number of formal parameters is the same for <span class="v">fi</span> and <span class="v">gi</span>, then the 
 functional substitution <span class="v">((f1 . g1) ... (fk . gk))</span> is applied to the 
 termination theorem for the <span class="v">fi</span>.  (Logical justification in a nutshell: 
 the termination proof for the <span class="v">fi</span> took place before adding their 
 definitional equations to the current theory, where the <span class="v">fi</span> were thus 
 stubs with no axioms.)  Note that unlike normal <a href="ACL2____FUNCTIONAL-INSTANTIATION.html">functional-instantiation</a>, here there is no proof obligation.  However, the 
 restriction applies from (5) above that the functions <span class="v">fi</span> are 
 instantiable; when that fails, then the replacement of each <span class="v">fi</span> by <span class="v">gi</span> 
 will not take place.</p> 
 
 <p>Finally, note that an optional second argument to <span class="v">:termination-theorem</span> 
 specifies an explicit functional substitution <span class="v">((f1 g1) ... (fn gn))</span>, 
 which is to be applied to the termination theorem for <span class="v">f</span>.  If that 
 argument is supplied, then there will be no attempt to derive a functional 
 substitution automatically, as described in the preceding paragraph.</p> 
 
 <p>(7) <span class="v">(:guard-theorem name)</span> or <span class="v">(:guard-theorem name simplify)</span>, 
 where <span class="v">name</span> is a <a href="ACL2____GUARD.html">guard</a>-verified function symbol (hence, in 
 particular, is in <a href="ACL2____LOGIC.html">logic</a> mode).  Such a lemma instance denotes the guard 
 theorem previously proved for <span class="v">name</span>, where by default <span class="v">simplify</span> is 
 <span class="v">:limited</span>, which enables certain simplifications as documented elsewhere; 
 see <a href="ACL2____GTHM.html">gthm</a>.  Otherwise <span class="v">simplify</span> should be <span class="v">nil</span>, to avoid all 
 such simplification.  If <span class="v">name</span> is defined as part of a mutually-recursive 
 clique of definitions (see <a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a>), then the lemma instance 
 refers to the guard theorem proved for the entire clique.  See <a href="ACL2____GUARD-THEOREM-EXAMPLE.html">guard-theorem-example</a> and see <a href="ACL2____GTHM.html">gthm</a>.</p> 
 
 <p>Obscure case for <a href="ACL2____DEFINITION.html">definition</a>s.  If the lemma instance refers to a 
 <span class="v">:definition</span> <a href="ACL2____RUNE.html">rune</a>, then it refers to the <span class="tt"><a href="ACL2____COROLLARY.html">corollary</a></span> formula 
 of that rune, which can be a normalized (simplified) form of the definition 
 body; see <a href="ACL2____NORMALIZE.html">normalize</a>.  However, if the hint is a <span class="v">:by</span> hint and the 
 lemma instance is based on a name (i.e., a symbol), rather than a rune, then 
 the formula is the original formula of the event, as shown by <span class="v">:</span><span class="tt"><a href="ACL2____PE.html">pe</a></span>, rather than the normalized version, as shown by <span class="v">:</span><span class="tt"><a href="ACL2____PF.html">pf</a></span>.  This 
 is as one would expect: If you supply the name of an event, you expect it to 
 refer to the original event.  For <span class="v">:use</span> hints we use the simplified (<a href="ACL2____NORMALIZE.html">normalize</a>d) form instead, which is reasonable since one would expect 
 simplification during the proof that re-traces the normalization done at the 
 time the rule was created.</p> 
 
 <p>We conclude with remarks on (6) and (7).  The termination theorem actually 
 used is an unsimplified version of what was originally proved for the 
 indicated function; the guard theorem is, by default, partially simplified. 
 That is: while in general, the termination theorem is simplified before being 
 given to the prover, nevertheless the unsimplified theorem is what is actually 
 used for <span class="v">:termination-theorem</span> lemma instances; for <span class="v">:guard-theorem</span>, 
 some simplification is done that is independent of the theory, by using a form 
 of ``subsumption'' to eliminate redundancy and by deleting tautologies as well 
 as instances of <a href="ACL2____BUILT-IN-CLAUSE.html">built-in-clause</a> rules that come with ACL2.  Also see 
 <a href="ACL2____GUARD-FORMULA-UTILITIES.html">guard-formula-utilities</a> and <a href="ACL2____GUARD-SIMPLIFICATION.html">guard-simplification</a>.  Moreover, the 
 <span class="v">:</span><span class="tt"><a href="ACL2____MEASURE-DEBUG.html">measure-debug</a></span> and <span class="v">:</span><span class="tt"><a href="ACL2____GUARD-DEBUG.html">guard-debug</a></span> keywords for <span class="tt"><a href="ACL2____XARGS.html">xargs</a></span> are ignored when generating the termination or guard theorem.  You can 
 see the termination or guard theorem for an existing function symbol <span class="v">FN</span> 
 by evaluating the form <span class="v">(<a href="ACL2____TERMINATION-THEOREM.html">termination-theorem</a> 'FN (<a href="ACL2____W.html">w</a> state))</span> or 
 <span class="v">(<a href="ACL2____GUARD-THEOREM.html">guard-theorem</a> 'FN simplify guard-debug (<a href="ACL2____W.html">w</a> state) state)</span>, respectively. 
 In the former case, failure is indicated by a result of the form <span class="v">(FAILED
 . msg)</span>, where <span class="v">msg</span> is a message suitable for <span class="tt"><a href="ACL2____FMT.html">fmt</a></span>; see <a href="ACL2____MSG.html">msg</a>.</p> 
 
 <p>Also see <a href="ACL2____MAKE-TERMINATION-THEOREM.html">make-termination-theorem</a>.</p> 
 
 <p>Why do we avoid simplification for <span class="v">:termination-theorem</span>, as described 
 in the preceding paragraph?  The reason is that it could in principle 
 strengthen the theorem, which is sound when admitting the original function 
 but not for lemma instances.  Future work might try to allow simplification at 
 lemma-instance time, by ensuring that simplification never strengthens the 
 theorem.  Alternatively, simplification might be checked for each usage to be 
 equivalence-preserving by defining a suitable macro based on <span class="tt"><a href="ACL2____MAKE-EVENT.html">make-event</a></span>.  For now, by avoiding simplification we guarantee that the 
 theorem we are using is truly a theorem.  The theorem being used might not be 
 exactly the theorem originally proved, for example because of the use of <a href="ACL2____CASE-SPLIT-LIMITATIONS.html">case-split-limitations</a>, which depends on the current logical <a href="ACL2____WORLD.html">world</a>; 
 but we expect the two theorems to be logically equivalent.</p>
</body>
</html>
