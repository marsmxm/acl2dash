<html>
<head>
<meta charset="UTF-8">
<title>Case-match</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____CASE-MATCH">Click for Case-match in the Full Manual</a></h3>

<p>Pattern matching or destructuring</p><pre class="code">General Form:
(<a href="ACL2____CASE-MATCH.html">case-match</a> x
  (pat1 dcl1 body1)
  ...
  (patk dclk bodyk))</pre> 
 
 <p>where <span class="v">x</span> is a variable symbol, the <span class="v">pati</span> are structural patterns as 
 described below, the <span class="v">dcli</span> are optional <span class="tt"><a href="COMMON-LISP____DECLARE.html">declare</a></span> forms and the 
 <span class="v">bodyi</span> are terms.  The legal <span class="v">declare</span> forms are the same as for <span class="tt"><a href="COMMON-LISP____LET.html">let</a></span>: <span class="v">ignore</span>, <span class="v">ignorable</span>, and <span class="v">type</span>.  Return the value(s) of the 
 <span class="v">bodyi</span> corresponding to the first <span class="v">pati</span> matching <span class="v">x</span>, or <span class="v">nil</span> 
 if none matches.</p> 
 
 <p>Pattern Language:<br> 
 
 With the few special exceptions described below, matching requires that the 
 <span class="tt"><a href="COMMON-LISP____CONS.html">cons</a></span> structure of <span class="v">x</span> be isomorphic to that of the pattern, down to 
 the <a href="COMMON-LISP____ATOM.html">atom</a>s in the pattern.  Non-symbol <a href="COMMON-LISP____ATOM.html">atom</a>s in the pattern match 
 only themselves.  Symbols in the pattern denote variables which match anything 
 and which are bound by a successful match to the corresponding substructure of 
 <span class="v">x</span>.  Variables that occur more than once must match the same (<span class="tt"><a href="COMMON-LISP____EQUAL.html">equal</a></span>) structure in every occurrence.</p> 
 
 <pre class="code">Exceptions:
&amp;               Matches anything and is not bound.  Repeated
                  occurrences of &amp; in a pattern may match different
                  structures.
nil, t, *sym*, :sym
                These symbols cannot be bound and match only their
                  global values.
!sym            where sym is a symbol that is already bound in the
                  context of the case-match, matches only the
                  current binding of sym.
'obj            Matches only itself.  This is the same as (<a href="COMMON-LISP____QUOTE.html">QUOTE</a> obj).
(QUOTE~ sym)    where sym is a symbol, is like (<a href="COMMON-LISP____QUOTE.html">QUOTE</a> sym) except it
                  matches any symbol with the same symbol-name as sym.
                  Note that QUOTE~ is in the "ACL2" package.</pre> 
 
 <p>Some examples are shown below.</p> 
 
 <p>Below we show some sample patterns and examples of things they match and do 
 not match.</p> 
 
 <pre class="code">pattern       matches         non-matches
(x y y)       (ABC 3 3)       (ABC 3 4)    ; 3 is not 4
(fn x . rst)  (P (A I) B C)   (ABC)        ; NIL is not (x . rst)
              (J (A I))                    ; rst matches nil
('fn (<a href="ACL2____G.html">g</a> x) 3) (FN (H 4) 3)    (GN (<a href="ACL2____G.html">G</a> X) 3) ; 'fn matches only itself
(&amp; t &amp; !x)    ((A) T (B) (C))              ; provided x is '(C)</pre> 
 
 <p>Consider the two binary trees that contain three leaves.  They might be 
 described as <span class="v">(x . (y . z))</span> and <span class="v">((x . y) . z)</span>, where <span class="v">x</span>, <span class="v">y</span>, 
 and <span class="v">z</span> are atomic.  Suppose we wished to recognize those trees.  The 
 following <span class="v">case-match</span> would do:</p> 
 
 <pre class="code">(<a href="ACL2____CASE-MATCH.html">case-match</a> tree
  ((x . (y . z))
   (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x) (<a href="COMMON-LISP____ATOM.html">atom</a> y) (<a href="COMMON-LISP____ATOM.html">atom</a> z)))
  (((x . y) . z)
   (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x) (<a href="COMMON-LISP____ATOM.html">atom</a> y) (<a href="COMMON-LISP____ATOM.html">atom</a> z))))</pre> 
 
 <p>Suppose we wished to recognize such trees where all three tips are 
 identical.  Suppose further we wish to return the tip if the tree is one of 
 those recognized ones and to return the number <span class="v">7</span> otherwise.</p> 
 
 <pre class="code">(<a href="ACL2____CASE-MATCH.html">case-match</a> tree
  ((x . (x . x))
   (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x) x 7))
  (((x . x) . x)
   (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x) x 7))
  (&amp; 7))</pre> 
 
 <p>Note that <span class="v">case-match</span> returns <span class="v">nil</span> if no <span class="v">pati</span> matches.  Thus 
 if we must return <span class="v">7</span> in that case, we have to add as the final pattern the 
 <span class="v">&amp;</span>, which always matches anything.</p> 
 
 <p>Technical point: The symbol <span class="v">sym</span> referenced by the symbol <span class="v">!sym</span> is 
 in the same package as <span class="v">!sym</span> but with the leading exclamation point 
 character, <span class="v">\#!</span>, removed from the <span class="tt"><a href="COMMON-LISP____SYMBOL-NAME.html">symbol-name</a></span> of <span class="v">!sym</span>.</p>
</body>
</html>
