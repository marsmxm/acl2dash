<html>
<head>
<meta charset="UTF-8">
<title>Redundant-events</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____REDUNDANT-EVENTS">Click for Redundant-events in the Full Manual</a></h3>

<p>Allowing a name to be introduced ``twice''</p><p>Sometimes an event will announce that it is ``redundant'', meaning 
 that the the form is not evaluated because ACL2 determines that its effect is 
 already incorporated into the logical <a href="ACL2____WORLD.html">world</a>.  Thus, when this happens, 
 no change to the logical <a href="ACL2____WORLD.html">world</a> takes place.  This feature permits two 
 independent <a href="ACL2____BOOKS.html">books</a>, each of which defines some name, to be included 
 sequentially provided they use exactly the same definition.</p> 
 
 <p>Note that by the definition above, a form can have no effect on the logical 
 <a href="ACL2____WORLD.html">world</a> yet not be considered to be redundant.  Here is an example of 
 such a form.</p> 
 
 <pre class="code">(<a href="ACL2____VALUE-TRIPLE.html">value-triple</a> (<a href="ACL2____CW.html">cw</a> "Hello world.~%"))</pre> 
 
 <p>When are two <a href="ACL2____LOGICAL-NAME.html">logical-name</a> definitions considered ``the same''?  It 
 depends upon the kind of event that introduces that name.  We consider these 
 below in alphabetical order, followed by ``Note About'' comments.  Macros in 
 the <a href="ACL2____COMMUNITY-BOOKS.html">community-books</a> may also support redundancy; see their 
 documentation for details, since below we only discuss ACL2 <a href="ACL2____EVENTS.html">events</a> that 
 are built into ACL2.</p> 
 
 <p>A <span class="tt"><a href="ACL2____DEFSTOBJ.html">defstobj</a></span> or <span class="tt"><a href="ACL2____DEFABSSTOBJ.html">defabsstobj</a></span> is redundant if there is already 
 an identical such event in the logical <a href="ACL2____WORLD.html">world</a>.</p> 
 
 <p>A <span class="tt"><a href="ACL2____DEFATTACH.html">defattach</a></span> event is never redundant.  (Reasons are provided in a 
 comment in the ACL2 sources definition of defattach in the ACL2 logic.)  Note 
 that <span class="v">defattach</span> events do not define any names.</p> 
 
 <p>A <span class="tt"><a href="ACL2____DEFAXIOM.html">defaxiom</a></span> or <span class="tt"><a href="ACL2____DEFTHM.html">defthm</a></span> event is redundant if there is already 
 an axiom or theorem of the given name and either the two <a href="ACL2____EVENTS.html">events</a> are 
 syntactically identical, or both the formula (after macroexpansion) and the 
 resulting <a href="ACL2____RULE-CLASSES.html">rule-classes</a> are syntactically identical.  Note that because 
 of the second of these two criteria, a <span class="tt"><a href="ACL2____DEFAXIOM.html">defaxiom</a></span> can make a subsequent 
 <span class="tt"><a href="ACL2____DEFTHM.html">defthm</a></span> redundant, and a <span class="tt"><a href="ACL2____DEFTHM.html">defthm</a></span> can make a subsequent <span class="tt"><a href="ACL2____DEFAXIOM.html">defaxiom</a></span> redundant as well.</p> 
 
 <p>A <span class="tt"><a href="ACL2____DEFCONST.html">defconst</a></span> is redundant if the name is already defined either with 
 a syntactically identical <span class="v">defconst</span> event or one that defines it to have 
 the same value.</p> 
 
 <p>A <span class="tt"><a href="ACL2____DEFLABEL.html">deflabel</a></span> event is never redundant.  This means that if you have a 
 <span class="tt"><a href="ACL2____DEFLABEL.html">deflabel</a></span> in a book and that book has been included (without error), 
 then references to that label denote the point in <a href="ACL2____HISTORY.html">history</a> at which the 
 book introduced the label.  See the note about shifting logical names, 
 below.</p> 
 
 <p>A <span class="tt"><a href="COMMON-LISP____DEFMACRO.html">defmacro</a></span> event is redundant if there is already a macro defined 
 with the same name and syntactically identical arguments, <a href="ACL2____GUARD.html">guard</a>, and 
 body.</p> 
 
 <p>A <span class="tt"><a href="ACL2____DEFPKG.html">defpkg</a></span> event is redundant if a package of the same name with 
 exactly the same imports has been defined.</p> 
 
 <p>A <span class="tt"><a href="ACL2____DEFTHM.html">defthm</a></span> event is redundant according to the criteria given above 
 in the discussion of <span class="v">defaxiom</span>.</p> 
 
 <p>A <span class="tt"><a href="ACL2____DEFTHEORY.html">deftheory</a></span> event is redundant if keyword argument 
 <span class="v">:redundant-okp</span> is not <span class="v">nil</span> and the theory is unchanged from the one 
 already associated with the name.  More precisely, the runic theory computed 
 from the theory expression must be equal to the runic theory already 
 associated with the name.  (See <a href="ACL2____THEORIES.html">theories</a> for a discussion of runic 
 theories.  Also see <a href="ACL2____DEFTHY.html">defthy</a> for a variant of <span class="v">deftheory</span> that 
 supports redundancy by default.)  Equality of runic theories is a rather 
 severe restriction, since most theory expressions are sensitive to the context 
 in which they occur.  Consider the following example.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHEORY.html">deftheory</a> foo (<a href="ACL2____DISABLE.html">disable</a> append revappend) :redundant-okp t)
(<a href="ACL2____DEFTHM.html">defthm</a> my-car-cons (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CONS.html">cons</a> x y)) x))
(<a href="ACL2____DEFTHEORY.html">deftheory</a> foo (<a href="ACL2____DISABLE.html">disable</a> revappend append) :redundant-okp t)</pre> 
 
 <p>The second <span class="v">deftheory</span> event above is not redundant, because its 
 computed runic theory includes the <a href="ACL2____RUNE.html">rune</a> <span class="v">(:rewrite my-car-cons)</span>, 
 which is not in the runic theory previously associated with <span class="v">foo</span>.  If we 
 change the example either to eliminate the <span class="tt"><a href="ACL2____DEFTHM.html">defthm</a></span> above or to change 
 it to call <span class="tt"><a href="ACL2____DEFTHMD.html">defthmd</a></span> instead, then the second <span class="v">deftheory</span> event is 
 redundant, because the runic theories are ordered, and hence the order of 
 runic designators (here, <span class="v">revappend</span> and <span class="v">append</span>) is irrelevant.</p> 
 
 <p>A <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span>, <span class="tt"><a href="ACL2____DEFUNS.html">defuns</a></span>, or <span class="tt"><a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a></span> event is 
 redundant if for each function to be introduced, there has already been 
 introduced a function with the same name, formals, and body (before 
 macroexpansion), and with the same values <a href="COMMON-LISP____DECLARE.html">declare</a>d for the <span class="v">:</span><span class="tt"><a href="ACL2____GUARD.html">guard</a></span>, <span class="v">:</span><span class="tt"><a href="ACL2____MEASURE.html">measure</a></span>, types, <span class="v">:</span><span class="tt"><a href="ACL2____RULER-EXTENDERS.html">ruler-extenders</a></span>, 
 <span class="v">:non-executable</span>, <span class="v">:type-prescription</span>, <span class="v">:</span><span class="tt"><a href="ACL2____STOBJ.html">stobj</a></span><span class="v">s</span>, and 
 <span class="v">:</span><span class="tt"><a href="ACL2____SPLIT-TYPES.html">split-types</a></span>, provided that the <a href="ACL2____DEFUN-MODE.html">defun-mode</a>s are 
 appropriate (see the ``Note About Appropriate Modes'' below).  Moreover, the 
 order of the combined <span class="v">:</span><span class="tt"><a href="ACL2____GUARD.html">guard</a></span> and type declarations must be the 
 same in both cases.  Exceptions and clarifications:</p> 
 
 <ol> 
 
 <li>If the new and existing function events have no explicit <a href="ACL2____RULER-EXTENDERS.html">ruler-extenders</a> (which are therefore syntactically equal), the <a href="ACL2____DEFAULT-RULER-EXTENDERS.html">default-ruler-extenders</a> for the new and existing function events must be the 
 same.</li> 
 
 <li>It is permissible for one definition to have a <span class="v">:</span><a href="ACL2____GUARD.html">guard</a> of 
 <span class="v">t</span> and the other to have no explicit guard (hence, the guard is implicitly 
 <span class="v">t</span>).</li> 
 
 <li>The <span class="v">:measure</span> check is avoided if the old definition is non-recursive 
 (and not defined within a <span class="tt"><a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a></span>) or we are skipping proofs 
 (for example, during <span class="tt"><a href="ACL2____INCLUDE-BOOK.html">include-book</a></span>).  Otherwise, the new definition may 
 have a <span class="v">:measure</span> of <span class="v">(:? v1 ... vk)</span>, where <span class="v">(v1 ... vk)</span> enumerates 
 the variables occurring in the measure stored for the old definition.</li> 
 
 <li>If either the old or new event is a <span class="tt"><a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a></span> event, then 
 redundancy requires that both are <span class="tt"><a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a></span> events that define 
 the same set of function symbols.</li> 
 
 <li>The <a href="ACL2____STOBJ.html">stobj</a>s declared by the two definitions are allowed to disagree 
 on <span class="v">state</span>: one can declare <span class="v">state</span> among its declared <span class="v">:stobjs</span> 
 values while the other does not, regardless of whether or not <span class="tt"><a href="ACL2____SET-STATE-OK.html">set-state-ok</a></span> has been evaluated.  That is, they only need to agree on the 
 <i>user-defined</i> stobjs.</li> 
 
 </ol> 
 
 <p>An <span class="tt"><a href="ACL2____ENCAPSULATE.html">encapsulate</a></span> event is most commonly redundant when a 
 syntactically identical <span class="tt"><a href="ACL2____ENCAPSULATE.html">encapsulate</a></span> has already been executed under 
 the same <span class="tt"><a href="ACL2____DEFAULT-DEFUN-MODE.html">default-defun-mode</a></span>, <span class="tt"><a href="ACL2____DEFAULT-RULER-EXTENDERS.html">default-ruler-extenders</a></span>, and 
 <span class="tt"><a href="ACL2____DEFAULT-VERIFY-GUARDS-EAGERNESS.html">default-verify-guards-eagerness</a></span>.  The full criterion for redundancy of 
 <span class="v">encapsulate</span> events is more complex, for example ignoring contents of 
 <span class="tt"><a href="ACL2____LOCAL.html">local</a></span> <a href="ACL2____EVENTS.html">events</a>; see <a href="ACL2____REDUNDANT-ENCAPSULATE.html">redundant-encapsulate</a>.</p> 
 
 <p>An <span class="tt"><a href="ACL2____IN-THEORY.html">in-theory</a></span> event is never redundant by default, though that can 
 be changed; see <a href="ACL2____SET-IN-THEORY-REDUNDANT-OKP.html">set-in-theory-redundant-okp</a>.  Note that it doesn't 
 define any name.</p> 
 
 <p>An <span class="tt"><a href="ACL2____INCLUDE-BOOK.html">include-book</a></span> event is redundant if the book has already been 
 included.</p> 
 
 <p>A call of <span class="tt"><a href="ACL2____MAKE-EVENT.html">make-event</a></span> is never redundant, as its argument is always 
 evaluated to obtain the make-event expansion.  However, that expansion may of 
 course be redundant.</p> 
 
 <p>A <span class="tt"><a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a></span> event is redundant according to the criteria in 
 the discussion above for the case of a <span class="v">defun</span> event.</p> 
 
 <p>A <span class="tt"><a href="COMMON-LISP____PROGN.html">progn</a></span> event is never redundant: its subsidiary <a href="ACL2____EVENTS.html">events</a> are 
 always considered.  Of course, its sub-events may themselves be redundant.  If 
 all of its sub-events are redundant — or more generally, if none of the 
 sub-events changes the logical <a href="ACL2____WORLD.html">world</a> — then the <span class="v">progn</span> event 
 also won't change the world.</p> 
 
 <p>A <span class="tt"><a href="ACL2____PUSH-UNTOUCHABLE.html">push-untouchable</a></span> event is redundant if every name supplied is 
 already a member of the corresponding list of untouchable symbols.</p> 
 
 <p>A <span class="tt"><a href="ACL2____REGENERATE-TAU-DATABASE.html">regenerate-tau-database</a></span> event is never redundant.  Note that it 
 doesn't define any name.</p> 
 
 <p>A <span class="tt"><a href="ACL2____REMOVE-UNTOUCHABLE.html">remove-untouchable</a></span> event is redundant if no name supplied is a 
 member of the corresponding list of untouchable symbols.</p> 
 
 <p>A <span class="tt"><a href="ACL2____RESET-PREHISTORY.html">reset-prehistory</a></span> event is redundant if it does not cause any 
 change.</p> 
 
 <p>A <span class="tt"><a href="ACL2____SET-BODY.html">set-body</a></span> event is redundant if the indicated body is already the 
 current body.</p> 
 
 <p>A <span class="tt"><a href="ACL2____TABLE.html">table</a></span> event not define any name.  It is redundant when it sets 
 the value already associated with a key of the table, or when it sets an 
 entire table (using keyword <span class="v">:clear</span>) to its existing value; see <a href="ACL2____TABLE.html">table</a>.  Setting a non-existent key to <span class="v">nil</span> is not redundant, with the 
 exception discussed next.</p> 
 
 <p><a href="ACL2____MEMOIZATION.html">Memoization</a> is carried out using a <a href="ACL2____TABLE.html">table</a>, 
 <span class="v">memoize-table</span>, that may associate a function symbol with <span class="v">nil</span> when it 
 is not memoized.  It is redundant to <span class="tt"><a href="ACL2____UNMEMOIZE.html">unmemoize</a></span> a currently-unmemoized 
 function symbol, thus associating it with <span class="v">nil</span> in the <span class="v">memoize-table</span> 
 — even if that function symbol is not already a key of that table (this 
 is the exception noted in the preceding paragraph).  It is redundant to <span class="tt"><a href="ACL2____MEMOIZE.html">memoize</a></span> a function when the function is already identically memoized, that 
 is, when the corresponding <span class="tt"><a href="ACL2____TABLE.html">table</a></span> event is redundant.</p> 
 
 <p>A <span class="tt"><a href="ACL2____VERIFY-GUARDS.html">verify-guards</a></span> event is redundant if the function has already had 
 its <a href="ACL2____GUARD.html">guard</a>s verified.</p> 
 
 <p><i>Note About Built-in (Predefined) Functions and Macros:</i></p> 
 
 <p>Redundancy is restricted for built-in macros and functions that have 
 special raw Lisp code.  Such redundancy is only legal in the context of <span class="tt"><a href="ACL2____LOCAL.html">local</a></span>.  This restriction is needed for soundness, for technical reasons 
 omitted here (details may be found in a long comment about redundant-events in 
 source function <span class="v">chk-acceptable-defuns-redundancy</span>).</p> 
 
 <p><i>Note About Appropriate Modes:</i></p> 
 
 <p>Suppose a function is being redefined and that the formals, guards, types, 
 user-defined stobjs, and bodies are identical.  When are the 
 modes (<span class="v">:</span><span class="tt"><a href="ACL2____PROGRAM.html">program</a></span> or <span class="v">:</span><span class="tt"><a href="ACL2____LOGIC.html">logic</a></span>) ``appropriate?'' 
 Identical modes are appropriate.  But what if the old mode was <span class="v">:program</span> 
 and the new mode is <span class="v">:logic</span>?  This is appropriate, provided the definition 
 meets the requirements of the logical definitional principle.  That is, you 
 may redefine ``redundantly'' a <span class="v">:program</span> mode function as a <span class="v">:logic</span> 
 mode function provide the measure conjectures can be proved.  This is what 
 <span class="tt"><a href="ACL2____VERIFY-TERMINATION.html">verify-termination</a></span> does.  Now consider the reverse style of 
 redefinition.  Suppose the function was defined in <span class="v">:logic</span> mode and is 
 being identically redefined in <span class="v">:program</span> mode.  ACL2 will treat the 
 redefinition as redundant, provided the appropriate criteria are met (as 
 though it were in :logic mode).</p> 
 
 <p><i>Note About Shifting Logical Names:</i></p> 
 
 <p>Suppose a book defines a function <span class="v">fn</span> and later uses <span class="v">fn</span> as a 
 logical name in a theory expression.  Consider the value of that theory 
 expression in two different sessions.  In session A, the book is included in a 
 <a href="ACL2____WORLD.html">world</a> in which <span class="v">fn</span> is not already defined, i.e., in a <a href="ACL2____WORLD.html">world</a> 
 in which the book's definition of <span class="v">fn</span> is not redundant.  In session B, the 
 book is included in a <a href="ACL2____WORLD.html">world</a> in which <span class="v">fn</span> is already identically 
 defined.  In session B, the book's definition of <span class="v">fn</span> is redundant.  When 
 <span class="v">fn</span> is used as a logical name in a theory expression, it denotes the point 
 in <a href="ACL2____HISTORY.html">history</a> at which <span class="v">fn</span> was introduced.  Observe that those points 
 are different in the two sessions.  Hence, it is likely that theory 
 expressions involving <span class="v">fn</span> will have different values in session A than in 
 session B.</p> 
 
 <p>This may adversely affect the user of your book.  For example, suppose your 
 book creates a theory via <span class="tt"><a href="ACL2____DEFTHEORY.html">deftheory</a></span> that is advertised just to contain 
 the names generated by the book.  But suppose you compute the theory as the 
 very last event in the book using:</p> 
 
 <pre class="code">(<a href="ACL2____SET-DIFFERENCE-THEORIES.html">set-difference-theories</a> (<a href="ACL2____UNIVERSAL-THEORY.html">universal-theory</a> :here)
                         (<a href="ACL2____UNIVERSAL-THEORY.html">universal-theory</a> fn))</pre> 
 
 <p>where <span class="v">fn</span> is the very first event in the book and happens to be a 
 <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> event.  This expression returns the advertised set if <span class="v">fn</span> is 
 not already defined when the book is included.  But if <span class="v">fn</span> were previously 
 (identically) defined, the theory is larger than advertised.</p> 
 
 <p>The moral of this is simple: when building <a href="ACL2____BOOKS.html">books</a> that other people 
 will use, it is best to describe your <a href="ACL2____THEORIES.html">theories</a> in terms of logical 
 names that will not shift around when the <a href="ACL2____BOOKS.html">books</a> are included.  The best 
 such names are those created by <span class="tt"><a href="ACL2____DEFLABEL.html">deflabel</a></span>.</p> 
 
 <p><i>Note About Unfortunate Redundancies.</i></p> 
 
 <p>Notice that our syntactic criterion for redundancy of <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> <a href="ACL2____EVENTS.html">events</a> may not allow redefinition to take effect unless there is a syntactic 
 change in the definition.  The following example shows how an attempt to 
 redefine a function can fail to make any change.</p> 
 
 <pre class="code">(<a href="ACL2____SET-LD-REDEFINITION-ACTION.html">set-ld-redefinition-action</a> '(:warn . :overwrite) state)
(<a href="COMMON-LISP____DEFMACRO.html">defmacro</a> mac (x) x)
(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (x) (mac x))
(<a href="COMMON-LISP____DEFMACRO.html">defmacro</a> mac (x) (<a href="COMMON-LISP____LIST.html">list</a> 'car x))
(<a href="ACL2____SET-LD-REDEFINITION-ACTION.html">set-ld-redefinition-action</a> nil state)
(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (x) (mac x)) ; redundant, unfortunately; foo does not change
(<a href="ACL2____THM.html">thm</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (foo 3) 3)) ; succeeds, showing that redef of foo didn't happen</pre> 
 
 <p>The call of macro <span class="v">mac</span> was expanded away before storing the first 
 definition of <span class="v">foo</span> for the theorem prover.  Therefore, the new definition 
 of <span class="v">mac</span> does not affect the expansion of <span class="v">foo</span> by the theorem prover, 
 because the new definition of <span class="v">foo</span> is ignored.</p> 
 
 <p>One workaround is first to supply a different definition of <span class="v">foo</span>, just 
 before the last definition of <span class="v">foo</span> above.  Then that final definition will 
 no longer be redundant.  However, as a courtesy to users, we strengthen the 
 redundancy check for function definitions when redefinition is active.  If in 
 the example above we remove the form <span class="v">(<a href="ACL2____SET-LD-REDEFINITION-ACTION.html">set-ld-redefinition-action</a> nil
 state)</span>, then the problem goes away:</p> 
 
 <pre class="code">(<a href="ACL2____SET-LD-REDEFINITION-ACTION.html">set-ld-redefinition-action</a> '(:warn . :overwrite) state)
(<a href="COMMON-LISP____DEFMACRO.html">defmacro</a> mac (x) x)
(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (x) (mac x))
(<a href="COMMON-LISP____DEFMACRO.html">defmacro</a> mac (x) (<a href="COMMON-LISP____LIST.html">list</a> 'car x))
(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (x) (mac x)) ; no longer redundant
(<a href="ACL2____THM.html">thm</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (foo 3) 3)) ; fails, as we would like</pre> 
 
 <p>To summarize: If a <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> form is submitted that meets the usual 
 redundancy criteria, then it may be considered redundant even if a macro 
 called in the definition has since been redefined.  The analogous problem 
 applies to constants, i.e., symbols defined by <span class="tt"><a href="ACL2____DEFCONST.html">defconst</a></span> that occur in 
 the definition body.  However, if redefinition is currently active the problem 
 goes away: that is, the redundancy check is strengthened to check the 
 ``translated'' body, in which macro calls and constants defined by <span class="tt"><a href="ACL2____DEFCONST.html">defconst</a></span> are expanded away.</p> 
 
 <p>The above discussion for <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> forms applies to <span class="tt"><a href="ACL2____DEFCONST.html">defconst</a></span> 
 forms as well.  However, for <span class="tt"><a href="COMMON-LISP____DEFMACRO.html">defmacro</a></span> forms ACL2 always checks 
 translated bodies, so such bogus redundancy does not occur.</p> 
 
 <p>Here is more complex example illustrating the limits of redefinition, based 
 on one supplied by Grant Passmore.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> n3 () 0)
(<a href="COMMON-LISP____DEFUN.html">defun</a> n4 () 1)
(<a href="COMMON-LISP____DEFUN.html">defun</a> n5 () (<a href="COMMON-LISP_____E3.html">&gt;</a> (n3) (n4))) ; body is see normalized to nil
(<a href="ACL2____THM.html">thm</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (n5) nil)) ; succeeds, trivially
(<a href="ACL2____SET-LD-REDEFINITION-ACTION.html">set-ld-redefinition-action</a> '(:warn . :overwrite) state)
(<a href="COMMON-LISP____DEFUN.html">defun</a> n3 () 2)
(<a href="ACL2____THM.html">thm</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (n5) nil)) ; still succeeds, sadly</pre> 
 
 <p>We may expect the final <span class="tt"><a href="ACL2____THM.html">thm</a></span> call to fail because of the following 
 reasoning: <span class="v">(n5)</span> = <span class="v">(<a href="COMMON-LISP_____E3.html">&gt;</a> (n3) (n4))</span> = <span class="v">(<a href="COMMON-LISP_____E3.html">&gt;</a> 2 1)</span> = <span class="v">t</span>. 
 Unfortunately, the body of <span class="v">n5</span> was simplified to <span class="v">nil</span> when <span class="v">n5</span> was 
 admitted (see <a href="ACL2____NORMALIZE.html">normalize</a>), so the redefinition of <span class="v">n3</span> is ignored 
 during the final <span class="v">thm</span> call.  (Such normalization can be avoided; see <a href="ACL2____XARGS.html">xargs</a> for discussion of the <span class="v">:normalize</span> keyword.)  So, given this 
 unfortunate situation, one might expect at this point simply to redefine 
 <span class="v">n5</span> using the same definition as before, in order to pick up the new 
 definition of <span class="v">n3</span>.  Such ``redefinition'' would, however, be redundant, 
 for the same reason as in the previous example: no syntactic change was made 
 to the definition.  Even with redefinition active, there is no change in the 
 body of <span class="v">n5</span>, even with macros and constants (defined by <span class="tt"><a href="ACL2____DEFCONST.html">defconst</a></span>) 
 expanded; there are none such!  The same workaround applies as before: 
 redefine <span class="v">n5</span> to be something different, and then redefine <span class="v">n5</span> again to 
 be as desired.</p> 
 
 <p>A related phenomenon can occur for <span class="tt"><a href="ACL2____ENCAPSULATE.html">encapsulate</a></span>.  As explained 
 above, an <span class="v">encapsulate</span> event is redundant if it is identical to one 
 already in the database.  (But a weaker condition applies in general; see 
 <a href="ACL2____REDUNDANT-ENCAPSULATE.html">redundant-encapsulate</a>.)  Consider then the following contrived 
 example.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFMACRO.html">defmacro</a> mac (x) x)
(<a href="ACL2____ENCAPSULATE.html">encapsulate</a> () (<a href="COMMON-LISP____DEFUN.html">defun</a> foo (x) (mac x)))
(<a href="ACL2____SET-LD-REDEFINITION-ACTION.html">set-ld-redefinition-action</a> '(:warn . :overwrite) state)
(<a href="COMMON-LISP____DEFMACRO.html">defmacro</a> mac (x) (<a href="COMMON-LISP____LIST.html">list</a> 'car x))
(<a href="ACL2____ENCAPSULATE.html">encapsulate</a> () (<a href="COMMON-LISP____DEFUN.html">defun</a> foo (x) (mac x)))</pre> 
 
 <p>The last <span class="v">encapsulate</span> event is redundant because it meets the criterion 
 for redundancy: it is identical to the earlier <span class="v">encapsulate</span> event.  Even 
 though redefinition is active, and hence ACL2 ``should'' be able to see that 
 the new <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> of <span class="v">foo</span> is not truly redundant, nevertheless the 
 criterion for redundancy of <span class="tt"><a href="ACL2____ENCAPSULATE.html">encapsulate</a></span> allows the new 
 <span class="v">encapsulate</span> form to be redundant.</p> 
 
 <p>A workaround can be to add something trivial to the <span class="v">encapsulate</span>, for 
 example:</p> 
 
 <pre class="code">(<a href="ACL2____ENCAPSULATE.html">encapsulate</a> ()
  (<a href="ACL2____DEFLABEL.html">deflabel</a> try2) ; ``Increment'' to try3 next time, and so on.
  (<a href="COMMON-LISP____DEFUN.html">defun</a> foo (x) x))</pre>
</body>
</html>
