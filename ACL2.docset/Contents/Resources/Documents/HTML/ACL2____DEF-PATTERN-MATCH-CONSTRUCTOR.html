<html>
<head>
<meta charset="UTF-8">
<title>Def-pattern-match-constructor</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____DEF-PATTERN-MATCH-CONSTRUCTOR">Click for Def-pattern-match-constructor in the Full Manual</a></h3>

<p>Allow pattern-match to recognize a constructor.</p><p>Example:</p> 
 
<pre class="code">(<a href="ACL2____DEF-PATTERN-MATCH-CONSTRUCTOR.html">def-pattern-match-constructor</a> cons consp (<a href="COMMON-LISP____CAR.html">car</a> cdr))</pre> 
 
<p>For a constructor <span class="v">cname</span>, defines a macro named 
<span class="v">cname-pattern-matcher</span> which will allow constructs using <span class="v">cname</span> to be 
recognized by the pattern-match macro; see <a href="ACL2____PATTERN-MATCH.html">pattern-match</a>.  This macro 
takes three arguments: the name of the constructor, which is the symbol that 
pattern-match will recognize; the name of a recognizer function which returns 
<span class="v">t</span> on objects produced by the constructor; and an ordered list of 
destructor function names, which when applied to the constructed object return 
the arguments to the constructor.</p> 
 
<p>For example, say we define a function cons3 that combines three objects into 
a triple.  We define a recognizer, cons3-p, for correctly-formed triples as 
created by cons3, as well as three accessors, cons3-first, cons3-second, 
cons3-third.  Now we'd like to have a pattern match expression like this</p> 
 
<pre class="code">(<a href="ACL2____PATTERN-MATCH.html">pattern-match</a> x
       ((cons3 a b c) ... body ..)
       ... other clauses ...)</pre> 
 
<p>resolve to this:</p> 
 
<pre class="code">(<a href="COMMON-LISP____IF.html">if</a> (cons3-p x)
    (<a href="COMMON-LISP____LET.html">let</a> ((a (cons3-first x))
          (b (cons3-second x))
          (c (cons3-third x)))
      ... body ...)
  ... other conditions ...)</pre> 
 
<p>Therefore the pattern match macro must know that the recognizer for a cons3 
object is cons3-p, and that the destructors are cons3-first, etc - we don't 
want to have to write out those names anywhere in the untranslated body.  Our 
solution is that when pattern-match sees a function symbol fun, it returns a 
call to a macro named fun-pattern-matcher.  If this macro does not exist, 
pattern-match will fail.  To easily define such macros, we provide 
def-pattern-match-constructor, which takes as arguments the constructor name, 
the recognizer name, and the ordered list of destructors.  For example, to 
allow pattern-match to deal with cons3, we'd call</p> 
 
<pre class="code">(<a href="ACL2____DEF-PATTERN-MATCH-CONSTRUCTOR.html">def-pattern-match-constructor</a> cons3 cons3-p
  (cons3-first cons3-second cons3-third))</pre> 
 
<p>Similarly for cons, the call would be</p> 
 
<pre class="code">(<a href="ACL2____DEF-PATTERN-MATCH-CONSTRUCTOR.html">def-pattern-match-constructor</a> cons consp (<a href="COMMON-LISP____CAR.html">car</a> cdr))</pre> 
 
<p>but this is built into the pattern match book.</p> 
 
<p>Pattern-matcher macros may be defined more flexibly without using 
<span class="v">def-pattern-match-constructor</span> in order to support, for example, macros 
with variable numbers of arguments; see <a href="ACL2____CONSTRUCTOR-PATTERN-MATCH-MACROS.html">constructor-pattern-match-macros</a>.</p> 
 

</body>
</html>
