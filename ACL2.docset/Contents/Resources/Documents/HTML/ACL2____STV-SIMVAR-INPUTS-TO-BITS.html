<html>
<head>
<meta charset="UTF-8">
<title>Stv-simvar-inputs-to-bits</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____STV-SIMVAR-INPUTS-TO-BITS">Click for Stv-simvar-inputs-to-bits in the Full Manual</a></h3>

<p>Convert the user-level input alist (which binds simulation variables 
to naturals) into a bit-level alist for <a href="ACL2____4V-SEXPR-EVAL.html">4v-sexpr-eval</a>.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(stv-simvar-inputs-to-bits user-alist in-usersyms) → *</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">user-alist</span> — The alist provided by the user that gives values to the input 
                 simulation variables.  Each value should be a natural number that 
                 is in the range for that simulation variable.</dd> 
  <dd>
<span class="tt">in-usersyms</span> — A fast alist that binds each input simulation variable for the 
                 STV with a list of variables that represent its bits; see <a href="ACL2____STV-COMPILE.html">stv-compile</a>, but in particular see the <span class="v">usersyms</span> output of 
                 <a href="ACL2____STV-EXPAND-INPUT-ENTRY.html">stv-expand-input-entry</a>.</dd> 
 
</dl></div> 
<p>We try to translate every user-level binding, like <span class="v">(opcode
. 7)</span>, into a set of bit-level bindings, say something like:</p> 
 
<pre class="code">((opcode[0] . *4vt*)
 (opcode[1] . *4vt*)
 (opcode[2] . *4vt*)
 (opcode[3] . *4vf*)
 ...)</pre> 
 
<p>For each input simulation variable bound in the user-level alist, we 
basically just need to look up the names of its bits in the <span class="v">in-usersyms</span> 
alist, explode the value into <a href="ACL2____4VP.html">4vp</a> bits, and then pairing up the bit 
names with the values.  In the process, we do some basic sanity checking to 
make sure that the names being bound exist and that the provided values are in 
range.</p> 
 
<p>The net result is a new alist that is suitable for <a href="ACL2____4V-SEXPR-EVAL.html">4v-sexpr-eval</a> that 
we can use to evaluate output expressions.</p> 
 
<p>We don't check for duplicates in the user-alist, and if there are duplicates 
it could lead to duplicate bindings in our resulting bit-level alist.  However, 
the alist semantics are preserved because shadowed bindings are still shadowed 
in the bit-level alist.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>stv-simvar-inputs-to-bits</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 stv-simvar-inputs-to-bits
 (user-alist in-usersyms)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((__function__ 'stv-simvar-inputs-to-bits))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
  (<a href="ACL2____B_A2.html">b*</a>
   (((when (<a href="COMMON-LISP____ATOM.html">atom</a> user-alist)) nil)
    (<a href="COMMON-LISP____REST.html">rest</a> (<a href="ACL2____STV-SIMVAR-INPUTS-TO-BITS.html">stv-simvar-inputs-to-bits</a> (<a href="COMMON-LISP____CDR.html">cdr</a> user-alist)
                                     in-usersyms))
    ((when (<a href="COMMON-LISP____ATOM.html">atom</a> (<a href="COMMON-LISP____CAR.html">car</a> user-alist)))
     (<a href="ACL2____CW.html">cw</a>
      "stv-simvar-inputs-to-bits: skipping malformed alist entry ~x0.~%"
      (<a href="COMMON-LISP____CAR.html">car</a> user-alist))
     rest)
    (<a href="ACL2____NAME.html">name</a> (<a href="COMMON-LISP____CAAR.html">caar</a> user-alist))
    (val (<a href="COMMON-LISP____CDAR.html">cdar</a> user-alist))
    (look (<a href="ACL2____HONS-GET.html">hons-get</a> name in-usersyms))
    ((unless look)
     (<a href="ACL2____RAISE.html">raise</a>
       "Value given for ~x0, but this is not a simulation variable."
       name)
     rest)
    (vars (<a href="COMMON-LISP____CDR.html">cdr</a> look))
    (nvars (<a href="ACL2____LEN.html">len</a> vars))
    (vals
     (<a href="COMMON-LISP____COND.html">cond</a>
      ((<a href="COMMON-LISP____EQ.html">eq</a> val *4vx*) (<a href="ACL2____REPLICATE.html">replicate</a> nvars *4vx*))
      ((<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> val) (<a href="COMMON-LISP_____C3.html">&lt;</a> val (<a href="COMMON-LISP____ASH.html">ash</a> 1 nvars)))
       (bool-to-4v-lst (int-to-v val nvars)))
      (t
       (<a href="ACL2____PROGN_42.html">progn$</a>
        (<a href="ACL2____RAISE.html">raise</a>
         "Value ~x0 given for ~x1, but this value is not X ~
                             or in range for a ~x2-bit unsigned number."
         val name nvars)
        (<a href="ACL2____REPLICATE.html">replicate</a> nvars *4vx*))))))
   (<a href="ACL2____SAFE-PAIRLIS-ONTO-ACC.html">safe-pairlis-onto-acc</a> vars vals rest))))</pre> 

</body>
</html>
