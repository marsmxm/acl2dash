<html>
<head>
<meta charset="UTF-8">
<title>Make-flag</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____MAKE-FLAG">Click for Make-flag in the Full Manual</a></h3>

<p>Create a flag-based <a href="ACL2____INDUCTION.html">ACL2::induction</a> scheme for a <a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a>.</p><p>The <span class="v">make-flag</span> macro lets you quickly introduce:</p> 
 
<ul> 
 
<li>a "flag function" that mimics a <a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a>, and</li> 
 
<li>a theorem proving that the appropriate invocations of the flag function are 
equivalent to the original mutually-recursive functions,</li> 
 
<li>a macro for proving properties by induction according to the flag 
function.</li> 
 
</ul> 
 
<p>Generally speaking, writing a corresponding flag function is the first step 
toward proving any inductive property about mutually recursive definitions; 
more discussion below.</p> 
 
<h3>Using <span class="v">make-flag</span>
</h3> 
 
<p>Example:</p> 
 
<pre class="code">(<a href="ACL2____MAKE-FLAG.html">make-flag</a> flag-pseudo-termp               ; flag function name (optional)
           pseudo-termp                    ; any member of the clique
           ;; optional arguments:
           :flag-mapping ((<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a>      term)
                          (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> list))
           :defthm-macro-name defthm-pseudo-termp
           :flag-var flag
           :body :last                     ; use last body, not original
           :hints (("Goal" ...))         ; for the measure theorem
                                           ; usually not necessary
           )</pre> 
 
<p>Here <span class="v">pseudo-termp</span> is the name of a function in a mutually recursive 
clique.  In this case, the clique has two functions, <span class="v">pseudo-termp</span> and 
<span class="v">pseudo-term-listp</span>.  The name of the newly generated flag function can be 
provided explicitly, or else will be formed by sticking <span class="v">flag-</span> on the front 
of the clique member's name.</p> 
 
<p>The other arguments are optional:</p> 
 
<ul> 
 
<li>
<span class="v">:flag-mapping</span> specifies short names to identify with each of the 
functions of the clique.  By default we just use the function names themselves, 
but it's usually nice to pick shorter names since you'll have to mention them 
in the theorems you prove.  The argument, if supplied and non-<span class="v">nil</span>, should 
be a list that specifies a short name for every function in the clique.  Each 
member of that list should be of the form <span class="v">(old new)</span> where (of course) 
<span class="v">old</span> and <span class="v">new</span> are symbols, except that for backward compatibility the 
form <span class="v">(old . new)</span> is allowed (but deprecated after March, 2021, ultimately 
to be eliminated).</li> 
 
<li>
<span class="v">:defthm-macro-name</span> lets you name the new macro that will be generated 
for proving theorems by inducting with the flag function.  By default it is 
named <span class="v">defthm-[flag-function-name]</span>, i.e., for the above example, it would 
be called <span class="v">defthm-flag-pseudo-termp</span>.</li> 
 
<li>
<span class="v">:flag-var</span> specifies the name of the variable to use for the flag.  By 
default it is just called <span class="v">flag</span>, and we rarely change it.  To be more 
precise, it is <span class="v">pkg::flag</span> where <span class="v">pkg</span> is the package of the new flag 
function's name; usually this means you don't have to think about the 
package.</li> 
 
<li>
<span class="v">:ruler-extenders</span> lets you give a value for the <a href="ACL2____RULER-EXTENDERS.html">ACL2::ruler-extenders</a> of the new flag function.</li> 
 
<li>
<span class="v">:body</span> is <span class="v">nil</span> by default, specifying that the original definition 
is used when extracting the body of each function.  The most recent definition 
rule is used if <span class="v">:body</span> is <span class="v">:last</span>.  Otherwise <span class="v">:body</span> should be a 
list with members of the form <span class="v">(fn1 fn2)</span>, indicating that the definition 
associated with a rule named <span class="v">fn2</span>, if there is one, should be used as the 
definition for the function symbol, <span class="v">fn1</span>.  See the community book 
<span class="v">books/tools/flag-tests.lisp</span> for an example of using such a alist for 
<span class="v">:body</span>, in particular for the purpose of using definitions installed with 
<span class="tt"><a href="ACL2____INSTALL-NOT-NORMALIZED.html">ACL2::install-not-normalized</a></span>.</li> 
 
</ul> 
 
 
<h3>Proving Theorems with <span class="v">make-flag</span>
</h3> 
 
<p>To prove an inductive theorem about a mutually-recursive function, you 
usually have to effectively prove a single, big, ugly formula that has a 
different case about each function in the clique.</p> 
 
<p>Normally, even with the flag function written for you, this would be a 
tedious process.  Here is an example of how you might prove by induction that 
<span class="v">pseudo-termp</span> and <span class="v">pseudo-term-listp</span> return Booleans:</p> 
 
<pre class="code">;; ACL2 can prove these are Booleans even without induction due to
;; type reasoning, so for illustration we'll turn these off so that
;; induction is required:

(<a href="ACL2____IN-THEORY.html">in-theory</a> (<a href="ACL2____DISABLE.html">disable</a> (:type-prescription pseudo-termp)
                    (:type-prescription pseudo-term-listp)
                    (:executable-counterpart tau-system)))

;; Main part of the proof, ugly lemma with cases.  Note that we
;; have to use :rule-classes nil here because this isn't a valid
;; rewrite rule.

(<a href="ACL2____LOCAL.html">local</a> (<a href="ACL2____DEFTHM.html">defthm</a> crux
         (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____EQUAL.html">equal</a> flag 'term)
                (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> x)))
               ((<a href="COMMON-LISP____EQUAL.html">equal</a> flag 'list)
                (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> lst)))
               (t
                t))
         :rule-classes nil
         :hints(("Goal" :induct (flag-pseudo-termp flag x lst)))))

;; Now we have to re-prove each part of the lemma so that we can use
;; it as a proper rule.

(<a href="ACL2____DEFTHM.html">defthm</a> type-of-pseudo-termp
  (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> x))
  :rule-classes :type-prescription
  :hints(("Goal" :use ((:instance crux (flag 'term))))))

(<a href="ACL2____DEFTHM.html">defthm</a> type-of-pseudo-term-listp
  (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> lst))
  :rule-classes :type-prescription
  :hints(("Goal" :use ((:instance crux (flag 'list))))))</pre> 
 
<p>Obviously this is tedious and makes you say everything twice.  Since the 
steps are so standard, <span class="v">make-flag</span> automatically gives you a macro to 
automate the process.  Here's the same proof, done with the new macro:</p> 
 
<pre class="code">(defthm-pseudo-termp
  (<a href="ACL2____DEFTHM.html">defthm</a> type-of-pseudo-termp
    (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> x))
    :rule-classes :type-prescription
    :flag term)
  (<a href="ACL2____DEFTHM.html">defthm</a> type-of-pseudo-term-listp
    (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> lst))
    :rule-classes :type-prescription
    :flag list))</pre> 
 
<p>It's worth understanding some of the details of what's going on here.</p> 
 
<p>The macro automatically tries to induct using the induction scheme.  But 
<font color="#ff0000">this only works if you're using the formals of the 
flag function as the variable names in the theorems.</font>  In the case of 
<span class="v">pseudo-termp</span>, this is pretty subtle: ACL2's definition uses different 
variables for the term/list cases, i.e.,</p> 
 
<pre class="code">(<a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a>
 (<a href="COMMON-LISP____DEFUN.html">defun</a> pseudo-termp (x) ...)
 (<a href="COMMON-LISP____DEFUN.html">defun</a> pseudo-term-listp (lst) ...))</pre> 
 
<p>So the theorem above only works without hints because we happened to choose 
<span class="v">x</span> and <span class="v">lst</span> as our variables.  If, instead, we wanted to use different 
variable names in our theorems, we'd have to give an explicit induction hint. 
For example:</p> 
 
<pre class="code">(defthm-pseudo-termp
  (<a href="ACL2____DEFTHM.html">defthm</a> type-of-pseudo-termp
    (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> term))
    :rule-classes :type-prescription
    :flag term)
  (<a href="ACL2____DEFTHM.html">defthm</a> type-of-pseudo-term-listp
    (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> termlist))
    :rule-classes :type-prescription
    :flag list)
  :hints(("Goal" :induct (flag-pseudo-termp flag term termlist))))</pre> 
 
 
<h3>Bells and Whistles</h3> 
 
<p><font color="#ff0000">New!</font> <b>Proof Templates</b>.  You can submit, 
e.g., <span class="v">(defthm-pseudo-termp)</span>, with no arguments, to print a ``template'' 
that is similar to the above form.  This can be a convenient starting place for 
writing down a new theorem.</p> 
 
 
<p><b>Localizing Theorems</b>.  Sometimes you may only want to export one of 
the theorems.  For instance, if we only want to add a rule about the term case, 
but no the list case, we could do this:</p> 
 
<pre class="code">(defthm-pseudo-termp
  (<a href="ACL2____DEFTHM.html">defthm</a> type-of-pseudo-termp
    (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> x))
    :rule-classes :type-prescription
    :flag term)
  (<a href="ACL2____DEFTHM.html">defthm</a> type-of-pseudo-term-listp
    (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> lst))
    :flag list
    :skip t))</pre> 
 
<p><b>Irrelevant Cases</b>. Sometimes the theorem you want is inductive in such 
a way that some functions are irrelevant; nothing needs to be proved about them 
in order to prove the desired theorem about the others.  The :skip keyword can 
be used with a theorem of T to do this:</p> 
 
<pre class="code">(defthm-pseudo-termp
  (<a href="ACL2____DEFTHM.html">defthm</a> type-of-pseudo-termp
    (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> x))
    :rule-classes :type-prescription
    :flag term)
  (<a href="ACL2____DEFTHM.html">defthm</a> type-of-pseudo-term-listp
    t
    :flag list
    :skip t))</pre> 
 
<p>Alternatively, you can provide the :skip-others keyword to the top-level 
macro and simply leave out the trivial parts:</p> 
 
<pre class="code">(defthm-pseudo-termp
  (<a href="ACL2____DEFTHM.html">defthm</a> type-of-pseudo-termp
    (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> x))
    :rule-classes :type-prescription
    :flag term)
  :skip-others t)</pre> 
 
<p><b>Multiple Theorems</b>. You may have more than one defthm form for a given 
flag.  For the main inductive proof, these are all simply conjoined 
together (and their hints are simply appended together), but they are exported 
as separate theorems and may have different <span class="v">:rule-classes</span>.</p> 
 
<p><b>Legacy Syntax</b>. There is an older, alternate syntax for <span class="v">make-flag</span> 
that is still available.  To encourage transitioning to the new syntax, the old 
syntax is not documented and should not be used.  Support for the old syntax 
will eventually be removed.  If you are maintaining legacy code that still uses 
the old syntax, see the comments in <span class="v">flag.lisp</span> for some details.</p> 
 
<h3>Advanced Hints</h3> 
 
<p>For advanced users, note that each individual "theorem" can have its own 
computed hints.  For instance we can write:</p> 
 
<pre class="code">(defthm-pseudo-termp
  (<a href="ACL2____DEFTHM.html">defthm</a> type-of-pseudo-termp
    (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> term))
    :rule-classes :type-prescription
    :flag term
    :hints ('(:expand ((<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> x)))))
  (<a href="ACL2____DEFTHM.html">defthm</a> type-of-pseudo-term-listp
    (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> termlist))
    :rule-classes :type-prescription
    :flag list
    :hints ('(:expand ((<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> lst)))))
  :hints(("Goal" :induct (flag-pseudo-termp flag term termlist))))</pre> 
 
<p>These hints are used <b>during the mutually inductive proof</b>.  Under the 
top-level induction, we check the clause for the current subgoal to determine 
the hypothesized setting of the flag variable, and provide the computed hints 
for the appropriate case.</p> 
 
<p>If you provide both a top-level hints form and hints on some or all of the 
separate theorems, both sets of hints have an effect; try <span class="v">:trans1</span> on such 
a defthm-flag-fn form to see what you get.</p> 
 
<p>You may use subgoal hints as well as computed hints, but they will not have 
any effect if the particular subgoal does not occur when those hints are in 
effect.  We simply translate subgoal hints to computed hints:</p> 
 
<pre class="code">("Subgoal *1/5.2" :in-theory (<a href="ACL2____THEORY.html">theory</a> 'foo))
  ---&gt;
(<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> id (parse-clause-id "Subgoal *1/5.2"))
     '(:in-theory (<a href="ACL2____THEORY.html">theory</a> 'foo)))</pre> 
 
<p>As mentioned above, if there is more than one defthm form for a given flag, 
the hints for all such forms are simply appended together; the hints given to 
one such form may affect what you might think of as the proof of another.</p> 

</body>
</html>
