<html>
<head>
<meta charset="UTF-8">
<title>Equivalence</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____EQUIVALENCE">Click for Equivalence in the Full Manual</a></h3>

<p>Mark a relation as an equivalence relation</p><p>See <a href="ACL2____RULE-CLASSES.html">rule-classes</a> for a general discussion of rule classes, 
 including how they are used to build rules from formulas and a discussion of 
 the various keywords in a rule class description.</p> 
 
 <pre class="code">Example:
(<a href="ACL2____DEFTHM.html">defthm</a> r-equal-is-an-equivalence ; assumes that r-equal has been defined
  (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (r-equal x y))
       (r-equal x x)
       (<a href="ACL2____IMPLIES.html">implies</a> (r-equal x y) (r-equal y x))
       (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (r-equal x y)
                     (r-equal y z))
                (r-equal x z)))
  :rule-classes :equivalence)</pre> 
 
 <p>Also see <a href="ACL2____DEFEQUIV.html">defequiv</a>.</p> 
 
 <pre class="code">General Form:
(<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (equiv x y))
     (equiv x x)
     (<a href="ACL2____IMPLIES.html">implies</a> (equiv x y) (equiv y x))
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (equiv x y)
                   (equiv y z))
              (equiv x z)))</pre> 
 
 <p>except that the order of the conjuncts and terms and the choice of variable 
 symbols is unimportant.  The effect of such a rule is to identify <span class="v">equiv</span> 
 as an equivalence relation.  Note that only Boolean 2-place function symbols 
 can be treated as equivalence relations.  See <a href="ACL2____CONGRUENCE.html">congruence</a> and see <a href="ACL2____REFINEMENT.html">refinement</a> for closely related concepts.</p> 
 
 <p>The macro form <span class="v">(<a href="ACL2____DEFEQUIV.html">defequiv</a> equiv)</span> is an abbreviation for a <span class="tt"><a href="ACL2____DEFTHM.html">defthm</a></span> of rule-class <span class="v">:equivalence</span> that establishes that <span class="v">equiv</span> is an 
 equivalence relation.  It generates the formula shown above.  See <a href="ACL2____DEFEQUIV.html">defequiv</a>.</p> 
 
 <p>When <span class="v">equiv</span> is marked as an equivalence relation, its reflexivity, 
 symmetry, and transitivity are built into the system in a deeper way than via 
 <span class="v">:</span><span class="tt"><a href="ACL2____REWRITE.html">rewrite</a></span> rules.  More importantly, after <span class="v">equiv</span> has been 
 shown to be an equivalence relation, lemmas about <span class="v">equiv</span>, e.g.,</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> hyps (equiv lhs rhs)),</pre> 
 
 <p>when stored as <span class="v">:</span><span class="tt"><a href="ACL2____REWRITE.html">rewrite</a></span> rules, cause the system to rewrite 
 certain occurrences of (instances of) <span class="v">lhs</span> to (instances of) <span class="v">rhs</span>. 
 Roughly speaking, an occurrence of <span class="v">lhs</span> in the <span class="v">kth</span> argument of some 
 <span class="v">fn</span>-expression, <span class="v">(fn ... lhs' ...)</span>, can be rewritten to produce <span class="v">(fn
 ...  rhs' ...)</span>, provided the system ``knows'' that the value of <span class="v">fn</span> is 
 unaffected by <span class="v">equiv</span>-substitution in the <span class="v">kth</span> argument.  Such 
 knowledge is communicated to the system via ``congruence lemmas.''</p> 
 
 <p>For example, suppose that <span class="v">r-equal</span> is known to be an equivalence 
 relation.  The <span class="v">:</span><span class="tt"><a href="ACL2____CONGRUENCE.html">congruence</a></span> lemma</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (r-equal s1 s2)
         (<a href="COMMON-LISP____EQUAL.html">equal</a> (fn s1 n) (fn s2 n)))</pre> 
 
 <p>informs the rewriter that, while rewriting the first argument of 
 <span class="v">fn</span>-expressions, it is permitted to use <span class="v">r-equal</span> rewrite-rules.  See 
 <a href="ACL2____CONGRUENCE.html">congruence</a> for details about <span class="v">:</span><span class="tt"><a href="ACL2____CONGRUENCE.html">congruence</a></span> lemmas. 
 Interestingly, congruence lemmas are automatically created when an equivalence 
 relation is stored, saying that either of the equivalence relation's arguments 
 may be replaced by an equivalent argument.  That is, if the equivalence 
 relation is <span class="v">fn</span>, we store congruence rules that state the following 
 fact:</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (fn x1 y1)
              (fn x2 y2))
         (<a href="ACL2____IFF.html">iff</a> (fn x1 x2) (fn y1 y2)))</pre> 
 
 <p>Another aspect of equivalence relations is that of ``refinement.''  We say 
 <span class="v">equiv1</span> ``refines'' <span class="v">equiv2</span> iff <span class="v">(equiv1 x y)</span> implies <span class="v">(equiv2 x
 y)</span>.  <span class="v">:</span><span class="tt"><a href="ACL2____REFINEMENT.html">refinement</a></span> rules permit you to establish such connections 
 between your equivalence relations.  The value of refinements is that if the 
 system is trying to rewrite something while maintaining <span class="v">equiv2</span> it is 
 permitted to use as a <span class="v">:</span><span class="tt"><a href="ACL2____REWRITE.html">rewrite</a></span> rule any refinement of 
 <span class="v">equiv2</span>.  Thus, if <span class="v">equiv1</span> is a refinement of <span class="v">equiv2</span> and there 
 are <span class="v">equiv1</span> rewrite-rules available, they can be brought to bear while 
 maintaining <span class="v">equiv2</span>.  See <a href="ACL2____REFINEMENT.html">refinement</a>.</p> 
 
 <p>The system initially has knowledge of two equivalence relations, equality, 
 denoted by the symbol <span class="tt"><a href="COMMON-LISP____EQUAL.html">equal</a></span>, and propositional equivalence, denoted by 
 <span class="tt"><a href="ACL2____IFF.html">iff</a></span>.  <span class="tt"><a href="COMMON-LISP____EQUAL.html">Equal</a></span> is known to be a refinement of all equivalence 
 relations and to preserve equality across all arguments of all functions.</p> 
 
 <p>Typically there are five steps involved in introducing and using a new 
 equivalence relation, equiv.</p> 
 
 <blockquote> 
 
 <p>(1) Define <span class="v">equiv</span>,</p> 
 
 <p>(2) prove the <span class="v">:equivalence</span> lemma about <span class="v">equiv</span>,</p> 
 
 <p>(3) prove the <span class="v">:</span><span class="tt"><a href="ACL2____CONGRUENCE.html">congruence</a></span> lemmas that show where <span class="v">equiv</span> 
 can be used to maintain known relations,</p> 
 
 <p>(4) prove the <span class="v">:</span><span class="tt"><a href="ACL2____REFINEMENT.html">refinement</a></span> lemmas that relate <span class="v">equiv</span> to 
 known relations other than equal, and</p> 
 
 <p>(5) develop the theory of conditional <span class="v">:</span><span class="tt"><a href="ACL2____REWRITE.html">rewrite</a></span> rules that 
 drive equiv rewriting.</p> 
 
 </blockquote> 
 
 <p>More will be written about this as we develop the techniques.  For now, 
 here is an example that shows how to make use of equivalence relations in 
 rewriting.</p> 
 
 <p>Among the theorems proved below is</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> insert-sort-is-id
  (perm (insert-sort x) x))</pre> 
 
 <p>Here <span class="v">perm</span> is defined as usual with <span class="v">delete</span> and is proved to be an 
 equivalence relation and to be a congruence relation for <span class="tt"><a href="COMMON-LISP____CONS.html">cons</a></span> and 
 <span class="tt"><a href="COMMON-LISP____MEMBER.html">member</a></span>.</p> 
 
 <p>Then we prove the lemma</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> insert-is-cons
  (perm (insert a x) (<a href="COMMON-LISP____CONS.html">cons</a> a x)))</pre> 
 
 <p>which you must think of as you would <span class="v">(insert a x) = (<a href="COMMON-LISP____CONS.html">cons</a> a x)</span>.</p> 
 
 <p>Now prove <span class="v">(perm (insert-sort x) x)</span>.  The base case is trivial.  The 
 induction step is</p> 
 
 <pre class="code">   (<a href="COMMON-LISP____CONSP.html">consp</a> x)
 &amp; (perm (insert-sort (<a href="COMMON-LISP____CDR.html">cdr</a> x)) (<a href="COMMON-LISP____CDR.html">cdr</a> x))

-&gt; (perm (insert-sort x) x).</pre> 
 
 <p>Opening <span class="v">insert-sort</span> makes the conclusion be</p> 
 
 <pre class="code">(perm (insert (<a href="COMMON-LISP____CAR.html">car</a> x) (insert-sort (<a href="COMMON-LISP____CDR.html">cdr</a> x))) x).</pre> 
 
 <p>Apply <span class="v">insert-is-cons</span> to get</p> 
 
 <pre class="code">(perm (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> x) (insert-sort (<a href="COMMON-LISP____CDR.html">cdr</a> x)) x)).</pre> 
 
 <p>Note that we have proved that <span class="v">perm</span> is a congruence relation for 
 <span class="v">cons</span>. That allows us to apply the induction hypothesis (rewriting 
 <span class="v">(insert-sort (<a href="COMMON-LISP____CDR.html">cdr</a> x))</span> to <span class="v">(<a href="COMMON-LISP____CDR.html">cdr</a> x)</span>), to make the conclusion be</p> 
 
 <pre class="code">(perm (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> x) (<a href="COMMON-LISP____CDR.html">cdr</a> x)) x).</pre> 
 
 <p>But we know that <span class="v">(<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> x) (<a href="COMMON-LISP____CDR.html">cdr</a> x))</span> is <span class="v">x</span>, so we get <span class="v">(perm
 x x)</span> which is trivial, since <span class="v">perm</span> is an equivalence relation.  An 
 exercise left to the reader is how this proof will change had we also proved 
 that <span class="v">perm</span> is a congruence relation for <span class="v">insert</span>.</p> 
 
 <p>Here are the events.</p> 
 
 <pre class="code">(<a href="ACL2____ENCAPSULATE.html">encapsulate</a> (((lt * *) =&gt; *))
  (<a href="ACL2____LOCAL.html">local</a> (<a href="COMMON-LISP____DEFUN.html">defun</a> lt (x y) (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORE.html">ignore</a> x y)) nil))
  (<a href="ACL2____DEFTHM.html">defthm</a> lt-non-symmetric (<a href="ACL2____IMPLIES.html">implies</a> (lt x y) (<a href="COMMON-LISP____NOT.html">not</a> (lt y x)))))

(<a href="COMMON-LISP____DEFUN.html">defun</a> insert (x lst)
  (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____ATOM.html">atom</a> lst) (<a href="COMMON-LISP____LIST.html">list</a> x))
        ((lt x (<a href="COMMON-LISP____CAR.html">car</a> lst)) (<a href="COMMON-LISP____CONS.html">cons</a> x lst))
        (t (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> lst) (insert x (<a href="COMMON-LISP____CDR.html">cdr</a> lst))))))

(<a href="COMMON-LISP____DEFUN.html">defun</a> insert-sort (lst)
  (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____ATOM.html">atom</a> lst) nil)
        (t (insert (<a href="COMMON-LISP____CAR.html">car</a> lst) (insert-sort (<a href="COMMON-LISP____CDR.html">cdr</a> lst))))))

(<a href="COMMON-LISP____DEFUN.html">defun</a> del (x lst)
  (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____ATOM.html">atom</a> lst) nil)
        ((<a href="COMMON-LISP____EQUAL.html">equal</a> x (<a href="COMMON-LISP____CAR.html">car</a> lst)) (<a href="COMMON-LISP____CDR.html">cdr</a> lst))
        (t (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> lst) (del x (<a href="COMMON-LISP____CDR.html">cdr</a> lst))))))

(<a href="COMMON-LISP____DEFUN.html">defun</a> mem (x lst)
  (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____ATOM.html">atom</a> lst) nil)
        ((<a href="COMMON-LISP____EQUAL.html">equal</a> x (<a href="COMMON-LISP____CAR.html">car</a> lst)) t)
        (t (mem x (<a href="COMMON-LISP____CDR.html">cdr</a> lst)))))

(<a href="COMMON-LISP____DEFUN.html">defun</a> perm (lst1 lst2)
  (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____ATOM.html">atom</a> lst1) (<a href="COMMON-LISP____ATOM.html">atom</a> lst2))
        ((mem (<a href="COMMON-LISP____CAR.html">car</a> lst1) lst2)
         (perm (<a href="COMMON-LISP____CDR.html">cdr</a> lst1) (del (<a href="COMMON-LISP____CAR.html">car</a> lst1) lst2)))
        (t nil)))

(<a href="ACL2____DEFTHM.html">defthm</a> perm-reflexive
  (perm x x))

(<a href="ACL2____DEFTHM.html">defthm</a> perm-cons
  (<a href="ACL2____IMPLIES.html">implies</a> (mem a x)
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (perm x (<a href="COMMON-LISP____CONS.html">cons</a> a y))
                  (perm (del a x) y)))
  :hints (("Goal" :induct (perm x y))))

(<a href="ACL2____DEFTHM.html">defthm</a> perm-symmetric
  (<a href="ACL2____IMPLIES.html">implies</a> (perm x y) (perm y x)))

(<a href="ACL2____DEFTHM.html">defthm</a> mem-del
  (<a href="ACL2____IMPLIES.html">implies</a> (mem a (del b x)) (mem a x)))

(<a href="ACL2____DEFTHM.html">defthm</a> perm-mem
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (perm x y)
                (mem a x))
           (mem a y)))

(<a href="ACL2____DEFTHM.html">defthm</a> mem-del2
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (mem a x)
                (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> a b)))
           (mem a (del b x))))

(<a href="ACL2____DEFTHM.html">defthm</a> comm-del
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (del a (del b x)) (del b (del a x))))

(<a href="ACL2____DEFTHM.html">defthm</a> perm-del
  (<a href="ACL2____IMPLIES.html">implies</a> (perm x y)
           (perm (del a x) (del a y))))

(<a href="ACL2____DEFTHM.html">defthm</a> perm-transitive
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (perm x y) (perm y z)) (perm x z)))

(<a href="ACL2____DEFEQUIV.html">defequiv</a> perm)

(<a href="ACL2____IN-THEORY.html">in-theory</a> (<a href="ACL2____DISABLE.html">disable</a> perm
                    perm-reflexive
                    perm-symmetric
                    perm-transitive))

(<a href="ACL2____DEFCONG.html">defcong</a> perm perm (<a href="COMMON-LISP____CONS.html">cons</a> x y) 2)

(<a href="ACL2____DEFCONG.html">defcong</a> perm iff (mem x y) 2)

(<a href="ACL2____DEFTHM.html">defthm</a> atom-perm
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x)) (perm x nil))
  :rule-classes :forward-chaining
  :hints (("Goal" :in-theory (<a href="ACL2____ENABLE.html">enable</a> perm))))

(<a href="ACL2____DEFTHM.html">defthm</a> insert-is-cons
  (perm (insert a x) (<a href="COMMON-LISP____CONS.html">cons</a> a x)))

(<a href="ACL2____DEFTHM.html">defthm</a> insert-sort-is-id
  (perm (insert-sort x) x))

(<a href="COMMON-LISP____DEFUN.html">defun</a> app (x y) (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x) (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> x) (app (<a href="COMMON-LISP____CDR.html">cdr</a> x) y)) y))

(<a href="COMMON-LISP____DEFUN.html">defun</a> rev (x)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x) (app (<a href="ACL2____REV.html">rev</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x)) (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CAR.html">car</a> x))) nil))

(<a href="ACL2____DEFCONG.html">defcong</a> perm perm (app x y) 2)

(<a href="ACL2____DEFTHM.html">defthm</a> app-cons
  (perm (app a (<a href="COMMON-LISP____CONS.html">cons</a> b c)) (<a href="COMMON-LISP____CONS.html">cons</a> b (app a c))))

(<a href="ACL2____DEFTHM.html">defthm</a> app-commutes
  (perm (app a b) (app b a)))

(<a href="ACL2____DEFCONG.html">defcong</a> perm perm (app x y) 1
  :hints (("Goal" :induct (app y x))))

(<a href="ACL2____DEFTHM.html">defthm</a> rev-is-id (perm (<a href="ACL2____REV.html">rev</a> x) x))

(<a href="COMMON-LISP____DEFUN.html">defun</a> == (x y)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x)
      (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> y)
          (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> x) (<a href="COMMON-LISP____CAR.html">car</a> y))
               (== (<a href="COMMON-LISP____CDR.html">cdr</a> x) (<a href="COMMON-LISP____CDR.html">cdr</a> y)))
          nil)
      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> y))))

(<a href="ACL2____DEFTHM.html">defthm</a> ==-reflexive (== x x))

(<a href="ACL2____DEFTHM.html">defthm</a> ==-symmetric (<a href="ACL2____IMPLIES.html">implies</a> (== x y) (== y x)))

(<a href="ACL2____DEFEQUIV.html">defequiv</a> ==)

(<a href="ACL2____IN-THEORY.html">in-theory</a> (<a href="ACL2____DISABLE.html">disable</a> ==-symmetric ==-reflexive))

(<a href="ACL2____DEFCONG.html">defcong</a> == == (<a href="COMMON-LISP____CONS.html">cons</a> x y) 2)

(<a href="ACL2____DEFCONG.html">defcong</a> == iff (<a href="COMMON-LISP____CONSP.html">consp</a> x) 1)

(<a href="ACL2____DEFCONG.html">defcong</a> == == (app x y) 2)

(<a href="ACL2____DEFCONG.html">defcong</a> == == (app x y) 1)

(<a href="ACL2____DEFTHM.html">defthm</a> rev-rev (== (<a href="ACL2____REV.html">rev</a> (<a href="ACL2____REV.html">rev</a> x)) x))</pre>
</body>
</html>
