<html>
<head>
<meta charset="UTF-8">
<title>Secp256k1-sign-det-rec</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ECDSA____SECP256K1-SIGN-DET-REC">Click for Secp256k1-sign-det-rec in the Full Manual</a></h3>

<p>ECDSA deterministic signature with public key recovery for secp256k1.</p><p>ECDSA signatures are specified in <a href="http://www.secg.org/sec1-v2.pdf" target="_blank"><nobr>Standards for Efficient Cryptography 1 (SEC 1)<img src="../Icon_External_Link.png" title="External link to http://www.secg.org/sec1-v2.pdf"></nobr></a> in general, and their deterministic version is specified in the <a href="https://tools.ietf.org/html/rfc6979" target="_blank"><nobr>RFC 6979 standard<img src="../Icon_External_Link.png" title="External link to https://tools.ietf.org/html/rfc6979"></nobr></a>. The public key recovery aspects are also described in SEC 1.</p><p>ECDSA, as specified in SEC 1, relies on 
     a randomly generated ephemeral private key for each signature. 
     RFC 6979 describes a procedure to generate 
     a deterministic but unpredictable ephemeral private key 
     (from the message and the signing key), 
     which can be considered indistinguishable from a random one. 
     The details of this are unimportant for the interface introduced here, 
     but the point is that, 
     since the ephemeral private key is deterministically generated, 
     the constrained ACL2 function introduced here requires 
     no additional inputs related to the random generation of 
     the ephemeral private key.</p><p>ECDSA is parameterized over a hash function applied to the message 
     prior to the creation of the signature. 
     To avoid this explicit dependency in our ACL2 function, 
     we have it take as input a hash of the message instead of the message: 
     this sidesteps the choice of the hash function, 
     providing the ability to sign messages 
     that are hashed by external means.</p><p>According to RFC 6979, 
     the same hash function is used as part of the procedure 
     to deterministically generate the ephemeral private key. 
     Mathematically speaking, 
     one could well use a different hash function though. 
     For now, our constrained ACL2 function is agnostic 
     in regard to the RFC 6979 hash function, 
     and can be in fact made executable via attachments 
     that pick different hash functions.</p><p>An ECDSA signature consists of a pair (r,s) 
     of positive integers below the order n of the curve. 
     This suffices to verify the signature against a known public key. 
     As explained in SEC 1 Section 4.1.6, given a signature (r,s), 
     there is generally a small number of possible public keys, 
     all of which can be inferred from the signature; 
     for the secp256k1 curve, there are at most four possibilities. 
     Thus, by enhancing the signature (r,s) 
     with a little additional information, 
     it is possible to recover the public key from the enhanced signature. 
     This information can be structured as (see SEC 1 Section 4.1.6) 
     (i) the index j of the x coordinate of the point R and 
     (ii) the parity of the y coordinate of the point R. 
     So our constrained function returns these (see below).</p><p>An ECDSA signature may involve the generation of successive 
     random or (random-looking) deterministic ephemeral private keys 
     until valid (r,s) are found. 
     This ``looping'' feature can be exploited 
     to put additional constraints on the signature or recovery information. 
     For instance, 
     one could require the aforementioned recovery index j to be always 0, 
     which is equivalent to saying that 
     r is the x coordinate of R 
     (in general it is x mod n); 
     this condition is almost always satisfied, 
     because there is a comparatively very small number of values 
     between the order n and the prime p. 
     Thus, our constrained function has an additional input flag 
     that says whether the x coordinate of R should be ``small'', 
     i.e. below n.</p><p>If (r,s) is a signature, (r,-s) is an equivalent signature, 
     where the negation is modulo n. 
     This fact can be used by requiring that the s signature component 
     be always below n/2, 
     which can be achieved simply by generating (r,s) 
     and then flipping s if needed. 
     To support this use case, 
     our constrained function has an additional input flag 
     that says whether s should be ``small'', i.e. below n/2.</p><p>To summarize, our constrained function takes as inputs 
     a hash (a list of bytes), a private key, and two boolean flags, 
     as formalized by the guard.</p><p>The function returns as outputs: 
     an error flag, constrained to be a boolean; 
     a public key recovery x index, constrained to be a natural number 
     (this is always 0 if the <span class="v">small-x?</span> flag is <span class="v">t</span>, 
     but we do not capture this constraint here); 
     a public key recovery y parity, constrained to be a boolean; 
     the signature value r, constrained to be a field element; 
     and the signature value s, constrained to be a field element. 
     The latter two results are always positive and below the order n, 
     but for now we use the field type for simplicity. 
     The error flag is <span class="v">t</span> when the signature operation fails, 
     due to the repeated inability of deterministically finding 
     an ephemeral private key that produces valid results; 
     this is believe essentially impossible 
     with just a few repetitions available, 
     but the mathematical possibility remains. 
     If the error flag is <span class="v">t</span>, the other results are irrelevant.</p><p>We constrain this function 
     to return results of the types described above unconditionally. 
     We also constrain it to fix its arguments to the guard types.</p><p>See also:<ul>
<li><a href="ECDSA____DETERMINISTIC-ECDSA-SECP256K1.html">Deterministic ECDSA executable specification</a></li>
<li><a href="ECDSA____SECP256K1-ECDSA-ATTACHMENT.html">attaching Deterministic ECDSA executable specification to this interface</a></li>
</ul></p> 
 
<h3>Definitions and Theorems</h3><p><b>Theorem: </b>booleanp-of-mv-nth-0-secp256k1-sign-det-rec</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 booleanp-of-mv-nth-0-secp256k1-sign-det-rec
 (<a href="ACL2____BOOLEANP.html">booleanp</a>
     (<a href="ACL2____MV-NTH.html">mv-nth</a> 0
             (<a href="ECDSA____SECP256K1-SIGN-DET-REC.html">secp256k1-sign-det-rec</a> hash priv small-x? small-s?))))</pre> 
<p><b>Theorem: </b>natp-of-mv-nth-1-secp256k1-sign-det-rec</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 natp-of-mv-nth-1-secp256k1-sign-det-rec
 (<a href="ACL2____NATP.html">natp</a>
     (<a href="ACL2____MV-NTH.html">mv-nth</a> 1
             (<a href="ECDSA____SECP256K1-SIGN-DET-REC.html">secp256k1-sign-det-rec</a> hash priv small-x? small-s?))))</pre> 
<p><b>Theorem: </b>booleanp-of-mv-nth-2-secp256k1-sign-det-rec</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 booleanp-of-mv-nth-2-secp256k1-sign-det-rec
 (<a href="ACL2____BOOLEANP.html">booleanp</a>
     (<a href="ACL2____MV-NTH.html">mv-nth</a> 2
             (<a href="ECDSA____SECP256K1-SIGN-DET-REC.html">secp256k1-sign-det-rec</a> hash priv small-x? small-s?))))</pre> 
<p><b>Theorem: </b>secp256k1-fieldp-of-mv-nth-3-secp256k1-sign-det-rec</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 secp256k1-fieldp-of-mv-nth-3-secp256k1-sign-det-rec
 (<a href="ECURVE____SECP256K1-FIELDP.html">secp256k1-fieldp</a>
     (<a href="ACL2____MV-NTH.html">mv-nth</a> 3
             (<a href="ECDSA____SECP256K1-SIGN-DET-REC.html">secp256k1-sign-det-rec</a> hash priv small-x? small-s?))))</pre> 
<p><b>Theorem: </b>secp256k1-fieldp-of-mv-nth-4-secp256k1-sign-det-rec</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 secp256k1-fieldp-of-mv-nth-4-secp256k1-sign-det-rec
 (<a href="ECURVE____SECP256K1-FIELDP.html">secp256k1-fieldp</a>
     (<a href="ACL2____MV-NTH.html">mv-nth</a> 4
             (<a href="ECDSA____SECP256K1-SIGN-DET-REC.html">secp256k1-sign-det-rec</a> hash priv small-x? small-s?))))</pre> 
<p><b>Theorem: </b>secp256k1-sign-det-rec-fixes-input-hash</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     secp256k1-sign-det-rec-fixes-input-hash
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ECDSA____SECP256K1-SIGN-DET-REC.html">secp256k1-sign-det-rec</a> (<a href="ACL2____BYTE-LIST-FIX.html">byte-list-fix</a> hash)
                                    priv small-x? small-s?)
            (<a href="ECDSA____SECP256K1-SIGN-DET-REC.html">secp256k1-sign-det-rec</a> hash priv small-x? small-s?)))</pre> 
<p><b>Theorem: </b>secp256k1-sign-det-rec-fixes-input-priv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   secp256k1-sign-det-rec-fixes-input-priv
   (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ECDSA____SECP256K1-SIGN-DET-REC.html">secp256k1-sign-det-rec</a> hash (<a href="ECURVE____SECP256K1-PRIV-KEY-FIX.html">secp256k1-priv-key-fix</a> priv)
                                  small-x? small-s?)
          (<a href="ECDSA____SECP256K1-SIGN-DET-REC.html">secp256k1-sign-det-rec</a> hash priv small-x? small-s?)))</pre> 
<p><b>Theorem: </b>secp256k1-sign-det-rec-fixes-input-small-x?</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     secp256k1-sign-det-rec-fixes-input-small-x?
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ECDSA____SECP256K1-SIGN-DET-REC.html">secp256k1-sign-det-rec</a> hash priv (<a href="ACL2____BOOL-FIX.html">bool-fix</a> small-x?)
                                    small-s?)
            (<a href="ECDSA____SECP256K1-SIGN-DET-REC.html">secp256k1-sign-det-rec</a> hash priv small-x? small-s?)))</pre> 
<p><b>Theorem: </b>secp256k1-sign-det-rec-fixes-input-small-s?</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 secp256k1-sign-det-rec-fixes-input-small-s?
 (<a href="COMMON-LISP____EQUAL.html">equal</a>
     (<a href="ECDSA____SECP256K1-SIGN-DET-REC.html">secp256k1-sign-det-rec</a> hash priv small-x? (<a href="ACL2____BOOL-FIX.html">bool-fix</a> small-s?))
     (<a href="ECDSA____SECP256K1-SIGN-DET-REC.html">secp256k1-sign-det-rec</a> hash priv small-x? small-s?)))</pre> 
<p><b>Theorem: </b>byte-list-equiv-implies-equal-secp256k1-sign-det-rec-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 byte-list-equiv-implies-equal-secp256k1-sign-det-rec-1
 (<a href="ACL2____IMPLIES.html">implies</a>
   (<a href="ACL2____BYTE-LIST-EQUIV.html">byte-list-equiv</a> hash hash-equiv)
   (<a href="COMMON-LISP____EQUAL.html">equal</a>
        (<a href="ECDSA____SECP256K1-SIGN-DET-REC.html">secp256k1-sign-det-rec</a> hash priv small-x? small-s?)
        (<a href="ECDSA____SECP256K1-SIGN-DET-REC.html">secp256k1-sign-det-rec</a> hash-equiv priv small-x? small-s?)))
 :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>secp256k1-priv-key-equiv-implies-equal-secp256k1-sign-det-rec-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 secp256k1-priv-key-equiv-implies-equal-secp256k1-sign-det-rec-2
 (<a href="ACL2____IMPLIES.html">implies</a>
   (secp256k1-priv-key-equiv priv priv-equiv)
   (<a href="COMMON-LISP____EQUAL.html">equal</a>
        (<a href="ECDSA____SECP256K1-SIGN-DET-REC.html">secp256k1-sign-det-rec</a> hash priv small-x? small-s?)
        (<a href="ECDSA____SECP256K1-SIGN-DET-REC.html">secp256k1-sign-det-rec</a> hash priv-equiv small-x? small-s?)))
 :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>iff-implies-equal-secp256k1-sign-det-rec-3</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 iff-implies-equal-secp256k1-sign-det-rec-3
 (<a href="ACL2____IMPLIES.html">implies</a>
   (<a href="ACL2____IFF.html">iff</a> small-x? small-x?-equiv)
   (<a href="COMMON-LISP____EQUAL.html">equal</a>
        (<a href="ECDSA____SECP256K1-SIGN-DET-REC.html">secp256k1-sign-det-rec</a> hash priv small-x? small-s?)
        (<a href="ECDSA____SECP256K1-SIGN-DET-REC.html">secp256k1-sign-det-rec</a> hash priv small-x?-equiv small-s?)))
 :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>iff-implies-equal-secp256k1-sign-det-rec-4</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 iff-implies-equal-secp256k1-sign-det-rec-4
 (<a href="ACL2____IMPLIES.html">implies</a>
   (<a href="ACL2____IFF.html">iff</a> small-s? small-s?-equiv)
   (<a href="COMMON-LISP____EQUAL.html">equal</a>
        (<a href="ECDSA____SECP256K1-SIGN-DET-REC.html">secp256k1-sign-det-rec</a> hash priv small-x? small-s?)
        (<a href="ECDSA____SECP256K1-SIGN-DET-REC.html">secp256k1-sign-det-rec</a> hash priv small-x? small-s?-equiv)))
 :rule-classes (:congruence))</pre> 

</body>
</html>
