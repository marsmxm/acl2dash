<html>
<head>
<meta charset="UTF-8">
<title>Lambda</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=COMMON-LISP____LAMBDA">Click for Lambda in the Full Manual</a></h3>

<p>Lambda expressions, <span class="v">LAMBDA</span> objects, and <span class="v">lambda$</span> expressions</p><p>The word ``lambda'' occurs in several different contexts in ACL2. 
  When we are being precise our meanings are as outlined below.</p> 
 
  <ul> 
 
  <li><p>lambda expression -- This phrase is used to describe the syntactic 
  entity beginning with the symbol <span class="v">lambda</span> that is allowed to occupy the 
  ``function'' position in an ACL2 <a href="ACL2____TERM.html">term</a>.  Lambda expressions are most 
  often created when <span class="v">let</span> expressions are translated into their formal 
  counterparts.  We provide an example below.</p></li> 
 
  <li><p><span class="v">LAMBDA</span> object -- An ACL2 list constant interpreted as a ``function'' 
  by <span class="tt"><a href="ACL2____APPLY_42.html">apply$</a></span>.  <span class="v">LAMBDA</span> objects may be written in terms by quoting them. 
  However, we urge the user to introduce <span class="v">LAMBDA</span> objects into terms by using 
  the built-in macro <span class="tt"><a href="ACL2____LAMBDA_42.html">lambda$</a></span>.  We provide examples below.</p></li> 
 
  <li><p><span class="v">lambda$</span> expressions -- These are untranslated terms beginning with 
  the macro symbol <span class="v">lambda$</span>.  They expand during translation to quoted <span class="v">LAMBDA</span> 
  objects.  We provide examples below.</p></li> 
 
  </ul> 
 
  <p>These three phrases are very similar but mean very different things.  You 
  should read carefully when you see us talk about lambda things! 
  Unfortunately, we're not always as precise as we might be so you might have 
  to disambiguous our usage by context.  If you see places in the documentation 
  where you think we've messed up, please bring them to our attention!</p> 
 
  <h3>About Lambda Expressions</h3> 
 
  <p>Consider the function <span class="v">odd-evenp</span>, defined with</p> 
 
  <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> odd-evenp (x)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> x)
      -1
      (<a href="COMMON-LISP____LET.html">let</a> ((ans (odd-evenp (<a href="COMMON-LISP____-.html">-</a> x 1))))
        (<a href="COMMON-LISP_____A2.html">*</a> (<a href="COMMON-LISP_____B2.html">+</a> ans 1) (<a href="COMMON-LISP____-.html">-</a> ans 1)))))</pre> 
 
  <p>Distracting Aside: Can you see why we gave this function this name?  Hint: 
  We might have named it ``weird <span class="v">evenp</span>.''</p> 
 
  <p>The translated body of <span class="v">odd-evenp</span> is</p> 
 
  <pre class="code">(<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> x)
    '-1
    ((<a href="COMMON-LISP____LAMBDA.html">lambda</a> (ans)
             (<a href="ACL2____BINARY-_A2.html">binary-*</a> (<a href="ACL2____BINARY-_B2.html">binary-+</a> ans '1)
                       (<a href="ACL2____BINARY-_B2.html">binary-+</a> '-1 ans)))
     (odd-evenp (<a href="ACL2____BINARY-_B2.html">binary-+</a> '-1 x))))</pre> 
 
  <p>The syntactic entity in the function position of the term in the false 
  branch, namely</p> 
 
  <pre class="code">(<a href="COMMON-LISP____LAMBDA.html">lambda</a> (ans)
  (<a href="ACL2____BINARY-_A2.html">binary-*</a> (<a href="ACL2____BINARY-_B2.html">binary-+</a> ans '1)
            (<a href="ACL2____BINARY-_B2.html">binary-+</a> '-1 ans)))</pre> 
 
  <p>is a lambda expression.</p> 
 
  <p>Lambda expressions are integral to the formal representation of terms. 
  They are the formal mechanism by which local variables are introduced and 
  thus allow repeated references to intermediate results without causing 
  recomputation.  In ACL2 they obey the rules of Common Lisp.  In particular, 
  while defining a recursive function it is allowed to call the function 
  recursively within the lambda expression, e.g., to temporarily save the value 
  of a recursive call for repeated use.  (This is not illustrated by 
  <span class="v">odd-evenp</span> where the recursive call is outside of the lambda expression.) 
  For more details on the formal representation of ACL2 terms, see <a href="ACL2____TERM.html">term</a>.</p> 
 
  <h3>About <span class="v">LAMBDA</span> Objects</h3> 
 
  <p>Prior to Version  8.0 when <span class="v">apply$</span> was introduced, ``lambda 
  expression'' was the only phrase the ACL2 developers used mentioning the word 
  ``lambda.''  Some Community Books introduced various terms or objects 
  mentioning the word but that is beyond the scope of this documentation. 
  Because ``lambda'' occurred in no other context before <span class="v">apply$</span> we are not 
  confident that every reference to what we are now calling ``lambda 
  expressions'' were called by that precise phrase in old documentation. 
  If you see a place where we refer to these entities by another phrase, please 
  let us know!</p> 
 
  <p>When <span class="tt"><a href="ACL2____APPLY_42.html">apply$</a></span> was introduced, <span class="v">LAMBDA</span> objects became a formally 
  supported concept in the ACL2 implementation and we started using 
  ``<span class="v">LAMBDA</span> objects'' to refer to them.  A <span class="v">LAMBDA</span> object is generally 
  a list, either of the form <span class="v">(<a href="COMMON-LISP____LAMBDA.html">LAMBDA</a> vars body)</span> or <span class="v">(<a href="COMMON-LISP____LAMBDA.html">LAMBDA</a> vars dcl
  body)</span>.  There are additional restrictions on <span class="v">vars</span>, <span class="v">dcl</span>, and 
  <span class="v">body</span> that we discuss later.  But <span class="v">apply$</span> treats any <span class="v">consp</span> 
  object and tries to extract those components by rudimentary pattern matching. 
  An example of a <span class="v">LAMBDA</span> object is the list of length three 
  <span class="v">(<a href="COMMON-LISP____LAMBDA.html">LAMBDA</a> (x) (<a href="ACL2____BINARY-_B2.html">BINARY-+</a> '1 X))</span>.</p> 
 
  <p>Generally speaking when <span class="v">LAMBDA</span> objects occur in translated terms they 
  are <span class="v">quote</span>d, as in</p> 
 
  <pre class="code">(<a href="ACL2____COLLECT_42.html">collect$</a> '(<a href="COMMON-LISP____LAMBDA.html">LAMBDA</a> (X) (<a href="ACL2____BINARY-_B2.html">BINARY-+</a> '1 X)) lst)</pre> 
 
  <p>To highlight the fact that these objects are constants, we try to write 
  them in UPPERCASE and <span class="v">typewriter</span> font in this documentation.  For the 
  same reason, we generally write ``<span class="v">LAMBDA</span> object'' rather than ``lambda 
  object.''</p> 
 
  <p>But of course there's no difference between the symbol <span class="v">LAMBDA</span> and the 
  symbol <span class="v">lambda</span>.  Furthermore, <span class="v">LAMBDA</span> objects need not be quoted. 
  From a logical perspective they could just be consed up because they are just 
  ordinary ACL2 list constants.  Their ``lambda'' status comes from being 
  treated as functions by <span class="v">apply$</span>.  So one could write</p> 
 
  <pre class="code">(<a href="ACL2____COLLECT_42.html">collect$</a> (<a href="COMMON-LISP____LIST.html">list</a> 'lambda '(x) '(<a href="ACL2____BINARY-_B2.html">binary-+</a> '1 x)) lst)</pre> 
 
  <p>and we would say that the value of the term in the first argument of 
  <span class="v">collect$</span> is a <span class="v">LAMBDA</span> object.</p> 
 
  <p>Beware, however, that consing up <span class="v">LAMBDA</span> objects defeats the <a href="ACL2____ILK.html">ilk</a> analysis in <span class="tt"><a href="ACL2____DEFWARRANT.html">defwarrant</a></span> and the <a href="ACL2____TAME.html">tame</a>ness analysis of 
  <span class="v">apply$</span> and hence prevents functions containing such terms from being 
  <span class="v">apply$</span>d.</p> 
 
  <p>According to the definitional axiom defining <span class="tt"><a href="ACL2____APPLY_42.html">apply$</a></span>, any object 
  satisfying <span class="v">consp</span> is treated as a <span class="v">LAMBDA</span> object.  <span class="v">Apply$</span> uses 
  ``accessor'' functions to extract the ``formals'' and ``body'' of the object 
  and proceeds to <span class="tt"><a href="ACL2____EV_42.html">ev$</a></span> the body in an alist binding the formals.  But 
  <span class="v">ev$</span> insists that the expression object being evaluated be <a href="ACL2____TAME.html">tame</a> or 
  else assigns it a default value.  This insistence on tameness is due to 
  fundamental logical reasons; otherwise, <span class="v">apply$</span> would allow us to prove 
  <span class="v">NIL</span>.  So axiomatically <span class="v">apply$</span> operates as ``naively expected'' only 
  on <span class="v">tamep-lambdap</span> objects.  One consequence of this, which we expect will 
  be a minor inconvenience, is that unlike ACL2's lambda expressions 
  <span class="v">apply$</span>'s <span class="v">LAMBDA</span> objects, when used in definitions of new functions, 
  may not include recursive calls of the function being defined because they 
  fail the tameness test.</p> 
 
  <p>But wait!  There's more.  Execution efficiency of <span class="v">apply$</span> imposes some 
  non-logical restrictions.  These restrictions come from ACL2's execution 
  story with respect to Common Lisp, and from the Common Lisp compiler.  To 
  execute <span class="v">LAMBDA</span> objects most efficiently they must be well-formed, which 
  is a concept even stronger than tameness.  Among other requirements, 
  well-formed <span class="v">LAMBDA</span> objects obey the ACL2 and Common Lisp rules on 
  variable names (not every symbol is a legal variable), on the use of free 
  variables, on the body being a fully translated formal term returning 1 
  value, that the declarations, if any, be meaningful to the Common Lisp 
  compiler, etc.  You can read about well-formedness in <span class="tt"><a href="ACL2____WELL-FORMED-LAMBDA-OBJECTP.html">well-formed-lambda-objectp</a></span> if you want, but we don't encourage beginners to 
  go there!</p> 
 
  <p>Note: Even well-formedness is not enough to guarantee execution of 
  compiled code.  The <span class="v">LAMBDA</span> object must also be guard verified (see 
  <span class="tt"><a href="ACL2____VERIFY-GUARDS.html">verify-guards</a></span> for a discussion) and its guard must be satisfied by 
  the arguments to which it is applied.</p> 
 
  <p>Note: A peculiar aspect of <span class="v">LAMBDA</span> objects is that they can be written 
  as legal ACL2 constants <i>before</i> they are well-formed <span class="v">LAMBDA</span> 
  objects, e.g., by referring to undefined functions, <span class="v">:program</span> mode 
  functions, unbadged functions, etc.  They are, after all, just arbitrary 
  quoted objects and any value in ACL2 can be quoted.  An ill-formed 
  <span class="v">LAMBDA</span> object can <i>become</i> well-formed if the world is 
  appropriately extended, e.g., the appropriate <span class="v">defun</span>s or 
  <span class="v">defwarrant</span>s are made.  Perhaps worse, they can be well-formed and then 
  <i>become</i> ill-formed by an undo.  So at runtime <span class="v">apply$</span> has to check 
  that the function symbol or <span class="v">LAMBDA</span> object is appropriate.  There is a 
  sophisticated cache behind the execution machinery for <span class="v">LAMBDA</span> objects in 
  the evaluation theory.</p> 
 
  <h3>About Lambda$ Expressions</h3> 
 
  <p>Rather than force users to type well-formed <span class="v">LAMBDA</span> objects as quoted 
  constants, ACL2 provides a macro allowing you to enter <span class="v">LAMBDA</span> objects by 
  typing something that looks like a lambda expression but which is properly 
  translated and generates well-formed results (or causes a translation 
  error).</p> 
 
  <p>That macro -- which is not really a defined macro but is built into ACL2's 
  translation mechanism -- is called <span class="tt"><a href="ACL2____LAMBDA_42.html">lambda$</a></span> and uses of it in terms 
  are called ``<span class="v">lambda$</span> expressions.''  <span class="v">Lambda$</span> expressions may only be 
  used in argument slots of <a href="ACL2____ILK.html">ilk</a> <span class="v">:FN</span>.</p> 
 
  <p>An example of a <span class="v">lambda$</span> expression is the first argument of 
  <span class="v">collect$</span> in</p> 
 
  <pre class="code">(<a href="ACL2____COLLECT_42.html">collect$</a> (<a href="ACL2____LAMBDA_42.html">lambda$</a> (x) (<a href="COMMON-LISP_____B2.html">+</a> 1 x)) lst)</pre> 
 
  <p>That <span class="v">lambda$</span> expression essentially translates to the quoted 
  well-formed <span class="v">LAMBDA</span> object</p> 
 
  <pre class="code">'(<a href="COMMON-LISP____LAMBDA.html">LAMBDA</a> (X) (<a href="ACL2____BINARY-_B2.html">BINARY-+</a> '1 X))</pre> 
 
  <p>Note that the body is fully translated, unlike its appearance in the 
  <span class="v">lambda$</span> expression.  We say ``essentially'' because <span class="v">lambda$</span> always 
  add a <span class="v">(<a href="COMMON-LISP____DECLARE.html">DECLARE</a> (<a href="COMMON-LISP____IGNORABLE.html">IGNORABLE</a> v1 ... vn))</span> that includes every formal.  In 
  addition, except when translating in theorems, <span class="v">lambda$</span> tags the 
  translated body with a <span class="tt"><a href="ACL2____RETURN-LAST.html">return-last</a></span> expression to indicate it came 
  from a <span class="v">lambda$</span>.  Despite these differences, the meaning of the 
  translated <span class="v">lambda$</span> is the simple quoted <span class="v">LAMBDA</span> object shown.</p> 
 
  <p><span class="v">Lambda$</span> expressions never appear in a fully translated term.  All the 
  <span class="v">lambda$</span> objects will have been translated into quoted <span class="v">LAMBDA</span> 
  objects.</p> 
 
  <p>Finally, to see how a <span class="v">lambda$</span> expression translates, see <span class="tt"><a href="ACL2____TRANSLAM.html">translam</a></span>.</p>
</body>
</html>
