<html>
<head>
<meta charset="UTF-8">
<title>Alternative-introduction</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____ALTERNATIVE-INTRODUCTION">Click for Alternative-introduction in the Full Manual</a></h3>

<p>Introduction to ACL2</p><p>This section contains introductory material on ACL2 including what 
 ACL2 is, how to get started using the system, how to read the output, and 
 other introductory topics.  It was written almost entirely by Bill Young of 
 Computational Logic, Inc.</p> 
 
 <p>You might also find CLI Technical Report 101 helpful, especially if you are 
 familiar with Nqthm.  If you would like more familiarity with Nqthm, we 
 suggest CLI Technical Report 100.</p> 
 
 <p><i>OVERVIEW</i></p> 
 
 <p>ACL2 is an automated reasoning system developed (for the first 9 years) at 
 Computational Logic, Inc. and (from January, 1997) at the University of Texas 
 at Austin.  It is the successor to the Nqthm (or Boyer-Moore) logic and proof 
 system and its Pc-Nqthm interactive enhancement.  The acronym ACL2 actually 
 stands for ``A Computational Logic for Applicative Common Lisp''.  This title 
 suggests several distinct but related aspects of ACL2.</p> 
 
 <p>We assume that readers of the ACL2 <a href="COMMON-LISP____DOCUMENTATION.html">documentation</a> have at least a 
 very slight familiarity with some Lisp-like language.  We will address the 
 issue of prerequisites further, in ``ABOUT THIS TUTORIAL'' below.</p> 
 
 <p>As a <b>logic</b>, ACL2 is a formal system with rigorously defined syntax 
 and semantics.  In mathematical parlance, the ACL2 logic is a first-order 
 logic of total recursive functions providing mathematical induction on the 
 ordinals up to epsilon-0 and two extension principles: one for recursive 
 definition and one for constrained introduction of new function symbols, here 
 called encapsulation.  The syntax of ACL2 is that of Common Lisp; ACL2 
 specifications are ``also'' Common Lisp programs in a way that we will make 
 clear later.  In less formal language, the ACL2 logic is an integrated 
 collection of rules for defining (or axiomatizing) recursive functions, 
 stating properties of those functions, and rigorously establishing those 
 properties.  Each of these activities is mechanically supported.</p> 
 
 <p>As a <b>specification language</b>, ACL2 supports modeling of systems of 
 various kinds.  An ACL2 function can equally be used to express purely formal 
 relationships among mathematical entities, to describe algorithms, or to 
 capture the intended behavior of digital systems.  For digital systems, an 
 ACL2 specification is a mathematical <b>model</b> that is intended to 
 formalize relevant aspects of system behavior.  Just as physics allows us to 
 model the behavior of continuous physical systems, ACL2 allows us to model 
 digital systems, including many with physical realizations such as computer 
 hardware.  As early as the 1930's Church, Kleene, Turing and others 
 established that recursive functions provide an expressive formalism for 
 modeling digital computation.  Digital computation should be understood in a 
 broad sense, covering a wide variety of activities including almost any 
 systematic or algorithmic activity, or activity that can be reasonably 
 approximated in that way.  This ranges from the behavior of a digital circuit 
 to the behavior of a programming language compiler to the behavior of a 
 controller for a physical system (as long as the system can be adequately 
 modeled discretely).  All of these have been modeled using ACL2 or its 
 predecessor Nqthm.</p> 
 
 <p>ACL2 is a <b>computational</b> logic in at least three distinct senses. 
 First, the theory of recursive functions is often considered the mathematics 
 of computation.  Church conjectured that any ``effective computation'' can be 
 modeled as a recursive function.  Thus, ACL2 provides an expressive language 
 for modeling digital systems.  Second, many ACL2 specifications are 
 executable.  In fact, recursive functions written in ACL2 <b>are</b> Common 
 Lisp functions that can be submitted to any compliant Common Lisp compiler and 
 executed (in an environment where suitable ACL2-specific macros and functions 
 are defined).  Third, ACL2 is computational in the sense that calculation is 
 heavily integrated into the reasoning process.  Thus, an expression with 
 explicit constant values but no free variables can be simplified by 
 calculation rather than by complex logical manipulations.</p> 
 
 <p>ACL2 is a powerful, automated <b>theorem prover</b> or proof checker.  This 
 means that a competent user can utilize the ACL2 system to discover proofs of 
 theorems stated in the ACL2 logic or to check previously discovered proofs. 
 The basic deductive steps in an ACL2-checked proof are often quite large, due 
 to the sophisticated combination of decision procedures, conditional 
 rewriting, mathematical and structural induction, propositional 
 simplification, and complex heuristics to orchestrate the interactions of 
 these capabilities.  Unlike some automated proof systems, ACL2 does not 
 produce a formal proof.  However, we believe that if ACL2 certifies the 
 ``theoremhood'' of a given conjecture, then such a formal proof exists and, 
 therefore, the theorem is valid.  The ultimate result of an ACL2 proof session 
 is a collection of ``<a href="ACL2____EVENTS.html">events</a>,'' possibly grouped into ``<a href="ACL2____BOOKS.html">books</a>,'' 
 that can be replayed in ACL2.  Therefore, a proof can be independently 
 validated by any ACL2 user.</p> 
 
 <p>ACL2 may be used in purely automated mode in the shallow sense that 
 conjectures are submitted to the prover and the user does not interact with 
 the proof attempt (except possibly to stop it) until the proof succeeds or 
 fails.  However, any non-trivial proof attempt is actually interactive, since 
 successful proof ``<a href="ACL2____EVENTS.html">events</a>'' influence the subsequent behavior of the 
 prover.  For example, proving a lemma may introduce a rule that subsequently 
 is used automatically by the prover.  Thus, any realistic proof attempt, even 
 in ``automatic'' mode, is really an interactive dialogue with the prover to 
 craft a sequence of <a href="ACL2____EVENTS.html">events</a> building an appropriate theory and proof 
 rules leading up to the proof of the desired result.  Also, ACL2 supports 
 annotating a theorem with ``<a href="ACL2____HINTS.html">hints</a>'' designed to guide the proof 
 attempt.  By supplying appropriate <a href="ACL2____HINTS.html">hints</a>, the user can suggest proof 
 strategies that the prover would not discover automatically.  There is a 
 ``<a href="ACL2____PROOF-TREE.html">proof-tree</a>'' facility (see <a href="ACL2____PROOF-TREE.html">proof-tree</a>) that allows the user to 
 <a href="ACL2____MONITOR.html">monitor</a> the progress and structure of a proof attempt in real-time. 
 Exploring failed proof attempts is actually where heavy-duty ACL2 users spend 
 most of their time.</p> 
 
 <p>ACL2 can also be used in a more explicitly interactive mode.  The 
 interactive <a href="ACL2____PROOF-BUILDER.html">proof-builder</a> subsystem of ACL2 allows exploration of a 
 proof on a fairly low level including expanding calls of selected function 
 symbols, invoking specific <a href="ACL2____REWRITE.html">rewrite</a> rules, and selectively navigating 
 around the proof.  This facility can be used to gain sufficient insight into 
 the proof to construct an automatic version, or to generate a detailed 
 interactive-style proof that can be replayed in batch mode.</p> 
 
 <p>Because ACL2 is all of these things — computational logic, 
 specification language, <a href="ACL2____PROGRAMMING.html">programming</a> system, and theorem prover — 
 it is more than the sum of its parts.  The careful integration of these 
 diverse aspects has produced a versatile automated reasoning system suitable 
 for building highly reliable digital systems.  In the remainder of this 
 tutorial, we will illustrate some simple uses of this automated reasoning 
 system.</p> 
 
 <p><i>ABOUT THIS TUTORIAL</i></p> 
 
 <p>ACL2 is a complex system with a vast array of features, bells and whistles. 
 However, it is possible to perform productive work with the system using only 
 a small portion of the available functionality.  The goals of this tutorial 
 are to:</p> 
 
 <blockquote> 
 
 <p>familiarize the new user with the most basic features of and modes of 
 interaction with ACL2;</p> 
 
 <p>familiarize her with the form of output of the system; and</p> 
 
 <p>work through a graduated series of examples.</p>
</blockquote> 
 
 <p>The more knowledge the user brings to this system, the easier it will be to 
 become proficient.  On one extreme: the <b>ideal</b> user of ACL2 is an expert 
 Common Lisp programmer, has deep understanding of automated reasoning, and is 
 intimately familiar with the earlier Nqthm system.  Such ideal users are 
 unlikely to need this tutorial.  However, without some background knowledge, 
 the beginning user is likely to become extremely confused and frustrated by 
 this system.  We suggest that a new user of ACL2 should:</p> 
 
 <blockquote> 
 
 <p>(a) have a little familiarity with Lisp, including basic Lisp programming 
 and prefix notation (a Lisp reference manual such as Guy Steele's ``Common 
 Lisp: The Language'' is also helpful);</p> 
 
 <p>(b) be convinced of the utility of formal modeling; and</p> 
 
 <p>(c) be willing to gain familiarity with basic automated theorem proving 
 topics such as rewriting and algebraic simplification.</p>
</blockquote> 
 
 <p>We will not assume any deep familiarity with Nqthm (the so-called 
 ``Boyer-Moore Theorem Prover''), though the book ``A Computational Logic 
 Handbook'' by Boyer and Moore (Academic Press, 1988) is an extremely useful 
 reference for many of the topics required to become a competent ACL2 user. 
 We'll refer to it as ACLH below.</p> 
 
 <p>As we said in the introduction, ACL2 has various facets.  For example, it 
 can be used as a Common Lisp <a href="ACL2____PROGRAMMING.html">programming</a> system to construct 
 application programs.  In fact, the ACL2 system itself is a large Common Lisp 
 program constructed almost entirely within ACL2.  Another use of ACL2 is as a 
 specification and modeling tool.  That is the aspect we will concentrate on in 
 the remainder of this tutorial.</p> 
 
 <p><i>GETTING STARTED</i></p> 
 
 <p>This section is an abridged version of what's available elsewhere; feel 
 free to see <a href="ACL2____STARTUP.html">startup</a> for more details.</p> 
 
 <p>How you start ACL2 will be system dependent, but you'll probably type 
 something like ``acl2'' at your operating system prompt.  Consult your system 
 administrator for details.</p> 
 
 <p>When you start up ACL2, you'll probably find yourself inside the ACL2 <a href="ACL2____COMMAND.html">command</a> loop, as indicated by the following <a href="ACL2____PROMPT.html">prompt</a>.</p> 
 
 <pre class="code">ACL2 !&gt;</pre> 
 
 <p>If not, you should type <span class="v">(<a href="ACL2____LP.html">LP</a>)</span>.  See <a href="ACL2____LP.html">lp</a>, which has a lot more 
 information about the ACL2 <a href="ACL2____COMMAND.html">command</a> loop.</p> 
 
 <p>There are two ``modes'' for using ACL2, <span class="v">:</span><span class="tt"><a href="ACL2____LOGIC.html">logic</a></span> and 
 <span class="v">:</span><span class="tt"><a href="ACL2____PROGRAM.html">program</a></span>.  When you begin ACL2, you will ordinarily be in the 
 <span class="v">:</span><span class="tt"><a href="ACL2____LOGIC.html">logic</a></span> mode.  This means that any new function defined is not 
 only executable but also is axiomatically defined in the ACL2 logic.  (See 
 <a href="ACL2____DEFUN-MODE.html">defun-mode</a> and see <a href="ACL2____DEFAULT-DEFUN-MODE.html">default-defun-mode</a>.)  Roughly speaking, 
 <span class="v">:</span><span class="tt"><a href="ACL2____PROGRAM.html">program</a></span> mode is available for using ACL2 as a <a href="ACL2____PROGRAMMING.html">programming</a> 
 language without some of the logical burdens necessary for formal reasoning. 
 In this tutorial we will assume that we always remain in <span class="v">:</span><span class="tt"><a href="ACL2____LOGIC.html">logic</a></span> 
 mode and that our purpose is to write formal models of digital systems and to 
 reason about them.</p> 
 
 <p>Now, within the ACL2 <a href="ACL2____COMMAND.html">command</a> loop you can carry out various kinds of 
 activities, including the following.  (We'll see examples later of many of 
 these.)</p> 
 
 <blockquote> 
 
 <p>define new functions (see <a href="COMMON-LISP____DEFUN.html">defun</a>);</p> 
 
 <p>execute functions on concrete data;</p> 
 
 <p>pose and attempt to prove conjectures about previously defined functions 
 (see <a href="ACL2____DEFTHM.html">defthm</a>);</p> 
 
 <p>query the ACL2 ``<a href="ACL2____WORLD.html">world</a>'' or database (e.g., see <a href="ACL2____PE.html">pe</a>); and</p> 
 
 <p>numerous other things.</p>
</blockquote> 
 
 <p>In addition, there is extensive on-line <a href="COMMON-LISP____DOCUMENTATION.html">documentation</a>, of which this 
 tutorial introduction is a part.</p> 
 
 <p><i>INTERACTING WITH ACL2</i></p> 
 
 <p>The standard means of interacting with ACL2 is to submit a sequence of 
 forms for processing by the ACL2 system.  These forms are checked for 
 syntactic and semantic acceptability and appropriately processed by the 
 system.  These forms can be typed directly at the ACL2 <a href="ACL2____PROMPT.html">prompt</a>. 
 However, most successful ACL2 users prefer to do their work using the Emacs 
 text editor, maintaining an Emacs ``working'' buffer in which forms are 
 edited.  Those forms are then copied to the ACL2 interaction buffer, which is 
 often the <span class="v">"*shell*"</span> buffer.</p> 
 
 <p>In some cases, processing succeeds and makes some change to the ACL2 
 ``logical <a href="ACL2____WORLD.html">world</a>,'' which affects the processing of subsequent forms. 
 How can this processing fail?  For example, a proposed theorem will be 
 rejected unless all function symbols mentioned have been previously defined. 
 Also the ability of ACL2 to discover the proof of a theorem may depend on the 
 user previously having proved other theorems.  Thus, the order in which forms 
 are submitted to ACL2 is quite important.  Maintaining forms in an appropriate 
 order in your working buffer will be helpful for re-playing the proof 
 later.</p> 
 
 <p>One of the most common <a href="ACL2____EVENTS.html">events</a> in constructing a model is introducing 
 new functions.  New functions are usually introduced using the <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> 
 form; we'll encounter some exceptions later.  Proposed function definitions 
 are checked to make sure that they are syntactically and semantically 
 acceptable (e.g., that all mentioned functions have been previously defined) 
 and, for recursive functions, that their recursive calls <b>terminate</b>.  A 
 recursive function definition is guaranteed to terminate if there is some some 
 ``measure'' of the arguments and a ``well-founded'' ordering such that the 
 arguments to the function get smaller in each recursive call.  See <a href="ACL2____WELL-FOUNDED-RELATION-RULE.html">well-founded-relation-rule</a>.</p> 
 
 <p>For example, suppose that we need a function that will append two lists 
 together.  (We already have one in the ACL2 <span class="tt"><a href="COMMON-LISP____APPEND.html">append</a></span> function; but 
 suppose perversely that we decide to define our own.)  Suppose we submit the 
 following definition (you should do so as well and study the system 
 output):</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> my-app (x y)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)
      y
    (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> x) (my-app x y))))</pre> 
 
 <p>The system responds with the following message:</p> 
 
 <pre class="code">ACL2 Error in ( DEFUN MY-APP ...):  No :MEASURE was supplied with
the definition of MY-APP.  Our heuristics for guessing one have not
made any suggestions.  No argument of the function is tested along
every branch and occurs as a proper subterm at the same argument
position in every recursive call.  You must specify a :MEASURE.  See
:DOC defun.</pre> 
 
 <p>This means that the system could not find an expression involving the 
 formal parameters <span class="v">x</span> and <span class="v">y</span> that decreases under some well-founded 
 order in every recursive call (there is only one such call).  It should be 
 clear that there is no such measure in this case because the only recursive 
 call doesn't change the arguments at all.  The definition is obviously flawed; 
 if it were accepted and executed it would loop forever.  Notice that a 
 definition that is rejected is not stored in the system database; there is no 
 need to take any action to have it ``thrown away.''  Let's try again with the 
 correct definition.  The interaction now looks like (we're also putting in the 
 ACL2 <a href="ACL2____PROMPT.html">prompt</a>; you don't type that):</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="COMMON-LISP____DEFUN.html">defun</a> my-app (x y)
         (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)
             y
           (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> x) (my-app (<a href="COMMON-LISP____CDR.html">cdr</a> x) y))))

The admission of MY-APP is trivial, using the relation O&lt;
(which is known to be well-founded on the domain recognized by
O-P) and the measure (<a href="ACL2____ACL2-COUNT.html">ACL2-COUNT</a> X).  We observe that the
type of MY-APP is described by the theorem
(<a href="COMMON-LISP____OR.html">OR</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> (MY-APP X Y)) (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (MY-APP X Y) Y)).
We used primitive type reasoning.

Summary
Form:  ( DEFUN MY-APP ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
Warnings:  None
Time:  0.07 seconds (prove: 0.00, print: 0.00, other: 0.07)
MY-APP</pre> 
 
 <p>Notice that this time the function definition was accepted.  We didn't have 
 to supply a measure explicitly; the system inferred one from the form of the 
 definition.  On complex functions it may be necessary to supply a measure 
 explicitly.  (See <a href="ACL2____XARGS.html">xargs</a>.)</p> 
 
 <p>The system output provides several pieces of information.</p> 
 
 <blockquote> 
 
 <p>The revised definition is acceptable.  The system realized that there is a 
 particular measure (namely, <span class="v">(<a href="ACL2____ACL2-COUNT.html">acl2-count</a> x)</span>) and a well-founded relation 
 (<span class="v">o&lt;</span>) under which the arguments of <span class="v">my-app</span> get smaller in recursion. 
 Actually, the theorem prover proved several theorems to admit <span class="v">my-app</span>. 
 The main one was that when <span class="v">(<a href="COMMON-LISP____ATOM.html">atom</a> x)</span> is false the <span class="v">acl2-count</span> of 
 <span class="v">(<a href="COMMON-LISP____CDR.html">cdr</a> x)</span> is less than (in the <span class="v">o&lt;</span> sense) the <span class="v">acl2-count</span> of 
 <span class="v">x</span>.  <span class="tt"><a href="ACL2____ACL2-COUNT.html">Acl2-count</a></span> is the most commonly used measure of the ``size`` 
 of an ACL2 object.  <span class="tt"><a href="ACL2____O_C3.html">o&lt;</a></span> is the ordering relation on ordinals less than 
 epsilon-0.  On the natural numbers it is just ordinary ``&lt;''.</p> 
 
 <p>The observation printed about ``the type of MY-APP'' means that calls of 
 the function <span class="v">my-app</span> will always return a value that is either a <a href="COMMON-LISP____CONS.html">cons</a> pair or is equal to the second parameter.</p> 
 
 <p>The <a href="ACL2____SUMMARY.html">summary</a> provides information about which previously introduced 
 definitions and lemmas were used in this proof, about some notable things to 
 watch out for (the Warnings), and about how long this event took to 
 process.</p>
</blockquote> 
 
 <p>Usually, it's not important to read this information.  However, it is a 
 good habit to scan it briefly to see if the type information is surprising to 
 you or if there are Warnings.  We'll see an example of them later.</p> 
 
 <p>After a function is accepted, it is stored in the database and available 
 for use in other function definitions or lemmas.  To see the definition of any 
 function use the <span class="v">:</span><span class="tt"><a href="ACL2____PE.html">pe</a></span> command (see <a href="ACL2____PE.html">pe</a>).  For example,</p> 
 
 <pre class="code">ACL2 !&gt;:pe my-app
 L       73:x(<a href="COMMON-LISP____DEFUN.html">DEFUN</a> MY-APP (X Y)
                    (<a href="COMMON-LISP____IF.html">IF</a> (<a href="COMMON-LISP____ATOM.html">ATOM</a> X)
                        Y (<a href="COMMON-LISP____CONS.html">CONS</a> (<a href="COMMON-LISP____CAR.html">CAR</a> X) (MY-APP (<a href="COMMON-LISP____CDR.html">CDR</a> X) Y))))</pre> 
 
 <p>This displays the definition along with some other relevant information. 
 In this case, we know that this definition was processed in <span class="v">:</span><span class="tt"><a href="ACL2____LOGIC.html">logic</a></span> mode (the ``<span class="v">L</span>'') and was the 73rd <a href="ACL2____COMMAND.html">command</a> processed in the 
 current session.</p> 
 
 <p>We can also try out our newly defined function on some sample data.  To do 
 that, just submit a form to be evaluated to ACL2.  For example,</p> 
 
 <pre class="code">ACL2 !&gt;(my-app '(0 1 2) '(3 4 5))
(0 1 2 3 4 5)
ACL2 !&gt;(my-app nil nil)
NIL
ACL2 !&gt;</pre> 
 
 <p>Now suppose we want to prove something about the function just introduced. 
 We conjecture, for example, that the length of the <a href="COMMON-LISP____APPEND.html">append</a> of two lists 
 is the sum of their lengths.  We can formulate this conjecture in the form of 
 the following ACL2 <span class="tt"><a href="ACL2____DEFTHM.html">defthm</a></span> form.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> my-app-length
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> (my-app x y))
         (<a href="COMMON-LISP_____B2.html">+</a> (<a href="ACL2____LEN.html">len</a> x) (<a href="ACL2____LEN.html">len</a> y))))</pre> 
 
 <p>First of all, how did we know about the functions <span class="v">len</span> and <span class="tt"><a href="COMMON-LISP_____B2.html">+</a></span>, 
 etc.?  The answer to that is somewhat unsatisfying — we know them from 
 our past experience in using Common Lisp and ACL2.  It's hard to know that a 
 function such as <span class="v">len</span> exists without first knowing some Common Lisp.  If 
 we'd guessed that the appropriate function was called <span class="tt"><a href="COMMON-LISP____LENGTH.html">length</a></span> (say, 
 from our knowledge of Lisp) and tried <span class="v">:pe length</span>, we would have seen that 
 <span class="tt"><a href="COMMON-LISP____LENGTH.html">length</a></span> is defined in terms of <span class="v">len</span>, and we could have explored 
 from there.  Luckily, you can write a lot of ACL2 functions without knowing 
 too many of the primitive functions.</p> 
 
 <p>Secondly, why don't we need some ``type'' hypotheses?  Does it make sense 
 to append things that are not lists?  Well, yes.  ACL2 and Lisp are both quite 
 weakly typed.  For example, inspection of the definition of <span class="v">my-app</span> shows 
 that if <span class="v">x</span> is not a <a href="COMMON-LISP____CONS.html">cons</a> pair, then <span class="v">(my-app x y)</span> always 
 returns <span class="v">y</span>, no matter what <span class="v">y</span> is.</p> 
 
 <p>Thirdly, would it matter if we rewrote the lemma with the equality 
 reversed, as follows?</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> my-app-length2
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP_____B2.html">+</a> (<a href="ACL2____LEN.html">len</a> x) (<a href="ACL2____LEN.html">len</a> y))
         (<a href="ACL2____LEN.html">len</a> (my-app x y)))).</pre> 
 
 <p>The two are <b>logically</b> equivalent, but...yes, it would make a big 
 difference.  Recall our remark that a lemma is not only a ``fact'' to be 
 proved; it also is used by the system to prove other later lemmas.  The 
 current lemma would be stored as a <a href="ACL2____REWRITE.html">rewrite</a> rule.  (See <a href="ACL2____RULE-CLASSES.html">rule-classes</a>.)  For a <a href="ACL2____REWRITE.html">rewrite</a> rule, a conclusion of the form <span class="v">(<a href="COMMON-LISP____EQUAL.html">EQUAL</a>
 LHS RHS)</span> means to replace instances of the <span class="v">LHS</span> by the appropriate 
 instance of the <span class="v">RHS</span>.  Presumably, it's better to <a href="ACL2____REWRITE.html">rewrite</a> <span class="v">(<a href="ACL2____LEN.html">len</a>
 (my-app x y))</span> to <span class="v">(<a href="COMMON-LISP_____B2.html">+</a> (<a href="ACL2____LEN.html">len</a> x) (<a href="ACL2____LEN.html">len</a> y))</span> than the other way around.  The 
 reason is that the system ``knows'' more about <span class="tt"><a href="COMMON-LISP_____B2.html">+</a></span> than it does about 
 the new function symbol <span class="v">my-app</span>.</p> 
 
 <p>So let's see if we can prove this lemma.  Submitting our preferred <span class="tt"><a href="ACL2____DEFTHM.html">defthm</a></span> to ACL2 (do it!), we get the following interaction:</p> 
 
 <pre class="code">          --------------------------------------------------
ACL2 !&gt;(<a href="ACL2____DEFTHM.html">defthm</a> my-app-length
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> (my-app x y))
         (<a href="COMMON-LISP_____B2.html">+</a> (<a href="ACL2____LEN.html">len</a> x) (<a href="ACL2____LEN.html">len</a> y))))

Name the formula above *1.

Perhaps we can prove *1 by induction.  Three induction schemes are
suggested by this conjecture.  These merge into two derived
induction schemes.  However, one of these is flawed and so we are
left with one viable candidate.

We will induct according to a scheme suggested by (<a href="ACL2____LEN.html">LEN</a> X), but
modified to accommodate (MY-APP X Y).  If we let (:P X Y) denote *1
above then the induction scheme we'll use is
(<a href="COMMON-LISP____AND.html">AND</a> (<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____NOT.html">NOT</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> X)) (:P X Y))
     (<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____AND.html">AND</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> X) (:P (<a href="COMMON-LISP____CDR.html">CDR</a> X) Y))
              (:P X Y))).
This induction is justified by the same argument used to admit LEN,
namely, the measure (<a href="ACL2____ACL2-COUNT.html">ACL2-COUNT</a> X) is decreasing according to the
relation O&lt; (which is known to be well-founded on the domain
recognized by O-P).  When applied to the goal at hand the
above induction scheme produces the following two nontautological
subgoals.

Subgoal *1/2
(<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____NOT.html">NOT</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> X))
         (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="ACL2____LEN.html">LEN</a> (MY-APP X Y))
                (<a href="COMMON-LISP_____B2.html">+</a> (<a href="ACL2____LEN.html">LEN</a> X) (<a href="ACL2____LEN.html">LEN</a> Y)))).

But simplification reduces this to T, using the :definitions of FIX,
LEN and MY-APP, the :type-prescription rule LEN, the :rewrite rule
UNICITY-OF-0 and primitive type reasoning.

Subgoal *1/1
(<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____AND.html">AND</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> X)
              (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="ACL2____LEN.html">LEN</a> (MY-APP (<a href="COMMON-LISP____CDR.html">CDR</a> X) Y))
                     (<a href="COMMON-LISP_____B2.html">+</a> (<a href="ACL2____LEN.html">LEN</a> (<a href="COMMON-LISP____CDR.html">CDR</a> X)) (<a href="ACL2____LEN.html">LEN</a> Y))))
         (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="ACL2____LEN.html">LEN</a> (MY-APP X Y))
                (<a href="COMMON-LISP_____B2.html">+</a> (<a href="ACL2____LEN.html">LEN</a> X) (<a href="ACL2____LEN.html">LEN</a> Y)))).

This simplifies, using the :definitions of LEN and MY-APP, primitive
type reasoning and the :rewrite rules COMMUTATIVITY-OF-+ and
CDR-CONS, to

Subgoal *1/1'
(<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____AND.html">AND</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> X)
              (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="ACL2____LEN.html">LEN</a> (MY-APP (<a href="COMMON-LISP____CDR.html">CDR</a> X) Y))
                     (<a href="COMMON-LISP_____B2.html">+</a> (<a href="ACL2____LEN.html">LEN</a> Y) (<a href="ACL2____LEN.html">LEN</a> (<a href="COMMON-LISP____CDR.html">CDR</a> X)))))
         (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="COMMON-LISP_____B2.html">+</a> 1 (<a href="ACL2____LEN.html">LEN</a> (MY-APP (<a href="COMMON-LISP____CDR.html">CDR</a> X) Y)))
                (<a href="COMMON-LISP_____B2.html">+</a> (<a href="ACL2____LEN.html">LEN</a> Y) 1 (<a href="ACL2____LEN.html">LEN</a> (<a href="COMMON-LISP____CDR.html">CDR</a> X))))).

But simplification reduces this to T, using linear arithmetic,
primitive type reasoning and the :type-prescription rule LEN.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM MY-APP-LENGTH ...)
Rules: ((:REWRITE UNICITY-OF-0)
        (:DEFINITION FIX)
        (:REWRITE COMMUTATIVITY-OF-+)
        (:DEFINITION LEN)
        (:REWRITE CDR-CONS)
        (:DEFINITION MY-APP)
        (:TYPE-PRESCRIPTION LEN)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:FAKE-RUNE-FOR-LINEAR NIL))
Warnings:  None
Time:  0.30 seconds (prove: 0.13, print: 0.05, other: 0.12)
 MY-APP-LENGTH
          --------------------------------------------------</pre> 
 
 <p>Wow, it worked!  In brief, the system first tried to <a href="ACL2____REWRITE.html">rewrite</a> and 
 simplify as much as possible.  Nothing changed; we know that because it said 
 ``Name the formula above *1.''  Whenever the system decides to name a formula 
 in this way, we know that it has run out of techniques to use other than proof 
 by induction.</p> 
 
 <p>The induction performed by ACL2 is structural or ``Noetherian'' induction. 
 You don't need to know much about that except that it is induction based on 
 the structure of some object.  The heuristics infer the structure of the 
 object from the way the object is recursively decomposed by the functions used 
 in the conjecture.  The heuristics of ACL2 are reasonably good at selecting an 
 induction scheme in simple cases.  It is possible to override the heuristic 
 choice by providing an <span class="v">:induction</span> hint (see <a href="ACL2____HINTS.html">hints</a>).  In the case 
 of the theorem above, the system inducts on the structure of <span class="v">x</span> as 
 suggested by the decomposition of <span class="v">x</span> in both <span class="v">(my-app x y)</span> and <span class="v">(<a href="ACL2____LEN.html">len</a>
 x)</span>.  In the base case, we assume that <span class="v">x</span> is not a <span class="tt"><a href="COMMON-LISP____CONSP.html">consp</a></span>.  In the 
 inductive case, we assume that it is a <span class="tt"><a href="COMMON-LISP____CONSP.html">consp</a></span> and assume that the 
 conjecture holds for <span class="v">(<a href="COMMON-LISP____CDR.html">cdr</a> x)</span>.</p> 
 
 <p>There is a close connection between the analysis that goes on when a 
 function like <span class="v">my-app</span> is accepted and when we try to prove something 
 inductively about it.  That connection is spelled out well in Boyer and 
 Moore's book ``A Computational Logic,'' if you'd like to look it up.  But it's 
 pretty intuitive.  We accepted <span class="v">my-app</span> because the ``size'' of the first 
 argument <span class="v">x</span> decreases in the recursive call.  That tells us that when we 
 need to prove something inductively about <span class="v">my-app</span>, it's a good idea to try 
 an induction on the size of the first argument.  Of course, when you have a 
 theorem involving several functions, it may be necessary to concoct a more 
 complicated <a href="ACL2____INDUCTION.html">induction</a> schema, taking several of them into account. 
 That's what's meant by ``merging'' the induction schemas.</p> 
 
 <p>The proof involves two cases: the base case, and the inductive case. 
 You'll notice that the subgoal numbers go <b>down</b> rather than up, so you 
 always know how many subgoals are left to process.  The base case (<span class="v">Subgoal
 *1/2</span>) is handled by opening up the function definitions, simplifying, doing 
 a little rewriting, and performing some reasoning based on the types of the 
 arguments.  You'll often encounter references to system defined lemmas (like 
 <span class="v">unicity-of-0</span>).  You can always look at those with <span class="v">:</span><span class="tt"><a href="ACL2____PE.html">pe</a></span>; but, 
 in general, assume that there's a lot of simplification power under the hood 
 that's not too important to understand fully.</p> 
 
 <p>The inductive case (<span class="v">Subgoal *1/1</span>) is also dispatched pretty easily. 
 Here we assume the conjecture true for the <span class="tt"><a href="COMMON-LISP____CDR.html">cdr</a></span> of the list and try to 
 prove it for the entire list.  Notice that the prover does some simplification 
 and then prints out an updated version of the goal (<span class="v">Subgoal *1/1'</span>). 
 Examining these gives you a pretty good idea of what's going on in the 
 proof.</p> 
 
 <p>Sometimes one goal is split into a number of subgoals, as happened with the 
 induction above.  Sometimes after some initial processing the prover decides 
 it needs to prove a subgoal by induction; this subgoal is given a name and 
 pushed onto a stack of goals.  Some steps, like generalization (see ACLH), are 
 not necessarily validity preserving; that is, the system may adopt a false 
 subgoal while trying to prove a true one.  (Note that this is ok in the sense 
 that it is not ``unsound.''  The system will fail in its attempt to establish 
 the false subgoal and the main proof attempt will fail.)  As you gain facility 
 with using the prover, you'll get pretty good at recognizing what to look for 
 when reading a proof script.  The prover's <a href="ACL2____PROOF-TREE.html">proof-tree</a> utility helps 
 with monitoring an ongoing proof and jumping to designated locations in the 
 proof (see <a href="ACL2____PROOF-TREE.html">proof-tree</a>).  See <a href="ACL2____TIPS.html">tips</a> for a number of useful 
 pointers on using the theorem prover effectively.</p> 
 
 <p>When the prover has successfully proved all subgoals, the proof is 
 finished.  As with a <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span>, a <a href="ACL2____SUMMARY.html">summary</a> of the proof is printed. 
 This was an extremely simple proof, needing no additional guidance.  More 
 realistic examples typically require the user to look carefully at the failed 
 proof log to find ways to influence the prover to do better on its next 
 attempt.  This means either: proving some rules that will then be available to 
 the prover, changing the global state in ways that will affect the proof, or 
 providing some <a href="ACL2____HINTS.html">hints</a> locally that will influence the prover's behavior. 
 Proving this lemma (<span class="v">my-app-length</span>) is an example of the first.  Since 
 this is a <a href="ACL2____REWRITE.html">rewrite</a> rule, whenever in a later proof an instance of the 
 form <span class="v">(<a href="ACL2____LEN.html">LEN</a> (MY-APP X Y))</span> is encountered, it will be rewritten to the 
 corresponding instance of <span class="v">(<a href="COMMON-LISP_____B2.html">+</a> (<a href="ACL2____LEN.html">LEN</a> X) (<a href="ACL2____LEN.html">LEN</a> Y))</span>.  Disabling the rule by 
 executing the <a href="ACL2____COMMAND.html">command</a></p> 
 
 <pre class="code">(<a href="ACL2____IN-THEORY.html">in-theory</a> (<a href="ACL2____DISABLE.html">disable</a> my-app-length)),</pre> 
 
 <p>is an example of a global change to the behavior of the prover since this 
 <a href="ACL2____REWRITE.html">rewrite</a> will not be performed subsequently (unless the rule is again 
 <a href="ACL2____ENABLE.html">enable</a>d).  Finally, we can add a (local) <a href="ACL2____DISABLE.html">disable</a> ``hint'' to a 
 <span class="tt"><a href="ACL2____DEFTHM.html">defthm</a></span>, meaning to <a href="ACL2____DISABLE.html">disable</a> the lemma only in the proof of one 
 or more subgoals.  For example:</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> my-app-length-commutativity
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> (my-app x y))
         (<a href="ACL2____LEN.html">len</a> (my-app y x)))
  :hints (("Goal" :in-theory (<a href="ACL2____DISABLE.html">disable</a> my-app-length))))</pre> 
 
 <p>In this case, the hint supplied is a bad idea since the proof is much 
 harder with the hint than without it.  Try it both ways.</p> 
 
 <p>By the way, to undo the previous event use <span class="v">:u</span> (see <a href="ACL2____U.html">u</a>).  To undo 
 back to some earlier event use <span class="v">:ubt</span> (see <a href="ACL2____UBT.html">ubt</a>).  To view the 
 current event use <span class="v">:pe :here</span>.  To list several <a href="ACL2____EVENTS.html">events</a> use <span class="v">:pbt</span> 
 (see <a href="ACL2____PBT.html">pbt</a>).</p> 
 
 <p>Notice the form of the hint in the previous example (see <a href="ACL2____HINTS.html">hints</a>).  It 
 specifies a goal to which the hint applies.  <span class="v">"Goal"</span> refers to the 
 top-level goal of the theorem.  Subgoals are given unique names as they are 
 generated.  It may be useful to suggest that a function symbol be <a href="ACL2____DISABLE.html">disable</a>d only for Subgoal 1.3.9, say, and a different function <a href="ACL2____ENABLE.html">enable</a>d 
 only on Subgoal 5.2.8.  Overuse of such <a href="ACL2____HINTS.html">hints</a> often suggests a poor 
 global proof strategy.</p> 
 
 <p>We now recommend that you visit <a href="COMMON-LISP____DOCUMENTATION.html">documentation</a> on additional 
 examples.  See <a href="ACL2____ANNOTATED-ACL2-SCRIPTS.html">annotated-ACL2-scripts</a>.</p>
</body>
</html>
