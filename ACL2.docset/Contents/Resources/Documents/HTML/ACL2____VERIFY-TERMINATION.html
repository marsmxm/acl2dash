<html>
<head>
<meta charset="UTF-8">
<title>Verify-termination</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____VERIFY-TERMINATION">Click for Verify-termination in the Full Manual</a></h3>

<p>Convert a function from :program mode to :logic mode</p><pre class="code">Example:
(<a href="ACL2____VERIFY-TERMINATION.html">verify-termination</a> fact)

General Forms:
(<a href="ACL2____VERIFY-TERMINATION.html">verify-termination</a> fn dcl ... dcl)
(<a href="ACL2____VERIFY-TERMINATION.html">verify-termination</a> (fn1 dcl ... dcl)
                    (fn2 dcl ... dcl)
                    ...)</pre> 
 
 <p>where <span class="v">fn</span> and the <span class="v">fni</span> are function symbols having <span class="v">:</span><span class="tt"><a href="ACL2____PROGRAM.html">program</a></span> mode (see <a href="ACL2____DEFUN-MODE.html">defun-mode</a>) and all of the <span class="v">dcl</span>s are either 
 <span class="tt"><a href="COMMON-LISP____DECLARE.html">declare</a></span> forms or <a href="COMMON-LISP____DOCUMENTATION.html">documentation</a> strings.  The first form above 
 is an abbreviation for</p> 
 
 <pre class="code">(<a href="ACL2____VERIFY-TERMINATION.html">verify-termination</a> (fn dcl ... dcl))</pre> 
 
 <p>so we limit our discussion to the second form.  Each of the <span class="v">fni</span> must 
 be in the same clique of mutually recursively defined functions, but not every 
 function in the clique need be among the <span class="v">fni</span>.</p> 
 
 <p><span class="v">Verify-termination</span> attempts to establish the admissibility of the 
 <span class="v">fni</span>. <span class="v">Verify-termination</span> retrieves their definitions, creates 
 modified definitions using the <span class="v">dcl</span>s supplied above, and resubmits these 
 definitions.  You could avoid using <span class="v">verify-termination</span> by typing the new 
 definitions yourself.  So in that sense, <span class="v">verify-termination</span> adds no new 
 functionality.  But if you have prototyped your system in <span class="v">:</span><span class="tt"><a href="ACL2____PROGRAM.html">program</a></span> mode and tested it, you can use <span class="v">verify-termination</span> to resubmit 
 your definitions and change their <a href="ACL2____DEFUN-MODE.html">defun-mode</a>s to <span class="v">:</span><span class="tt"><a href="ACL2____LOGIC.html">logic</a></span>, 
 adding <a href="ACL2____HINTS.html">hints</a> without having to retype or recopy the code.</p> 
 
 <p>The <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> <a href="ACL2____COMMAND.html">command</a> executed by <span class="v">verify-termination</span> is 
 obtained by retrieving the <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> (or <span class="tt"><a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a></span>) <a href="ACL2____COMMAND.html">command</a> that introduced the clique in question and then possibly modifying 
 each definition as follows.  Consider a function, <span class="v">fn</span>, in the clique.  If 
 <span class="v">fn</span> is not among the <span class="v">fni</span> above, its definition is left unmodified 
 other than to add <span class="v">(<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :mode :logic))</span>.  Otherwise, <span class="v">fn</span> is 
 some <span class="v">fni</span> and we modify its definition by inserting into it the 
 corresponding <span class="v">dcl</span>s listed with <span class="v">fni</span> in the arguments to 
 <span class="v">verify-termination</span>, as well as <span class="v">(<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :mode :logic))</span>.  In 
 addition, we throw out from the old declarations in <span class="v">fn</span> the <span class="v">:mode</span> 
 specification and anything that is specified in the new <span class="v">dcl</span>s.</p> 
 
 <p>For example, suppose that <span class="v">fact</span> was introduced with:</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> fact (n)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> integer n)
           (<a href="ACL2____XARGS.html">xargs</a> :mode :program))
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> n) 1 (<a href="COMMON-LISP_____A2.html">*</a> n (fact (<a href="COMMON-LISP____1-.html">1-</a> n))))).</pre> 
 
 <p>Suppose later we do <span class="v">(<a href="ACL2____VERIFY-TERMINATION.html">verify-termination</a> fact)</span>.  Then the following 
 definition is submitted.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> fact (n)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> integer n))
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> n) 1 (<a href="COMMON-LISP_____A2.html">*</a> n (fact (<a href="COMMON-LISP____1-.html">1-</a> n))))).</pre> 
 
 <p>Observe that this is the same definition as the original one, except the 
 old specification of the <span class="v">:mode</span> has been deleted so that the <a href="ACL2____DEFUN-MODE.html">defun-mode</a> now defaults to <span class="v">:</span><span class="tt"><a href="ACL2____LOGIC.html">logic</a></span>.  Although the termination 
 proof succeeds, ACL2 also tries to verify the <a href="ACL2____GUARD.html">guard</a>, because we have 
 (implicitly) provided a <a href="ACL2____GUARD.html">guard</a>, namely <span class="v">(<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)</span>, for this 
 function.  (See <a href="ACL2____GUARD.html">guard</a> for a general discussion of guards, and see <a href="ACL2____TYPE-SPEC.html">type-spec</a> for a discussion of how type declarations are used in guards.) 
 Unfortunately, the <a href="ACL2____GUARD.html">guard</a> verification fails, because the subterm <span class="v">(<a href="ACL2____ZP.html">zp</a>
 n)</span> requires that <span class="v">n</span> be nonnegative, as can be seen by invoking <span class="v">:args
 zp</span>.  (For a discussion of termination issues relating to recursion on the 
 naturals, see <a href="ACL2____ZERO-TEST-IDIOMS.html">zero-test-idioms</a>.)  So we might be tempted to submit the 
 following:</p> 
 
 <pre class="code">(<a href="ACL2____VERIFY-TERMINATION.html">verify-termination</a>
 fact
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n) (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 0 n))))).</pre> 
 
 <p>However, this is considered a changing of the guard (from <span class="v">(<a href="COMMON-LISP____INTEGERP.html">integerp</a>
 n)</span>), which is illegal.  If we instead change the guard in the earlier 
 <span class="v">defun</span> after undoing that earlier definition with <span class="v">:</span><span class="tt"><a href="ACL2____UBT.html">ubt</a></span><span class="v">
 fact</span>, then <span class="v">(<a href="ACL2____VERIFY-TERMINATION.html">verify-termination</a> fact)</span> will succeed.</p> 
 
 <p><b>Remark on system functions.</b> There may be times when you want to 
 apply <span class="v">verify-termination</span> (and also, perhaps, <span class="tt"><a href="ACL2____VERIFY-GUARDS.html">verify-guards</a></span>) to 
 functions that are predefined in ACL2.  It may be necessary in such cases to 
 modify the system code first.  See <a href="ACL2____VERIFY-GUARDS-FOR-SYSTEM-FUNCTIONS.html">verify-guards-for-system-functions</a> 
 for a discussion of the process for contributing updates to the system code 
 and <a href="ACL2____BOOKS.html">books</a> with such <span class="v">verify-termination</span> or <span class="tt"><a href="ACL2____VERIFY-GUARDS.html">verify-guards</a></span> 
 <a href="ACL2____EVENTS.html">events</a>, perhaps resulting in more system functions being built-in as 
 <a href="ACL2____GUARD.html">guard</a>-verified.  To see which built-in functions have already received 
 such treatment, see community books directory <span class="v">books/system/</span>; or, evaluate 
 the constant <span class="v">*system-verify-guards-alist*</span>, which specifies a list of 
 functions whose guard-verification is proved by including that book.  See the 
 above URL for more details.</p> 
 
 <p>Note that if <span class="v">fn1</span> is already in <span class="v">:</span><span class="tt"><a href="ACL2____LOGIC.html">logic</a></span> mode, then the 
 <span class="v">verify-termination</span> call has no effect.  It is generally considered to be 
 redundant, in the sense that it returns without error; but if the <span class="v">fn1</span> is 
 a constrained function (i.e., introduced in the signature of an <span class="tt"><a href="ACL2____ENCAPSULATE.html">encapsulate</a></span>, or by <span class="tt"><a href="ACL2____DEFCHOOSE.html">defchoose</a></span>), then an error occurs.  This error is 
 intended to highlight unintended uses of <span class="v">verify-termination</span>; but if you 
 do not want to see an error in this case, you can write and use your own macro 
 in place of <span class="v">verify-termination</span>.  The following explanation of the 
 implementation of <span class="v">verify-termination</span> may help with such a task.</p> 
 
 <p>We conclude with a discussion of the use of <span class="tt"><a href="ACL2____MAKE-EVENT.html">make-event</a></span> to implement 
 <span class="v">verify-termination</span>.  This discussion can be skipped; we include it only 
 for those who want to create variants of <span class="v">verify-termination</span>, or who are 
 interested in seeing an application of <span class="tt"><a href="ACL2____MAKE-EVENT.html">make-event</a></span>.</p> 
 
 <p>Consider the following proof of <span class="v">nil</span>, which succeeded up through 
 Version_3.4 of ACL2.</p> 
 
 <pre class="code">(<a href="ACL2____ENCAPSULATE.html">encapsulate</a>
 ()
 (<a href="COMMON-LISP____DEFUN.html">defun</a> foo (x y)
   (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :mode :program))
   (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____OR.html">or</a> (<a href="ACL2____ZP.html">zp</a> x) (<a href="ACL2____ZP.html">zp</a> y))
       (<a href="COMMON-LISP____LIST.html">list</a> x y)
     (foo (<a href="COMMON-LISP____1_B2.html">1+</a> x) (<a href="COMMON-LISP____1-.html">1-</a> y))))
 (<a href="ACL2____LOCAL.html">local</a> (<a href="COMMON-LISP____DEFUN.html">defun</a> foo (x y)
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :measure (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> y)))
          (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____OR.html">or</a> (<a href="ACL2____ZP.html">zp</a> x) (<a href="ACL2____ZP.html">zp</a> y))
              (<a href="COMMON-LISP____LIST.html">list</a> x y)
            (foo (<a href="COMMON-LISP____1_B2.html">1+</a> x) (<a href="COMMON-LISP____1-.html">1-</a> y)))))
 (<a href="ACL2____VERIFY-TERMINATION.html">verify-termination</a> foo))

(<a href="ACL2____DEFTHM.html">defthm</a> bad-lemma
  (<a href="ACL2____ZP.html">zp</a> x)
  :hints (("Goal" :induct (foo x 1)))
  :rule-classes nil)</pre> 
 
 <p>How did this work?  In the first pass of the <span class="tt"><a href="ACL2____ENCAPSULATE.html">encapsulate</a></span>, the 
 second <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> of <span class="v">foo</span> promoted <span class="v">foo</span> from <span class="v">:program</span> to 
 <span class="v">:logic</span> mode, with <span class="v">y</span> as the unique measured variable.  The following 
 call to <span class="v">verify-termination</span> was then redundant.  However, on the second 
 pass of the <span class="tt"><a href="ACL2____ENCAPSULATE.html">encapsulate</a></span>, the second (<span class="tt"><a href="ACL2____LOCAL.html">local</a></span>) definition of 
 <span class="v">foo</span> was skipped, and the <span class="v">verify-termination</span> event then used the 
 first definition of <span class="v">foo</span> to guess the measure, based (as with all guesses 
 of measures) on a purely syntactic criterion.  ACL2 incorrectly chose 
 <span class="v">(<a href="ACL2____ACL2-COUNT.html">acl2-count</a> x)</span> as the measure, installing <span class="v">x</span> as the unique measured 
 variable, which in turn led to an unsound induction scheme subsequently used 
 to prove <span class="v">nil</span> (lemma <span class="v">bad-lemma</span>, above)</p> 
 
 <p>Now, <span class="v">verify-termination</span> is a macro whose calls expand to <span class="tt"><a href="ACL2____MAKE-EVENT.html">make-event</a></span> calls.  So in the first pass above, the <span class="v">verify-termination</span> 
 call generated a <span class="v">defun</span> event identical to the <span class="tt"><a href="ACL2____LOCAL.html">local</a></span> <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> 
 of <span class="v">foo</span>, which was correctly identified as redundant.  That expansion was 
 recorded, and on the second pass of the <span class="tt"><a href="ACL2____ENCAPSULATE.html">encapsulate</a></span>, the expansion was 
 recalled and used in place of the <span class="v">verify-termination</span> call (that is how 
 <span class="tt"><a href="ACL2____MAKE-EVENT.html">make-event</a></span> works).  So instead of a measure being guessed for the 
 <span class="v">verify-termination</span> call on the second pass, the same measure was used as 
 was used on the first pass, and a sound induction scheme was stored.  The 
 attempt to prove <span class="v">nil</span> (lemma <span class="v">bad-lemma</span>) then failed.</p>
</body>
</html>
