<html>
<head>
<meta charset="UTF-8">
<title>Deftagsum</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=FTY____DEFTAGSUM">Click for Deftagsum in the Full Manual</a></h3>

<p>Define a (possibly recursive) tagged union, a.k.a. ``sum of 
          products'' type.</p><p><span class="v">Deftagsum</span> produces a tagged union type consisting of several 
product types, each with a tag to distinguish them.  It is similar in spirit to 
ML or Haskell's recursive data types, although without the dependent-type 
features.</p> 
 
<p><span class="v">Deftagsum</span> is compatible with <a href="FTY____DEFTYPES.html">deftypes</a>, and can be 
mutually-recursive with other <span class="v">deftypes</span> compatible type generators.  As 
with all <a href="FTY____DEFTYPES.html">deftypes</a>-compatible type generators, the types of the fields of 
its products must each either be one produced by a compatible type generator or 
else have an associated fixing function given by <a href="FTY____DEFFIXTYPE.html">deffixtype</a>.  (Fields 
can also be untyped.)  See <a href="FTY____BASETYPES.html">basetypes</a> for some base types with fixing 
functions.</p> 
 
<h3>Example</h3> 
 
<p>Note: It may be helpful to be familiar with <a href="FTY____DEFPROD.html">defprod</a>.</p> 
 
<pre class="code">(<a href="FTY____DEFTAGSUM.html">deftagsum</a> arithtm
  (:num ((val integerp)))
  (:plus ((left arithtm-p)
          (right arithtm-p)))
  (:minus ((arg arithtm-p))))</pre> 
 
<p>This defines the following functions and macros:</p> 
 
<ul> 
<li>Recognizer <span class="v">arithtm-p</span>
</li> 
<li>Fixing function <span class="v">arithtm-fix</span>
</li> 
<li>Equivalence relation <span class="v">arithtm-equiv</span>
</li> 
<li>
<span class="v">arithtm-kind</span>, which returns either <span class="v">:num</span>, <span class="v">:plus</span>, or 
<span class="v">:minus</span> to distinguish the different kinds of arithtm objects</li> 
<li>Constructors <span class="v">arithtm-num</span>, <span class="v">arithtm-plus</span>, <span class="v">arithtm-minus</span>
</li> 
<li>Accessors <span class="v">arithtm-num-&gt;val</span>, <span class="v">arithtm-plus-&gt;left</span>, 
<span class="v">arithtm-plus-&gt;right</span>, and <span class="v">arithtm-minus-&gt;arg</span>
</li> 
<li>Constructor macros <span class="v">make-aritherm-num</span>, <span class="v">make-arithtm-plus</span>, 
<span class="v">make-arithtm-minus</span>
</li> 
<li>Changer macros <span class="v">change-arithtm-num</span>, <span class="v">change-arithtm-plus</span>, 
<span class="v">change-arithtm-minus</span>
</li> 
<li>
<a href="ACL2____B_A2.html">b*</a> binders <span class="v">arithtm-num</span>, <span class="v">arithtm-plus</span>, 
<span class="v">arithtm-minus</span>
</li> 
<li>
<span class="v">arithtm-case</span>, a macro that combines case splitting and accessor binding.</li> 
</ul> 
 
 
 
<p>Note: The individual products in a <span class="v">deftagsum</span> type are not themselves 
types: they have no recognizer or fixing function of their own.  The guard for 
accessors is the sum type and the kind, e.g., for <span class="v">arithtm-plus-&gt;right</span>,</p> 
<pre class="code">(<a href="COMMON-LISP____AND.html">and</a> (arithtm-p x) (<a href="COMMON-LISP____EQUAL.html">equal</a> (arithtm-kind x) :plus))</pre> 
 
<h4>Using Tagsum Objects</h4> 
 
<p>The following example shows how to use an arithtm object.  We define an 
evaluator function that computes the value of an arithtm and a transformation 
that doubles every leaf in an arithtm, and prove that the doubling function 
doubles the value according to the evaluator.  The doubling function also shows 
how the arithtm-case macro is used.  Note that the return type theorems and 
the theorem about the evaluation of arithtm-double are all hypothesis-free -- 
a benefit of following a consistent type-fixing convention.</p> 
 
<pre class="code">(<a href="ACL2____DEFINE.html">define</a> arithtm-eval ((x arithtm-p))
  :returns (val integerp :rule-classes :type-prescription)
  :measure (arithtm-count x)
  :verify-guards nil
  (<a href="COMMON-LISP____CASE.html">case</a> (arithtm-kind x)
    (:num (arithtm-num-&gt;val x))
    (:plus (<a href="COMMON-LISP_____B2.html">+</a> (arithtm-eval (arithtm-plus-&gt;left x))
              (arithtm-eval (arithtm-plus-&gt;right x))))
    (:minus (<a href="COMMON-LISP____-.html">-</a> (arithtm-eval (arithtm-minus-&gt;arg x)))))
  ///
  (<a href="ACL2____VERIFY-GUARDS.html">verify-guards</a> arithtm-eval))


(<a href="ACL2____DEFINE.html">define</a> arithtm-double ((x arithtm-p))
  :returns (xx arithtm-p)
  :measure (arithtm-count x)
  :verify-guards nil
  (arithtm-case x
   :num (arithtm-num (<a href="COMMON-LISP_____A2.html">*</a> 2 x.val))
   :plus (arithtm-plus (arithtm-double x.left)
                       (arithtm-double x.right))
   :minus (arithtm-minus (arithtm-double x.arg)))
  ///
  (<a href="ACL2____VERIFY-GUARDS.html">verify-guards</a> arithtm-double)

  (<a href="ACL2____LOCAL.html">local</a> (<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "arithmetic/top-with-meta" :dir :system))

  (<a href="ACL2____DEFTHM.html">defthm</a> arithtm-eval-of-double
    (<a href="COMMON-LISP____EQUAL.html">equal</a> (arithtm-eval (arithtm-double x))
           (<a href="COMMON-LISP_____A2.html">*</a> 2 (arithtm-eval x)))
    :hints(("Goal" :in-theory (<a href="ACL2____ENABLE.html">enable</a> arithtm-eval)))))</pre> 
 
<h3>Deftagsum Usage and Options</h3> 
 
<p>A <span class="v">deftagsum</span> form consists of the type name, a list of product 
specifiers, and some optional keyword arguments.</p> 
 
<h4>Product specifiers</h4> 
 
<p>A product specifier consists of a tag (a keyword symbol), a list of fields 
given as <a href="STD____EXTENDED-FORMALS.html">std::extended-formals</a>, and some optional keyword arguments. 
The possible keyword arguments are:</p> 
 
<ul> 
<li>
<span class="v">:layout</span>, one of <span class="v">:tree</span>, <span class="v">:list</span>, or <span class="v">:alist</span>, determining 
the arrangement of fields within the product object (as in <a href="FTY____DEFPROD.html">defprod</a>),</li> 
<li>
<span class="v">:inline</span>, determining whether the constructor and accessors are inlined 
or not.  This may be <span class="v">:all</span> or a subset of <span class="v">(:xtor :acc)</span>.  Defaults to 
<span class="v">(:acc)</span> if not overridden.</li> 
<li>
<span class="v">:hons</span>, NIL by default, determining whether objects are constructed 
with <a href="ACL2____HONS.html">hons</a>.</li> 
<li>
<span class="v">:base-name</span>, overrides the name of the constructor and the base name 
used to generate accessors.</li> 
<li>
<span class="v">:require</span> adds a dependent type requirement; see the section on this 
feature in <a href="FTY____DEFPROD.html">defprod</a>.</li> 
</ul> 
 
<h4>Tagsum Options</h4> 
 
<p>The following keyword options are recognized at the top level of a 
<span class="v">deftagsum</span> form (as opposed to inside the individual product forms):</p> 
<ul> 
 
<li>
<span class="v">:pred</span>, <span class="v">:fix</span>, <span class="v">:equiv</span>, <span class="v">:kind</span>, <span class="v">:count</span>: override 
default function names.  <span class="v">:count</span> may also be set to NIL, to turn of 
generation of the count function.</li> 
 
<li>
<span class="v">:parents</span>, <span class="v">:short</span>, <span class="v">:long</span>: add xdoc about the type.</li> 
 
<li>
<span class="v">:measure</span>: override the measures used to admit the recognizer, fixing 
function, and count function; the default is <span class="v">(<a href="ACL2____ACL2-COUNT.html">acl2-count</a> x)</span>.</li> 
 
<li>
<span class="v">:prepwork</span>: events submitted before</li> 
 
<li>
<span class="v">:inline</span>: sets default for inlining of products and determines whether 
the kind and fixing functions are inlined.  This may be <span class="v">:all</span> or a subset 
of <span class="v">(:kind :fix :acc :xtor)</span>, defaulting to <span class="v">(:kind :fix :acc)</span>.</li> 
 
<li>
<span class="v">:layout</span>: sets default layout for products</li> 
 
<li>
<span class="v">:base-case-override</span>: Override which product is the base case.  This 
may affect termination of the fixing function; see below.</li> 
 
</ul> 
 
<h3>Dealing with Base Cases</h3> 
 
<p>Consider the following type definition:</p> 
 
<pre class="code">(<a href="FTY____DEFTYPES.html">deftypes</a> fntree
  (<a href="FTY____DEFTAGSUM.html">deftagsum</a> fntree
    (:pair ((left fntree-p) (right fntree-p)))
    (:call ((fn symbol) (<a href="ACL2____ARGS.html">args</a> fntreelist-p))))
  (<a href="FTY____DEFLIST.html">deflist</a> fntreelist-p :elt-type fntree))</pre> 
 
<p>As is, deftypes will fail to admit this event, saying:</p> 
 
<blockquote> 
We couldn't find a base case for tagsum FNTREE, so we don't know what its 
fixing function should return when the input is an atom.  To override this, add 
keyword arg :base-case-override [product], where [product] is one of your 
product keywords, and provide a measure that will allow the fixing function to 
terminate. 
</blockquote> 
 
<p>What is the problem?  As the text suggests, the problem lies in what we 
should do when given an atom as input to the fixing function.  With the default 
measure of <span class="v">(<a href="ACL2____ACL2-COUNT.html">acl2-count</a> x)</span>, we're not allowed to recur on, say, <span class="v">NIL</span>, 
because its acl2-count is already 0.  This is fine as long as we can pick a 
product type that has no recursive components, but in this case, the <span class="v">:pair</span> 
and <span class="v">:call</span> product both do.  However, the <span class="v">:call</span> product could have an 
empty list as its arguments, and this seems like a reasonable thing to use as 
the fix of an atom.  To give <span class="v">deftagsum</span> the hint to do this, we need to 
tell it which product to fix an atom to, and what measure to use.  The 
following modification of the above form works:</p> 
 
<pre class="code">(<a href="FTY____DEFTYPES.html">deftypes</a> fntree
  (<a href="FTY____DEFTAGSUM.html">deftagsum</a> fntree
    (:pair ((left fntree-p) (right fntree-p)))
    (:call ((fn symbol) (arg fntreelist-p)))
    :base-case-override :call
    :measure (<a href="ACL2____TWO-NATS-MEASURE.html">two-nats-measure</a> (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> x) 1))
  (<a href="FTY____DEFLIST.html">deflist</a> fntreelist-p :elt-type fntree
    :measure (<a href="ACL2____TWO-NATS-MEASURE.html">two-nats-measure</a> (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> x) 0)))</pre> 
</body>
</html>
