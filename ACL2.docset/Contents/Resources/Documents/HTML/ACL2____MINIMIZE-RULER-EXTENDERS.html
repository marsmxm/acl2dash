<html>
<head>
<meta charset="UTF-8">
<title>Minimize-ruler-extenders</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____MINIMIZE-RULER-EXTENDERS">Click for Minimize-ruler-extenders in the Full Manual</a></h3>

<p>Minimize the ruler-extenders necessary to admit a definition.</p><p><span class="v">Minimize-ruler-extenders</span> is really two utilities.  The first, 
 which we call MIN_NEW below, admits a proposed <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> or <span class="tt"><a href="ACL2____DEFUND.html">defund</a></span> 
 form by declaring a minimal set of <a href="ACL2____RULER-EXTENDERS.html">ruler-extenders</a>.  This MIN_NEW 
 utility uses proof to eliminate ruler-extenders as completely as possible, 
 while still permitting the termination proof to succeed.  The second utility, 
 which we call MIN_OLD below, is applied to a function symbol that already has 
 a recursive (but not mutually recursive) definition.  Here are examples that 
 illustrate each of these two respective utilities.</p> 
 
 <pre class="code">; MIN_NEW (to admit a proposed definition):
(<a href="ACL2____MINIMIZE-RULER-EXTENDERS.html">minimize-ruler-extenders</a>
 (<a href="COMMON-LISP____DEFUN.html">defun</a> foo (x)
   (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ENDP.html">endp</a> x)
            x
          (<a href="COMMON-LISP____CONS.html">cons</a> (foo (<a href="COMMON-LISP____CDR.html">cdr</a> x))
                (<a href="ACL2____EVENS.html">evens</a> (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x))
                           (foo (<a href="COMMON-LISP____CDDR.html">cddr</a> x))
                         nil)))))))

; MIN_OLD (to compute minimal ruler-extenders for an existing definition):
(<a href="COMMON-LISP____DEFUN.html">defun</a> bar (x)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :ruler-extenders :all))
  (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x)
           (<a href="COMMON-LISP_____A2.html">*</a> (bar (<a href="COMMON-LISP____CAR.html">car</a> x))
              (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x))
                  (<a href="ACL2____IFIX.html">ifix</a> (<a href="COMMON-LISP____CADR.html">cadr</a> x))
                17))
         3)
       23))
(<a href="ACL2____MINIMIZE-RULER-EXTENDERS.html">minimize-ruler-extenders</a> bar) ; returns (<a href="COMMON-LISP____MOD.html">MOD</a>)</pre> 
 
 <p>In the first (MIN_NEW) example above, a minimal set of <a href="ACL2____RULER-EXTENDERS.html">ruler-extenders</a> — in fact, THE minimal set — is the set 
 <span class="v">{car}</span>.  So the definition that is actually submitted, successfully, to 
 ACL2 is obtained by making that explicit:</p> 
 
 <pre class="code">ACL2 !&gt;:pe foo
 L         2:x(<a href="ACL2____MINIMIZE-RULER-EXTENDERS.html">MINIMIZE-RULER-EXTENDERS</a> (<a href="COMMON-LISP____DEFUN.html">DEFUN</a> FOO # ...))
              \
&gt;L             (<a href="COMMON-LISP____DEFUN.html">DEFUN</a> FOO (X)
                      (<a href="COMMON-LISP____DECLARE.html">DECLARE</a> (<a href="ACL2____XARGS.html">XARGS</a> :RULER-EXTENDERS (<a href="COMMON-LISP____CAR.html">CAR</a>)))
                      (<a href="COMMON-LISP____CAR.html">CAR</a> (<a href="COMMON-LISP____IF.html">IF</a> (<a href="COMMON-LISP____ENDP.html">ENDP</a> X)
                               X
                               (<a href="COMMON-LISP____CONS.html">CONS</a> (FOO (<a href="COMMON-LISP____CDR.html">CDR</a> X))
                                     (<a href="ACL2____EVENS.html">EVENS</a> (<a href="COMMON-LISP____IF.html">IF</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> (<a href="COMMON-LISP____CDR.html">CDR</a> X))
                                                (FOO (<a href="COMMON-LISP____CDDR.html">CDDR</a> X))
                                                NIL))))))
ACL2 !&gt;</pre> 
 
 <p>The input form for the MIN_NEW utility should be a call of <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> or 
 <span class="tt"><a href="ACL2____DEFUND.html">defund</a></span> that defines a function symbol that is not already defined.  If 
 that form specifies <span class="v">:ruler-extenders lst</span>, then ACL2 will look for a 
 minimal subsequence of <span class="v">lst</span> that can serve as the ruler-extenders. 
 Otherwise, ACL2 will start by additing an <span class="tt"><a href="ACL2____XARGS.html">xargs</a></span> declaration, 
 <span class="v">:ruler-extenders lst</span>, where <span class="v">lst</span> contains every plausible 
 ruler-extender, and then will try to find a minimal subsequence of 
 <span class="v">lst</span>.</p> 
 
 <p>Now we turn to the MIN_OLD utility.  This utility is applied to a function 
 symbol <span class="v">F</span> that already has a (singly) recursive definition.  It returns a 
 subset of the ruler-extenders <span class="v">R</span> of <span class="v">F</span> that is minimal in the 
 following sense: it provides the same induction-machine as <span class="v">R</span>.  (The 
 ``induction-machine'' is an ACL2 data structure representing the scheme used 
 when doing induction based on the recursion in <span class="v">F</span>.)</p>
</body>
</html>
