<html>
<head>
<meta charset="UTF-8">
<title>Integer-formats</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=C____INTEGER-FORMATS">Click for Integer-formats in the Full Manual</a></h3>

<p>C integer formats.</p><p>[C] provides constraints on the formats of the integer types [C:6.2.5], 
     but not a complete definition of the formats (unlike Java). 
     A general formalization of C should be parameterized over these formats; 
     we plan to do that in our formalization of C. 
     However, for now we define the formats, but we do so in a way that 
     should make it easy to change and swap some aspects of the definitions.</p><p>[C:6.2.6.2/2] allows padding bits, which we disallow for now. 
     [C:6.2.6.2/2] allows signed integers to be 
     two's complement, one's complement, or sign and magnitude; 
     for now we assume two's complement.</p><p>The exact number of bits in a byte is also implementation-dependent 
     [C:5.2.4.2.1/1] [C:6.2.6.1/3], 
     so we introduce a nullary function for the number of bits in a byte, 
     i.e. in a <span class="v">char</span> (unsigned, signed, or plain). 
     We define it to be 8 for now, because that is the most frequent case. 
     A step towards generalizing this is in <a href="C____BYTES.html">bytes</a>, 
     which we plan to use for a future more general version of 
     our formalization of the integer formats.</p><p>We also introduce nullary functions for the number of bits that form 
     (signed and unsigned) 
     <span class="v">short</span>s, <span class="v">int</span>s, <span class="v">long</span>, and <span class="v">long long</span>s. 
     Given the above current choice of no padding bits, 
     these numbers of bits have to be multiples of the number of bits in a byte, 
     because those integers have to take a whole number of bytes. 
     Recall that each unsigned/signed integer type 
     takes the same storage as the corresponding signed/unsigned type 
     [C:6.2.5/6].</p><p>We prove some theorems about the nullary functions. 
     We disable the definitions of the nullary functions, 
     including executable counterparts. 
     This way, we minimize the dependencies from the exact definitions, 
     and we define the integer values, conversions, and operations 
     as independently from the exact sizes as possible. 
     Thus, it may not be difficult to replace this file 
     with another one with different definitions, 
     or to replace the definitions with a parameterization.</p><p>The definitions that we pick here are consistent with <span class="v">gcc</span> 
     on (at least some versions of) macOS and Linux, namely: 
     <span class="v">char</span> is 8 bits, 
     <span class="v">short</span> is 16 bits (2 bytes), 
     <span class="v">int</span> is 32 bits (4 bytes), 
     <span class="v">long</span> is 64 bits (8 bytes), and 
     <span class="v">long long</span> is also 64 bits (8 bytes). 
     These are all consistent with the ranges in [C:5.2.4.2.1]: 
     <span class="v">char</span> must be at least 8 bits, 
     <span class="v">short</span> must be at least 16 bits, 
     <span class="v">int</span> must be at least 16 bits, 
     <span class="v">long</span> must be at least 32 bits, and 
     <span class="v">long long</span> must be at least 64 bits. 
     Furthermore, the ranges must be non-decreasing [C:6.2.5/8].</p><p>For now we only define formats for 
     the standard signed and unsigned integer types except <span class="v">_Bool</span>. 
     Note that the plain <span class="v">char</span> type is not covered yet; 
     it is an integer type, 
     but not a standard integer type in C's terminology.</p>
</body>
</html>
