<html>
<head>
<meta charset="UTF-8">
<title>Practice-formulating-strong-rules-6</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____PRACTICE-FORMULATING-STRONG-RULES-6">Click for Practice-formulating-strong-rules-6 in the Full Manual</a></h3>

<p>Rules suggested by <span class="v">(<a href="COMMON-LISP____MEMBER.html">MEMBER</a> (FOO A) (NATS-BELOW (BAR B)))</span></p><p>What rules come to mind when looking at the following subterm of a 
 Key Checkpoint?  Think of <i>strong</i> rules (see <a href="ACL2____STRONG-REWRITE-RULES.html">strong-rewrite-rules</a>).</p> 
 
 <pre class="code">(<a href="COMMON-LISP____MEMBER.html">MEMBER</a> (FOO A) (NATS-BELOW (BAR B)))</pre> 
 
 <p>The definition of <span class="v">NATS-BELOW</span> is</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> nats-below (j)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> j)
      '(0)
      (<a href="COMMON-LISP____CONS.html">cons</a> j (nats-below (<a href="COMMON-LISP____-.html">-</a> j 1)))))</pre> 
 
 <p>Thus, <span class="v">(nats-below 7)</span> is <span class="v">(7 6 5 4 3 2 1 0)</span>.  So when is <span class="v">k</span> a 
 member of <span class="v">(nats-below j)</span>?</p> 
 
 <p>The weakest version is</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> member-nats-below-weak
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> k)
                (<a href="ACL2____NATP.html">natp</a> j)
                (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> k j))
           (<a href="COMMON-LISP____MEMBER.html">member</a> k (nats-below j))))</pre> 
 
 <p>But clearly we could improve this to:</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> member-nats-below-weak-better
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> k)
                (<a href="ACL2____NATP.html">natp</a> j))
           (<a href="ACL2____IFF.html">iff</a> (<a href="COMMON-LISP____MEMBER.html">member</a> k (nats-below j))
                (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> k j))))</pre> 
 
 <p>or even</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> member-nats-below-weak-better
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____NATP.html">natp</a> j)
           (<a href="ACL2____IFF.html">iff</a> (<a href="COMMON-LISP____MEMBER.html">member</a> k (nats-below j))
                (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> k)
                     (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> k j)))))</pre> 
 
 <p>Clearly though, we'd like to get rid of the <span class="v">(<a href="ACL2____NATP.html">natp</a> j)</span> hypothesis and 
 the neatest plausible version is:</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> member-nats-below-weak-neatest
  (<a href="ACL2____IFF.html">iff</a> (<a href="COMMON-LISP____MEMBER.html">member</a> k (nats-below j))
       (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> j)
            (<a href="ACL2____NATP.html">natp</a> k)
            (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> k j))))</pre> 
 
 <p>But it is not a theorem!  For example, if <span class="v">j</span> is <span class="v">-1</span> and <span class="v">k</span> is 
 0, then the left-hand side above returns <span class="v">t</span>, because <span class="v">(nats-below j)</span> 
 is <span class="v">(0)</span>, but the right-hand side is <span class="v">nil</span>.</p> 
 
 <p>But this suggests a strategy for dealing with necessary hypotheses, like 
 <span class="v">(<a href="ACL2____NATP.html">natp</a> j)</span>.  We can move them into an <span class="v">IF</span> on the right-hand side! 
 Something like this might be a useful rewrite rule:</p> 
 
 <pre class="code">(<a href="ACL2____IFF.html">iff</a> (<a href="COMMON-LISP____MEMBER.html">member</a> k (nats-below j))
     (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____NATP.html">natp</a> j)
         (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> k)
              (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> k j))
         ...)).</pre> 
 
 <p>We know, from <span class="v">member-nats-below-weak-better</span>, that if <span class="v">(<a href="ACL2____NATP.html">natp</a> j)</span> is 
 true, the <span class="v">member</span> is equivalent to <span class="v">(<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> k) (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> k j))</span>.  So now 
 consider what we know if <span class="v">(<a href="ACL2____NATP.html">natp</a> j)</span> is false.  If we can think of some term 
 it's equivalent to and that term is simpler than the <span class="v">member</span> expression, 
 we have a strong rule.</p> 
 
 <p>But by inspection of the definition of <span class="v">nats-below</span>, we see that when 
 <span class="v">(<a href="ACL2____NATP.html">natp</a> j)</span> is false, <span class="v">(nats-below j)</span> is the list <span class="v">(0)</span> because 
 <span class="v">(<a href="ACL2____ZP.html">zp</a> j)</span> is t.  That is, <span class="v">nats-below</span> treats all non-natural arguments 
 like they were <span class="v">0</span>.  Thus, when <span class="v">(<a href="ACL2____NATP.html">natp</a> j)</span> is false, <span class="v">(<a href="COMMON-LISP____MEMBER.html">member</a> k
 (nats-below j))</span> is <span class="v">(<a href="COMMON-LISP____MEMBER.html">member</a> k '(0))</span>, which is <span class="v">(<a href="COMMON-LISP____EQUAL.html">equal</a> k 0)</span>.</p> 
 
 <p>So the strong version is</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> member-nats-below-strong
   (<a href="ACL2____IFF.html">iff</a> (<a href="COMMON-LISP____MEMBER.html">member</a> k (nats-below j))
        (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____NATP.html">natp</a> j)
            (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> k)
                 (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> k j))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> k 0))))</pre> 
 
 <p>This is a great <span class="v">:</span><span class="tt"><a href="ACL2____REWRITE.html">rewrite</a></span> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a> 
 rule.  It gets rid of the <span class="v">member</span> and <span class="v">nats-below</span> and introduces 
 arithmetic.</p> 
 
 <p>This example illustrates the idea of putting an <span class="v">if</span> on the 
 right-hand-side of the equivalence.  Many users tend to limit themselves to 
 propositional forms inside <span class="v">iff</span> or to simple expressions inside of 
 <span class="v">equal</span>.  But it is quite natural to use <span class="v">if</span> to express what the answer 
 is: if <span class="v">j</span> is a natural, then <span class="v">k</span> is in <span class="v">(nats-below j)</span> precisely if 
 <span class="v">k</span> is a natural less than or equal to <span class="v">j</span>; if <span class="v">j</span> is not a natural, 
 then <span class="v">k</span> is in <span class="v">(nats-below j)</span> precisely if <span class="v">k</span> is <span class="v">0</span>.</p> 
 
 <p>Use <span class="v">if</span> to lay out the cases you must consider, if you can think of a 
 simpler, equivalent expression for every possible case.</p> 
 
 <p>Use your browser's <b>Back Button</b> now to return to <a href="ACL2____PRACTICE-FORMULATING-STRONG-RULES.html">practice-formulating-strong-rules</a>.</p>
</body>
</html>
