<html>
<head>
<meta charset="UTF-8">
<title>Faig-constructors</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____FAIG-CONSTRUCTORS">Click for Faig-constructors in the Full Manual</a></h3>

<p>Low-level functions for constructing <a href="ACL2____FAIG.html">faig</a>s.</p><p>These functions construct new FAIGs from existing ones.  They 
typically <a href="ACL2____HONS.html">hons</a>ing up some new onset and offset <a href="ACL2____AIG.html">aig</a>s by using the 
using <a href="ACL2____AIG-CONSTRUCTORS.html">aig-constructors</a> like <a href="ACL2____AIG-AND.html">aig-and</a> and <a href="ACL2____AIG-NOT.html">aig-not</a>, and then 
<a href="COMMON-LISP____CONS.html">cons</a> those new onset/offset AIGs together to form a new FAIG.</p> 
 
<p>Most of these functions are geared toward modeling hardware.  For instance, 
<a href="ACL2____F-AIG-AND.html">f-aig-and</a> is intended to produce a new FAIG that captures the 
four-valued logic semantics of an AND gate.</p> 
 
<div class="box"><p>Note: the details about how X and Z are handled by these functions are 
often subtle and this documentation doesn't really explain <i>why</i> these 
functions work the way they do.  <b>However</b>, for most functions here there 
are corresponding <a href="ACL2____4V-OPERATIONS.html">4v-operations</a>, and the documentation there typically 
<i>does</i> explaining the X/Z behavior.</p></div> 
 
 
<h3>Three-valued (T-) vs. Four-valued (F-) constructors</h3> 
 
<p>There is an important optimization you can make when modeling hardware gates 
as FAIGs.  In particular, it is often possible to construct more 
efficient (smaller) FAIGs to represent the gate's output when you know that the 
gate's inputs cannot evaluate to Z.</p> 
 
<p>In CMOS designs, this property—never evaluating to Z—holds for 
the outputs of most logic gates.  Accordingly, it's true for most <i>inputs</i> 
to other gates.  For example, suppose you are trying to model a circuit like 
this:</p> 
 
<pre class="code">   |\  b
---| &gt;o---+
   |/     |       ____
          +------|    \
   |             | and )---
---| &gt;o----------|____/   o
   |/    a</pre> 
 
<p>Here, we know that wires <span class="v">a</span> and <span class="v">b</span> can never have the value Z, 
because they are produced by NOT gates.  Accordingly, when we want to create 
the FAIG corresponding to <span class="v">o</span>, we can use an optimized, less-general 
implementation of the <i>and</i> gate, where we assume that our inputs are 
non-Z.</p> 
 
<p>Of course, some logic gates (e.g., tri-state buffers) <i>can</i> produce Z 
valued outputs, so occasionally these sorts of optimizations aren't possible. 
Because of this, we typically have two versions of each FAIG constructor:</p> 
 
<ul> 
 
<li>
<span class="v">t-aig-*</span> functions make the assumption that their inputs are can never 
evaluate to Z.  These are generally more efficient, and will produce smaller 
AIGs that are easier to analyze with SAT solvers.</li> 
 
<li>
<span class="v">f-aig-*</span> functions do not make this assumption.  This makes them more 
general purpose and able to operate on any FAIG inputs, at the cost of larger 
AIGs.</li> 
 
</ul> 
 
<h3>Rulesets</h3> 
 
<p>For historic reasons these functions are left enabled.  There are two 
useful <a href="ACL2____RULESETS.html">rulesets</a> you can use to disable them:</p> 
 
<ul> 
<li>
<span class="v">f-aig-defs</span> has all of the <span class="v">f-</span> constructors.</li> 
<li>
<span class="v">t-aig-defs</span> has all of the <span class="v">t-</span> constructors.</li> 
</ul>
</body>
</html>
