<html>
<head>
<meta charset="UTF-8">
<title>Bed-order</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=BED____BED-ORDER">Click for Bed-order in the Full Manual</a></h3>

<p>Ordering mechanism for canonicalizing symmetric operators.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(bed-order a b order) → (mv okp order)</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">a</span> — The first node to consider.</dd> 
  <dd>
<span class="tt">b</span> — The second node to consider.</dd> 
  <dd>
<span class="tt">order</span> — Table mapping nodes to ranks.</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">okp</span> — Is <span class="v">a &lt;= b</span> per this order?.</dd> 
<dd>
<span class="tt">order</span> — Possibly updated order table.</dd> 
 
</dl></div> 
<p>One of the main drawbacks of using a Hons-based representation is 
that there isn't a convenient way to ask whether one node comes "earlier" 
than another.  In a DAG-based representation you could just compare the indices 
of the nodes.  But our DAG, being extralogical, is inaccessible and can't be 
used in this heuristic way.</p> 
 
<p>Well, we still want to be able to reorder the children of, e.g., AND nodes, 
since keeping things in a particular order will encourage structure sharing and 
help us to notice opportunities for additional reductions such as <span class="v">A &amp; A --&gt;
A</span>.  So, we impose an order on the nodes using an explicit table.</p> 
 
<p>We want to keep the reasoning impact of this table to a minimum. 
Accordingly, we don't require any guards on it.  The general idea is that the 
order table maps nodes to numbers.  These numbers are assigned in an arbitrary 
way as we happen to encounter nodes.  That is, if <span class="v">a</span> or <span class="v">b</span> hasn't yet 
been assigned an index, we will go ahead and assign it one here.</p> 
 
<p>The nature of <a href="ACL2____HONS-ACONS.html">hons-acons</a> means that the <a href="COMMON-LISP____CAR.html">car</a> of <span class="v">order</span> will 
be the most recently assigned node.  So, it's easy to assign sequential indices 
without having to maintain some separate free counter.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>bed-order</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> bed-order (a b order)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'bed-order))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
            (<a href="ACL2____B_A2.html">b*</a> (((when (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____ATOM.html">atom</a> a) (<a href="COMMON-LISP____ATOM.html">atom</a> b)))
                  (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____ATOM.html">atom</a> a) (<a href="COMMON-LISP____ATOM.html">atom</a> b))
                         (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____OR.html">or</a> a (<a href="COMMON-LISP____NOT.html">not</a> b)) order))
                        ((<a href="COMMON-LISP____ATOM.html">atom</a> a) (<a href="ACL2____MV.html">mv</a> t order))
                        (t (<a href="ACL2____MV.html">mv</a> nil order))))
                 (alook (<a href="ACL2____HONS-GET.html">hons-get</a> a order))
                 (blook (<a href="ACL2____HONS-GET.html">hons-get</a> b order))
                 ((when (<a href="COMMON-LISP____AND.html">and</a> alook blook))
                  (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____IFIX.html">ifix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> alook))
                          (<a href="ACL2____IFIX.html">ifix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> blook)))
                      order))
                 (free (<a href="ACL2____IFIX.html">ifix</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> order)
                                  (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CAR.html">car</a> order))
                                  (<a href="COMMON-LISP____CDAR.html">cdar</a> order))))
                 ((<a href="ACL2____MV.html">mv</a> aidx order free)
                  (<a href="ACL2____B_A2.html">b*</a> (((when alook)
                        (<a href="ACL2____MV.html">mv</a> (<a href="ACL2____IFIX.html">ifix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> alook)) order free))
                       (free (<a href="COMMON-LISP_____B2.html">+</a> 1 free))
                       (order (<a href="ACL2____HONS-ACONS.html">hons-acons</a> a free order)))
                      (<a href="ACL2____MV.html">mv</a> free order free)))
                 ((<a href="ACL2____MV.html">mv</a> bidx order)
                  (<a href="ACL2____B_A2.html">b*</a> (((when blook)
                        (<a href="ACL2____MV.html">mv</a> (<a href="ACL2____IFIX.html">ifix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> blook)) order))
                       (free (<a href="COMMON-LISP_____B2.html">+</a> 1 free))
                       (order (<a href="ACL2____HONS-ACONS.html">hons-acons</a> b free order)))
                      (<a href="ACL2____MV.html">mv</a> free order))))
                (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> aidx bidx) order))))</pre> 

</body>
</html>
