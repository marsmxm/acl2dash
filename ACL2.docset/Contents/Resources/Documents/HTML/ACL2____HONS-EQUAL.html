<html>
<head>
<meta charset="UTF-8">
<title>Hons-equal</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____HONS-EQUAL">Click for Hons-equal in the Full Manual</a></h3>

<p><span class="v">(<a href="ACL2____HONS-EQUAL.html">hons-equal</a> x y)</span> is a recursive equality check that optimizes 
when parts of its arguments are <a href="ACL2____NORMED.html">normed</a>.</p><p>In the logic, <span class="v">hons-equal</span> is just <span class="tt"><a href="COMMON-LISP____EQUAL.html">equal</a></span>; we leave it 
 enabled and would think it odd to ever prove a theorem about it.</p> 
 
 <p>Under the hood, when <span class="v">hons-equal</span> encounters two arguments that are both 
 normed, it becomes a mere <span class="tt"><a href="COMMON-LISP____EQL.html">eql</a></span> check, and hence avoids the overhead of 
 recursively checking large cons structures for equality.</p> 
 
 <p>Note.  If <span class="v">hons-equal</span> is given arguments that do not contain many 
 normed objects, it can actually be much slower than <span class="tt"><a href="COMMON-LISP____EQUAL.html">equal</a></span>!  This is 
 because it checks to see whether its arguments are normed at each recursive 
 step, and so you are repeatedly paying the price of such checks.  Also see 
 <a href="ACL2____HONS-EQUAL-LITE.html">hons-equal-lite</a>, which only checks at the top level whether its 
 arguments are normed.</p> 
 
 <p><b>Function: </b>hons-equal</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> hons-equal (x y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> x y))</pre>
</body>
</html>
