<html>
<head>
<meta charset="UTF-8">
<title>Atc-write-object-rules</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=C____ATC-WRITE-OBJECT-RULES">Click for Atc-write-object-rules in the Full Manual</a></h3>

<p>Rules about <span class="tt"><a href="C____WRITE-OBJECT.html">write-object</a></span>.</p><p>The theorem about <span class="tt"><a href="C____WRITE-OBJECT.html">write-object</a></span> turns it into <span class="tt"><a href="C____UPDATE-OBJECT.html">update-object</a></span>, 
     similarly to how <span class="tt"><a href="C____WRITE-VAR.html">write-var</a></span> is turned into <span class="tt"><a href="C____UPDATE-VAR.html">update-var</a></span>. 
     The condition for the replacement is captured by <span class="v">write-object-okp</span>, 
     for which we supply rules to go through all the computation state layers. 
     When the computation state (meta) variable is reached, 
     it must be the case that there are hypotheses available 
     saying that reading the object 
     yields a value of appropriate type and length. 
     The rule is used as last resort, 
     only if the computation state is an ACL2 variable 
     (as enforced by the <span class="tt"><a href="ACL2____SYNTAXP.html">syntaxp</a></span> hypothesis).</p><p>For now we only support top-level object designators, 
     but we plan to extend things to other object designators.</p><p>Since <span class="tt"><a href="C____UPDATE-OBJECT.html">update-object</a></span> takes the base address, 
     the rules <span class="v">write-object-okp-of-update-object-same</span> 
     and <span class="v">write-object-okp-when-valuep-of-read-object</span> 
     need the hypothesis that the object designator is a top-level one.</p><p>We include the rule for commutativity of <span class="tt"><a href="C____OBJECT-DISJOINTP.html">object-disjointp</a></span>, 
     so it does not matter the order of the disjoint objects 
     in the hypotheses of the rules vs. the available hypothesis 
     during the symbolic execution 
     (i.e. commutativity normalizes them, via its loop stopper).</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>write-object-okp</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> write-object-okp (objdes val compst)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="C____OBJDESIGNP.html">objdesignp</a> objdes)
                                   (<a href="C____VALUEP.html">valuep</a> val)
                                   (<a href="C____COMPUSTATEP.html">compustatep</a> compst))))
       (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'write-object-okp))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
            (<a href="ACL2____B_A2.html">b*</a> (((unless (<a href="C____OBJDESIGN-CASE.html">objdesign-case</a> objdes :address))
                  nil)
                 (addr (<a href="C____OBJDESIGN-ADDRESS-_E3GET.html">objdesign-address-&gt;get</a> objdes))
                 (<a href="C____HEAP.html">heap</a> (<a href="C____COMPUSTATE-_E3HEAP.html">compustate-&gt;heap</a> compst))
                 (addr+obj (<a href="OMAP____IN.html">omap::in</a> addr heap))
                 ((unless (<a href="COMMON-LISP____CONSP.html">consp</a> addr+obj)) nil)
                 (obj (<a href="COMMON-LISP____CDR.html">cdr</a> addr+obj))
                 ((unless (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____TYPE-OF-VALUE.html">type-of-value</a> val)
                                 (<a href="C____TYPE-OF-VALUE.html">type-of-value</a> obj)))
                  nil))
                t)))</pre> 
<p><b>Theorem: </b>booleanp-of-write-object-okp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> booleanp-of-write-object-okp
        (<a href="ACL2____B_A2.html">b*</a> ((yes/no (write-object-okp objdes val compst)))
            (<a href="ACL2____BOOLEANP.html">booleanp</a> yes/no))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>write-object-okp-of-objdesign-fix-objdes</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> write-object-okp-of-objdesign-fix-objdes
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (write-object-okp (<a href="C____OBJDESIGN-FIX.html">objdesign-fix</a> objdes)
                                 val compst)
               (write-object-okp objdes val compst)))</pre> 
<p><b>Theorem: </b>write-object-okp-objdesign-equiv-congruence-on-objdes</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> write-object-okp-objdesign-equiv-congruence-on-objdes
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____OBJDESIGN-EQUIV.html">objdesign-equiv</a> objdes objdes-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (write-object-okp objdes val compst)
                        (write-object-okp objdes-equiv val compst)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>write-object-okp-of-value-fix-val</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> write-object-okp-of-value-fix-val
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (write-object-okp objdes (<a href="C____VALUE-FIX.html">value-fix</a> val)
                                 compst)
               (write-object-okp objdes val compst)))</pre> 
<p><b>Theorem: </b>write-object-okp-value-equiv-congruence-on-val</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> write-object-okp-value-equiv-congruence-on-val
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____VALUE-EQUIV.html">value-equiv</a> val val-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (write-object-okp objdes val compst)
                        (write-object-okp objdes val-equiv compst)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>write-object-okp-of-compustate-fix-compst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> write-object-okp-of-compustate-fix-compst
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (write-object-okp objdes val (<a href="C____COMPUSTATE-FIX.html">compustate-fix</a> compst))
               (write-object-okp objdes val compst)))</pre> 
<p><b>Theorem: </b>write-object-okp-compustate-equiv-congruence-on-compst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> write-object-okp-compustate-equiv-congruence-on-compst
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____COMPUSTATE-EQUIV.html">compustate-equiv</a> compst compst-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (write-object-okp objdes val compst)
                        (write-object-okp objdes val compst-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>write-object-okp-of-add-frame</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> write-object-okp-of-add-frame
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (write-object-okp objdes val (<a href="C____ADD-FRAME.html">add-frame</a> fun compst))
               (write-object-okp objdes val compst)))</pre> 
<p><b>Theorem: </b>write-object-okp-of-enter-scope</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> write-object-okp-of-enter-scope
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (write-object-okp objdes val (<a href="C____ENTER-SCOPE.html">enter-scope</a> compst))
               (write-object-okp objdes val compst)))</pre> 
<p><b>Theorem: </b>write-object-okp-of-add-var</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     write-object-okp-of-add-var
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (write-object-okp objdes val (<a href="C____ADD-VAR.html">add-var</a> var val2 compst))
            (write-object-okp objdes val compst)))</pre> 
<p><b>Theorem: </b>write-object-okp-of-update-var</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   write-object-okp-of-update-var
   (<a href="COMMON-LISP____EQUAL.html">equal</a> (write-object-okp objdes val (<a href="C____UPDATE-VAR.html">update-var</a> var val2 compst))
          (write-object-okp objdes val compst)))</pre> 
<p><b>Theorem: </b>write-object-okp-of-update-object-same</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 write-object-okp-of-update-object-same
 (<a href="ACL2____IMPLIES.html">implies</a>
    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____OBJDESIGN-KIND.html">objdesign-kind</a> objdes) :address)
    (<a href="COMMON-LISP____EQUAL.html">equal</a> (write-object-okp objdes
                             val (<a href="C____UPDATE-OBJECT.html">update-object</a> objdes val2 compst))
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____TYPE-OF-VALUE.html">type-of-value</a> val)
                  (<a href="C____TYPE-OF-VALUE.html">type-of-value</a> val2)))))</pre> 
<p><b>Theorem: </b>write-object-okp-of-update-object-disjoint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 write-object-okp-of-update-object-disjoint
 (<a href="ACL2____IMPLIES.html">implies</a>
   (<a href="C____OBJECT-DISJOINTP.html">object-disjointp</a> objdes objdes2)
   (<a href="COMMON-LISP____EQUAL.html">equal</a> (write-object-okp objdes
                            val (<a href="C____UPDATE-OBJECT.html">update-object</a> objdes2 val2 compst))
          (write-object-okp objdes val compst))))</pre> 
<p><b>Theorem: </b>write-object-okp-when-valuep-of-read-object</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> write-object-okp-when-valuep-of-read-object
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SYNTAXP.html">syntaxp</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> compst))
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____OBJDESIGN-KIND.html">objdesign-kind</a> objdes) :address)
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> old-val (<a href="C____READ-OBJECT.html">read-object</a> objdes compst))
                      (<a href="C____VALUEP.html">valuep</a> old-val))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (write-object-okp objdes val compst)
                        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____TYPE-OF-VALUE.html">type-of-value</a> val)
                               (<a href="C____TYPE-OF-VALUE.html">type-of-value</a> old-val)))))</pre> 
<p><b>Theorem: </b>write-object-to-update-object</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> write-object-to-update-object
        (<a href="ACL2____IMPLIES.html">implies</a> (write-object-okp objdes val compst)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____WRITE-OBJECT.html">write-object</a> objdes val compst)
                        (<a href="C____UPDATE-OBJECT.html">update-object</a> objdes val compst))))</pre> 

</body>
</html>
