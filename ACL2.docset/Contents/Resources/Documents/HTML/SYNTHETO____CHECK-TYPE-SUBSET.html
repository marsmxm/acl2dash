<html>
<head>
<meta charset="UTF-8">
<title>Check-type-subset</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=SYNTHETO____CHECK-TYPE-SUBSET">Click for Check-type-subset in the Full Manual</a></h3>

<p>Check if a type subset is statically well-formed.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(check-type-subset tsub ctxt) → (mv err? obligs)</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">tsub</span> — <font color="#606060">Guard <span class="v">(<a href="SYNTHETO____TYPE-SUBSETP.html">type-subsetp</a> tsub)</span>.</font>
</dd> 
  <dd>
<span class="tt">ctxt</span> — <font color="#606060">Guard <span class="v">(<a href="SYNTHETO____CONTEXTP.html">contextp</a> ctxt)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">obligs</span> — <font color="#606060">Type <span class="v">(<a href="SYNTHETO____PROOF-OBLIGATION-LISTP.html">proof-obligation-listp</a> obligs)</span>.</font>
</dd> 
 
</dl></div> 
<p>The guard assumptions on the context are motivated 
     as in <span class="tt"><a href="SYNTHETO____CHECK-TYPE-PRODUCT.html">check-type-product</a></span>.</p><p>The supertype must be well-formed. 
     We check the restriction expression in a context 
     with the type subset variable as the only one; 
     the expression must be boolean-valued. 
     If a witness expression is present, 
     we check it in a context with no variables 
     (so it has to be a ground expression); 
     we ensures it matches the supertype (which may generate proof obligations) 
     and we generate a proof obligation saying that 
     the expression satisfies the restriction.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>check-type-subset</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 check-type-subset (tsub ctxt)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SYNTHETO____TYPE-SUBSETP.html">type-subsetp</a> tsub)
                             (<a href="SYNTHETO____CONTEXTP.html">contextp</a> ctxt))))
 (<a href="COMMON-LISP____DECLARE.html">declare</a>
      (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NULL.html">null</a> (<a href="SYNTHETO____CONTEXT-_E3FUNCTIONS.html">context-&gt;functions</a> ctxt))
                         (<a href="OMAP____EMPTY.html">omap::empty</a> (<a href="SYNTHETO____CONTEXT-_E3VARIABLES.html">context-&gt;variables</a> ctxt))
                         (<a href="COMMON-LISP____NULL.html">null</a> (<a href="SYNTHETO____CONTEXT-_E3OBLIGATION-VARS.html">context-&gt;obligation-vars</a> ctxt))
                         (<a href="COMMON-LISP____NULL.html">null</a> (<a href="SYNTHETO____CONTEXT-_E3OBLIGATION-HYPS.html">context-&gt;obligation-hyps</a> ctxt)))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((__function__ 'check-type-subset))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
  (<a href="ACL2____B_A2.html">b*</a>
   (((<a href="SYNTHETO____TYPE-SUBSET.html">type-subset</a> tsub) tsub)
    ((when (<a href="COMMON-LISP____NOT.html">not</a> (<a href="SYNTHETO____CHECK-TYPE.html">check-type</a> tsub.supertype ctxt)))
     (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____LIST.html">list</a> :malformed-supertype (<a href="SYNTHETO____TYPE-SUBSET-FIX.html">type-subset-fix</a> tsub))
         nil))
    (tvar (<a href="SYNTHETO____MAKE-TYPED-VARIABLE.html">make-typed-variable</a> :name tsub.variable
                               :type tsub.supertype))
    (var-ctxt (<a href="SYNTHETO____TYPED-VARIABLES-TO-VARIABLE-CONTEXT.html">typed-variables-to-variable-context</a> (<a href="COMMON-LISP____LIST.html">list</a> tvar)))
    (ctxt-restr (<a href="SYNTHETO____CHANGE-CONTEXT.html">change-context</a> ctxt
                                :variables var-ctxt
                                :obligation-vars (<a href="COMMON-LISP____LIST.html">list</a> tvar)
                                :obligation-hyps nil))
    (result-restr (<a href="SYNTHETO____CHECK-EXPRESSION.html">check-expression</a> tsub.restriction ctxt-restr)))
   (<a href="SYNTHETO____TYPE-RESULT-CASE.html">type-result-case</a>
    result-restr
    :err (<a href="ACL2____MV.html">mv</a> result-restr.info nil)
    :ok
    (<a href="ACL2____B_A2.html">b*</a>
     ((<a href="SYNTHETO____TYPE.html">type</a> (<a href="SYNTHETO____ENSURE-SINGLE-TYPE.html">ensure-single-type</a> result-restr.types))
      ((when (<a href="COMMON-LISP____NOT.html">not</a> type))
       (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____LIST.html">list</a> :multi-valued-restriction (<a href="SYNTHETO____TYPE-SUBSET-FIX.html">type-subset-fix</a> tsub))
           nil))
      ((unless (<a href="SYNTHETO____SUBTYPEP.html">subtypep</a> type (<a href="SYNTHETO____TYPE-BOOLEAN.html">type-boolean</a>)
                         (<a href="SYNTHETO____CONTEXT-_E3TOPS.html">context-&gt;tops</a> ctxt)))
       (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____LIST.html">list</a> :non-boolean-restriction (<a href="SYNTHETO____TYPE-SUBSET-FIX.html">type-subset-fix</a> tsub))
           nil))
      ((when (<a href="COMMON-LISP____NOT.html">not</a> tsub.witness))
       (<a href="ACL2____MV.html">mv</a> nil result-restr.obligations))
      (result-wit (<a href="SYNTHETO____CHECK-EXPRESSION.html">check-expression</a> tsub.witness ctxt)))
     (<a href="SYNTHETO____TYPE-RESULT-CASE.html">type-result-case</a>
      result-wit
      :err (<a href="ACL2____MV.html">mv</a> result-wit.info nil)
      :ok
      (<a href="ACL2____B_A2.html">b*</a>
       ((<a href="SYNTHETO____TYPE.html">type</a> (<a href="SYNTHETO____ENSURE-SINGLE-TYPE.html">ensure-single-type</a> result-wit.types))
        ((when (<a href="COMMON-LISP____NOT.html">not</a> type))
         (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____LIST.html">list</a> :multi-valued-restriction (<a href="SYNTHETO____TYPE-SUBSET-FIX.html">type-subset-fix</a> tsub))
             nil))
        ((<a href="ACL2____MV.html">mv</a> okp obligs)
         (<a href="SYNTHETO____MATCH-TYPE.html">match-type</a> tsub.witness type tsub.supertype ctxt))
        ((when (<a href="COMMON-LISP____NOT.html">not</a> okp))
         (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____LIST.html">list</a> :type-mismatch-witness (<a href="SYNTHETO____TYPE-SUBSET-FIX.html">type-subset-fix</a> tsub))
             nil))
        (<a href="COMMON-LISP____SUBST.html">subst</a> (<a href="OMAP____UPDATE.html">omap::update</a> tsub.variable tsub.witness nil))
        (<a href="ACL2____FORMULA.html">formula</a> (<a href="SYNTHETO____SUBST-EXPRESSION.html">subst-expression</a> subst tsub.restriction))
        (oblig?
         (<a href="SYNTHETO____NON-TRIVIAL-PROOF-OBLIGATION.html">non-trivial-proof-obligation</a>
              nil nil formula
              (<a href="SYNTHETO____EXPRESSION-LITERAL.html">expression-literal</a> (<a href="SYNTHETO____LITERAL-STRING.html">literal-string</a> "type-subset")))))
       (<a href="ACL2____MV.html">mv</a> nil
           (<a href="COMMON-LISP____APPEND.html">append</a> result-restr.obligations
                   result-wit.obligations
                   obligs oblig?)))))))))</pre> 
<p><b>Theorem: </b>proof-obligation-listp-of-check-type-subset.obligs</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> proof-obligation-listp-of-check-type-subset.obligs
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?err? ?obligs)
              (<a href="SYNTHETO____CHECK-TYPE-SUBSET.html">check-type-subset</a> tsub ctxt)))
            (<a href="SYNTHETO____PROOF-OBLIGATION-LISTP.html">proof-obligation-listp</a> obligs))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>check-type-subset-of-type-subset-fix-tsub</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> check-type-subset-of-type-subset-fix-tsub
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____CHECK-TYPE-SUBSET.html">check-type-subset</a> (<a href="SYNTHETO____TYPE-SUBSET-FIX.html">type-subset-fix</a> tsub)
                                  ctxt)
               (<a href="SYNTHETO____CHECK-TYPE-SUBSET.html">check-type-subset</a> tsub ctxt)))</pre> 
<p><b>Theorem: </b>check-type-subset-type-subset-equiv-congruence-on-tsub</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> check-type-subset-type-subset-equiv-congruence-on-tsub
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SYNTHETO____TYPE-SUBSET-EQUIV.html">type-subset-equiv</a> tsub tsub-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____CHECK-TYPE-SUBSET.html">check-type-subset</a> tsub ctxt)
                        (<a href="SYNTHETO____CHECK-TYPE-SUBSET.html">check-type-subset</a> tsub-equiv ctxt)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>check-type-subset-of-context-fix-ctxt</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> check-type-subset-of-context-fix-ctxt
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____CHECK-TYPE-SUBSET.html">check-type-subset</a> tsub (<a href="SYNTHETO____CONTEXT-FIX.html">context-fix</a> ctxt))
               (<a href="SYNTHETO____CHECK-TYPE-SUBSET.html">check-type-subset</a> tsub ctxt)))</pre> 
<p><b>Theorem: </b>check-type-subset-context-equiv-congruence-on-ctxt</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> check-type-subset-context-equiv-congruence-on-ctxt
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SYNTHETO____CONTEXT-EQUIV.html">context-equiv</a> ctxt ctxt-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____CHECK-TYPE-SUBSET.html">check-type-subset</a> tsub ctxt)
                        (<a href="SYNTHETO____CHECK-TYPE-SUBSET.html">check-type-subset</a> tsub ctxt-equiv)))
        :rule-classes :congruence)</pre> 

</body>
</html>
