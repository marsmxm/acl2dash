<html>
<head>
<meta charset="UTF-8">
<title>Defret</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____DEFRET">Click for Defret in the Full Manual</a></h3>

<p>Prove additional theorems about a <a href="ACL2____DEFINE.html">define</a>d 
function, implicitly binding the return variables.</p><p><span class="v">defret</span> is basically defthm, but has a few extra features.</p> 
 
<p>The main feature is that it automatically binds the declared return values 
for a function, which defaults to the most recent function created using <a href="ACL2____DEFINE.html">define</a>.</p> 
 
<p>It also supports the <span class="v">:hyp</span> keyword similar to define's <a href="STD____RETURNS-SPECIFIERS.html">returns-specifiers</a>.</p> 
 
<p>Syntax:</p> 
 
<p>Suppose we have a function created using define with the following 
signature:</p> 
 
<pre class="code">(<a href="ACL2____DEFINE.html">define</a> my-function ((a natp)
                     (b stringp)
                     (c true-listp))
  :returns (<a href="ACL2____MV.html">mv</a> (d pseudo-termp)
               (e booleanp)
               (f (<a href="STD____TUPLEP.html">tuplep</a> 3 f)))
  ...)</pre> 
 
<p>(The guards and return types aren't important for our purposes, just the 
names.)</p> 
 
<p>A <span class="v">defret</span> form like this:</p> 
 
<pre class="code">(<a href="ACL2____DEFRET.html">defret</a> a-theorem-about-&lt;fn&gt;
   :hyp (something-about a b c)
   :pre-bind ((q (foo a b c)))
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> e)
            (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> d)
                 (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> d))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____SECOND.html">second</a> d) q)))
   :fn my-function   ;; defaults to the most recent define
   :hints ...
   :rule-classes ...)</pre> 
 
<p>will then expand to this:</p> 
 
<pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> a-theorem-about-my-function
  (<a href="ACL2____IMPLIES.html">implies</a> (something-about a b c)
     (<a href="ACL2____B_A2.html">b*</a> ((q (foo a b c))
          ((<a href="ACL2____MV.html">mv</a> ?d ?e ?f) (my-function a b c)))
       (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> e)
                (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> d)
                     (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> d))
                     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____SECOND.html">second</a> d) q)))))
  :hints ...
  :rule-classes ...)</pre> 
 
<p>The <span class="v">:hyp :guard</span> and <span class="v">:hyp :fguard</span> features of <a href="STD____RETURNS-SPECIFIERS.html">returns-specifiers</a> are also supported.</p> 
 
<p><span class="v">Defret</span> does <i>not</i> support the feature where a single function name 
specifies a type of a return value.  Perhaps we could support it for functions 
with a single return value.</p> 
 
<p>One limitation of <span class="v">defret</span> is that the conclusion term can't refer to a 
formal if there is a return value that has the same name.  To work around this, 
the <span class="v">:pre-bind</span> argument accepts a list of <a href="ACL2____B_A2.html">b*</a> bindings that occur 
before the binding of the return values.  You may also just want to not share 
names between your formals and returns.</p> 
 
<h3>Features</h3> 
 
<ul> 
 
<li>The return value names specified by <span class="v">:returns</span> for the function are 
bound in the body of the theorem.  This way if the function is changed to 
e.g. return an additional value, <span class="v">defret</span> forms don't necessarily need to 
change as long as the <span class="v">:returns</span> specifiers are kept up to date.</li> 
 
<li>The return value names are substituted for appropriate expressions in the 
rule-classes.  E.g., in the above example, an occurrence of <span class="v">d</span> in the hints 
or rule-classes would be replaced by <span class="v">(<a href="ACL2____MV-NTH.html">mv-nth</a> 0 (my-function a b c))</span>.  This 
substitution may optionally also be applied to the hints by setting the 
<span class="v">:hints-sub-returnnames</span> option; see <a href="STD____RETURNS-SPECIFIERS.html">returns-specifiers</a>.</li> 
 
<li>Any symbol named <span class="v">&lt;CALL&gt;</span> (in any package) is replaced by the call of 
the function in the body, hints, and rule-classes.  Similarly any symbol named 
<span class="v">&lt;FN&gt;</span> is replaced by the function name or macro alias; additionally, any 
symbol named <span class="v">&lt;FN!&gt;</span> is replaced by strictly the function name (not the 
macro alias).</li> 
 
<li>The substrings <span class="v">"&lt;FN&gt;"</span> and <span class="v">"&lt;FN!&gt;"</span> are replaced in the theorem name by 
the names of the function/macro alias and function (respectively), so that 
similar theorems for different functions can be copied/pasted without editing 
the names.</li> 
 
</ul> 
 

</body>
</html>
