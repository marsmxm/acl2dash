<html>
<head>
<meta charset="UTF-8">
<title>Getting-started</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=VL____GETTING-STARTED">Click for Getting-started in the Full Manual</a></h3>

<p>An introduction to VL, with suggested starting points for how to get 
started with evaluating it for use in your own projects.</p><h3>Introduction</h3> 
 
<p><b>VL</b> is an <a href="ACL2____ACL2.html">ACL2</a> library for working with <a href="http://en.wikipedia.org/wiki/SystemVerilog" target="_blank"><nobr>SystemVerilog<img src="../Icon_External_Link.png" title="External link to http://en.wikipedia.org/wiki/SystemVerilog"></nobr></a> (and also 
regular <a href="http://en.wikipedia.org/wiki/Verilog" target="_blank"><nobr>Verilog<img src="../Icon_External_Link.png" title="External link to http://en.wikipedia.org/wiki/Verilog"></nobr></a>) source 
code, developed at Centaur Technology by Jared Davis and Sol Swords.  At a high 
level, VL includes:</p> 
 
<ul> 
 <li>An internal representation for Verilog <a href="VL____SYNTAX.html">syntax</a>,</li> 
 <li>A <a href="VL____LOADER.html">loader</a> for parsing Verilog source code into this representation,</li> 
 <li>Utilities for inspecting, analyzing, and manipulating these designs,</li> 
 <li>Various <a href="VL____TRANSFORMS.html">transforms</a> that can simplify these designs, and</li> 
 <li>Pretty-printing and other report-generation functions.</li> 
</ul> 
 
<p>Much of VL is general purpose Verilog processing code that is independent of 
particular analysis or back-end tool.  This approach has allowed us to use VL 
to implement a family of Verilog-related tools.  Here are some examples:</p> 
 
<ul> 
 
<li>VL can build <a href="ACL2____SV.html">sv</a> models of Verilog modules for formal 
verification with ACL2.  This is the basis for much of Centaur's formal 
verification efforts.</li> 
 
<li>The VL <a href="VL____KIT.html">kit</a> is a standalone command-line program that you can build 
on top of ACL2 and VL.  It provides some high-level commands that you can use 
to do things like lint your design directly from the command line.  It also 
provides an interactive shell for an instant way to start up ACL2 with VL 
already loaded.</li> 
 
<li>VL has been used to build a web-based ``module browser'' that lets you see 
the source code for our modules with, e.g., hyperlinks for navigating between 
wires and following wires.  This is now integrated into the VL <a href="VL____KIT.html">kit</a>; see 
<a href="VL____VL-SERVER.html">vl-server</a>.</li> 
 
<li>(unreleased) We have used VL to implement <i>samev</i>, a sequential 
equivalence checking tool with a tick-based timing model that handles both RTL 
and transistor-level constructs.</li> 
 
<li>(unreleased) We have used it to implement <i>VL-Mangle</i>, a web-based 
Verilog refactoring tool.  A paper describing this tool can be found in: Jared 
Davis. <a href="https://www.kookamara.com/jared/2013-doform-embedding.pdf" target="_blank"><nobr>Embedding 
ACL Models in End-User Applications<img src="../Icon_External_Link.png" title="External link to https://www.kookamara.com/jared/2013-doform-embedding.pdf"></nobr></a>.  In <a href="http://www.cs.bham.ac.uk/research/projects/formare/events/aisb2013/" target="_blank"><nobr>Do-Form 
2013<img src="../Icon_External_Link.png" title="External link to http://www.cs.bham.ac.uk/research/projects/formare/events/aisb2013/"></nobr></a>.  April, 2013, Exeter, UK.</li> 
 
</ul> 
 
<p>We imagine that parts of VL may be useful for implementing other 
SystemVerilog processing tools.</p> 
 
 
<h3>Starting Points</h3> 
 
<p>The first step in using VL for anything is probably to try to get it to 
parse your design; see the documentation for the <a href="VL____LOADER.html">loader</a>.  You may want 
to read the notes about <a href="VL____SUPPORTED-CONSTRUCTS.html">supported-constructs</a>.</p> 
 
<p>Once you have parsed your design (or at least some portion of it) you will 
have a list of modules.  You might want to at least glance through the 
documentation for <a href="VL____SYNTAX.html">syntax</a>, which explains how modules are represented. 
This may be particularly useful if you are going to write your own analysis 
tools.</p> 
 
<p>You may find it useful to pretty-print modules, see for instance <a href="VL____VL-PPCS-MODULE.html">vl-ppcs-module</a> and perhaps more generally the VL <a href="VL____PRINTER.html">printer</a>.</p> 
 
<p>After getting a feel for how modules are represented, it would be good to 
look at the available <a href="VL____TRANSFORMS.html">transforms</a>.  For instance, you might look at the 
code for <span class="v">run-vl-lint-main</span> to see a transformation sequence geared toward 
linting.  You might also see <a href="VL____VL-DESIGN-_E3SV-DESIGN.html">vl-design-&gt;sv-design</a> to see how the new 
<a href="ACL2____SV.html">sv</a> flow works.</p> 
 
<p>If you are going to write any Verilog-processing tools of your own, you 
should probably read through how VL deals with <a href="VL____WARNINGS.html">warnings</a> and then take a 
look at <a href="VL____MLIB.html">mlib</a>, which provides many functions for working with expressions 
and ranges, finding modules and module items, working with the module 
hierarchy, generating fresh names, and working with modules at the bit 
level.</p>
</body>
</html>
