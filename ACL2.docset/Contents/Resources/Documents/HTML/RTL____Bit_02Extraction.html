<html>
<head>
<meta charset="UTF-8">
<title>Bit Extraction</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=RTL____Bit_02Extraction">Click for Bit Extraction in the Full Manual</a></h3>

<p>Bit Extraction</p><h3>Definitions and Theorems</h3><p><b>Function: </b>bitn</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> bitn (x n)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x) (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n))))
       (<a href="ACL2____MBE.html">mbe</a> :logic (bits x n n)
            :exec (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EVENP.html">evenp</a> (<a href="COMMON-LISP____ASH.html">ash</a> x (<a href="COMMON-LISP____-.html">-</a> n))) 0 1)))</pre><p><b>Theorem: </b>bitn-nonnegative-integer</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bitn-nonnegative-integer
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> (bitn x n))
             (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 0 (bitn x n)))
        :rule-classes (:type-prescription))</pre><p><b>Theorem: </b>bits-n-n-rewrite</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bits-n-n-rewrite
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (bits x n n) (bitn x n)))</pre><p><b>Theorem: </b>bitn-def</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bitn-def
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____CASE-SPLIT.html">case-split</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (bitn x n)
                        (<a href="COMMON-LISP____MOD.html">mod</a> (fl (<a href="COMMON-LISP_____F2.html">/</a> x (<a href="COMMON-LISP____EXPT.html">expt</a> 2 n))) 2))))</pre><p><b>Theorem: </b>bitn-rec-0</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bitn-rec-0
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (bitn x 0) (<a href="COMMON-LISP____MOD.html">mod</a> x 2))))</pre><p><b>Theorem: </b>bitn-rec-pos</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     bitn-rec-pos
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> 0 n)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (bitn x n)
                     (bitn (fl (<a href="COMMON-LISP_____F2.html">/</a> x 2)) (<a href="COMMON-LISP____1-.html">1-</a> n))))
     :rule-classes ((:definition :controller-alist ((bitn t t)))))</pre><p><b>Theorem: </b>bitn-0-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bitn-0-1
        (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (bitn x n) 0)
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (bitn x n) 1))
        :rule-classes nil)</pre><p><b>Theorem: </b>bitn-bvecp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bitn-bvecp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 1 k) (<a href="ACL2____CASE-SPLIT.html">case-split</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> k)))
                 (bvecp (bitn x n) k)))</pre><p><b>Theorem: </b>bitn-bvecp-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    bitn-bvecp-forward (bvecp (bitn x n) 1)
    :rule-classes ((:forward-chaining :trigger-terms ((bitn x n)))))</pre><p><b>Theorem: </b>bitn-neg</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bitn-neg
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> n 0) (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (bitn x n) 0)))</pre><p><b>Theorem: </b>bitn-0</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bitn-0 (<a href="COMMON-LISP____EQUAL.html">equal</a> (bitn 0 k) 0))</pre><p><b>Theorem: </b>bitn-bvecp-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bitn-bvecp-1
        (<a href="ACL2____IMPLIES.html">implies</a> (bvecp x 1)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (bitn x 0) x)))</pre><p><b>Theorem: </b>bitn-bitn-0</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bitn-bitn-0
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (bitn (bitn x n) 0) (bitn x n)))</pre><p><b>Theorem: </b>bitn-mod</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bitn-mod
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> k n) (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n) (<a href="COMMON-LISP____INTEGERP.html">integerp</a> k))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (bitn (<a href="COMMON-LISP____MOD.html">mod</a> x (<a href="COMMON-LISP____EXPT.html">expt</a> 2 n)) k)
                        (bitn x k))))</pre><p><b>Theorem: </b>bvecp-bitn-0</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bvecp-bitn-0
        (<a href="ACL2____IMPLIES.html">implies</a> (bvecp x n)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (bitn x n) 0)))</pre><p><b>Theorem: </b>neg-bitn-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> neg-bitn-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> x 0)
                      (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> x (<a href="COMMON-LISP____-.html">-</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 n))))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (bitn x n) 1)))</pre><p><b>Theorem: </b>bitn-minus-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bitn-minus-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____NATP.html">natp</a> i)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (bitn -1 i) 1)))</pre><p><b>Theorem: </b>neg-bitn-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> neg-bitn-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> k)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> k n)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> x (<a href="COMMON-LISP____-.html">-</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 k) (<a href="COMMON-LISP____EXPT.html">expt</a> 2 n)))
                      (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> x (<a href="COMMON-LISP____-.html">-</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 n))))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (bitn x k) 0)))</pre><p><b>Theorem: </b>neg-bitn-0</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> neg-bitn-0
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x)
                      (<a href="ACL2____NATP.html">natp</a> n)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> x (<a href="COMMON-LISP____-.html">-</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 n)))
                      (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> x (<a href="COMMON-LISP____-.html">-</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP____1_B2.html">1+</a> n)))))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (bitn x n) 0)))</pre><p><b>Theorem: </b>bitn-shift-up</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bitn-shift-up
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n) (<a href="COMMON-LISP____INTEGERP.html">integerp</a> k))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (bitn (<a href="COMMON-LISP_____A2.html">*</a> x (<a href="COMMON-LISP____EXPT.html">expt</a> 2 k)) (<a href="COMMON-LISP_____B2.html">+</a> n k))
                        (bitn x n))))</pre><p><b>Theorem: </b>bitn-shift-down</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bitn-shift-down
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> i) (<a href="COMMON-LISP____INTEGERP.html">integerp</a> k))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (bitn (fl (<a href="COMMON-LISP_____F2.html">/</a> x (<a href="COMMON-LISP____EXPT.html">expt</a> 2 k))) i)
                        (bitn x (<a href="COMMON-LISP_____B2.html">+</a> i k)))))</pre><p><b>Theorem: </b>bitn-bits</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bitn-bits
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> k (<a href="COMMON-LISP____-.html">-</a> i j))
                      (<a href="ACL2____CASE-SPLIT.html">case-split</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 0 k))
                      (<a href="ACL2____CASE-SPLIT.html">case-split</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> i))
                      (<a href="ACL2____CASE-SPLIT.html">case-split</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> j))
                      (<a href="ACL2____CASE-SPLIT.html">case-split</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> k)))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (bitn (bits x i j) k)
                        (bitn x (<a href="COMMON-LISP_____B2.html">+</a> j k)))))</pre><p><b>Theorem: </b>bitn-plus-bits</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bitn-plus-bits
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> m n) (<a href="COMMON-LISP____INTEGERP.html">integerp</a> m) (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n))
                 (<a href="COMMON-LISP_____D3.html">=</a> (bits x n m)
                    (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP_____A2.html">*</a> (bitn x n) (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP____-.html">-</a> n m)))
                       (bits x (<a href="COMMON-LISP____1-.html">1-</a> n) m))))
        :rule-classes nil)</pre><p><b>Theorem: </b>bits-plus-bitn</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bits-plus-bitn
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> m n) (<a href="COMMON-LISP____INTEGERP.html">integerp</a> m) (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n))
                 (<a href="COMMON-LISP_____D3.html">=</a> (bits x n m)
                    (<a href="COMMON-LISP_____B2.html">+</a> (bitn x m) (<a href="COMMON-LISP_____A2.html">*</a> 2 (bits x n (<a href="COMMON-LISP____1_B2.html">1+</a> m))))))
        :rule-classes nil)</pre><p><b>Function: </b>sumbits</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> sumbits (x n)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x) (<a href="ACL2____NATP.html">natp</a> n))))
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> n)
           0
           (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP_____A2.html">*</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP____1-.html">1-</a> n)) (bitn x (<a href="COMMON-LISP____1-.html">1-</a> n)))
              (sumbits x (<a href="COMMON-LISP____1-.html">1-</a> n)))))</pre><p><b>Theorem: </b>sumbits-bits</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sumbits-bits
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x) (<a href="ACL2____NATP.html">natp</a> n) (<a href="COMMON-LISP_____E3.html">&gt;</a> n 0))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (sumbits x n)
                        (bits x (<a href="COMMON-LISP____1-.html">1-</a> n) 0))))</pre><p><b>Theorem: </b>sumbits-thm</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sumbits-thm
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (bvecp x n) (<a href="ACL2____NATP.html">natp</a> n) (<a href="COMMON-LISP_____E3.html">&gt;</a> n 0))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (sumbits x n) x)))</pre><p><b>Function: </b>all-bits-p</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> all-bits-p (b k)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____POSP.html">posp</a> k)
           (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> b)
                (all-bits-p (<a href="COMMON-LISP____CDR.html">cdr</a> b) (<a href="COMMON-LISP____1-.html">1-</a> k))
                (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> b) 0)
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> b) 1)))
           (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> b) (<a href="COMMON-LISP____EQUAL.html">equal</a> k 0))))</pre><p><b>Function: </b>sum-b</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> sum-b (b k)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (all-bits-p b k)))
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> k)
           0
           (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP_____A2.html">*</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP____1-.html">1-</a> k)) (<a href="COMMON-LISP____NTH.html">nth</a> (<a href="COMMON-LISP____1-.html">1-</a> k) b))
              (sum-b b (<a href="COMMON-LISP____1-.html">1-</a> k)))))</pre><p><b>Theorem: </b>sum-bitn</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> sum-bitn
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (all-bits-p b n) (<a href="ACL2____NATP.html">natp</a> k) (<a href="COMMON-LISP_____C3.html">&lt;</a> k n))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (bitn (sum-b b n) k) (<a href="COMMON-LISP____NTH.html">nth</a> k b))))</pre><p><b>Function: </b>bit-diff</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> bit-diff (x y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x))
               (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> y))
               (<a href="COMMON-LISP_____D3.html">=</a> x y))
           nil
           (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____D3.html">=</a> (bitn x 0) (bitn y 0))
               (<a href="COMMON-LISP____1_B2.html">1+</a> (bit-diff (fl (<a href="COMMON-LISP_____F2.html">/</a> x 2)) (fl (<a href="COMMON-LISP_____F2.html">/</a> y 2))))
               0)))</pre><p><b>Theorem: </b>bit-diff-diff</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bit-diff-diff
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> y)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP_____D3.html">=</a> x y)))
                 (<a href="COMMON-LISP____LET.html">let</a> ((n (bit-diff x y)))
                      (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> n)
                           (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP_____D3.html">=</a> (bitn x n) (bitn y n))))))
        :rule-classes nil)</pre><p><b>Theorem: </b>bvecp-bitn-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bvecp-bitn-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (bvecp x (<a href="COMMON-LISP____1_B2.html">1+</a> n))
                      (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 n) x)
                      (<a href="ACL2____NATP.html">natp</a> n))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (bitn x n) 1)))</pre><p><b>Theorem: </b>bvecp-bitn-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bvecp-bitn-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (bvecp x n)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> k n)
                      (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="COMMON-LISP____-.html">-</a> (<a href="COMMON-LISP____EXPT.html">expt</a> 2 n) (<a href="COMMON-LISP____EXPT.html">expt</a> 2 k)) x)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> k))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (bitn x k) 1))
        :rule-classes ((:rewrite :match-free :all)))</pre><p><b>Theorem: </b>bitn-expt</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bitn-expt
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____CASE-SPLIT.html">case-split</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (bitn (<a href="COMMON-LISP____EXPT.html">expt</a> 2 n) n) 1)))</pre><p><b>Theorem: </b>bitn-expt-0</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bitn-expt-0
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> i n))
                      (<a href="ACL2____CASE-SPLIT.html">case-split</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> i)))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (bitn (<a href="COMMON-LISP____EXPT.html">expt</a> 2 i) n) 0)))</pre><p><b>Theorem: </b>bitn-plus-expt-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bitn-plus-expt-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____RATIONALP.html">rationalp</a> x) (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n))
                 (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (bitn (<a href="COMMON-LISP_____B2.html">+</a> x (<a href="COMMON-LISP____EXPT.html">expt</a> 2 n)) n)
                             (bitn x n))))
        :rule-classes nil)</pre><p><b>Theorem: </b>bitn-plus-mult</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bitn-plus-mult
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> n m) (<a href="COMMON-LISP____INTEGERP.html">integerp</a> m) (<a href="COMMON-LISP____INTEGERP.html">integerp</a> k))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (bitn (<a href="COMMON-LISP_____B2.html">+</a> x (<a href="COMMON-LISP_____A2.html">*</a> k (<a href="COMMON-LISP____EXPT.html">expt</a> 2 m))) n)
                        (bitn x n))))</pre><p><b>Theorem: </b>bitn-plus-mult-rewrite</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bitn-plus-mult-rewrite
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SYNTAXP.html">syntaxp</a> (<a href="ACL2____QUOTEP.html">quotep</a> c))
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> c (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP____1_B2.html">1+</a> n))) 0))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (bitn (<a href="COMMON-LISP_____B2.html">+</a> c x) n) (bitn x n))))</pre> 
 

</body>
</html>
