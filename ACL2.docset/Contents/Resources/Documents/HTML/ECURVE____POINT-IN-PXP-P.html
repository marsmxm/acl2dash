<html>
<head>
<meta charset="UTF-8">
<title>Point-in-pxp-p</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ECURVE____POINT-IN-PXP-P">Click for Point-in-pxp-p in the Full Manual</a></h3>

<p>Check if a point is in the cartesian product of a prime field, 
          or it is the point at infinity.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(point-in-pxp-p point p) → *</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">point</span> — <font color="#606060">Guard <span class="v">(<a href="ECURVE____POINTP.html">pointp</a> point)</span>.</font>
</dd> 
  <dd>
<span class="tt">p</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____NATP.html">natp</a> p)</span>.</font>
</dd> 
 
</dl></div> 
<p>This predicate checks if a point (as defined in <span class="tt"><a href="ECURVE____POINTP.html">pointp</a></span>) 
     is either the point at infity, 
     or is in the cartesian product 
     \{0, \ldots, p-1\} \times \{0, \ldots, p-1\}, 
     where p \geq 2. 
     In the context of elliptic curves, p is the prime, 
     and this predicate checks if the point, if finite, 
     is in the ``plane'' of the curve.</p><p>The purpose of this predicate is to provide a preliminary constraint 
     for points of curves in specific fields (described by p). 
     Thus, we must include the point at infinity in this predicate, 
     even though it is not actually on the the aforementioned plane.</p><p>We do not require the parameter <span class="v">p</span> to be prime here. 
     It suffices, for the purpose of defining this predicate, 
     for <span class="v">p</span> to be an integer that is at least 2.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>point-in-pxp-p</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> point-in-pxp-p (<a href="ECURVE____POINT.html">point</a> p)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ECURVE____POINTP.html">pointp</a> point) (<a href="ACL2____NATP.html">natp</a> p))))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 2 p)))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'point-in-pxp-p))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____EQ.html">eq</a> point :infinity)
                (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="COMMON-LISP____CAR.html">car</a> point) p)
                     (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="COMMON-LISP____CDR.html">cdr</a> point) p)))))</pre> 
<p><b>Theorem: </b>point-in-pxp-p-of-infinity</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> point-in-pxp-p-of-infinity
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> 0 p)
                 (<a href="ECURVE____POINT-IN-PXP-P.html">point-in-pxp-p</a> :infinity p)))</pre> 

</body>
</html>
