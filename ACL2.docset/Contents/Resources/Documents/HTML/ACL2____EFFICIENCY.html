<html>
<head>
<meta charset="UTF-8">
<title>Efficiency</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____EFFICIENCY">Click for Efficiency in the Full Manual</a></h3>

<p>Efficiency considerations</p><p>This topic is a grab-bag of ideas for the efficient use of ACL2, 
 including proofs and programming.  It is far from complete, and <a href="ACL2____TIPS.html">tips</a> 
 for using ACL2 effectively may be found throughout the <a href="COMMON-LISP____DOCUMENTATION.html">documentation</a>. 
 The present topic will, ideally, improve over time, both in its content and in 
 its organization.  Please contribute!</p> 
 
 <p>Here we discuss primarily time efficiency rather than space efficiency. 
 You can time forms using <span class="tt"><a href="ACL2____TIME_42.html">time$</a></span>.  That may show you that your tweaks 
 to proof scripts or function definitions don't make a noticeable difference! 
 We focus below on some techniques that have a reasonable chance of making a 
 difference.</p> 
 
 <h3>Proof efficiency</h3> 
 
 <p>Perhaps the most basic idea for carrying out proofs efficiently is to use 
 rewriting effectively; see <a href="ACL2____INTRODUCTION-TO-THE-THEOREM-PROVER.html">introduction-to-the-theorem-prover</a> and, in 
 particular, the sections on rewriting.  Here we mention just a few common ways 
 to improve the efficiency of rewriting in ACL2.</p> 
 
 <ul> 
 
 <li>Consider minimizing the number of hypotheses of a rule.  See <a href="ACL2____REMOVE-HYPS.html">remove-hyps</a> for a tool that can help with that.</li> 
 
 <li> Manage <a href="ACL2____THEORIES.html">theories</a> effectively.  See <a href="ACL2____ACCUMULATED-PERSISTENCE.html">accumulated-persistence</a> 
 for a way to identify rules that might best be <a href="ACL2____DISABLE.html">disable</a>d.  In 
 particular, it can be useful to disable functions whose expansions generate 
 large case splits (see <a href="ACL2____SPLITTER.html">splitter</a>); otherwise, sometimes it can be useful 
 to limit case-splits with <span class="tt"><a href="ACL2____SET-CASE-SPLIT-LIMITATIONS.html">set-case-split-limitations</a></span>.</li> 
 
 <li>When many similar proofs are being performed (for example, for families of 
 similar theorems generated by macros), the tool <a href="ACL2____REMOVABLE-RUNES.html">removable-runes</a> may be 
 helpful.</li> 
 
 </ul> 
 
 <p>Sometimes rewriting is slow for inherent algorithmic reasons.  For example, 
 if you have a binary function, <span class="v">op</span>, and you prove the <a href="ACL2____REWRITE.html">rewrite</a> rules 
 <span class="v">(<a href="COMMON-LISP____EQUAL.html">equal</a> (op x y) (op y x)</span>) and <span class="v">(<a href="COMMON-LISP____EQUAL.html">equal</a> (op x (op y z)) (op y (op x
 z)))</span>, then ACL2 will use an <span class="v">n^2</span> algorithm to put arguments in order, 
 essentially with bubblesort, in a sequence like this:</p> 
 
 <pre class="code">(op d (op c (op b a)))
(op d (op c (op a b)))
(op d (op a (op c b)))
(op d (op a (op b c)))
(op a (op d (op b c)))
(op a (op b (op d c)))
(op a (op b (op c d)))</pre> 
 
 <p>In such a case, you may find it very helpful to create a suitable <a href="ACL2____META.html">meta</a> rule or a <a href="ACL2____CLAUSE-PROCESSOR.html">clause-processor</a> rule, to implement an <span class="v">n*log(n)</span> 
 algorithm.  You may consider creating calls of <span class="tt"><a href="ACL2____HIDE.html">hide</a></span> to avoid exploring 
 terms that are in the expected form.  Calls of <span class="v">hide</span> may be removed when 
 ready either with a suitable <span class="v">:expand</span> hint or by enabling a <a href="ACL2____REWRITE.html">rewrite</a> 
 rule <span class="v">(<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____HIDE.html">hide</a> x) x)</span>.</p> 
 
 <p>We conclude this section with ways to tweak the ACL2 system to speed up 
 slow proofs.  These can be especially useful if very large terms are involved. 
 One simple thing to try is to turn off the rewrite cache.</p> 
 
 <pre class="code">(<a href="ACL2____SET-RW-CACHE-STATE.html">set-rw-cache-state</a> nil)</pre> 
 
 <p>Some system behaviors can be modified using <span class="tt"><a href="ACL2____DEFATTACH-SYSTEM.html">defattach-system</a></span> 
 — also see <a href="ACL2____SYSTEM-ATTACHMENTS.html">system-attachments</a> — typically by modifying 
 heuristics.  You can find all attachments by evaluating <span class="v">(<a href="ACL2____ALL-ATTACHMENTS.html">all-attachments</a> (<a href="ACL2____W.html">w</a>
 state))</span> and all built-in such attachments by evaluating <span class="v">(global-val
 'attachments-at-ground-zero (<a href="ACL2____W.html">w</a> state))</span>, except for a few exceptions (see 
 <a href="ACL2____DEFATTACH.html">defattach</a>).  For most of these, however, you will need to consult the 
 ACL2 source files for relevant information.  Here are some key examples of how 
 to modify system behavior.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> constant-nil-function-arity-2 (x y)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :mode :logic :guard t) (<a href="COMMON-LISP____IGNORE.html">ignore</a> x y))
  nil)
(<a href="ACL2____DEFATTACH-SYSTEM.html">defattach-system</a> too-many-ifs-post-rewrite
  constant-nil-function-arity-2)
(<a href="ACL2____DEFATTACH-SYSTEM.html">defattach-system</a> too-many-ifs-pre-rewrite
  constant-nil-function-arity-2)
(<a href="ACL2____DEFATTACH-SYSTEM.html">defattach-system</a> quick-and-dirty-srs
  constant-nil-function-arity-2)</pre> 
 
 <p>In some cases books may provide more sophisticated uses of <span class="tt"><a href="ACL2____DEFATTACH-SYSTEM.html">defattach-system</a></span> (or <span class="tt"><a href="ACL2____DEFATTACH.html">defattach</a></span>).  For a key example, see <span class="tt"><a href="ACL2____USE-TRIVIAL-ANCESTORS-CHECK.html">use-trivial-ancestors-check</a></span>.</p> 
 
 <p>Another way to speed up system functions can be by using <a href="ACL2____MEMOIZATION.html">memoization</a>.  Here is an example from 
 <span class="v">books/projects/stateman/stateman22.lisp</span>.</p> 
 
 <pre class="code">(<a href="ACL2____MEMOIZE.html">memoize</a> 'acl2::sublis-var1
         :condition '(<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NULL.html">null</a> acl2::alist)
                          (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::form)
                          (<a href="COMMON-LISP____EQ.html">eq</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::form) 'HIDE)))</pre> 
 
 <p>See <a href="ACL2____MEMOIZED-PROVER-FNS.html">memoized-prover-fns</a> for a convenient way to do such memoization 
 that automatically clears memoization tables after each event.  (Also see 
 <a href="ACL2____CLEAR-MEMOIZE-TABLE.html">clear-memoize-table</a> and <a href="ACL2____CLEAR-MEMOIZE-TABLES.html">clear-memoize-tables</a>, and see <a href="ACL2____HONS-WASH.html">hons-wash</a> for another way to clean up after memoization.)  Comments in the 
 book <span class="v">books/tools/memoize-prover-fns.lisp</span> note a reduction in proof time 
 from 4200 seconds to 49 seconds for one example by memoizing some system 
 functions.  Those comments also have some discussion about which system 
 functions to consider memoizing.  Perhaps ACL2 users will contribute further 
 documentation on which system functions to memoize for efficiency.</p> 
 
 <p>The following may be helpful at the level of book certification, and are 
 discussed in :doc certify-book-debug.</p> 
 
 <pre class="code">(<a href="ACL2____SET-SERIALIZE-CHARACTER-SYSTEM.html">set-serialize-character-system</a> nil)
(<a href="ACL2____SET-BAD-LISP-CONSP-MEMOIZE.html">set-bad-lisp-consp-memoize</a> nil)
(<a href="ACL2____SET-INHIBIT-OUTPUT-LST.html">set-inhibit-output-lst</a> '(<a href="ACL2____PROOF-TREE.html">proof-tree</a> event))</pre> 
 
 <h3>Programming efficiency</h3> 
 
 <p>Ideas for efficient programming include the use of compilation for host 
 Lisps (other than CCL and SBCL, which compile automatically); see <a href="ACL2____COMP.html">comp</a> 
 and <a href="ACL2____SET-COMPILE-FNS.html">set-compile-fns</a>.  For <a href="ACL2____LOGIC.html">logic</a>-mode functions, verify <a href="ACL2____GUARD.html">guard</a>s if feasible; otherwise consider using <a href="ACL2____PROGRAM.html">program</a>-mode wrappers 
 (see <a href="ACL2____PROGRAM-WRAPPER.html">program-wrapper</a>).  Consider writing recursive definitions using 
 tail recursion when possible.  In some cases the use of hash cons, 
 memoization, or fast alists may reduce computation time dramatically; see 
 <a href="ACL2____HONS-AND-MEMOIZATION.html">hons-and-memoization</a>.  Single-threaded objects (see <a href="ACL2____STOBJ.html">stobj</a>), 
 <a href="ACL2____ARRAYS.html">arrays</a>, multiple-value return (see <a href="ACL2____MV.html">mv</a> and <a href="ACL2____MV-LET.html">mv-let</a>), and 
 <span class="tt"><a href="ACL2____MBE.html">mbe</a></span> are helpful programming constructs provided by ACL2 for efficient 
 execution.  Some built-in functions are constructed for efficiency; see for 
 example <span class="tt"><a href="ACL2____CONS-WITH-HINT.html">cons-with-hint</a></span> to reduce consing and <a href="ACL2____READ-FILE-INTO-STRING.html">read-file-into-string</a> for obtaining the contents of a file quickly.</p> 
 
 <p>You might find <span class="tt"><a href="COMMON-LISP____TYPE.html">type</a></span> <a href="COMMON-LISP____DECLARATION.html">declaration</a>s to be useful.  In 
 particular, if your host Lisp is GCL then the use of the declaration 
 <span class="v">(signed-byte 64)</span>, or any stronger declaration (e.g., <span class="v">(unsigned-byte
 63)</span>, <span class="v">(signed-byte 12)</span>, or <span class="v">(integer 0 100)</span>), can provide dramatic 
 performance improvements in compiled code.  You can peruse that code using 
 <a href="ACL2____DISASSEMBLE_42.html">disassemble$</a>.</p> 
 
 <p>Of course, if a programming technique or construct is useful for efficient 
 execution in Common Lisp and it is supported by ACL2, then it is useful for 
 efficient execution in ACL2.  In particular, consider using <span class="tt"><a href="COMMON-LISP____TYPE.html">type</a></span> <a href="COMMON-LISP____DECLARATION.html">declaration</a>s for numbers in place of <span class="tt"><a href="ACL2____XARGS.html">xargs</a></span> <span class="v">:</span><span class="tt"><a href="ACL2____GUARD.html">guard</a></span>.</p> 
 
 <h3>Miscellaneous efficiency ideas</h3> 
 
 <p>The use of <span class="tt"><a href="ACL2____MAKE-EVENT.html">make-event</a></span> can sometimes reduce computation time; see 
 for example <a href="ACL2____USING-TABLES-EFFICIENTLY.html">using-tables-efficiently</a> and <a href="ACL2____DEFCONSTS.html">defconsts</a>.</p> 
 
 <p>You can <a href="ACL2____PROFILE.html">profile</a> functions to see where time is being spent during 
 proofs or when computing with user-defined functions.  Sometimes it is even 
 useful to profile virtually all ACL2 source functions, or even virtually all 
 user-defined functions.  That can be done as follows — also see <a href="ACL2____PROFILE-ACL2.html">profile-ACL2</a> and <a href="ACL2____PROFILE-ALL.html">profile-all</a> — but note that when the problem is 
 slow proofs, then since the results will display time spent in various ACL2 
 prover routines, those results might not be helpful to most users.</p> 
 
 <pre class="code">(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "centaur/memoize/old/profile" :dir :system)
(<a href="ACL2____PROFILE-ACL2.html">profile-acl2</a>) ; or, (<a href="ACL2____PROFILE-ALL.html">profile-all</a>) to include user-defined functions
[[Then run a slow form.]]
(<a href="ACL2____MEMSUM.html">memsum</a>) ; shows where time is spent</pre> 
 
 <p>For computations and proofs that may benefit from parallel computation, you 
 could build the variant ACL2(p) of ACL2.  See <a href="ACL2____PARALLELISM.html">parallelism</a>.</p> 
 
 
</body>
</html>
