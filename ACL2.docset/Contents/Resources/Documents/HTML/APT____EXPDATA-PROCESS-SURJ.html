<html>
<head>
<meta charset="UTF-8">
<title>Expdata-process-surj</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=APT____EXPDATA-PROCESS-SURJ">Click for Expdata-process-surj in the Full Manual</a></h3>

<p>Process a <span class="v">surj</span> component of the <span class="v">surjmaps</span> input.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(expdata-process-surj surj k old$ 
                      verify-guards$ names-to-avoid ctx state) 
 
   
(mv erp result state)</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">surj</span>  The <span class="v">surjk</span> component of <span class="v">surjmaps</span>.</dd> 
  <dd>
<span class="tt">k</span>  The <span class="v">k</span> in <span class="v">surjk</span>.<br><font color="#606060">Guard <span class="v">(<a href="ACL2____POSP.html">posp</a> k)</span>.</font>
</dd> 
  <dd>
<span class="tt">old$</span>  <font color="#606060">Guard <span class="v">(<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> old$)</span>.</font>
</dd> 
  <dd>
<span class="tt">verify-guards$</span>  <font color="#606060">Guard <span class="v">(<a href="ACL2____BOOLEANP.html">booleanp</a> verify-guards$)</span>.</font>
</dd> 
  <dd>
<span class="tt">names-to-avoid</span>  <font color="#606060">Guard <span class="v">(<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> names-to-avoid)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">result</span>  A tuple <span class="v">(surjmap updated-names-to-avoid)</span> 
                        satisfying <span class="v">(typed-tuplep expdata-surjmapp
                                                    symbol-listp
                                                    result)</span>.</dd> 
 
</dl></div> 
<p>If <span class="v">surj</span> is the name of an existing <span class="tt"><a href="ACL2____DEFSURJ.html">defsurj</a></span>, 
     the <span class="v">names-to-avoid</span> argument is returned unchanged, 
     because we are not generating any fresh theorem names in this case.</p><p>If instead <span class="v">surj</span> is a list 
     <span class="v">(oldp newp forth back)</span> or <span class="v">(oldp newp forth back :hints ...)</span>, 
     the <span class="v">names-to-avoid</span> argument is augmented with 
     the names of the theorems that 
     will be generated by the local <span class="tt"><a href="ACL2____DEFSURJ.html">defsurj</a></span>.</p><p>When <span class="v">surj</span> is the name of an existing <span class="tt"><a href="ACL2____DEFSURJ.html">defsurj</a></span>, 
     to check whether its <span class="v">:guard-thms</span> is <span class="v">t</span>, 
     which is required when <span class="v">verify-guards$</span> is <span class="v">t</span>, 
     we check whether one of the <span class="v">...-guard</span> theorems 
     recorded in the <span class="tt"><a href="ACL2____DEFSURJ.html">defsurj</a></span> is not <span class="v">nil</span>. 
     We pick <span class="v">doma-guard</span>, 
     but any of the other three would work as well.</p><p>When <span class="v">surj</span> is not the name of an existing <span class="tt"><a href="ACL2____DEFSURJ.html">defsurj</a></span>, 
     and instead we generate a local one as part of <span class="tt"><a href="APT____EXPDATA.html">expdata</a></span>, 
     we use <span class="tt"><a href="ACL2____DEFSURJ.html">defsurj</a></span>'s input processing code, 
     and then we check that the functions are all unary and single-valued; 
     given the constraints already checked 
     by the <span class="tt"><a href="ACL2____DEFSURJ.html">defsurj</a></span> input processing code, 
     here it suffices to check that the two domains are unary. 
     We cannot just generate the <span class="tt"><a href="ACL2____DEFSURJ.html">defsurj</a></span> later; 
     we need the actual (translated) functions 
     to use them in the events generated by <span class="tt"><a href="APT____EXPDATA.html">expdata</a></span> proper. 
     When we call <span class="tt"><a href="ACL2____DEFSURJ.html">defsurj</a></span>'s input processing functions, 
     we set the context <span class="v">ctx</span> to the one for the <span class="tt"><a href="ACL2____DEFSURJ.html">defsurj</a></span> call, 
     so that the error message is appropriate. 
     (When the generated <span class="tt"><a href="ACL2____DEFSURJ.html">defsurj</a></span> call is actually submitted, 
     these input processing steps will be repeated, 
     but will succeed since they have been already performed here; 
     and they should be quite fast to execute.) 
     The name of this local <span class="tt"><a href="ACL2____DEFSURJ.html">defsurj</a></span> is a combination 
     that involves <span class="v">old</span> and <span class="v">k</span>, 
     to make the name of the <span class="tt"><a href="ACL2____DEFSURJ.html">defsurj</a></span> readable 
     (in case of errors due to failed applicability conditions) 
     and unique within the <span class="tt"><a href="ACL2____ENCAPSULATE.html">encapsulate</a></span> generated by <span class="tt"><a href="APT____EXPDATA.html">expdata</a></span>.</p><p>If the processing is successful, 
     we return the surjective mapping record specified by <span class="v">surj</span>.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>expdata-process-surj</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 expdata-process-surj
 (surj k old$
       verify-guards$ names-to-avoid ctx state)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (<a href="ACL2____STATE.html">state</a>)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____POSP.html">posp</a> k)
                             (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> old$)
                             (<a href="ACL2____BOOLEANP.html">booleanp</a> verify-guards$)
                             (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> names-to-avoid))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((__function__ 'expdata-process-surj))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
  (<a href="COMMON-LISP____IF.html">if</a>
   (<a href="COMMON-LISP____ATOM.html">atom</a> surj)
   (<a href="ACL2____B_A2.html">b*</a>
    (((<a href="ACL2____ER.html">er</a> &amp;)
      (<a href="ACL2____ENSURE-VALUE-IS-SYMBOL_42.html">ensure-value-is-symbol$</a>
       surj
       (<a href="ACL2____MSG.html">msg</a>
        "The ~n0 SURJ component ~x1 ~
                          of the second input ~
                          must be a symbol or a list. ~
                          Since it is an atom,"
        (<a href="COMMON-LISP____LIST.html">list</a> k)
        surj)
       t nil))
     (info (<a href="ACL2____DEFSURJ-LOOKUP.html">defsurj-lookup</a> surj (<a href="ACL2____W.html">w</a> state)))
     ((unless info)
      (<a href="ACL2____ER-SOFT_B2.html">er-soft+</a>
       ctx t nil
       "The ~n0 SURJ component of the second input, ~
                       which is the symbol ~x1, ~
                       must be the name of an existing DEFSURJ, ~
                       but no DEFSURJ with this name exists.  ~
                       See :DOC DEFSURJ."
       (<a href="COMMON-LISP____LIST.html">list</a> k)
       surj))
     ((<a href="ACL2____DEFMAPPING-INFO.html">defmapping-info</a> info) info)
     ((when (<a href="COMMON-LISP____AND.html">and</a> verify-guards$ (<a href="COMMON-LISP____NULL.html">null</a> info.doma-guard)))
      (<a href="ACL2____ER-SOFT_B2.html">er-soft+</a>
       ctx t nil
       "Since the :VERIFY-GUARDS input is T, ~
                       or it is (perhaps by default) :AUTO ~
                       and the target function ~x0 is guard-verified, ~
                       the DEFSURJ ~x1 must include ~
                       the guard-related theorems, ~
                       but it does not.  ~
                       See :DOC DEFSURJ."
       old$ surj))
     (surjmap
         (<a href="APT____MAKE-EXPDATA-SURJMAP.html">make-expdata-surjmap</a> :surjname surj
                               :localp nil
                               :oldp info.domb
                               :newp info.doma
                               :forth info.beta
                               :back info.alpha
                               :forth-image info.beta-image
                               :back-image info.alpha-image
                               :back-of-forth info.alpha-of-beta
                               :forth-injective info.alpha-injective
                               :oldp-guard info.domb-guard
                               :newp-guard info.doma-guard
                               :forth-guard info.beta-guard
                               :back-guard info.alpha-guard
                               :hints nil)))
    (<a href="ACL2____VALUE.html">value</a> (<a href="COMMON-LISP____LIST.html">list</a> surjmap names-to-avoid)))
   (<a href="ACL2____B_A2.html">b*</a>
    ((wrld (<a href="ACL2____W.html">w</a> state))
     (surjname (<a href="ACL2____PACKN-POS.html">packn-pos</a> (<a href="COMMON-LISP____LIST.html">list</a> 'defsurj-expdata- old$ '- k)
                          old$))
     (surjname
          (<a href="APT____EXPDATA-FRESH-DEFSURJ-NAME-WITH-_A2S-SUFFIX.html">expdata-fresh-defsurj-name-with-*s-suffix</a> surjname wrld))
     ((<a href="ACL2____MV.html">mv</a> forth-image
          back-image back-of-forth oldp-guard
          newp-guard forth-guard back-guard
          forth-injective names-to-avoid)
      (<a href="APT____EXPDATA-FRESH-DEFSURJ-THM-NAMES.html">expdata-fresh-defsurj-thm-names</a>
           surjname
           verify-guards$ names-to-avoid wrld))
     ((unless (<a href="ACL2____TRUE-LISTP.html">true-listp</a> surj))
      (<a href="ACL2____ER-SOFT_B2.html">er-soft+</a>
       ctx t nil
       "The ~n0 SURJ component ~x1 of the second input ~
                     must be a symbol or a list. ~
                     Since it is not an atom, it must be a list."
       (<a href="COMMON-LISP____LIST.html">list</a> k)
       surj))
     ((unless (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP_____D3.html">=</a> (<a href="ACL2____LEN.html">len</a> surj) 4) (<a href="COMMON-LISP_____D3.html">=</a> (<a href="ACL2____LEN.html">len</a> surj) 6)))
      (<a href="ACL2____ER-SOFT_B2.html">er-soft+</a>
       ctx t nil
       "The ~n0 SURJ component ~x1 of the second input ~
                     must be a list of length 4 or 6."
       (<a href="COMMON-LISP____LIST.html">list</a> k)
       surj))
     (oldp (<a href="COMMON-LISP____FIRST.html">first</a> surj))
     (newp (<a href="COMMON-LISP____SECOND.html">second</a> surj))
     (forth (<a href="COMMON-LISP____THIRD.html">third</a> surj))
     (back (<a href="COMMON-LISP____FOURTH.html">fourth</a> surj))
     ((unless (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP_____D3.html">=</a> (<a href="ACL2____LEN.html">len</a> surj) 4)
                  (<a href="COMMON-LISP____EQ.html">eq</a> (<a href="COMMON-LISP____FIFTH.html">fifth</a> surj) :hints)))
      (<a href="ACL2____ER-SOFT_B2.html">er-soft+</a>
       ctx t nil
       "The fifth component ~x0 ~
                     of the ~n1 SURJ component ~x2 ~
                     of the second input ~
                     must be the keyword :HINTS."
       (<a href="COMMON-LISP____FIFTH.html">fifth</a> surj)
       (<a href="COMMON-LISP____LIST.html">list</a> k)
       surj))
     (hints (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____D3.html">=</a> (<a href="ACL2____LEN.html">len</a> surj) 6) (<a href="COMMON-LISP____SIXTH.html">sixth</a> surj)))
     (ctx-defsurj (<a href="COMMON-LISP____CONS.html">cons</a> 'defsurj surjname))
     ((<a href="ACL2____ER.html">er</a> (<a href="COMMON-LISP____LIST.html">list</a> newp$ oldp$ back$ forth$))
      (<a href="ACL2____DEFMAPPING-PROCESS-FUNCTIONS.html">acl2::defmapping-process-functions</a>
           newp oldp back
           forth verify-guards$ ctx-defsurj state))
     (oldp-arity (<a href="ACL2____ARITY.html">arity</a> oldp$ wrld))
     ((unless (<a href="COMMON-LISP_____D3.html">=</a> oldp-arity 1))
      (<a href="ACL2____ER-SOFT_B2.html">er-soft+</a>
       ctx t nil
       "The first component ~x0 ~
                     of the ~n1 SURJ component ~
                     of the third input ~
                     must have one argument, but it has ~x2 arguments instead."
       oldp (<a href="COMMON-LISP____LIST.html">list</a> k)
       oldp-arity))
     (newp-arity (<a href="ACL2____ARITY.html">arity</a> newp$ wrld))
     ((unless (<a href="COMMON-LISP_____D3.html">=</a> newp-arity 1))
      (<a href="ACL2____ER-SOFT_B2.html">er-soft+</a>
       ctx t nil
       "The second component ~x0 ~
                     of the ~n1 SURJ component ~
                     of the third input ~
                     must have one argument, but it has ~x2 arguments instead."
       newp (<a href="COMMON-LISP____LIST.html">list</a> k)
       newp-arity))
     (surjmap (<a href="APT____MAKE-EXPDATA-SURJMAP.html">make-expdata-surjmap</a> :surjname surjname
                                    :localp t
                                    :oldp oldp$
                                    :newp newp$
                                    :forth forth$
                                    :back back$
                                    :forth-image forth-image
                                    :back-image back-image
                                    :back-of-forth back-of-forth
                                    :forth-injective forth-injective
                                    :oldp-guard oldp-guard
                                    :newp-guard newp-guard
                                    :forth-guard forth-guard
                                    :back-guard back-guard
                                    :hints hints)))
    (<a href="ACL2____VALUE.html">value</a> (<a href="COMMON-LISP____LIST.html">list</a> surjmap names-to-avoid))))))</pre> 

</body>
</html>
