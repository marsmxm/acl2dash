<html>
<head>
<meta charset="UTF-8">
<title>Tonelli-shanks-algorithm-is-correct</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=PRIMES____TONELLI-SHANKS-ALGORITHM-IS-CORRECT">Click for Tonelli-shanks-algorithm-is-correct in the Full Manual</a></h3>

<p>Proof of correctness of the Tonelli-Shanks Modular Square Root Algorithm.</p><h3> Overview </h3> 
 
         <p> Below are the key lemmas and proof of correctness of the 
         Tonelli-Shanks modular square root algorithm.</p> 
 
         <h3>Theorems </h3> 
         <p>Key lemmas:</p> 
 
         <p><b>Theorem: </b>y^2=1modp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> y^2=1modp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="RTL____PRIMEP.html">rtl::primep</a> p)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> y)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> 2 p))
                 (<a href="ACL2____IFF.html">iff</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> y y) p) 1)
                      (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> y p) 1)
                          (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> y p) (<a href="COMMON-LISP____MOD.html">mod</a> -1 p))))))</pre> 
         <p><b>Theorem: </b>least-repeated-square-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> least-repeated-square-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> tt)
                      (<a href="ACL2____NATP.html">natp</a> m)
                      (<a href="ACL2____NATP.html">natp</a> p)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> 2 p)
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (least-repeated-square tt m p)
                             lrs)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP_____D3.html">=</a> lrs 0)))
                 (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP____EXPT.html">expt</a> tt (<a href="COMMON-LISP____EXPT.html">expt</a> 2 lrs)) p) 1)))</pre> 
         <p><b>Theorem: </b>least-repeated-square-tt^2^lrs=1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     least-repeated-square-tt^2^lrs=1
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> tt)
                   (<a href="ACL2____NATP.html">natp</a> m)
                   (<a href="ACL2____NATP.html">natp</a> p)
                   (<a href="ACL2____NATP.html">natp</a> i)
                   (<a href="COMMON-LISP_____C3.html">&lt;</a> i m)
                   (<a href="COMMON-LISP_____C3.html">&lt;</a> 2 p)
                   (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP____EXPT.html">expt</a> tt (<a href="COMMON-LISP____EXPT.html">expt</a> 2 i)) p) 1))
              (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP____EXPT.html">expt</a> tt
                            (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (least-repeated-square tt m p)))
                      p)
                 1)))</pre> 
         <p><b>Theorem: </b>least-repeated-square-is-least</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> least-repeated-square-is-least
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> tt)
                      (<a href="ACL2____NATP.html">natp</a> m)
                      (<a href="ACL2____NATP.html">natp</a> p)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> 2 p)
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (least-repeated-square tt m p) d)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP_____D3.html">=</a> d 0)))
                 (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP____EXPT.html">expt</a> tt (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP____-.html">-</a> d 1))) p)
                         1))))</pre> 
 
         <p>Theorem about loop invariants of the algorithm:</p> 
         <p><b>Theorem: </b>t-s-aux-loop-invariants</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 t-s-aux-loop-invariants
 (<a href="ACL2____IMPLIES.html">implies</a>
  (<a href="COMMON-LISP____AND.html">and</a>
     (<a href="ACL2____POSP.html">posp</a> n)
     (<a href="PRIMES____HAS-SQUARE-ROOT_F3.html">has-square-root?</a> n p)
     (<a href="ACL2____POSP.html">posp</a> m)
     (<a href="ACL2____NATP.html">natp</a> c)
     (<a href="ACL2____NATP.html">natp</a> tt)
     (<a href="ACL2____NATP.html">natp</a> r)
     (<a href="ACL2____NATP.html">natp</a> p)
     (<a href="COMMON-LISP_____C3.html">&lt;</a> n p)
     (<a href="RTL____PRIMEP.html">rtl::primep</a> p)
     (<a href="COMMON-LISP_____C3.html">&lt;</a> 2 p)
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP____EXPT.html">expt</a> c (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP____-.html">-</a> m 1))) p)
            (<a href="COMMON-LISP____MOD.html">mod</a> -1 p))
     (<a href="COMMON-LISP_____D3.html">=</a> (acl2::mod-expt-fast tt
                             (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (least-repeated-square tt m p))
                             p)
        1)
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> r r) p) (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> tt n) p))
     (<a href="COMMON-LISP_____C3.html">&lt;</a> 0 (least-repeated-square tt m p)))
  (<a href="COMMON-LISP____LET.html">let</a>
   ((b (<a href="PRIMES____REPEATED-SQUARE.html">repeated-square</a> c
                        (<a href="COMMON-LISP____-.html">-</a> (<a href="COMMON-LISP____-.html">-</a> m (least-repeated-square tt m p))
                           1)
                        p)))
   (<a href="COMMON-LISP____LET.html">let</a>
    ((c2 (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> b b) p))
     (tt2 (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> tt b b) p))
     (r2 (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> r b) p)))
    (<a href="COMMON-LISP____AND.html">and</a>
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> r2 r2) p)
            (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> tt2 n) p))
     (<a href="COMMON-LISP_____D3.html">=</a>
      (acl2::mod-expt-fast
       tt2
       (<a href="COMMON-LISP____EXPT.html">expt</a>
           2
           (least-repeated-square tt2 (least-repeated-square tt m p)
                                  p))
       p)
      1)
     (<a href="COMMON-LISP____EQUAL.html">equal</a>
          (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP____EXPT.html">expt</a> c2
                     (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP____-.html">-</a> (least-repeated-square tt m p) 1)))
               p)
          (<a href="COMMON-LISP____MOD.html">mod</a> -1 p)))))))</pre> 
 
         <p>Base case theorem:</p> 
         <p><b>Theorem: </b>t-s-aux-base-case</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     t-s-aux-base-case
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (least-repeated-square tt m p) 0)
                   (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)
                   (<a href="COMMON-LISP_____C3.html">&lt;</a> 0 n)
                   (<a href="RTL____PRIMEP.html">rtl::primep</a> p)
                   (<a href="COMMON-LISP____EQUAL.html">equal</a> (acl2::mod-expt-fast n (<a href="COMMON-LISP_____B2.html">+</a> -1/2 (<a href="COMMON-LISP_____A2.html">*</a> 1/2 p))
                                               p)
                          1)
                   (<a href="COMMON-LISP____INTEGERP.html">integerp</a> m)
                   (<a href="COMMON-LISP_____C3.html">&lt;</a> 0 m)
                   (<a href="COMMON-LISP____INTEGERP.html">integerp</a> c)
                   (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 0 c)
                   (<a href="COMMON-LISP____INTEGERP.html">integerp</a> tt)
                   (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 0 tt)
                   (<a href="COMMON-LISP____INTEGERP.html">integerp</a> r)
                   (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 0 r)
                   (<a href="COMMON-LISP_____C3.html">&lt;</a> n p)
                   (<a href="COMMON-LISP_____C3.html">&lt;</a> 2 p)
                   (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP____EXPT.html">expt</a> c (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP_____B2.html">+</a> -1 m))) p)
                          (<a href="COMMON-LISP_____B2.html">+</a> -1 p))
                   (<a href="COMMON-LISP____EQUAL.html">equal</a> (acl2::mod-expt-fast tt 1 p) 1)
                   (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> r r) p)
                          (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> n tt) p)))
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> n tt) p) n)))</pre> 
 
         <p> Assuming some properties about the loop invariants and using the 
         theorems t-s-aux-loop-invariants, t-s-aux-base-case, we can prove the 
         following theorem about t-s-aux function of the Tonelli-Shanks 
         algorithm. </p> 
 
         <p><b>Theorem: </b>t-s-aux-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 t-s-aux-equiv
 (<a href="ACL2____IMPLIES.html">implies</a>
  (<a href="COMMON-LISP____AND.html">and</a>
     (<a href="ACL2____POSP.html">posp</a> n)
     (<a href="PRIMES____HAS-SQUARE-ROOT_F3.html">has-square-root?</a> n p)
     (<a href="ACL2____POSP.html">posp</a> m)
     (<a href="ACL2____NATP.html">natp</a> c)
     (<a href="ACL2____NATP.html">natp</a> tt)
     (<a href="ACL2____NATP.html">natp</a> r)
     (<a href="COMMON-LISP_____C3.html">&lt;</a> n p)
     (<a href="RTL____PRIMEP.html">rtl::primep</a> p)
     (<a href="COMMON-LISP_____C3.html">&lt;</a> 2 p)
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP____EXPT.html">expt</a> c (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP____-.html">-</a> m 1))) p)
            (<a href="COMMON-LISP____MOD.html">mod</a> -1 p))
     (<a href="COMMON-LISP_____D3.html">=</a> (acl2::mod-expt-fast tt
                             (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (least-repeated-square tt m p))
                             p)
        1)
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> r r) p)
            (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> tt n) p)))
  (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> (t-s-aux m c tt r p)
             (t-s-aux m c tt r p))
          p)
     n)))</pre> 
 
         <p> Proof that the algorithm returns the square root of n modulo p if 
         a square root exists for n modulo p: </p> 
 
         <p><b>Theorem: </b>tonelli-shanks-sqrt-aux-is-sqrt-modp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> tonelli-shanks-sqrt-aux-is-sqrt-modp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> n)
                      (<a href="ACL2____NATP.html">natp</a> z)
                      (<a href="COMMON-LISP_____E3.html">&gt;</a> p 2)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> n p)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> z p)
                      (<a href="RTL____PRIMEP.html">rtl::primep</a> p)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="PRIMES____HAS-SQUARE-ROOT_F3.html">has-square-root?</a> z p))
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (tonelli-shanks-sqrt-aux n p z)
                             y))
                 (<a href="COMMON-LISP____IF.html">if</a> (<a href="PRIMES____HAS-SQUARE-ROOT_F3.html">has-square-root?</a> n p)
                     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> y y) p) n)
                     (<a href="COMMON-LISP____EQUAL.html">equal</a> y 0))))</pre> 
 
         <p>Key lemma required to prove that the algorithm is correct: </p> 
 
         <p><b>Theorem: </b>modx^2-y^2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> modx^2-y^2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> x)
                      (<a href="ACL2____NATP.html">natp</a> y)
                      (<a href="RTL____PRIMEP.html">rtl::primep</a> p)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> 2 p)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> x p)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> y p)
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> x x) p) (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> y y) p)))
                 (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> x y)
                     (<a href="COMMON-LISP____EQUAL.html">equal</a> x (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP____-.html">-</a> y) p)))))</pre> 
 
         <p> Proof that the Tonelli-Shanks modular square root 
         algorithm is correct: </p> 
 
         <p><b>Theorem: </b>tonelli-shanks-sqrt-aux-is-correct</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> tonelli-shanks-sqrt-aux-is-correct
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> z)
                      (<a href="COMMON-LISP_____E3.html">&gt;</a> p 2)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> z p)
                      (<a href="RTL____PRIMEP.html">rtl::primep</a> p)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="PRIMES____HAS-SQUARE-ROOT_F3.html">has-square-root?</a> z p))
                      (<a href="ACL2____NATP.html">natp</a> y)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> y p)
                      (<a href="COMMON-LISP_____D3.html">=</a> (<a href="COMMON-LISP____MOD.html">mod</a> (<a href="COMMON-LISP_____A2.html">*</a> y y) p) n))
                 (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP_____D3.html">=</a> (tonelli-shanks-sqrt-aux n p z) y)
                     (<a href="COMMON-LISP_____D3.html">=</a> (tonelli-shanks-sqrt-aux n p z)
                        (<a href="COMMON-LISP____-.html">-</a> p y)))))</pre>
</body>
</html>
