<html>
<head>
<meta charset="UTF-8">
<title>Lstate-renamevarp</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=YUL____LSTATE-RENAMEVARP">Click for Lstate-renamevarp in the Full Manual</a></h3>

<p>Variable renaming relation over local states.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(lstate-renamevarp old new ren) → yes/no</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">old</span> — <font color="#606060">Guard <span class="v">(<a href="YUL____LSTATEP.html">lstatep</a> old)</span>.</font>
</dd> 
  <dd>
<span class="tt">new</span> — <font color="#606060">Guard <span class="v">(<a href="YUL____LSTATEP.html">lstatep</a> new)</span>.</font>
</dd> 
  <dd>
<span class="tt">ren</span> — <font color="#606060">Guard <span class="v">(<a href="YUL____RENAMINGP.html">renamingp</a> ren)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">yes/no</span> — <font color="#606060">Type <span class="v">(<a href="ACL2____BOOLEANP.html">booleanp</a> yes/no)</span>.</font>
</dd> 
 
</dl></div> 
<p>The renaming must cover all the variables in the old and new local states, 
     i.e. every variable in the states must be in the renaming. 
     Furthermore, the two states must agree on the renaming: 
     see <span class="tt"><a href="YUL____LSTATE-MATCH-RENAMEVARP.html">lstate-match-renamevarp</a></span>.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>lstate-renamevarp</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> lstate-renamevarp (old new ren)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="YUL____LSTATEP.html">lstatep</a> old)
                                   (<a href="YUL____LSTATEP.html">lstatep</a> new)
                                   (<a href="YUL____RENAMINGP.html">renamingp</a> ren))))
       (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'lstate-renamevarp))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
            (<a href="COMMON-LISP____AND.html">and</a> (<a href="SET____SUBSET.html">subset</a> (<a href="OMAP____KEYS.html">omap::keys</a> (<a href="YUL____LSTATE-FIX.html">lstate-fix</a> old))
                         (<a href="YUL____RENAMING-OLD.html">renaming-old</a> ren))
                 (<a href="SET____SUBSET.html">subset</a> (<a href="OMAP____KEYS.html">omap::keys</a> (<a href="YUL____LSTATE-FIX.html">lstate-fix</a> new))
                         (<a href="YUL____RENAMING-NEW.html">renaming-new</a> ren))
                 (<a href="YUL____LSTATE-MATCH-RENAMEVARP.html">lstate-match-renamevarp</a> old new ren))))</pre> 
<p><b>Theorem: </b>booleanp-of-lstate-renamevarp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> booleanp-of-lstate-renamevarp
        (<a href="ACL2____B_A2.html">b*</a> ((yes/no (<a href="YUL____LSTATE-RENAMEVARP.html">lstate-renamevarp</a> old new ren)))
            (<a href="ACL2____BOOLEANP.html">booleanp</a> yes/no))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>same-defined-when-lstate-renamevarp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> same-defined-when-lstate-renamevarp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="YUL____LSTATEP.html">lstatep</a> old-lstate)
                      (<a href="YUL____LSTATEP.html">lstatep</a> new-lstate)
                      (<a href="YUL____IDENTIFIERP.html">identifierp</a> old-var)
                      (<a href="YUL____IDENTIFIERP.html">identifierp</a> new-var)
                      (<a href="YUL____LSTATE-RENAMEVARP.html">lstate-renamevarp</a> old-lstate new-lstate ren)
                      (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> (<a href="COMMON-LISP____CONS.html">cons</a> old-var new-var)
                                    (<a href="YUL____RENAMING-_E3LIST.html">renaming-&gt;list</a> ren)))
                 (<a href="ACL2____IFF.html">iff</a> (<a href="SET____IN.html">in</a> old-var (<a href="OMAP____KEYS.html">omap::keys</a> old-lstate))
                      (<a href="SET____IN.html">in</a> new-var (<a href="OMAP____KEYS.html">omap::keys</a> new-lstate)))))</pre> 
<p><b>Theorem: </b>lstate-renamevarp-of-nil</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lstate-renamevarp-of-nil
        (<a href="YUL____LSTATE-RENAMEVARP.html">lstate-renamevarp</a> nil nil (<a href="YUL____RENAMING.html">renaming</a> nil)))</pre> 
<p><b>Theorem: </b>lstate-renamevarp-of-lstate-fix-old</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lstate-renamevarp-of-lstate-fix-old
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="YUL____LSTATE-RENAMEVARP.html">lstate-renamevarp</a> (<a href="YUL____LSTATE-FIX.html">lstate-fix</a> old)
                                  new ren)
               (<a href="YUL____LSTATE-RENAMEVARP.html">lstate-renamevarp</a> old new ren)))</pre> 
<p><b>Theorem: </b>lstate-renamevarp-lstate-equiv-congruence-on-old</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lstate-renamevarp-lstate-equiv-congruence-on-old
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="YUL____LSTATE-EQUIV.html">lstate-equiv</a> old old-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="YUL____LSTATE-RENAMEVARP.html">lstate-renamevarp</a> old new ren)
                        (<a href="YUL____LSTATE-RENAMEVARP.html">lstate-renamevarp</a> old-equiv new ren)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>lstate-renamevarp-of-lstate-fix-new</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lstate-renamevarp-of-lstate-fix-new
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="YUL____LSTATE-RENAMEVARP.html">lstate-renamevarp</a> old (<a href="YUL____LSTATE-FIX.html">lstate-fix</a> new)
                                  ren)
               (<a href="YUL____LSTATE-RENAMEVARP.html">lstate-renamevarp</a> old new ren)))</pre> 
<p><b>Theorem: </b>lstate-renamevarp-lstate-equiv-congruence-on-new</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lstate-renamevarp-lstate-equiv-congruence-on-new
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="YUL____LSTATE-EQUIV.html">lstate-equiv</a> new new-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="YUL____LSTATE-RENAMEVARP.html">lstate-renamevarp</a> old new ren)
                        (<a href="YUL____LSTATE-RENAMEVARP.html">lstate-renamevarp</a> old new-equiv ren)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>lstate-renamevarp-of-renaming-fix-ren</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lstate-renamevarp-of-renaming-fix-ren
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="YUL____LSTATE-RENAMEVARP.html">lstate-renamevarp</a> old new (<a href="YUL____RENAMING-FIX.html">renaming-fix</a> ren))
               (<a href="YUL____LSTATE-RENAMEVARP.html">lstate-renamevarp</a> old new ren)))</pre> 
<p><b>Theorem: </b>lstate-renamevarp-renaming-equiv-congruence-on-ren</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lstate-renamevarp-renaming-equiv-congruence-on-ren
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="YUL____RENAMING-EQUIV.html">renaming-equiv</a> ren ren-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="YUL____LSTATE-RENAMEVARP.html">lstate-renamevarp</a> old new ren)
                        (<a href="YUL____LSTATE-RENAMEVARP.html">lstate-renamevarp</a> old new ren-equiv)))
        :rule-classes :congruence)</pre> 

</body>
</html>
