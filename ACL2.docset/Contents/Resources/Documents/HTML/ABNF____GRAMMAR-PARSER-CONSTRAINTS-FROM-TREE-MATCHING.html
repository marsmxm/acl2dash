<html>
<head>
<meta charset="UTF-8">
<title>Grammar-parser-constraints-from-tree-matching</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ABNF____GRAMMAR-PARSER-CONSTRAINTS-FROM-TREE-MATCHING">Click for Grammar-parser-constraints-from-tree-matching in the Full Manual</a></h3>

<p>Tree maching constraint theorems for the parser of ABNF grammars.</p><p>If a (list of) terminated tree(s) matches a syntactic entity, 
     the string at the leaves of the tree(s) must satisfy certain constraints. 
     For example, if a terminated tree matches <span class="v">CRLF</span>, 
     the string at the leaves of the tree 
     must be non-empty and start with a carriage return.</p><p>The tree matching constraint theorems below 
     capture constraints of this kind. 
     While these theorems are not directly related to the parser, 
     they are motivated by the parser (see below).</p><h3>Usage</h3><p>These theorems are used, together with the <a href="ABNF____GRAMMAR-PARSER-CONSTRAINTS-FROM-PARSING.html">parsing constraint theorems</a>, to prove the <a href="ABNF____GRAMMAR-PARSER-DISAMBIGUATION.html">disambiguation theorems</a>, which in turn are used to prove the <a href="ABNF____GRAMMAR-PARSER-COMPLETENESS.html">completeness theorems</a>.</p><p>The tree matching constraint theorems have no rule classes. 
     They are used in the proofs of the disambiguation theorems 
     via <span class="v">:use</span> hints.</p><p>Some tree matching constraint theorems are used 
     to incrementally prove other tree matching constraint theorems (see below), 
     also via <span class="v">:use</span> hints.</p><h3>Scope</h3><p>There are tree matching constraint theorems 
     only for some syntactic entities: 
     just the ones used to prove the disambiguation theorems, 
     and to incrementally prove other tree matching constraint theorems. 
     Furthermore, each tree matching constraint theorem only states necessary, 
     but generally not sufficient, 
     conditions for the matching of the corresponding syntactic entity: 
     it states only the constraints used to prove the disambiguation theorems 
     (and, incrementally, other tree matching constraint theorems).</p><p>Most tree matching constraint theorems state constraints 
     just on the first natural number of the string at the leaves of the tree(s) 
     (the <span class="tt"><a href="COMMON-LISP____CAR.html">car</a></span>), 
     because most of the grammar is LL(1). 
     A few tree matching constraint theorems state additional constraints 
     on the second natural number of the string at the leaves of the tree(s) 
     (the <span class="tt"><a href="COMMON-LISP____CADR.html">cadr</a></span>), 
     as needed for the LL(2) portions of the grammar. 
     Since the tree matching constraint theorem 
     <span class="tt"><a href="ABNF____CONSTRAINTS-FROM-TREE-MATCH-ICHARS.html">constraints-from-tree-match-ichars</a></span> 
     would have to state constraints 
     either on the first natural number 
     or on the first and second natural numbers 
     depending on the instantiation of <span class="v">charstring</span>, 
     for simplicity this theorem states constraints 
     on the whole string at the leaves of the tree.</p><h3>Hypotheses on the Tree(s)</h3><p>Most tree matching constraint theorems include 
     hypotheses saying that the trees are terminated. 
     This ensures that the strings at the leaves of the trees 
     consist of natural numbers and not rule names, 
     since the constraints are stated on natural numbers.</p><p>A few tree matching constraint theorems do not need these hypotheses 
     because the corresponding syntactic entities can only be matched 
     by trees whose (starting) leaves are natural numbers. 
     For instance, in <span class="tt"><a href="ABNF____CONSTRAINTS-FROM-TREE-MATCH-DOT-ETC..html">constraints-from-tree-match-dot-etc.</a></span>, 
     the group <span class="v">("." ...)</span> can only be matched 
     by a tree whose first leaf is a natural number, 
     upon which the theorem states the constraint.</p><h3>Hypotheses on the String at the Leaves of the Tree(s)</h3><p>The tree matching constraint theorems 
     whose names end with <span class="v">-when-nonempty</span> 
     include hypotheses saying that the string at the leaves is not empty. 
     This is because the corresponding syntactic entities may be matched 
     by a tree with an empty string at the leaves 
     or by an empty list of trees. 
     For example, 
     in <span class="tt"><a href="ABNF____CONSTRAINTS-FROM-TREE-MATCH-BIN-VAL-REST-WHEN-NONEMPTY.html">constraints-from-tree-match-bin-val-rest-when-nonempty</a></span>, 
     the matching tree may have no subtrees, 
     since the syntactic entity in question 
     is an option <span class="v">[ 1*("." 1*BIT) / ("-" 1*BIT) ]</span>. 
     As another example, 
     in <span class="tt"><a href="ABNF____CONSTRAINTS-FROM-TREE-LIST-MATCH-_A2DIGIT-WHEN-NONEMPTY.html">constraints-from-tree-list-match-*digit-when-nonempty</a></span>, 
     the matching list of trees may be empty.</p><h3>Proof Methods</h3><p>The proof of each tree matching constraint theorem 
     expands <span class="tt"><a href="ABNF____TREE-MATCH-ELEMENT-P.html">tree-match-element-p</a></span> 
     or <span class="tt"><a href="ABNF____TREE-LIST-MATCH-REPETITION-P.html">tree-list-match-repetition-p</a></span> 
     (depending on whether the theorem applies to 
     a single tree or to a list of trees). 
     But most theorems need explicit <span class="v">:expand</span> hints for that: 
     just enabling the functions does not suffice 
     (presumably due to ACL2's heuristics for expanding recursive functions).</p><p>Since many repetitions consist of one element, 
     the rewrite rule <span class="tt"><a href="ABNF____TREE-LIST-MATCH-REPETITION-P-OF-1-REPETITION.html">tree-list-match-repetition-p-of-1-repetition</a></span> 
     is used in many proofs. 
     It is enabled just before the tree matching constraint theorems 
     and disabled just after.</p><p>Except for 
     <span class="tt"><a href="ABNF____CONSTRAINTS-FROM-TREE-MATCH-DOT-ETC..html">constraints-from-tree-match-dot-etc.</a></span> and 
     <span class="tt"><a href="ABNF____CONSTRAINTS-FROM-TREE-MATCH-DASH-ETC..html">constraints-from-tree-match-dash-etc.</a></span>, 
     the alternations and concatenations of the syntactic entities being matched 
     have an explicit list structure, 
     and so the proof automatically uses rewrite rules like 
     <span class="tt"><a href="ABNF____TREE-LIST-LIST-MATCH-ALTERNATION-P-OF-CONS-ALTERNATION.html">tree-list-list-match-alternation-p-of-cons-alternation</a></span>. 
     In contrast, 
     for <span class="tt"><a href="ABNF____CONSTRAINTS-FROM-TREE-MATCH-DOT-ETC..html">constraints-from-tree-match-dot-etc.</a></span> and 
     for <span class="tt"><a href="ABNF____CONSTRAINTS-FROM-TREE-MATCH-DASH-ETC..html">constraints-from-tree-match-dash-etc.</a></span>, 
     we expand 
     <span class="tt"><a href="ABNF____TREE-LIST-LIST-MATCH-ALTERNATION-P.html">tree-list-list-match-alternation-p</a></span> and 
     <span class="tt"><a href="ABNF____TREE-LIST-LIST-MATCH-CONCATENATION-P.html">tree-list-list-match-concatenation-p</a></span> 
     via explicit <span class="v">:expand</span> hints, 
     because just enabling these two functions does not suffice 
     (presumably due to ACL2's heuristics for expanding recursive functions).</p><p>The expansions described above reduce 
     the matching of the (list of) tree(s) with syntactic entities 
     in the hypothesis, 
     to the matching of subtrees with syntactic sub-entities. 
     Tree matching constraint theorems for these subtrees 
     are used in the proofs for the containing trees, via <span class="v">:use</span> hints. 
     For example, the proof of <span class="tt"><a href="ABNF____CONSTRAINTS-FROM-TREE-MATCH-ALPHA.html">constraints-from-tree-match-alpha</a></span> 
     uses <span class="tt"><a href="ABNF____CONSTRAINTS-FROM-TREE-MATCH-ICHARS.html">constraints-from-tree-match-ichars</a></span> twice, 
     once for each alternative of <span class="v">ALPHA</span> that the subtree may match.</p><p>As the matching of the tree(s) in the hypotheses of the theorems 
     is reduced, in the proofs, to the matching of subtrees as just explained, 
     we also need 
     to reduce the tree strings to subtree strings and 
     to reduce the terminated tree hypotheses to terminated subtree hypotheses, 
     so that the tree matching constraint theorems for the subtrees apply. 
     We accomplish the latter reductions by expanding the definitions of 
     <span class="tt"><a href="ABNF____TREE-_E3STRING.html">tree-&gt;string</a></span>, 
     <span class="tt"><a href="ABNF____TREE-LIST-_E3STRING.html">tree-list-&gt;string</a></span>, 
     <span class="tt"><a href="ABNF____TREE-LIST-LIST-_E3STRING.html">tree-list-list-&gt;string</a></span>, and 
     <span class="tt"><a href="ABNF____TREE-TERMINATEDP.html">tree-terminatedp</a></span>. 
     We enable them just before the tree matching constraint theorems 
     and we disable them just after. 
     Enabled rules for 
     <span class="tt"><a href="ABNF____TREE-LIST-TERMINATEDP.html">tree-list-terminatedp</a></span> and <span class="tt"><a href="ABNF____TREE-LIST-LIST-TERMINATEDP.html">tree-list-list-terminatedp</a></span> 
     suffice, so we do not need to enable these two functions.</p><p>Since <span class="tt"><a href="ABNF____CONSTRAINTS-FROM-TREE-MATCH-ICHARS.html">constraints-from-tree-match-ichars</a></span> 
     states constraints with <span class="tt"><a href="ABNF____NATS-MATCH-INSENSITIVE-CHARS-P.html">nats-match-insensitive-chars-p</a></span>, 
     and since that theorem is used in the proofs 
     of several other tree matching constraint theorems, 
     the proofs of the latter theorems 
     use the definition of <span class="tt"><a href="ABNF____NAT-MATCH-INSENSITIVE-CHAR-P.html">nat-match-insensitive-char-p</a></span>, 
     which we enable just before the tree matching constraint theorems 
     and we disable just after. 
     The rewrite rules 
     <span class="v">nats-match-sensitive-chars-p-when-atom-chars</span> and 
     <span class="v">nats-match-sensitive-chars-p-when-cons-chars</span> 
     reduce <span class="tt"><a href="ABNF____NATS-MATCH-INSENSITIVE-CHARS-P.html">nats-match-insensitive-chars-p</a></span> 
     to <span class="tt"><a href="ABNF____NAT-MATCH-INSENSITIVE-CHAR-P.html">nat-match-insensitive-char-p</a></span> 
     because the <span class="v">chars</span> argument is constant.</p>
</body>
</html>
