<html>
<head>
<meta charset="UTF-8">
<title>Defarray1type</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____DEFARRAY1TYPE">Click for Defarray1type in the Full Manual</a></h3>

<p>Characterize 1-dimensional arrays with a fixed element type.</p><p>Example form:</p> 
 
<pre class="code">(<a href="ACL2____DEFARRAY1TYPE.html">DEFARRAY1TYPE</a> INTEGERP-ARRAY1P INTEGERP)</pre> 
 
<p>The above example defines a recognizer, INTEGERP-ARRAYP, for 1-dimensional 
arrays whose elements are all INTEGERP.</p> 
 
<p>General form:</p> 
 
<pre class="code">(DEF1ARRAYTYPE recognizer predicate
               &amp;key size doc
                    (aref1-lemma-rule-classes ':REWRITE)
                    (aset1-lemma-rule-classes ':REWRITE))</pre> 
 
<p>DEFARRAY1TYPE defines a recognizer for 1-dimensional arrays whose elements 
are all of a single type.  The recognizer argument is a symbol that is used as 
the name of the recognizer.  The predicate argument should be a 1-argument, 
unguarded Boolean function that recognizes objects of the desired type.  The 
predicate may either be a symbol (the name of the predicate), or a LAMBDA 
expression.</p> 
 
<p>If :SIZE is specified it should be a variable-free term that will evaluate 
to a positive integer.  If specified, then the recognizer will only recognize 
1-dimensional arrays of the given type and of a fixed size.</p> 
 
<p>If :DOC is specified it should be a string, and it will be inserted as the 
documentation string in the recognizer.</p> 
 
<p>DEFARRAY1TYPE defines a recognizer:</p> 
 
<pre class="code">(recognizer NAME L)</pre> 
 
<p>and proves 4 useful theorems about it.  If the :SIZE is not specified then 
the three theorems will be:</p> 
 
<pre class="code">1. (<a href="ACL2____IMPLIES.html">IMPLIES</a> (recognizer NAME L)
            (<a href="ACL2____ARRAY1P.html">ARRAY1P</a> NAME L))

2. (<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____AND.html">AND</a> (recognizer NAME L)
                 (<a href="COMMON-LISP____INTEGERP.html">INTEGERP</a> N))
            (predicate (<a href="ACL2____AREF1.html">AREF1</a> NAME L N)))

3. (<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____AND.html">AND</a> (recognizer NAME L)
                 (<a href="COMMON-LISP_____C3.html">&lt;</a> N (<a href="COMMON-LISP____CAR.html">CAR</a> (<a href="ACL2____DIMENSIONS.html">DIMENSIONS</a> NAME L)))
                 (<a href="COMMON-LISP____INTEGERP.html">INTEGERP</a> N)
                 (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> N 0)
                 (predicate VAL))
            (recognizer NAME (<a href="ACL2____ASET1.html">ASET1</a> NAME L N VAL)))

4. (<a href="ACL2____IMPLIES.html">IMPLIES</a> (recognizer NAME l)
            (recognizer NAME (<a href="ACL2____RESET-ARRAY1.html">RESET-ARRAY1</a> name l)))</pre> 
 
<p>If :SIZE is specified then the first and third theorems become:</p> 
 
<pre class="code">1. (<a href="ACL2____IMPLIES.html">IMPLIES</a> (recognizer NAME L)
            (<a href="COMMON-LISP____AND.html">AND</a> (<a href="ACL2____ARRAY1P.html">ARRAY1P</a> NAME L)
                 (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="COMMON-LISP____CAR.html">CAR</a> (<a href="ACL2____DIMENSIONS.html">DIMENSIONS</a> name l))
                        size)))

3. (<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____AND.html">AND</a> (recognizer NAME L)
                 (<a href="COMMON-LISP_____C3.html">&lt;</a> N size)
                 (<a href="COMMON-LISP____INTEGERP.html">INTEGERP</a> N)
                 (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> N 0)
                 (predicate VAL))
            (recognizer NAME (<a href="ACL2____ASET1.html">ASET1</a> NAME L N VAL)))</pre> 
 
<p>The first theorem is stored as both :REWRITE and :FORWARD-CHAINING rules. 
The :RULE-CLASSES of the second and third lemmas default to :REWRITE, but are 
selectable by the user by means of the :AREF1-LEMMA-RULE-CLASSES and 
:ASET1-LEMMA-RULE-CLASSSES arguments to DEFARRAY1TYPE (respectively).  If 
using :RULE-CLASSES other than :REWRITE the user should bear in mind the 
documented restrictions on the applicability of :TYPE-PRESCRIPTION and 
:FORWARD-CHAINING rules.  The fourth rule is always a :REWRITE rule.</p> 
 
<p>Note the the recognizer is a very strong recognizer that specifies that the 
array alist is a BOUNDED-INTEGER-ALISTP whose elements all satisfy the type 
predicate.  The recognizer also specifies that the default element of the array 
satisfies the predicate as well.</p> 
 
<p>WARNING: The recognizer is defined in terms of a recursive recognizer, named 
<span class="v">&lt;recognizer&gt;-FN</span>.  THE RECURSIVE RECOGNIZER SHOULD BE COMPILED BEFORE YOU 
TRY TO EXECUTE IT, OR IT MAY CAUSE A STACK OVERFLOW.  Also note that the 
recognizer will be DISABLEd after execution of this macro.  The user must 
insure that the recognizer remains DISABLEd, otherwise the above lemmas will 
never be applied.</p> 
 
<p>DEFARRAY1TYPE proves the generated lemmas in a minimal, ENCAPSULATEd theory 
that should guarantee that the proofs always succeed.  If one should encounter 
a case where a proof fails (as opposed to a translation or other syntax 
failure), please notify the author.</p> 
 

</body>
</html>
