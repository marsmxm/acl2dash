<html>
<head>
<meta charset="UTF-8">
<title>Grammar-parser-disambiguation</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ABNF____GRAMMAR-PARSER-DISAMBIGUATION">Click for Grammar-parser-disambiguation in the Full Manual</a></h3>

<p>Disambiguation theorems for the parser of ABNF grammars.</p><p>If a (list of) terminated tree(s) matches a syntactic entity, 
     attempting to parse the string at the leaves of the tree(s) 
     with a parsing function for a different syntactic entity fails, in general. 
     For example, if a terminated tree matches <span class="v">HTAB</span>, 
     <span class="tt"><a href="ABNF____PARSE-SP.html">parse-sp</a></span> fails on the string at the leaves of the tree: 
     this is stated by the disambiguation theorem 
     <span class="tt"><a href="ABNF____FAIL-SP-WHEN-MATCH-HTAB.html">fail-sp-when-match-htab</a></span>.</p><p>The disambiguation theorems below state this kind of facts. 
     Essentially, these theorems say that certain syntactic entities 
     are incompatible with certain parsing functions; 
     they are used to show that the parser can disambiguate its input 
     (hence the name of these theorems).</p><h3>Usage</h3><p>The disambiguation theorems are used to prove the <a href="ABNF____GRAMMAR-PARSER-COMPLETENESS.html">completeness theorems</a>.</p><p>The disambiguation theorems are rewrite rules that are disabled by default. 
     They are explicitly enabled in the individual completeness theorems.</p><p>Some disambiguation theorems are used 
     to incrementally prove other disambiguation theorems (see below), 
     also via explicit enabling.</p><h3>Scope</h3><p>There are disambiguation theorems 
     only for some combinations of syntactic entities and parsing functions: 
     just the ones used to prove the completeness theorems, 
     and to incrementally prove other disambiguation theorems.</p><p>Given the potentially ``quadratic'' number 
     of disambiguation theorems 
     (i.e. for all syntactic entities combined with all parsing functions), 
     some disambiguation theorems group together 
     multiple tree matching hypotheses or multiple parsing failure conclusions. 
     For example, <span class="tt"><a href="ABNF____FAIL-BIT_F2DIGIT_F2HEXDIG_F2DOT_F2DASH-WHEN-MATCH-SLASH.html">fail-bit/digit/hexdig/dot/dash-when-match-slash</a></span> 
     asserts the failure of multiple parsing functions 
     for the given tree matching hypothesis: 
     this theorem replaces five potential theorems 
     (one for each parsing function mentioned there). 
     As another example, <span class="tt"><a href="ABNF____FAIL-CWSP-WHEN-MATCH-ALT_F2CONC_F2REP.html">fail-cwsp-when-match-alt/conc/rep</a></span> 
     asserts the failure of a given parsing function 
     for multiple syntactic entities matched by the tree: 
     this theorem replaces three potential theorems 
     (one for each syntactic entity mentioned there). 
     More grouping (and thus reduction in the number of disambiguation theorems) 
     is possible, 
     but we also try to keep the disambiguation theorems' names 
     sufficiently descriptive while not excessively long.</p><h3>Formulation</h3><p>The formulation of the disambiguation theorems is derived from 
     the subgoals that arise in the completeness proofs 
     (and in the incrementally proved disambiguation proofs): 
     the disambiguation theorems serve to prove those subgoals. 
     The disambiguation theorems were developed 
     in the process of proving the completeness theorems, 
     based on failed subgoals in the latter.</p><p>In particular, 
     the ``asymmetric'' use of trees and parsing functions 
     to show incompatibility 
     (as opposed to showing incompatibility 
     between parsing functions or between trees) 
     reflects the structure of the subgoals in the completeness theorems; 
     see the documentation of the completeness theorems for details.</p><p>The formulation of each disambiguation theorem also involves 
     some remaining input 
     that is <span class="tt"><a href="COMMON-LISP____APPEND.html">append</a></span>ed after the string at the leaves of the tree(s). 
     That is, each disambiguation theorem says something of this form: 
     if a (list of) terminated tree(s) matches certain syntactic entities 
     and possibly satisfies certain <a href="ABNF____GRAMMAR-PARSER-DISAMBIGUATING-RESTRICTIONS.html">disambiguating restrictions</a>, then running certain parsing functions on the <span class="tt"><a href="COMMON-LISP____APPEND.html">append</a></span> of 
     (i) the string at the leaves of the tree and 
     (ii) some remaining input 
     possibly satisfing certain hypotheses explained below, 
     fails. 
     This is similar to the way in which 
     the completeness theorems are formulated.</p><p>Most disambiguation theorems involve a single (list of) tree(s). 
     Four of them (i.e. 
     <span class="tt"><a href="ABNF____FAIL-ALPHA_F2DIGIT_F2DASH-WHEN-MATCH-_A2CWSP-CLOSE-ROUND_F2SQUARE.html">fail-alpha/digit/dash-when-match-*cwsp-close-round/square</a></span>, 
     <span class="tt"><a href="ABNF____FAIL-BIT_F2DIGIT_F2HEXDIG_F2DOT_F2DASH-WHEN-MATCH-_A2CWSP-CLOSE-ROUND_F2SQUARE.html">fail-bit/digit/hexdig/dot/dash-when-match-*cwsp-close-round/square</a></span>, 
     <span class="tt"><a href="ABNF____FAIL-ALT-REST-COMP-WHEN-MATCH-_A2CWSP-CLOSE-ROUND_F2SQUARE.html">fail-alt-rest-comp-when-match-*cwsp-close-round/square</a></span>, and 
     <span class="tt"><a href="ABNF____FAIL-CONC-REST-COMP-WHEN-MATCH-_A2CWSP-CLOSE-ROUND_F2SQUARE.html">fail-conc-rest-comp-when-match-*cwsp-close-round/square</a></span>) 
     involve a list of trees matching <span class="v">*c-wsp</span> 
     and a tree matching <span class="v">")"</span> or <span class="v">"]"</span>; 
     the parsing function in their conclusion 
     is applied to the <span class="tt"><a href="COMMON-LISP____APPEND.html">append</a></span> of 
     (i) the string at the leaves of the list of trees, 
     (ii) the string at the leaves of the tree, and 
     (iii) some remaining input. 
     These four theorems are used 
     in the completeness proofs of the mutually recursive parsing functions, 
     precisely in the induction step lemmas 
     for <span class="tt"><a href="ABNF____PARSE-GROUP.html">parse-group</a></span> and <span class="tt"><a href="ABNF____PARSE-OPTION.html">parse-option</a></span>. 
     In those lemmas, the tree matching hypothesis reduces to, among others, 
     the fact that a list of subtrees matches <span class="v">*c-wsp</span> 
     and that the subtree just after that list matches <span class="v">")"</span> or <span class="v">"]"</span>: 
     the four disambiguation theorems apply to that (list of) subtree(s). 
     Note that <span class="v">*c-wsp ")"</span> and <span class="v">*c-wsp "]"</span> are the ending parts 
     of the definientia of <span class="v">group</span> and <span class="v">option</span>.</p><h3>Hypotheses on the Remaining Input</h3><p>In all the disambiguation theorems, 
     the remaining input (following the string at the leaves of the tree(s)) 
     is denoted by the variable <span class="v">rest-input</span>. 
     The hypotheses on the remaining input, when present, 
     are that certain parsing functions fail on the remaining input.</p><p>In most cases, the hypotheses on the remaining input are present 
     when the (list of) tree(s) may have an empty string at the leaves. 
     When that string is empty, 
     the incompatibility between the tree(s) and the parsing functions 
     does not apply. 
     Thus, each of these theorems includes the hypothesis 
     that the parsing function fails on the remaining input, 
     to ensure that the conclusion holds in this case. 
     For example, in <span class="tt"><a href="ABNF____FAIL-BIT-WHEN-MATCH-_A2CWSP.html">fail-bit-when-match-*cwsp</a></span>, 
     if the list of trees is empty, 
     the incompatibility 
     between (the first tree of the list matching) <span class="v">c-wsp</span> 
     and the parsing function <span class="tt"><a href="ABNF____PARSE-BIT.html">parse-bit</a></span> does not apply; 
     but the hypothesis that <span class="tt"><a href="ABNF____PARSE-BIT.html">parse-bit</a></span> fails on <span class="v">rest-input</span> 
     maintains the truth of the theorem in case the list of trees is empty. 
     In general, for each of these disambiguation theorems, 
     the hypothesis asserts the failure on the remaining input 
     of the same parsing function that the theorem shows to be 
     incompatible with the syntactic entity matched by the tree(s).</p><p>The hypotheses just mentioned could be weakened 
     to require the parsing failure on the remaining input 
     only if the string at the leaves of the tree(s) is in fact empty; 
     however, the stronger hypotheses keep the theorems simpler 
     without precluding the eventual proof of 
    the top-level completeness theorem. 
     Another possibility is to have, instead, hypotheses stating that 
     the string at the leaves of the tree(s) are not empty; 
     however, the current formulation seems more readily usable 
     in the proofs of completeness, 
     obviating a case split based on whether the string is empty or not.</p><p>The disambiguation theorem 
     <span class="tt"><a href="ABNF____FAIL-EQUAL-SLASH-WHEN-MATCH-EQUAL-AND-REST-FAIL-SLASH.html">fail-equal-slash-when-match-equal-and-rest-fail-slash</a></span> 
     has the hypothesis that <span class="tt"><a href="ABNF____PARSE-ICHAR.html">parse-ichar</a></span> with argument <span class="v">#\/</span> 
     fails on the remaining input. 
     Without this hypothesis, 
     <span class="tt"><a href="ABNF____PARSE-ICHAR2.html">parse-ichar2</a></span> with arguments <span class="v">#\=</span> and <span class="v">#\/</span> could succeed: 
     after parsing the <span class="v">"="</span> in the string at the leaves of the tree, 
     it could parse a <span class="v">"/"</span> in the remaining input, 
     obtaining a <span class="v">"=/"</span>.</p><p>The disambiguation theorem 
     <span class="tt"><a href="ABNF____FAIL-_A2DIGIT-STAR-_A2DIGIT-WHEN-MATCH-1_A2DIGIT.html">fail-*digit-star-*digit-when-match-1*digit</a></span> 
     has the hypotheses that 
     both <span class="tt"><a href="ABNF____PARSE-ICHAR.html">parse-ichar</a></span> with argument <span class="v">#\*</span> 
     and <span class="tt"><a href="ABNF____PARSE-DIGIT.html">parse-digit</a></span> 
     fail on the remaining input. 
     Without the first hypothesis, 
     <span class="tt"><a href="ABNF____PARSE-_A2DIGIT-STAR-_A2DIGIT.html">parse-*digit-star-*digit</a></span> could succeed: 
     after parsing the <span class="v">DIGIT</span>s from the string at the leaves of the trees, 
     it could parse a <span class="v">"*"</span> from the remaining input, 
     and then zero or more <span class="v">DIGIT</span>s, 
     obtaining a <span class="v">(*DIGIT "*" *DIGIT)</span>. 
     Without the second hypothesis, 
     <span class="tt"><a href="ABNF____PARSE-_A2DIGIT-STAR-_A2DIGIT.html">parse-*digit-star-*digit</a></span> could also succeed: 
     after parsing the <span class="v">DIGIT</span>s from the string at the leaves of the trees, 
     it could parse additional <span class="v">DIGIT</span>s from the remaining input, 
     then a <span class="v">"*"</span>, 
     and then zero or more <span class="v">DIGIT</span>s, 
     obtaining a <span class="v">(*DIGIT "*" *DIGIT)</span>. 
     The second hypothesis is stronger than needed, 
     because the presence of a <span class="v">DIGIT</span> at the start of the remaining input 
     does not imply the success of <span class="tt"><a href="ABNF____PARSE-_A2DIGIT-STAR-_A2DIGIT.html">parse-*digit-star-*digit</a></span>; 
     however, the stronger hypothesis keeps the theorems simpler 
     without precluding the eventual proof of 
     the top-level completeness theorem.</p><p>The disambiguation theorem <span class="tt"><a href="ABNF____FAIL-CWSP-WHEN-MATCH-CNL.html">fail-cwsp-when-match-cnl</a></span> 
     has the hypothesis that <span class="tt"><a href="ABNF____PARSE-WSP.html">parse-wsp</a></span> fails on the remaining input. 
     Without this hypothesis, <span class="tt"><a href="ABNF____PARSE-CWSP.html">parse-cwsp</a></span> could succeed: 
     after parsing the <span class="v">c-nl</span> from the string at the leaves of the tree, 
     it could parse a <span class="v">WSP</span> from the remaining input, 
     obtaining a <span class="v">c-wsp</span>.</p><p>The disambiguation theorems 
     <span class="tt"><a href="ABNF____FAIL-ALT-REST-COMP-WHEN-MATCH-CNL.html">fail-alt-rest-comp-when-match-cnl</a></span> and 
     <span class="tt"><a href="ABNF____FAIL-CONC-REST-COMP-WHEN-MATCH-CNL.html">fail-conc-rest-comp-when-match-cnl</a></span> 
     also have the hypothesis that <span class="tt"><a href="ABNF____PARSE-WSP.html">parse-wsp</a></span> fails 
     on the remaining input. 
     Without this hypothesis, 
     <span class="tt"><a href="ABNF____PARSE-ALT-REST-COMP.html">parse-alt-rest-comp</a></span> or 
     <span class="tt"><a href="ABNF____PARSE-CONC-REST-COMP.html">parse-conc-rest-comp</a></span> 
     could succeed: 
     after parsing the <span class="v">c-nl</span> from the string at the leaves of the tree, 
     it could parse a <span class="v">WSP</span> from the remaining input, 
     forming the first <span class="v">c-wsp</span> 
     of a <span class="v">(*c-wsp "/" *c-wsp concatenation)</span> 
     or of a <span class="v">*(1*c-wsp repetition)</span>, 
     and then proceed to parse more, eventually obtaining 
     a <span class="v">(*c-wsp "/" *c-wsp concatenation)</span> or <span class="v">*(1*c-wsp repetition)</span>. 
     The hypothesis is stronger than needed, 
     because the presence of a <span class="v">WSP</span> at the start of the remaining input 
     does not imply the success of 
     <span class="tt"><a href="ABNF____PARSE-ALT-REST-COMP.html">parse-alt-rest-comp</a></span> or 
     <span class="tt"><a href="ABNF____PARSE-CONC-REST-COMP.html">parse-conc-rest-comp</a></span>; 
     however, the stronger hypothesis keeps the theorems simpler 
     without precluding the eventual proof of 
     the top-level completeness theorem.</p><p>The disambiguation theorem <span class="tt"><a href="ABNF____FAIL-CONC-REST-COMP-WHEN-MATCH-_A2CWSP.html">fail-conc-rest-comp-when-match-*cwsp</a></span> 
     has the hypotheses that 
     both <span class="tt"><a href="ABNF____PARSE-REPETITION.html">parse-repetition</a></span> and <span class="tt"><a href="ABNF____PARSE-CWSP.html">parse-cwsp</a></span> 
     fail on the remaining input. 
     Without the first hypothesis, 
     <span class="tt"><a href="ABNF____PARSE-CONC-REST-COMP.html">parse-conc-rest-comp</a></span> could succeed: 
     after parsing the <span class="v">*c-wsp</span> from the string at the leaves of the trees, 
     assuming that there is at least one tree, 
     it could parse a <span class="v">repetition</span> from the remaining input, 
     obtaining a <span class="v">(1*c-wsp repetition)</span>. 
     Without the second hypothesis, 
     <span class="tt"><a href="ABNF____PARSE-CONC-REST-COMP.html">parse-conc-rest-comp</a></span> could also succeed: 
     after parsing the <span class="v">*c-wsp</span> from the string at the leaves of the trees, 
     it could parse a <span class="v">c-wsp</span> from the remaining input, 
     and then a <span class="v">repetition</span>, 
     obtaining a <span class="v">(1*c-wsp repetition)</span>.</p><h3>Hypotheses on the Tree(s)</h3><p>Many disambiguation theorems include 
     hypotheses saying that the trees are terminated. 
     This ensures that the strings at the leaves of the trees 
     consist of natural numbers and not rule names, 
     since the incompatibilities with the parsing functions 
     are in terms of natural numbers. 
     Some disambiguation theorems do not need these hypotheses 
     because the syntactic entities can only be matched 
     by trees whose (starting) leaves are natural numbers. 
     For instance, in <span class="tt"><a href="ABNF____FAIL-DOT-WHEN-MATCH-DASH-ETC..html">fail-dot-when-match-dash-etc.</a></span>, 
     the group <span class="v">("-" ...)</span> can only be matched by a tree 
     whose first leaf is a natural number, 
     upon which the incompatibility with the parsing function applies.</p><p>A few disambiguation theorems include hypotheses 
     that the tree(s) satisfy the <a href="ABNF____GRAMMAR-PARSER-DISAMBIGUATING-RESTRICTIONS.html">disambiguating restrictions</a>. These theorems say that <span class="tt"><a href="ABNF____PARSE-WSP.html">parse-wsp</a></span> fails 
     on the strings at the leaves of trees 
     that satisfy the disambiguating restrictions. 
     Since the restrictions say that these trees cannot start with <span class="v">WSP</span>, 
     as the syntactic entities matched by the trees 
     would otherwise allow that, 
     these hypotheses are essential to the truth of these theorems.</p><h3>Proof Methods</h3><p>Most disambiguation theorems are proved by using, via <span class="v">:use</span> hints, 
     parsing constraint theorems and tree matching constraint theorems 
     that explicate incompatible constraints 
     between the parsing functions 
     and the syntactic entities matched by the trees. 
     For example, in <span class="tt"><a href="ABNF____FAIL-SP-WHEN-MATCH-HTAB.html">fail-sp-when-match-htab</a></span>, 
     the fact that the tree matches <span class="v">HTAB</span> induces the constraint that 
     the first natural number of the string at the leaves of the tree is 9, 
     but the fact that <span class="tt"><a href="ABNF____PARSE-SP.html">parse-sp</a></span> succeeds induces the constraint that 
     the first natural number of the string at the leaves of the tree is 32.</p><p>The disambiguation theorems 
     <span class="tt"><a href="ABNF____FAIL-CASE-INSENSITIVE-STRING-WHEN-MATCH-CASE-SENSITIVE-STRING.html">fail-case-insensitive-string-when-match-case-sensitive-string</a></span> and 
     <span class="tt"><a href="ABNF____FAIL-CHAR-VAL-WHEN-MATCH-NUM_F2PROSE-VAL.html">fail-char-val-when-match-num/prose-val</a></span> 
     have a <span class="v">:cases</span> hint on whether 
     the string at the leaves of the tree has a second natural number or not. 
     Without this hint, the proof fails. 
     Perhaps this case split is related to the fact that 
     these disambiguation theorems are proved via constraints that involve 
     not only the first but also the second natural number in the string, 
     for LL(2) parts of the grammar.</p><p>The proofs of some disambiguation theorems 
     use other disambiguation theorems. 
     The former enable the latter explcitly, to use them as rewrite rules. 
     As explained earlier, some disambiguation theorems group together 
     multiple tree matching hypotheses or multiple parsing conclusions, 
     to reduce the potentially quadratic number of theorems. 
     This means that, 
     when some of these disambiguation theorems 
     are used in the proofs of others, 
     only ``parts'' of the former are actually used.</p><p>A disambiguation theorem about a list of trees matching a repetition, 
     such that another disambiguation theorem exists 
     about a tree matching the element of that repetition 
     and about the same parsing function, 
     is proved just by enabling the latter disambiguation theorem 
     and <span class="tt"><a href="ABNF____TREE-LIST-MATCH-REPETITION-P.html">tree-list-match-repetition-p</a></span>, 
     without any parsing constraint theorems 
     and tree matching constraint theorems. 
     For example, <span class="tt"><a href="ABNF____FAIL-BIT-WHEN-MATCH-_A2CWSP.html">fail-bit-when-match-*cwsp</a></span> is proved just by enabling 
     <span class="tt"><a href="ABNF____FAIL-BIT_F2DIGIT_F2HEXDIG_F2DOT_F2DASH-WHEN-MATCH-CWSP.html">fail-bit/digit/hexdig/dot/dash-when-match-cwsp</a></span> 
     (of which only the <span class="tt"><a href="ABNF____PARSE-BIT.html">parse-bit</a></span> failure is used here) and 
     <span class="tt"><a href="ABNF____TREE-LIST-MATCH-REPETITION-P.html">tree-list-match-repetition-p</a></span>.</p><p>Some disambiguation theorems are proved by 
     expanding the tree matching hypotheses 
     and the parsing function calls in the conclusions, 
     and enabling disambiguation theorems so that they apply to 
     the resulting subtree matching facts and called parsing functions; 
     we also enable 
     predicates like <span class="tt"><a href="ABNF____TREE-TERMINATEDP.html">tree-terminatedp</a></span> and recursive companions and 
     functions like <span class="tt"><a href="ABNF____TREE-_E3STRING.html">tree-&gt;string</a></span> and recursive companions, 
     so that they apply to the subtrees resulting from the matching expansion. 
     For example, 
     <span class="tt"><a href="ABNF____FAIL-ALPHA_F2DIGIT_F2DASH-WHEN-MATCH-ALT-REST-COMP.html">fail-alpha/digit/dash-when-match-alt-rest-comp</a></span> is proved by 
     reducing the tree matching hypothesis to 
     a list of subtrees matching <span class="v">*c-wsp</span> and a tree matching <span class="v">"/"</span>. 
     Then <span class="tt"><a href="ABNF____FAIL-ALPHA_F2DIGIT_F2DASH-WHEN-MATCH-CWSP.html">fail-alpha/digit/dash-when-match-cwsp</a></span> 
     is used for the case in which the list of subtrees is not empty, 
     while <span class="tt"><a href="ABNF____FAIL-ALPHA_F2DIGIT_F2DASH-WHEN-MATCH-SLASH-_F2-CLOSE-ROUND_F2SQUARE.html">fail-alpha/digit/dash-when-match-slash-/-close-round/square</a></span> 
     (the <span class="v">slash</span> part) 
     is used for the case in which the list of subtree is empty.</p><p>The proofs of some disambiguation theorems 
     use certain completeness theorems. 
     In some cases, this is related to LL(*) parts of the grammar: 
     the completeness theorems serve to go ``past'' 
     the unbounded look-ahead, 
     before reaching the point where the constraints 
     from (sub)tree matching and (called) parsing functions are incompatible. 
     For example, <span class="tt"><a href="ABNF____FAIL-CONC-REST-COMP-WHEN-MATCH-ALT-REST-COMP.html">fail-conc-rest-comp-when-match-alt-rest-comp</a></span> 
     shows the incompatibility 
     between <span class="v">(*c-wsp "/" *c-wsp concatenation)</span> 
     and <span class="v">(1*c-wsp repetition)</span>: 
     the completeness theorem <span class="tt"><a href="ABNF____PARSE-1_A2CWSP-WHEN-TREE-LIST-MATCH.html">parse-1*cwsp-when-tree-list-match</a></span> 
     is used to go past the unbounded <span class="v">1*c-wsp</span> 
     that could start <span class="v">(*c-wsp "/" *c-wsp concatenation)</span> 
     to show that <span class="v">repetition</span> is incompatible with <span class="v">"/"</span>. 
     As another example, <span class="tt"><a href="ABNF____FAIL-_A2DIGIT-STAR-_A2DIGIT-WHEN-MATCH-1_A2DIGIT.html">fail-*digit-star-*digit-when-match-1*digit</a></span> 
     shows the incompatibility 
     between <span class="v">(*DIGIT "*" *DIGIT)</span> and <span class="v">1*DIGIT</span>: 
     the completeness theorem <span class="tt"><a href="ABNF____PARSE-_A2DIGIT-WHEN-TREE-LIST-MATCH.html">parse-*digit-when-tree-list-match</a></span> 
     is used to go past the unbounded <span class="v">*DIGIT</span> 
     that could start <span class="v">1*DIGIT</span> 
     to show that <span class="v">"*"</span> is incompatible with 
     the assumptions on the remaining input.</p><p>In other disambiguation theorems, 
     the use of completeness theorems 
     is not related to LL(*) parts of the grammar, 
     but is suggested by subgoals involving trees 
     and parsing functions called by the ones in the theorems' conclusions. 
     For example, in <span class="tt"><a href="ABNF____FAIL-CWSP-WHEN-MATCH-CNL.html">fail-cwsp-when-match-cnl</a></span>, 
     the expansion of <span class="tt"><a href="ABNF____PARSE-CWSP.html">parse-cwsp</a></span> and <span class="tt"><a href="ABNF____PARSE-CNL-WSP.html">parse-cnl-wsp</a></span> 
     produces a call to <span class="tt"><a href="ABNF____PARSE-CNL.html">parse-cnl</a></span> 
     on the string at the leaves of the tree 
     that the theorem hypothesizes to match <span class="v">c-nl</span>: 
     thus, <span class="tt"><a href="ABNF____PARSE-CNL-WHEN-TREE-MATCH.html">parse-cnl-when-tree-match</a></span> applies here.</p><p>When a disambiguation theorem uses a completeness theorem, 
     the former appears in the file just after the latter, 
     with a comment referring to the completeness theorem used. 
     However, the disambiguation theorem is 
     under the manual topic about disambiguation theorems, 
     not under the manual topic about completeness theorems.</p><p>The disambiguation theorem <span class="tt"><a href="ABNF____FAIL-CONC-REST-COMP-WHEN-MATCH-_A2CWSP.html">fail-conc-rest-comp-when-match-*cwsp</a></span> 
     uses, as a rewrite rule, the <a href="ABNF____GRAMMAR-PARSER-PARSING-FAILURE-PROPAGATION.html">parsing failure propagation theorem</a> <span class="tt"><a href="ABNF____FAIL-CONC-REST-COMP-WHEN-FAIL-CWSP.html">fail-conc-rest-comp-when-fail-cwsp</a></span>.</p><p>In some theorems, just enabling some functions does not suffice 
     to expand them in all the places where they need to be expanded 
     (presumably due to ACL2's heuristics for expanding recursive functions). 
     Thus, we use <span class="v">:expand</span> hints in those cases.</p><p>Some of the disambiguation theorem proofs 
     do not seem as systematic as desired. 
     Two of them use <span class="v">:cases</span> hints 
     (different from the ones discussed earlier, 
     which are related to LL(2) parts of the grammar), 
     one of them uses an <span class="v">:induct</span> hint, 
     one of them uses a local lemma, 
     some use various rules about <span class="tt"><a href="ABNF____TREE-LIST-MATCH-REPETITION-P.html">tree-list-match-repetition-p</a></span>, 
     and some expand many definitions. 
     It may be possible to make these proofs more systematic, 
     by introducing and using 
     some additional ``intermediate '' disambiguation theorems 
     and some additional rules about the ABNF semantics.</p>
</body>
</html>
