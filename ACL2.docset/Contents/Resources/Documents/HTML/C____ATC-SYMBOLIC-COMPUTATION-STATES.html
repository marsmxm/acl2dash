<html>
<head>
<meta charset="UTF-8">
<title>Atc-symbolic-computation-states</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=C____ATC-SYMBOLIC-COMPUTATION-STATES">Click for Atc-symbolic-computation-states in the Full Manual</a></h3>

<p>Canonical representation of 
          the computation states for the symbolic execution.</p><p>Starting from a generic (symbolic) computation state, 
     a symbolic execution starting with <span class="tt"><a href="C____EXEC-FUN.html">exec-fun</a></span> 
     will push a frame (for the function), 
     possibly read variables, 
     possibly create new variables, 
     possibly write existing variables, 
     possibly enter new scopes, 
     possibly exit existing scopes, 
     and eventually pop the frame. 
     Just one frame is pushed and then popped 
     because the symbolic execution is compositional w.r.t. functions, 
     i.e. the symbolic execution rewrites function calls in function bodies 
     using the theorems about the called functions.</p><p>The dynamic semantics functions that perform the above actions, 
     namely <span class="tt"><a href="C____PUSH-FRAME.html">push-frame</a></span>, @tsee enter-scope), <span class="tt"><a href="C____CREATE-VAR.html">create-var</a></span>, etc., 
     go into the frame stack component of the computation state, 
     via the <span class="tt"><a href="C____COMPUSTATE-_E3FRAMES.html">compustate-&gt;frames</a></span> accessor. 
     That would lead to a complex symbolic term for the computation state.</p><p>Instead, we pull the ``additions'' to the computation state, 
     i.e. the added frames, scopes, and variables, 
     out of the computation state via the functions 
     <span class="tt"><a href="C____ADD-FRAME.html">add-frame</a></span>, <span class="tt"><a href="C____ENTER-SCOPE.html">enter-scope</a></span>, and <span class="tt"><a href="C____ADD-VAR.html">add-var</a></span>: 
     the first and third one are defined below, 
     while the second one is from the dynamic semantics of C. 
     These three functions are defined to 
     push the frames, scopes, and variables into the computation state, 
     but we leave these functions disabled during symbolic execution, 
     so that the symbolic computation states has these additions explicit. 
     Thus, the symbolic computation state is 
     a sequence of applications of the three functions below 
     to an initial symbolic computation state <span class="v">&lt;compst&gt;</span>:</p><pre class="code">(<a href="C____ADD-VAR.html">add-var</a> ... (<a href="C____ENTER-SCOPE.html">enter-scope</a> (<a href="C____ADD-VAR.html">add-var</a> ... (<a href="C____ADD-FRAME.html">add-frame</a> ... &lt;compst&gt;)...)</pre><p>The reason for introducing a new function <span class="tt"><a href="C____ADD-VAR.html">add-var</a></span>, 
     instead of just using <span class="tt"><a href="C____CREATE-VAR.html">create-var</a></span> (leaving it disabled), 
     is that <span class="tt"><a href="C____ADD-VAR.html">add-var</a></span> unconditionally satisfies certain properties 
     that <span class="tt"><a href="C____CREATE-VAR.html">create-var</a></span> satisfies when it does not return an error: 
     <span class="tt"><a href="C____ADD-VAR.html">add-var</a></span> unconditionally returns a computation state, 
     and always ensured that the added variable is in the computation state. 
     During symbolic execution, 
     <span class="tt"><a href="C____CREATE-VAR.html">create-var</a></span> is replaced with <span class="tt"><a href="C____ADD-VAR.html">add-var</a></span> 
     via a rule that requires <span class="tt"><a href="C____CREATE-VAR.html">create-var</a></span> to not return an error: 
     in a way, <span class="tt"><a href="C____ADD-VAR.html">add-var</a></span> ``caches'' the aforementioned properties. 
     This leads to simpler rules on this kind of computation states: 
     for example, when <span class="tt"><a href="C____READ-VAR.html">read-var</a></span> appears applied to <span class="tt"><a href="C____ADD-VAR.html">add-var</a></span> 
     during symbolic execution, 
     if the two variables are equal, 
     we can readily rewrite this term to the value in <span class="tt"><a href="C____ADD-VAR.html">add-var</a></span>, 
     because that function guarantees the variable to exist with that value. 
     In contrast, if <span class="tt"><a href="C____READ-VAR.html">read-var</a></span> appeared applied to <span class="tt"><a href="C____CREATE-VAR.html">create-var</a></span>, 
     additional hypotheses would be needed (and would have to be discharged) 
     saying that <span class="tt"><a href="C____CREATE-VAR.html">create-var</a></span> succeeds.</p><p>For a similar reason, we introduce a function <span class="tt"><a href="C____UPDATE-VAR.html">update-var</a></span> 
     that replaces <span class="tt"><a href="C____WRITE-VAR.html">write-var</a></span> when the latter succeeds, 
     and that is easier and more efficient to manipulate 
     during symbolic execution.</p><p>Given these canonical representations of computation states, 
     we prove theorems that describe 
     the effect of <span class="tt"><a href="C____PUSH-FRAME.html">push-frame</a></span> and other functions 
     on computation states of this form, 
     where the effect is another state in that form. 
     These theorems are enabled during symbolic execution, 
     and manipulate the computation state.</p><p>In the presence of C loops, 
     which are represented by ACL2 recursive functions, 
     we generate theorems that describe the execution of the loops 
     starting from generic (symbolic) computation states. 
     The execution of a loop does not push a new frame, 
     because the loop executes in the frame of the enclosing C function. 
     In this case, the initial generic computation state 
     includes part of the frame of the enclosing C function; 
     the execution of the loop may add new scopes and variables, 
     so in this case the symbolic computtion state looks like</p><pre class="code">(<a href="C____ADD-VAR.html">add-var</a> ... (<a href="C____ADD-VAR.html">add-var</a> ... (<a href="C____ENTER-SCOPE.html">enter-scope</a> &lt;compst&gt;)...)</pre><p>In fact, the innermost function there 
     must be <span class="tt"><a href="C____ENTER-SCOPE.html">enter-scope</a></span> (it cannot be <span class="tt"><a href="C____ADD-VAR.html">add-var</a></span>), 
     because the loops we generate have compound statements as bodies, 
     which create new scopes.</p><p>The initial symbolic computation state <span class="v">&lt;compst&gt;</span> 
     contains the initial part of the frame 
     of the function that contains the loop; 
     the loop extends the frame with <span class="tt"><a href="C____ENTER-SCOPE.html">enter-scope</a></span> and <span class="tt"><a href="C____ADD-VAR.html">add-var</a></span> 
     as shown above. 
     But the structure of the initial part of the frame 
     is not known in the symbolic execution for the loop itself: 
     it is just the initial <span class="v">&lt;compst&gt;</span>. 
     However, the loop may access variables in that initial part of the frame: 
     the theorem generated for the loop includes hypotheses 
     saying that <span class="tt"><a href="C____READ-VAR.html">read-var</a></span> applied to <span class="v">&lt;compst&gt;</span> 
     for certain variables (i.e. identifiers) 
     yields values of certain C types: 
     this way, any of these <span class="tt"><a href="C____READ-VAR.html">read-var</a></span> calls 
     arising during symbolic execution match those hypotheses. 
     A loop may write to those variables: 
     in this case, after replacing <span class="tt"><a href="C____WRITE-VAR.html">write-var</a></span> with <span class="tt"><a href="C____UPDATE-VAR.html">update-var</a></span> 
     right away as explained earlier, 
     the <span class="tt"><a href="C____UPDATE-VAR.html">update-var</a></span> will go through 
     all the <span class="tt"><a href="C____ADD-VAR.html">add-var</a></span> and <span class="tt"><a href="C____ENTER-SCOPE.html">enter-scope</a></span> layers shown above, 
     and reach <span class="v">&lt;compst&gt;</span>, where it is not further reducible. 
     This may happen for several different variables, 
     leading to states of the form</p><pre class="code">(... (<a href="C____ENTER-SCOPE.html">enter-scope</a> (<a href="C____ADD-VAR.html">add-var</a> (<a href="C____UPDATE-VAR.html">update-var</a> ... (<a href="C____UPDATE-VAR.html">update-var</a> ... &lt;compst&gt;)...)</pre><p>Below we introduce rules to order these <span class="tt"><a href="C____UPDATE-VAR.html">update-var</a></span>s 
     according to the variables, 
     maintaining a canonical form.</p><p>Note that this form of the computation states 
     serves to represent side effects performed by the loop 
     on the initial computation state. 
     The same approach is used to generate proofs for 
     more general side effects, e.g. on the heap, as explained below.</p><p>A computation state has a heap, 
     whose arrays may be updated during the symbolic execution. 
     We represent these updates via the function <span class="tt"><a href="C____UPDATE-ARRAY.html">update-array</a></span>, 
     which is similar to <span class="tt"><a href="C____WRITE-ARRAY.html">write-array</a></span> 
     but always satisfies additional properties: 
     the relation between <span class="tt"><a href="C____UPDATE-ARRAY.html">update-array</a></span> and <span class="tt"><a href="C____WRITE-ARRAY.html">write-array</a></span> 
     is similar to the one between <span class="tt"><a href="C____UPDATE-VAR.html">update-var</a></span> and <span class="tt"><a href="C____WRITE-VAR.html">write-var</a></span> 
     and to the one between <span class="tt"><a href="C____ADD-VAR.html">add-var</a></span> and <span class="tt"><a href="C____CREATE-VAR.html">create-var</a></span>, 
     explained above.</p><p>Arrays may be updated by C functions and C loops, 
     so they need to be incorporated in both of 
     the symbolic computation state representations described above. 
     We push the <span class="tt"><a href="C____UPDATE-ARRAY.html">update-array</a></span> past all the other functions, 
     leading to states of the form</p><pre class="code">(... (<a href="C____ADD-FRAME.html">add-frame</a> (<a href="C____UPDATE-ARRAY.html">update-array</a> ... (<a href="C____UPDATE-ARRAY.html">update-array</a> ... &lt;compst&gt;)...)</pre><p>for C functions and of the form</p><pre class="code">(... (<a href="C____ENTER-SCOPE.html">enter-scope</a> (<a href="C____ADD-VAR.html">add-var</a> ... (<a href="C____UPDATE-ARRAY.html">update-array</a> ... &lt;compst&gt;)...)</pre><p>for C loops. 
     We order the <span class="tt"><a href="C____UPDATE-ARRAY.html">update-array</a></span> calls 
     according to their first argument (i.e. the pointer). 
     Note that for a C functions this first argument is an ACL2 variable, 
     while for a C loop it is a <span class="v">(<a href="C____READ-VAR.html">read-var</a> &lt;identifier&gt; ...)</span>. 
     These two kinds of first arguments never appear together. 
     We prove rules that order according to the symbols, 
     which apply to proofs of theorems of C functions, 
     and we prove rules that order according to the identifiers, 
     which apply to proofs of theorems of C loops.</p><p>After introducing the ACL2 functions 
     that represent the canonical symbolic computation states, 
     we provide theorems expressing how 
     functions like <span class="tt"><a href="C____PUSH-FRAME.html">push-frame</a></span> transform those computation states, 
     maintaining their canonical form.</p>
</body>
</html>
