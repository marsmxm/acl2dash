<html>
<head>
<meta charset="UTF-8">
<title>Exec-expr-pure</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=C____EXEC-EXPR-PURE">Click for Exec-expr-pure in the Full Manual</a></h3>

<p>Execute a pure expression.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(exec-expr-pure e compst) → result</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">e</span> — <font color="#606060">Guard <span class="v">(<a href="C____EXPRP.html">exprp</a> e)</span>.</font>
</dd> 
  <dd>
<span class="tt">compst</span> — <font color="#606060">Guard <span class="v">(<a href="C____COMPUSTATEP.html">compustatep</a> compst)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">result</span> — <font color="#606060">Type <span class="v">(<a href="C____VALUE-RESULTP.html">value-resultp</a> result)</span>.</font>
</dd> 
 
</dl></div> 
<p>We return an error if we encounter a non-pure expression. 
     While function calls do not necessarily have side effects, 
     establishing that requires looking at the function. 
     Thus, for simplicity, we regard function calls to be non-pure, 
     i.e. we return an error if we encounter them here.</p><p>We also reject pre/post-increment/decrement expressions, 
     which are obviously non-pure.</p><p>Recall that our C abstract syntax does not cover 
     all the possible C expressions yet. 
     Thus, we may extend this ACL2 function 
     with support for more kinds of pure expressions in the future.</p><p>If no error occurs, none of the expressions has side effects. 
     Thus, the order in which the sub-expressions are evaluated does not matter: 
     we just proceed left to right.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>exec-expr-pure</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 exec-expr-pure (e compst)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="C____EXPRP.html">exprp</a> e) (<a href="C____COMPUSTATEP.html">compustatep</a> compst))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((__function__ 'exec-expr-pure))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
  (<a href="ACL2____B_A2.html">b*</a>
   ((e (<a href="C____EXPR-FIX.html">expr-fix</a> e)))
   (<a href="C____EXPR-CASE.html">expr-case</a>
    e
    :ident (<a href="C____EXEC-IDENT.html">exec-ident</a> e.get compst)
    :const (<a href="C____EXEC-CONST.html">exec-const</a> e.get)
    :arrsub (<a href="C____EXEC-ARRSUB.html">exec-arrsub</a> (<a href="C____EXEC-EXPR-PURE.html">exec-expr-pure</a> e.arr compst)
                         (<a href="C____EXEC-EXPR-PURE.html">exec-expr-pure</a> e.sub compst)
                         compst)
    :call (<a href="C____ERROR.html">error</a> (<a href="COMMON-LISP____LIST.html">list</a> :non-pure-expr e))
    :member (<a href="C____ERROR.html">error</a> (<a href="COMMON-LISP____LIST.html">list</a> :not-supported-yet e))
    :memberp (<a href="C____ERROR.html">error</a> (<a href="COMMON-LISP____LIST.html">list</a> :not-supported-yet e))
    :postinc (<a href="C____ERROR.html">error</a> (<a href="COMMON-LISP____LIST.html">list</a> :non-pure-expr e))
    :postdec (<a href="C____ERROR.html">error</a> (<a href="COMMON-LISP____LIST.html">list</a> :non-pure-expr e))
    :preinc (<a href="C____ERROR.html">error</a> (<a href="COMMON-LISP____LIST.html">list</a> :non-pure-expr e))
    :predec (<a href="C____ERROR.html">error</a> (<a href="COMMON-LISP____LIST.html">list</a> :non-pure-expr e))
    :unary (<a href="C____EXEC-UNARY.html">exec-unary</a> e.op (<a href="C____EXEC-EXPR-PURE.html">exec-expr-pure</a> e.arg compst))
    :cast (<a href="C____EXEC-CAST.html">exec-cast</a> e.type (<a href="C____EXEC-EXPR-PURE.html">exec-expr-pure</a> e.arg compst))
    :binary
    (<a href="ACL2____B_A2.html">b*</a>
     (((unless (<a href="C____BINOP-PUREP.html">binop-purep</a> e.op))
       (<a href="C____ERROR.html">error</a> (<a href="COMMON-LISP____LIST.html">list</a> :non-pure-expr e))))
     (<a href="COMMON-LISP____CASE.html">case</a>
      (<a href="C____BINOP-KIND.html">binop-kind</a> e.op)
      (:logand
           (<a href="ACL2____B_A2.html">b*</a> ((test1 (<a href="C____EXEC-TEST.html">exec-test</a> (<a href="C____EXEC-EXPR-PURE.html">exec-expr-pure</a> e.arg1 compst)))
                ((when (<a href="C____ERRORP.html">errorp</a> test1)) test1)
                ((when (<a href="COMMON-LISP____NOT.html">not</a> test1)) (<a href="C____SINT.html">sint</a> 0))
                (test2 (<a href="C____EXEC-TEST.html">exec-test</a> (<a href="C____EXEC-EXPR-PURE.html">exec-expr-pure</a> e.arg2 compst)))
                ((when (<a href="C____ERRORP.html">errorp</a> test2)) test2))
               (<a href="COMMON-LISP____IF.html">if</a> test2 (<a href="C____SINT.html">sint</a> 1) (<a href="C____SINT.html">sint</a> 0))))
      (:logor
           (<a href="ACL2____B_A2.html">b*</a> ((test1 (<a href="C____EXEC-TEST.html">exec-test</a> (<a href="C____EXEC-EXPR-PURE.html">exec-expr-pure</a> e.arg1 compst)))
                ((when (<a href="C____ERRORP.html">errorp</a> test1)) test1)
                ((when test1) (<a href="C____SINT.html">sint</a> 1))
                (test2 (<a href="C____EXEC-TEST.html">exec-test</a> (<a href="C____EXEC-EXPR-PURE.html">exec-expr-pure</a> e.arg2 compst)))
                ((when (<a href="C____ERRORP.html">errorp</a> test2)) test2))
               (<a href="COMMON-LISP____IF.html">if</a> test2 (<a href="C____SINT.html">sint</a> 1) (<a href="C____SINT.html">sint</a> 0))))
      (t
        (<a href="C____EXEC-BINARY-STRICT-PURE.html">exec-binary-strict-pure</a> e.op (<a href="C____EXEC-EXPR-PURE.html">exec-expr-pure</a> e.arg1 compst)
                                 (<a href="C____EXEC-EXPR-PURE.html">exec-expr-pure</a> e.arg2 compst)))))
    :cond (<a href="ACL2____B_A2.html">b*</a> ((test (<a href="C____EXEC-TEST.html">exec-test</a> (<a href="C____EXEC-EXPR-PURE.html">exec-expr-pure</a> e.test compst)))
               ((when (<a href="C____ERRORP.html">errorp</a> test)) test))
              (<a href="COMMON-LISP____IF.html">if</a> test (<a href="C____EXEC-EXPR-PURE.html">exec-expr-pure</a> e.then compst)
                  (<a href="C____EXEC-EXPR-PURE.html">exec-expr-pure</a> e.else compst)))))))</pre> 
<p><b>Theorem: </b>value-resultp-of-exec-expr-pure</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> value-resultp-of-exec-expr-pure
        (<a href="ACL2____B_A2.html">b*</a> ((result (<a href="C____EXEC-EXPR-PURE.html">exec-expr-pure</a> e compst)))
            (<a href="C____VALUE-RESULTP.html">value-resultp</a> result))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>value-resultp-of-exec-expr-pure-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   value-resultp-of-exec-expr-pure-forward
   (<a href="ACL2____B_A2.html">b*</a> ((?result (<a href="C____EXEC-EXPR-PURE.html">exec-expr-pure</a> e compst)))
       (<a href="C____VALUE-RESULTP.html">value-resultp</a> result))
   :rule-classes
   ((:forward-chaining :trigger-terms ((<a href="C____EXEC-EXPR-PURE.html">exec-expr-pure</a> e compst)))))</pre> 
<p><b>Theorem: </b>exec-expr-pure-of-expr-fix-e</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> exec-expr-pure-of-expr-fix-e
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____EXEC-EXPR-PURE.html">exec-expr-pure</a> (<a href="C____EXPR-FIX.html">expr-fix</a> e) compst)
               (<a href="C____EXEC-EXPR-PURE.html">exec-expr-pure</a> e compst)))</pre> 
<p><b>Theorem: </b>exec-expr-pure-expr-equiv-congruence-on-e</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> exec-expr-pure-expr-equiv-congruence-on-e
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____EXPR-EQUIV.html">expr-equiv</a> e e-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____EXEC-EXPR-PURE.html">exec-expr-pure</a> e compst)
                        (<a href="C____EXEC-EXPR-PURE.html">exec-expr-pure</a> e-equiv compst)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>exec-expr-pure-of-compustate-fix-compst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> exec-expr-pure-of-compustate-fix-compst
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____EXEC-EXPR-PURE.html">exec-expr-pure</a> e (<a href="C____COMPUSTATE-FIX.html">compustate-fix</a> compst))
               (<a href="C____EXEC-EXPR-PURE.html">exec-expr-pure</a> e compst)))</pre> 
<p><b>Theorem: </b>exec-expr-pure-compustate-equiv-congruence-on-compst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> exec-expr-pure-compustate-equiv-congruence-on-compst
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____COMPUSTATE-EQUIV.html">compustate-equiv</a> compst compst-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____EXEC-EXPR-PURE.html">exec-expr-pure</a> e compst)
                        (<a href="C____EXEC-EXPR-PURE.html">exec-expr-pure</a> e compst-equiv)))
        :rule-classes :congruence)</pre> 

</body>
</html>
