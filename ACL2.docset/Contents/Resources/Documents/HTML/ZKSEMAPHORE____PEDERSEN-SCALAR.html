<html>
<head>
<meta charset="UTF-8">
<title>Pedersen-scalar</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ZKSEMAPHORE____PEDERSEN-SCALAR">Click for Pedersen-scalar in the Full Manual</a></h3>

<p>The function that maps each message segment to a scalar.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(pedersen-scalar segment) → i</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">segment</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____BIT-LISTP.html">bit-listp</a> segment)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">i</span> — <font color="#606060">Type <span class="v">(<a href="COMMON-LISP____INTEGERP.html">integerp</a> i)</span>, given <span class="v">(<a href="ACL2____BIT-LISTP.html">bit-listp</a> segment)</span>.</font>
</dd> 
 
</dl></div> 
<p>This is the function that maps M_i to \langle M_i \rangle 
     in [IS], 
     while in [IS] it is part of the double summation. 
     Each M_i is a segment, 
     and the result is used in the scalar multiplication 
     of a BabyJubjub curve point: 
     this motivates the name of this ACL2 function.</p><p>This is a weighted sum of the encodings of the 4-bit windows 
     (see <span class="tt"><a href="ZKSEMAPHORE____PEDERSEN-ENC.html">pedersen-enc</a></span>). 
     The sum in [IS] appears to be off by one: 
     it should end at k_i, not at k_i-1, 
     otherwise it would ignore the last 4-bit window. 
     The sum in [ES] is correct, because W is 50, 
     but it neglects to accommodate the fact that 
     the last segment may consist of less than 200 bits 
     (i.e. less than 50 4-bit windows). 
     Nonetheless, both issues are easily resolved and fixable: 
     it is clear what our specification should say here.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>pedersen-scalar-loop</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> pedersen-scalar-loop (<a href="ACL2____W.html">w</a> segment)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> w) (<a href="ACL2____BIT-LISTP.html">bit-listp</a> segment))))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____INTEGERP.html">integerp</a> (<a href="COMMON-LISP_____F2.html">/</a> (<a href="ACL2____LEN.html">len</a> segment) 4))))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'pedersen-scalar-loop))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> segment)
                (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP_____A2.html">*</a> (<a href="ZKSEMAPHORE____PEDERSEN-ENC.html">pedersen-enc</a> (<a href="ACL2____TAKE.html">take</a> 4 segment))
                      (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP_____A2.html">*</a> 5 w)))
                   (pedersen-scalar-loop (<a href="COMMON-LISP____1_B2.html">1+</a> w)
                                         (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> 4 segment)))
                0)))</pre> 
<p><b>Theorem: </b>integerp-of-pedersen-scalar-loop</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> integerp-of-pedersen-scalar-loop
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> w) (<a href="ACL2____BIT-LISTP.html">bit-listp</a> segment))
                 (<a href="ACL2____B_A2.html">b*</a> ((i (pedersen-scalar-loop w segment)))
                     (<a href="COMMON-LISP____INTEGERP.html">integerp</a> i)))
        :rule-classes :rewrite)</pre> 
<p><b>Function: </b>pedersen-scalar</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> pedersen-scalar (segment)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____BIT-LISTP.html">bit-listp</a> segment)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____INTEGERP.html">integerp</a> (<a href="COMMON-LISP_____F2.html">/</a> (<a href="ACL2____LEN.html">len</a> segment) 4))))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'pedersen-scalar))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (pedersen-scalar-loop 0 segment)))</pre> 
<p><b>Theorem: </b>integerp-of-pedersen-scalar</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> integerp-of-pedersen-scalar
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____BIT-LISTP.html">bit-listp</a> segment)
                 (<a href="ACL2____B_A2.html">b*</a> ((i (<a href="ZKSEMAPHORE____PEDERSEN-SCALAR.html">pedersen-scalar</a> segment)))
                     (<a href="COMMON-LISP____INTEGERP.html">integerp</a> i)))
        :rule-classes :rewrite)</pre> 

</body>
</html>
