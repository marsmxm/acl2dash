<html>
<head>
<meta charset="UTF-8">
<title>Sorting-candidate-ids</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=IRV____SORTING-CANDIDATE-IDS">Click for Sorting-candidate-ids in the Full Manual</a></h3>

<p></p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>&lt;-ordered-p</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> acl2::&lt;-ordered-p (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> t (<a href="ACL2____NAT-LISTP.html">nat-listp</a> x))
                       :stobjs nil))
       (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____ATOM.html">atom</a> x) t)
             ((<a href="COMMON-LISP____ATOM.html">atom</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x)) t)
             ((<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="COMMON-LISP____FIRST.html">first</a> x) (<a href="COMMON-LISP____SECOND.html">second</a> x))
              (acl2::&lt;-ordered-p (<a href="COMMON-LISP____CDR.html">cdr</a> x)))
             (t (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="COMMON-LISP____SECOND.html">second</a> x) (<a href="COMMON-LISP____FIRST.html">first</a> x)))
                     (acl2::&lt;-ordered-p (<a href="COMMON-LISP____CDR.html">cdr</a> x))))))</pre> 
<p><b>Function: </b>&lt;-merge</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> acl2::&lt;-merge (x y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs nil
                       :guard (<a href="COMMON-LISP____AND.html">and</a> t (<a href="ACL2____NAT-LISTP.html">nat-listp</a> x) (<a href="ACL2____NAT-LISTP.html">nat-listp</a> y))))
       (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____ATOM.html">atom</a> x) y)
             ((<a href="COMMON-LISP____ATOM.html">atom</a> y) x)
             ((<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="COMMON-LISP____CAR.html">car</a> y) (<a href="COMMON-LISP____CAR.html">car</a> x))
              (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> y)
                    (acl2::&lt;-merge x (<a href="COMMON-LISP____CDR.html">cdr</a> y))))
             (t (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> x)
                      (acl2::&lt;-merge (<a href="COMMON-LISP____CDR.html">cdr</a> x) y)))))</pre> 
<p><b>Function: </b>&lt;-merge-tr</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> acl2::&lt;-merge-tr (x y acl2::acc)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs nil
                       :guard (<a href="COMMON-LISP____AND.html">and</a> t (<a href="ACL2____NAT-LISTP.html">nat-listp</a> x) (<a href="ACL2____NAT-LISTP.html">nat-listp</a> y))))
       (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____ATOM.html">atom</a> x)
              (acl2::revappend-without-guard acl2::acc y))
             ((<a href="COMMON-LISP____ATOM.html">atom</a> y)
              (acl2::revappend-without-guard acl2::acc x))
             ((<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="COMMON-LISP____CAR.html">car</a> y) (<a href="COMMON-LISP____CAR.html">car</a> x))
              (acl2::&lt;-merge-tr x (<a href="COMMON-LISP____CDR.html">cdr</a> y)
                                (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> y) acl2::acc)))
             (t (acl2::&lt;-merge-tr (<a href="COMMON-LISP____CDR.html">cdr</a> x)
                                  y (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> x) acl2::acc)))))</pre> 
<p><b>Function: </b>&lt;-mergesort-fixnum</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 acl2::&lt;-mergesort-fixnum (x len)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs nil
                 :guard (<a href="COMMON-LISP____AND.html">and</a> t (<a href="ACL2____NAT-LISTP.html">nat-listp</a> x)
                             (<a href="ACL2____NATP.html">natp</a> len)
                             (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> len (<a href="ACL2____LEN.html">len</a> x))))
          (<a href="COMMON-LISP____TYPE.html">type</a> (signed-byte 30) len))
 (<a href="COMMON-LISP____COND.html">cond</a>
  ((<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____ZP.html">zp</a> len)
        :exec (<a href="COMMON-LISP____EQL.html">eql</a> (<a href="COMMON-LISP____THE.html">the</a> (signed-byte 30) len) 0))
   nil)
  ((<a href="COMMON-LISP____EQL.html">eql</a> (<a href="COMMON-LISP____THE.html">the</a> (signed-byte 30) len) 1)
   (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CAR.html">car</a> x)))
  (t
   (<a href="COMMON-LISP____LET_A2.html">let*</a> ((acl2::len1 (<a href="COMMON-LISP____THE.html">the</a> (signed-byte 30)
                           (<a href="COMMON-LISP____ASH.html">ash</a> (<a href="COMMON-LISP____THE.html">the</a> (signed-byte 30) len) -1)))
          (acl2::len2 (<a href="COMMON-LISP____THE.html">the</a> (signed-byte 30)
                           (<a href="COMMON-LISP____-.html">-</a> (<a href="COMMON-LISP____THE.html">the</a> (signed-byte 30) len)
                              (<a href="COMMON-LISP____THE.html">the</a> (signed-byte 30) acl2::len1))))
          (acl2::part1 (acl2::&lt;-mergesort-fixnum x acl2::len1))
          (acl2::part2
               (acl2::&lt;-mergesort-fixnum (<a href="ACL2____REST-N.html">acl2::rest-n</a> acl2::len1 x)
                                         acl2::len2)))
         (acl2::&lt;-merge-tr acl2::part1 acl2::part2 nil)))))</pre> 
<p><b>Function: </b>&lt;-mergesort-integers</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 acl2::&lt;-mergesort-integers (x len)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs nil
                 :guard (<a href="COMMON-LISP____AND.html">and</a> t (<a href="ACL2____NAT-LISTP.html">nat-listp</a> x)
                             (<a href="ACL2____NATP.html">natp</a> len)
                             (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> len (<a href="ACL2____LEN.html">len</a> x))))
          (<a href="COMMON-LISP____TYPE.html">type</a> integer len))
 (<a href="COMMON-LISP____COND.html">cond</a>
  ((<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____ZP.html">zp</a> len)
        :exec (<a href="COMMON-LISP____EQL.html">eql</a> (<a href="COMMON-LISP____THE.html">the</a> integer len) 0))
   nil)
  ((<a href="COMMON-LISP____EQL.html">eql</a> (<a href="COMMON-LISP____THE.html">the</a> integer len) 1)
   (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CAR.html">car</a> x)))
  (t
   (<a href="COMMON-LISP____LET_A2.html">let*</a>
    ((acl2::len1 (<a href="COMMON-LISP____THE.html">the</a> integer (<a href="COMMON-LISP____ASH.html">ash</a> (<a href="COMMON-LISP____THE.html">the</a> integer len) -1)))
     (acl2::len2 (<a href="COMMON-LISP____THE.html">the</a> integer
                      (<a href="COMMON-LISP____-.html">-</a> (<a href="COMMON-LISP____THE.html">the</a> integer len)
                         (<a href="COMMON-LISP____THE.html">the</a> integer acl2::len1))))
     (acl2::part1 (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="COMMON-LISP____THE.html">the</a> integer acl2::len1)
                         (acl2::mergesort-fixnum-threshold))
                      (acl2::&lt;-mergesort-fixnum x acl2::len1)
                      (acl2::&lt;-mergesort-integers x acl2::len1)))
     (acl2::part2
         (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="COMMON-LISP____THE.html">the</a> integer acl2::len2)
                (acl2::mergesort-fixnum-threshold))
             (acl2::&lt;-mergesort-fixnum (<a href="ACL2____REST-N.html">acl2::rest-n</a> acl2::len1 x)
                                       acl2::len2)
             (acl2::&lt;-mergesort-integers (<a href="ACL2____REST-N.html">acl2::rest-n</a> acl2::len1 x)
                                         acl2::len2))))
    (acl2::&lt;-merge-tr acl2::part1 acl2::part2 nil)))))</pre> 
<p><b>Function: </b>&lt;-sort</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 acl2::&lt;-sort (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> t (<a href="ACL2____NAT-LISTP.html">nat-listp</a> x))
                 :stobjs nil))
 (<a href="ACL2____MBE.html">mbe</a>
  :logic
  (<a href="COMMON-LISP____COND.html">cond</a>
     ((<a href="COMMON-LISP____ATOM.html">atom</a> x) nil)
     ((<a href="COMMON-LISP____ATOM.html">atom</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x)) (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CAR.html">car</a> x)))
     (t (<a href="COMMON-LISP____LET.html">let</a> ((acl2::half (<a href="COMMON-LISP____FLOOR.html">floor</a> (<a href="ACL2____LEN.html">len</a> x) 2)))
             (acl2::&lt;-merge (acl2::&lt;-sort (<a href="ACL2____TAKE.html">take</a> acl2::half x))
                            (acl2::&lt;-sort (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> acl2::half x))))))
  :exec (<a href="COMMON-LISP____LET.html">let</a> ((<a href="ACL2____LEN.html">len</a> (<a href="ACL2____LEN.html">len</a> x)))
             (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> len (acl2::mergesort-fixnum-threshold))
                 (acl2::&lt;-mergesort-fixnum x len)
                 (acl2::&lt;-mergesort-integers x len)))))</pre> 
<p><b>Theorem: </b>&lt;-sort-preserves-duplicity</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> acl2::&lt;-sort-preserves-duplicity
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____DUPLICITY.html">acl2::duplicity</a> a (acl2::&lt;-sort x))
               (<a href="ACL2____DUPLICITY.html">acl2::duplicity</a> a x)))</pre> 
<p><b>Theorem: </b>&lt;-sort-creates-comparable-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> acl2::&lt;-sort-creates-comparable-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____NAT-LISTP.html">nat-listp</a> x)
                 (<a href="ACL2____NAT-LISTP.html">nat-listp</a> (acl2::&lt;-sort x))))</pre> 
<p><b>Theorem: </b>&lt;-sort-sorts</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> acl2::&lt;-sort-sorts
        (acl2::&lt;-ordered-p (acl2::&lt;-sort x)))</pre> 
<p><b>Theorem: </b>&lt;-sort-no-duplicatesp-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> acl2::&lt;-sort-no-duplicatesp-equal
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____NO-DUPLICATESP-EQUAL.html">no-duplicatesp-equal</a> (acl2::&lt;-sort x))
               (<a href="ACL2____NO-DUPLICATESP-EQUAL.html">no-duplicatesp-equal</a> x)))</pre> 
<p><b>Theorem: </b>&lt;-sort-true-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> acl2::&lt;-sort-true-listp
        (<a href="ACL2____TRUE-LISTP.html">true-listp</a> (acl2::&lt;-sort x))
        :rule-classes :type-prescription)</pre> 
<p><b>Theorem: </b>&lt;-sort-len</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> acl2::&lt;-sort-len
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> (acl2::&lt;-sort x)) (<a href="ACL2____LEN.html">len</a> x)))</pre> 
<p><b>Theorem: </b>&lt;-sort-consp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> acl2::&lt;-sort-consp
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (acl2::&lt;-sort x))
               (<a href="COMMON-LISP____CONSP.html">consp</a> x)))</pre> 
<p><b>Theorem: </b>&lt;-sort-is-identity-under-set-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> acl2::&lt;-sort-is-identity-under-set-equiv
        (<a href="ACL2____SET-EQUIV.html">acl2::set-equiv</a> (acl2::&lt;-sort x) x))</pre> 
<p><b>Function: </b>&lt;-insert</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> acl2::&lt;-insert (elt x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> t (<a href="ACL2____NATP.html">natp</a> elt) (<a href="ACL2____NAT-LISTP.html">nat-listp</a> x))
                       :stobjs nil))
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)
           (<a href="COMMON-LISP____LIST.html">list</a> elt)
           (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="COMMON-LISP____CAR.html">car</a> x) elt)
               (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> x)
                     (acl2::&lt;-insert elt (<a href="COMMON-LISP____CDR.html">cdr</a> x)))
               (<a href="COMMON-LISP____CONS.html">cons</a> elt x))))</pre> 
<p><b>Function: </b>&lt;-insertsort</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> acl2::&lt;-insertsort (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> t (<a href="ACL2____NAT-LISTP.html">nat-listp</a> x))
                       :stobjs nil))
       (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)
           nil
           (acl2::&lt;-insert (<a href="COMMON-LISP____CAR.html">car</a> x)
                           (acl2::&lt;-insertsort (<a href="COMMON-LISP____CDR.html">cdr</a> x)))))</pre> 
<p><b>Theorem: </b>&lt;-mergesort-equals-insertsort</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> acl2::&lt;-mergesort-equals-insertsort
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (acl2::&lt;-sort x)
               (acl2::&lt;-insertsort x)))</pre> 
<p><b>Theorem: </b>&lt;-insertsort-preserves-duplicity</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> acl2::&lt;-insertsort-preserves-duplicity
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____DUPLICITY.html">acl2::duplicity</a> a (acl2::&lt;-insertsort x))
               (<a href="ACL2____DUPLICITY.html">acl2::duplicity</a> a x)))</pre> 
<p><b>Theorem: </b>&lt;-insertsort-creates-comparable-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> acl2::&lt;-insertsort-creates-comparable-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____NAT-LISTP.html">nat-listp</a> x)
                 (<a href="ACL2____NAT-LISTP.html">nat-listp</a> (acl2::&lt;-insertsort x))))</pre> 
<p><b>Theorem: </b>&lt;-insertsort-sorts</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> acl2::&lt;-insertsort-sorts
        (acl2::&lt;-ordered-p (acl2::&lt;-insertsort x)))</pre> 
<p><b>Theorem: </b>&lt;-insertsort-no-duplicatesp-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> acl2::&lt;-insertsort-no-duplicatesp-equal
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____NO-DUPLICATESP-EQUAL.html">no-duplicatesp-equal</a> (acl2::&lt;-insertsort x))
               (<a href="ACL2____NO-DUPLICATESP-EQUAL.html">no-duplicatesp-equal</a> x)))</pre> 
<p><b>Theorem: </b>&lt;-insertsort-true-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> acl2::&lt;-insertsort-true-listp
        (<a href="ACL2____TRUE-LISTP.html">true-listp</a> (acl2::&lt;-insertsort x))
        :rule-classes :type-prescription)</pre> 
<p><b>Theorem: </b>&lt;-insertsort-len</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> acl2::&lt;-insertsort-len
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> (acl2::&lt;-insertsort x))
               (<a href="ACL2____LEN.html">len</a> x)))</pre> 
<p><b>Theorem: </b>&lt;-insertsort-consp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> acl2::&lt;-insertsort-consp
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (acl2::&lt;-insertsort x))
               (<a href="COMMON-LISP____CONSP.html">consp</a> x)))</pre> 
<p><b>Theorem: </b>subsetp-cdr-and-&lt;-insertsort</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> subsetp-cdr-and-&lt;-insertsort
        (<a href="ACL2____SUBSETP-EQUAL.html">subsetp-equal</a> (acl2::&lt;-insertsort (<a href="COMMON-LISP____CDR.html">cdr</a> a))
                       (acl2::&lt;-insertsort a)))</pre> 
<p><b>Theorem: </b>a-is-a-subset-of-&lt;-insertsort-a</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> a-is-a-subset-of-&lt;-insertsort-a
        (<a href="ACL2____SUBSETP-EQUAL.html">subsetp-equal</a> a (acl2::&lt;-insertsort a)))</pre> 
<p><b>Theorem: </b>&lt;-insertsort-a-is-a-subset-of-a</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> &lt;-insertsort-a-is-a-subset-of-a
        (<a href="ACL2____SUBSETP-EQUAL.html">subsetp-equal</a> (acl2::&lt;-insertsort a)
                       a))</pre> 
<p><b>Theorem: </b>&lt;-insertsort-equal-under-set-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> &lt;-insertsort-equal-under-set-equiv
        (<a href="ACL2____SET-EQUIV.html">acl2::set-equiv</a> (acl2::&lt;-insertsort a)
                         a))</pre> 

</body>
</html>
