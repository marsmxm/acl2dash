<html>
<head>
<meta charset="UTF-8">
<title>Atj-tutorial-ACL2-environment</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=JAVA____ATJ-TUTORIAL-ACL2-ENVIRONMENT">Click for Atj-tutorial-ACL2-environment in the Full Manual</a></h3>

<p>ATJ tutorial: Java Representation of the ACL2 Environment.</p><p><a href="JAVA____ATJ-TUTORIAL-AIJ.html">AIJ</a> provides a Java representation of the ACL2 environment. 
    For the <a href="JAVA____ATJ-TUTORIAL-DEEP.html">deep embedding approach</a>, this environment consists of <a href="ACL2____DEFPKG.html">ACL2 package definitions</a> and <a href="COMMON-LISP____DEFUN.html">ACL2 function definitions</a>; for the <a href="JAVA____ATJ-TUTORIAL-SHALLOW.html">shallow embedding approach</a>, this environment consists of package definitions only, 
    because in this approach functions are represented as methods 
    outside of AIJ. 
    This tutorial page may be skipped at first reading.</p><h5>Representation of the ACL2 Package Definitions</h5><p>AIJ represents ACL2 packages 
    as objects of the class <span class="v">Acl2Package</span> in the <a href="JAVA____ATJ-TUTORIAL-SIMPLIFIED-UML.html">simplified UML class diagram</a> below. 
    An <span class="v">Acl2PackageName</span> is a wrapper of <span class="v">java.lang.String</span> 
    that enforces the restrictions of valid package names 
    described in <span class="tt"><a href="ACL2____DEFPKG.html">defpkg</a></span>. 
    An <span class="v">Acl2Package</span> stores, in private fields, 
    a name and a list of 0 or more imported symbols. 
    A <span class="tt"><a href="ACL2____DEFPKG.html">defpkg</a></span> may also include a documentation string, 
    but this is not represented in <span class="v">Acl2Package</span>.</p><div class="ximg"><img src="../res/kestrel-java-atj-images/package-classes.png"></div><p>The <span class="v">Acl2Package</span> class also has a private static field 
    that contains all the packages defined so far, 
    as a <span class="v">java.util.Map&lt;Acl2PackageName,Acl2Package&gt;</span> object. 
    This map is initially empty; 
    it is extended, one package definition at a time, 
    via the static method 
    <span class="v">Acl2Package.define(Acl2PackageName, List&lt;Acl2Symbol&gt;)</span>. 
    This method ensures that the first three packages defined are 
    <span class="v">"KEYWORD"</span>, <span class="v">"COMMON-LISP"</span>, and <span class="v">"ACL2"</span>, 
    in that order; 
    these are the first three packages, in that order, 
    that appear in the ACL2 <a href="ACL2____WORLD.html">world</a>. 
    The method also checks that 
    <span class="v">"KEYWORD"</span> and <span class="v">"COMMON-LISP"</span> have empty import lists, 
    and that <span class="v">"ACL2"</span> only imports symbols from <span class="v">"COMMON-LISP"</span>. 
    These properties, which can be easily checked in an ACL2 shell, 
    help guarantee the well-formedness of certain <span class="v">Acl2Symbol</span> instances 
    that are pre-created when the class <span class="v">Acl2Symbol</span> is initialized 
    (i.e. before any other symbol can be created). 
    See AIJ's Java code and Javadoc for more details.</p><h5>Building of the ACL2 Package Definitions</h5><p>The Java code generated by ATJ repeatedly calls the method 
    <span class="v">Acl2Package.define(Acl2PackageName, List&lt;Acl2Symbol&gt;)</span> 
    to define all the ACL2 packages 
    that are known when ATJ is called to generate the Java code.</p><h5>Representation of the ACL2 Function Definitions</h5><p>AIJ represents ACL2 functions as decribed in <a href="JAVA____ATJ-TUTORIAL-ACL2-TERMS.html">atj-tutorial-ACL2-terms</a>. 
    The <a href="JAVA____ATJ-TUTORIAL-SIMPLIFIED-UML.html">simplified UML class diagram</a> on that page shows that instances of <span class="v">Acl2DefinedFunction</span> 
    have lambda expressions as definientia, 
    where each lambda expression consists of 
    zero or more formal parameters and a body. 
    An ACL2 function definition has additional information, 
    such as the guard of the function; 
    none of this additional information is currently present 
    in AIJ's Java representation.</p><p>The <span class="v">Acl2DefinedFunction</span> class also has a private static field 
    that contains all the functions defined so far, 
    as a <span class="v">java.util.Map&lt;Acl2Symbol, Acl2DefinedFunction&gt;</span> object. 
    This map is initially empty; 
    it is extended, one function definition at a time, 
    via the instance method 
    <span class="v">Acl2NamedFunction.define(Acl2Symbol[], Acl2Term)</span>, 
    which is abstract in the public class <span class="v">Acl2NamedFunction</span> 
    and implemented in the non-public class <span class="v">Acl2DefinedFunction</span>. 
    Objects of <span class="v">Acl2NamedFunction</span> are interned, 
    i.e. there is a unique instance for each function name: 
    this is ensured by the public factory method 
    <span class="v">Acl2NamedFunction.make(Acl2Symbol)</span>, 
    which is the only way for code external to AIJ 
    to build <span class="v">Acl2NamedFunction</span> objects. 
    Thus, calling the instance method 
    <span class="v">Acl2NamedFunction.define(Acl2Symbol[], Acl2Term)</span> 
    always defines that unique instance; 
    the method sets the private instance field <span class="v">definiens</span>.</p><h5>Building of the ACL2 Function Definitions</h5><p>In the <a href="JAVA____ATJ-TUTORIAL-DEEP.html">deep embedding approach</a>, the Java code generated by ATJ repeatedly 
    builds <span class="v">Acl2NamedFunction</span> instances 
    via <span class="v">Acl2NamedFunction.make(Acl2Symbol)</span> 
    for all the ACL2 defined functions to be translated to Java, 
    and defines each such function by calling 
    <span class="v">Acl2NamedFunction.define(Acl2Symbol[], Acl2Term)</span> 
    on those instances. 
    The ATJ-generated code also uses <span class="v">Acl2NamedFunction.make(Acl2Symbol)</span> 
    to build function names as part of the ACL2 terms 
    that form the bodies of defined functions; 
    there is just one instance for each name, as explained above, 
    to which the definition is attached. 
    The ATJ-generated code also builds <span class="v">Acl2NamedFunction</span> instances 
    for functions that are implemented natively in Java 
    (e.g. for the <a href="ACL2____PRIMITIVE.html">ACL2 primitive functions</a>, which have no definition), 
    i.e. for instances of the <span class="v">Acl2NativeFunction</span> class. 
    The factory method <span class="v">Acl2NamedFunction.make(Acl2Symbol)</span> 
    knows which function symbols have native Java implementations 
    and accordingly returns 
    either <span class="v">Acl2NativeFunction</span> or <span class="v">Acl2DefinedFunction</span> instances. 
    The ATJ-generated code calls 
    <span class="v">Acl2NamedFunction.define(Acl2Symbol[], Acl2Term)</span> 
    only on instances of <span class="v">Acl2DefinedFunction</span>; 
    ATJ also knows which ACL2 functions have native Java implementations 
    (the implementing method in <span class="v">Acl2NativeFunction</span> 
    of <span class="v">Acl2NamedFunction.define(Acl2Symbol[], Acl2Term)</span> 
    throws an exception).</p><div class="box"></div><p><b>Previous:</b> <a href="JAVA____ATJ-TUTORIAL-ACL2-TERMS.html">Java Representation of the ACL2 Terms</a></p><p><b>Next:</b> <a href="JAVA____ATJ-TUTORIAL-NATIVE-FUNCTIONS.html">Native Java Implementations of ACL2 Functions</a></p>
</body>
</html>
