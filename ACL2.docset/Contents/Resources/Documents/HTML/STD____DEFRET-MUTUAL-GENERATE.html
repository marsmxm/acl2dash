<html>
<head>
<meta charset="UTF-8">
<title>Defret-mutual-generate</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=STD____DEFRET-MUTUAL-GENERATE">Click for Defret-mutual-generate in the Full Manual</a></h3>

<p>Generate a <a href="STD____DEFRET-MUTUAL.html">defret-mutual</a> form using rules that produce hyps and 
          conclusion conjuncts based on <a href="ACL2____DEFINE.html">define</a> formal and return 
          specifiers.</p> 
<h3>Motivation</h3> 
 
<p>Suppose you have a mutual recursion with several functions and you want to 
prove some theorems about them.  Often you need to prove something about all of 
them at once using mutual induction; <a href="STD____DEFRET-MUTUAL.html">defret-mutual</a> and <a href="ACL2____MAKE-FLAG.html">ACL2::make-flag</a> are good tools for doing this. But sometimes there are so many 
functions that it becomes unwieldy to write a full <span class="v">defret-mutual</span> form 
containing an explicit theorem for each function.  This often involves a lot of 
repetition and isn't very DRY.  Instead, one might be able to generate the 
theorems using rules based on the input/output signature of the functions. 
That is what defret-mutual-generate is intended to do.</p> 
 
<p>The general idea is that for each function in the clique, we get that 
function's input/output signature and apply a sequence of rules, defined by the 
arguments to <span class="v">defret-mutual-generate</span>, which result in a theorem to prove. 
The rules may check things like the presence or absence of a formal or return 
value, the name of the function, etc., and compose the resulting theorem by 
adding hypothesis or conclusion conjuncts, <span class="v">B*</span> bindings, etc.  Then we 
take the results from all the functions in the clique and prove them all 
together using <span class="v">defret-mutual</span>.</p> 
 
<h4>Invocation Syntax</h4> 
 
<p>For a single set of rules generating a mutually inductive set of theorems, use 
the following form.  The conditions and actions used by the rules entries are 
described below.</p> 
 
<pre class="code">(<a href="STD____DEFRET-MUTUAL-GENERATE.html">defret-mutual-generate</a> thmname-template
  :rules ((condition1 action1 ...)
          (condition2 action2 ...)
          ...)
  ;; abbreviations that generate more rules
  :formal-hyps ...
  :return-concls ...
  :function-keys ...

  ;; optional keywords
  :hints top-level-hints
  :instructions rarely-used
  :no-induction-hint nil
  :otf-flg nil
  ;; defaults to the most recent defines form:
  :mutual-recursion defines-name)</pre> 
 
<p>A few other keywords effectively generate additional <span class="v">:rules</span> entries, as 
discussed below under Common Abbreviations.  These may be used wherever 
<span class="v">:rules</span> may occur.</p> 
 
<p>For example:</p> 
 
<pre class="code">(<a href="STD____DEFRET-MUTUAL-GENERATE.html">defret-mutual-generate</a> term-vars-of-&lt;fn&gt;
   :rules ((t
            (:each-formal :type pseudo-termp :var x (:add-hyp (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____MEMBER.html">member</a> v (term-vars x)))))
            (:each-formal :type pseudo-term-listp :var x (:add-hyp (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____MEMBER.html">member</a> v (termlist-vars x)))))
            (:each-return :type pseudo-termp :var x (:add-concl (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____MEMBER.html">member</a> v (term-vars x)))))
            (:each-return :type pseudo-term-listp :var x (:add-concl (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____MEMBER.html">member</a> v (termlist-vars x))))))
           ((:has-return :type pseudo-term-listp)
            (:set-thmname termlist-vars-of-&lt;fn&gt;))
           ((:has-formal :name x :type pseudo-term-listp)
            (:add-keyword :hints ('(:expand ((termlist-vars x)))))))
  :mutual-recursion my-rewriter)</pre> 
 
<p>Sometimes it is necessary to prove more than one kind of theorem at once 
within a mutual induction.  In this case <span class="v">defret-mutual-generate</span> allows 
more than one set of rules to apply separately to each function in the mutual 
recursion, and makes a <span class="v">defret-mutual</span> form containing all of the resulting 
<span class="v">defret</span> forms. The syntax for this is as follows:</p> 
 
<pre class="code">(<a href="STD____DEFRET-MUTUAL-GENERATE.html">defret-mutual-generate</a>
  (defret-generate thmname-template1
    :rules rules1
    ...)
  (defret-generate thmname-template2
    :rules rules2
    ...)
  ...
  ;; same optional keywords as above
  :hints top-level-hints
  :mutual-recursion my-defines-name)</pre> 
 
 
<h3>Theorem Generation Rules</h3> 
 
<p>The format of rules and rule abbreviations are described in the topic <a href="STD____DEFRETGEN-RULES.html">defretgen-rules</a>.</p> 

</body>
</html>
