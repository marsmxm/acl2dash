<html>
<head>
<meta charset="UTF-8">
<title>Without-evisc</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____WITHOUT-EVISC">Click for Without-evisc in the Full Manual</a></h3>

<p>Print output in full</p><pre class="code">General Form:
(<a href="ACL2____WITHOUT-EVISC.html">without-evisc</a> form)</pre> 
 
 <p>where <span class="v">form</span> is any expression to evaluate.  The effect is to evaluate 
 <span class="v">form</span> as though the <span class="v">without-evisc</span> wrapper were absent, except that 
 expressions are printed in full for the ensuing output, regardless of the 
 current evisc-tuples (see <a href="ACL2____SET-EVISC-TUPLE.html">set-evisc-tuple</a>).  See <a href="ACL2____SET-IPRINT.html">set-iprint</a> for 
 an example.</p> 
 
 <p>More precisely, <span class="v">without-evisc</span> binds each of the term-evisc-tuple, 
 ld-evisc-tuple, abbrev-evisc-tuple and gag-mode-evisc-tuple to <span class="v">nil</span> (see 
 <a href="ACL2____SET-EVISC-TUPLE.html">set-evisc-tuple</a>).  It does not modify the trace or brr evisc-tuples, so 
 trace and brr output are not modified by <span class="v">without-evisc</span>.  Also note that 
 calls of printing functions such as <span class="tt"><a href="ACL2____FMT.html">fmt</a></span> that include explicit 
 evisc-tuples will not have those evisc-tuples overridden.  The following 
 example illustrates this point.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="ACL2____WITHOUT-EVISC.html">without-evisc</a>
        (<a href="ACL2____FMS.html">fms</a> "~x0~%"
             (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> #0 '((a b ((c d)) e f g) u v w x y)))
             *standard-co*
             state
             (<a href="ACL2____EVISC-TUPLE.html">evisc-tuple</a> 2 3 nil nil)))

((A B # ...) U V ...)
&lt;state&gt;
ACL2 !&gt;</pre> 
 
 <p>We conclude with two remarks.  (1) A call of <span class="v">without-evisc</span> on 
 expression <span class="v">exp</span> actually invokes a specialized call of <span class="tt"><a href="ACL2____LD.html">ld</a></span> on a 
 one-element list containing <span class="v">exp</span>, which prints the value returned by 
 evaluation of <span class="v">exp</span>.  It actually returns the useless value <span class="v">(<a href="ACL2____MV.html">mv</a> nil
 :invisible state)</span>, except that if an error is detected then it generally 
 returns <span class="v">(<a href="ACL2____MV.html">mv</a> t nil state)</span>, indicating an error; see <a href="ACL2____ERROR-TRIPLE.html">error-triple</a>. 
 So do not use <span class="v">without-evisc</span> in programs if you want the value of the 
 computation to be returned, rather than merely printed.  (2) Even when using 
 without-evisc, if the ACL2 logical <a href="ACL2____WORLD.html">world</a> is part of the value returned, 
 it will be printed in abbreviated form because the ACL2 read-eval-print loop 
 always arranges for this to be the case, regardless of the ld-evisc-tuple. 
 For example:</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="ACL2____WITHOUT-EVISC.html">without-evisc</a> (<a href="ACL2____W.html">w</a> state))
&lt;world&gt;
ACL2 !&gt;</pre> 
 
 <p>An alternative to the use of <span class="v">without-evisc</span> is to explore large objects 
 using the ACL2 function <span class="v">(<a href="ACL2____WALKABOUT.html">walkabout</a> object state)</span>; see <a href="ACL2____WALKABOUT.html">walkabout</a>.</p>
</body>
</html>
