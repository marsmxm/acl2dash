<html>
<head>
<meta charset="UTF-8">
<title>Integer-type-to-type-name</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=C____INTEGER-TYPE-TO-TYPE-NAME">Click for Integer-type-to-type-name in the Full Manual</a></h3>

<p>Turn an integer type into a type name.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(integer-type-to-type-name type) → tyname</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">type</span> — <font color="#606060">Guard <span class="v">(<a href="C____TYPEP.html">typep</a> type)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">tyname</span> — <font color="#606060">Type <span class="v">(<a href="C____TYNAMEP.html">tynamep</a> tyname)</span>.</font>
</dd> 
 
</dl></div> 
<p>Our model of type names does not cover all the types we model; 
     specifically, our type names only have one level of pointers allowed, 
     while our types allow multiple levels. 
     So at the moment we cannot have a total function 
     from all our types to our type names. 
     For now we actually only need the mapping for integer types, 
     so we define this function on integer types for now.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>integer-type-to-type-name</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> integer-type-to-type-name (<a href="C____TYPE.html">type</a>)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="C____TYPEP.html">typep</a> type)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="C____TYPE-INTEGERP.html">type-integerp</a> type)))
       (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'integer-type-to-type-name))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
            (<a href="COMMON-LISP____CASE.html">case</a> (<a href="C____TYPE-KIND.html">type-kind</a> type)
                  (:char (<a href="C____MAKE-TYNAME.html">make-tyname</a> :specs (<a href="C____TYSPECSEQ-CHAR.html">tyspecseq-char</a>)
                                      :pointerp nil))
                  (:schar (<a href="C____MAKE-TYNAME.html">make-tyname</a> :specs (<a href="C____TYSPECSEQ-SCHAR.html">tyspecseq-schar</a>)
                                       :pointerp nil))
                  (:uchar (<a href="C____MAKE-TYNAME.html">make-tyname</a> :specs (<a href="C____TYSPECSEQ-UCHAR.html">tyspecseq-uchar</a>)
                                       :pointerp nil))
                  (:sshort (<a href="C____MAKE-TYNAME.html">make-tyname</a> :specs (<a href="C____TYSPECSEQ-SSHORT.html">tyspecseq-sshort</a>)
                                        :pointerp nil))
                  (:ushort (<a href="C____MAKE-TYNAME.html">make-tyname</a> :specs (<a href="C____TYSPECSEQ-USHORT.html">tyspecseq-ushort</a>)
                                        :pointerp nil))
                  (:sint (<a href="C____MAKE-TYNAME.html">make-tyname</a> :specs (<a href="C____TYSPECSEQ-SINT.html">tyspecseq-sint</a>)
                                      :pointerp nil))
                  (:uint (<a href="C____MAKE-TYNAME.html">make-tyname</a> :specs (<a href="C____TYSPECSEQ-UINT.html">tyspecseq-uint</a>)
                                      :pointerp nil))
                  (:slong (<a href="C____MAKE-TYNAME.html">make-tyname</a> :specs (<a href="C____TYSPECSEQ-SLONG.html">tyspecseq-slong</a>)
                                       :pointerp nil))
                  (:ulong (<a href="C____MAKE-TYNAME.html">make-tyname</a> :specs (<a href="C____TYSPECSEQ-ULONG.html">tyspecseq-ulong</a>)
                                       :pointerp nil))
                  (:sllong (<a href="C____MAKE-TYNAME.html">make-tyname</a> :specs (<a href="C____TYSPECSEQ-SLLONG.html">tyspecseq-sllong</a>)
                                        :pointerp nil))
                  (:ullong (<a href="C____MAKE-TYNAME.html">make-tyname</a> :specs (<a href="C____TYSPECSEQ-ULLONG.html">tyspecseq-ullong</a>)
                                        :pointerp nil))
                  (t (<a href="ACL2____PROG2_42.html">prog2$</a> (<a href="ACL2____IMPOSSIBLE.html">impossible</a>) (<a href="C____IRR-TYNAME.html">irr-tyname</a>))))))</pre> 
<p><b>Theorem: </b>tynamep-of-integer-type-to-type-name</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> tynamep-of-integer-type-to-type-name
        (<a href="ACL2____B_A2.html">b*</a> ((<a href="C____TYNAME.html">tyname</a> (<a href="C____INTEGER-TYPE-TO-TYPE-NAME.html">integer-type-to-type-name</a> type)))
            (<a href="C____TYNAMEP.html">tynamep</a> tyname))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>integer-type-to-type-name-of-type-fix-type</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> integer-type-to-type-name-of-type-fix-type
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____INTEGER-TYPE-TO-TYPE-NAME.html">integer-type-to-type-name</a> (<a href="C____TYPE-FIX.html">type-fix</a> type))
               (<a href="C____INTEGER-TYPE-TO-TYPE-NAME.html">integer-type-to-type-name</a> type)))</pre> 
<p><b>Theorem: </b>integer-type-to-type-name-type-equiv-congruence-on-type</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> integer-type-to-type-name-type-equiv-congruence-on-type
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="C____TYPE-EQUIV.html">type-equiv</a> type type-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="C____INTEGER-TYPE-TO-TYPE-NAME.html">integer-type-to-type-name</a> type)
                        (<a href="C____INTEGER-TYPE-TO-TYPE-NAME.html">integer-type-to-type-name</a> type-equiv)))
        :rule-classes :congruence)</pre> 

</body>
</html>
