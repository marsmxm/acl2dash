<html>
<head>
<meta charset="UTF-8">
<title>Vl-reorient-partitioned-args</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=VL2014____VL-REORIENT-PARTITIONED-ARGS">Click for Vl-reorient-partitioned-args in the Full Manual</a></h3>

<p>Group arguments for instances after <a href="VL2014____VL-PARTITION-PLAINARGLIST.html">vl-partition-plainarglist</a>.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(vl-reorient-partitioned-args lists n) → *</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">lists</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____TRUE-LISTP.html">true-listp</a> lists)</span>.</font>
</dd> 
  <dd>
<span class="tt">n</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____NATP.html">natp</a> n)</span>.</font>
</dd> 
 
</dl></div> 
<p>We are given <span class="v">lists</span>, which should be a <a href="VL2014____VL-PLAINARGLISTLIST-P.html">vl-plainarglistlist-p</a> formed by calling <a href="VL2014____VL-PARTITION-PLAINARGLIST.html">vl-partition-plainarglist</a>, and 
<span class="v">n</span>, the number of instances we are trying to generate.  Note that every 
list in <span class="v">lists</span> has length <span class="v">n</span>.</p> 
 
<p>At this point, the args are bundled up in a bad order.  That is, to create 
the new instances, we want to have lists of the form</p> 
 
<pre class="code">(arg1-slice1 arg2-slice1 arg3-slice1 ...) for the first instance,
(arg1-slice2 arg2-slice2 arg3-slice2 ...) for the second instance,
etc.</pre> 
 
<p>But instead, what <a href="VL2014____VL-PARTITION-PLAINARGLIST.html">vl-partition-plainarglist</a> does is create lists 
of the slices, e.g., </p> 
 
<pre class="code">(arg1-slice1 arg1-slice2 arg1-slice3 ...)
(arg2-slice1 arg2-slice2 arg2-slice3 ...)
etc.</pre> 
 
<p>So our goal is simply to simply transpose this matrix and aggregate the data 
by slice, rather than by argument.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>vl-reorient-partitioned-args</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     vl-reorient-partitioned-args (lists n)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> lists) (<a href="ACL2____NATP.html">natp</a> n))))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="VL2014____ALL-HAVE-LEN.html">all-have-len</a> lists n)))
     (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'vl-reorient-partitioned-args))
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
          (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> n)
              nil
              (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="ACL2____STRIP-CARS.html">strip-cars</a> lists)
                    (<a href="VL2014____VL-REORIENT-PARTITIONED-ARGS.html">vl-reorient-partitioned-args</a> (<a href="ACL2____STRIP-CDRS.html">strip-cdrs</a> lists)
                                                  (<a href="COMMON-LISP____-.html">-</a> n 1))))))</pre> 
<p><b>Theorem: </b>vl-plainarglistlist-p-of-vl-reorient-partitioned-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 vl-plainarglistlist-p-of-vl-reorient-partitioned-args
 (<a href="ACL2____IMPLIES.html">implies</a>
    (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____FORCE.html">force</a> (<a href="VL2014____VL-PLAINARGLISTLIST-P.html">vl-plainarglistlist-p</a> lists))
         (<a href="ACL2____FORCE.html">force</a> (<a href="VL2014____ALL-HAVE-LEN.html">all-have-len</a> lists n)))
    (<a href="VL2014____VL-PLAINARGLISTLIST-P.html">vl-plainarglistlist-p</a> (<a href="VL2014____VL-REORIENT-PARTITIONED-ARGS.html">vl-reorient-partitioned-args</a> lists n))))</pre> 
<p><b>Theorem: </b>all-have-len-of-vl-reorient-partitioned-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> all-have-len-of-vl-reorient-partitioned-args
        (<a href="VL2014____ALL-HAVE-LEN.html">all-have-len</a> (<a href="VL2014____VL-REORIENT-PARTITIONED-ARGS.html">vl-reorient-partitioned-args</a> lists n)
                      (<a href="ACL2____LEN.html">len</a> lists)))</pre> 
<p><b>Theorem: </b>len-of-vl-reorient-partitioned-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> len-of-vl-reorient-partitioned-args
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> (<a href="VL2014____VL-REORIENT-PARTITIONED-ARGS.html">vl-reorient-partitioned-args</a> lists n))
               (<a href="ACL2____NFIX.html">nfix</a> n)))</pre> 
<p><b>Theorem: </b>vl-reorient-partitioned-args-of-list-fix-lists</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> vl-reorient-partitioned-args-of-list-fix-lists
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="VL2014____VL-REORIENT-PARTITIONED-ARGS.html">vl-reorient-partitioned-args</a> (<a href="ACL2____LIST-FIX.html">list-fix</a> lists)
                                             n)
               (<a href="VL2014____VL-REORIENT-PARTITIONED-ARGS.html">vl-reorient-partitioned-args</a> lists n)))</pre> 
<p><b>Theorem: </b>vl-reorient-partitioned-args-list-equiv-congruence-on-lists</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     vl-reorient-partitioned-args-list-equiv-congruence-on-lists
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____LIST-EQUIV.html">list-equiv</a> lists lists-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="VL2014____VL-REORIENT-PARTITIONED-ARGS.html">vl-reorient-partitioned-args</a> lists n)
                     (<a href="VL2014____VL-REORIENT-PARTITIONED-ARGS.html">vl-reorient-partitioned-args</a> lists-equiv n)))
     :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>vl-reorient-partitioned-args-of-nfix-n</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> vl-reorient-partitioned-args-of-nfix-n
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="VL2014____VL-REORIENT-PARTITIONED-ARGS.html">vl-reorient-partitioned-args</a> lists (<a href="ACL2____NFIX.html">nfix</a> n))
               (<a href="VL2014____VL-REORIENT-PARTITIONED-ARGS.html">vl-reorient-partitioned-args</a> lists n)))</pre> 
<p><b>Theorem: </b>vl-reorient-partitioned-args-nat-equiv-congruence-on-n</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     vl-reorient-partitioned-args-nat-equiv-congruence-on-n
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____NAT-EQUIV.html">acl2::nat-equiv</a> n n-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="VL2014____VL-REORIENT-PARTITIONED-ARGS.html">vl-reorient-partitioned-args</a> lists n)
                     (<a href="VL2014____VL-REORIENT-PARTITIONED-ARGS.html">vl-reorient-partitioned-args</a> lists n-equiv)))
     :rule-classes :congruence)</pre> 

</body>
</html>
