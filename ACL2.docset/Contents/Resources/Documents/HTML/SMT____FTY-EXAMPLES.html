<html>
<head>
<meta charset="UTF-8">
<title>Fty-examples</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=SMT____FTY-EXAMPLES">Click for Fty-examples in the Full Manual</a></h3>

<p>A list of FTY examples</p><h3>FTY examples</h3> 
<p>Prerequisite read for this tutorial example is <span class="tt"><a href="SMT____TUTORIAL.html">tutorial</a></span>.</p> 
<p>Smtlink supports types defined by <span class="tt"><a href="ACL2____FTY.html">ACL2::fty</a></span> macros <span class="tt"><a href="FTY____DEFPROD.html">defprod</a></span>, <span class="tt"><a href="FTY____DEFLIST.html">deflist</a></span>, <span class="tt"><a href="FTY____DEFALIST.html">defalist</a></span> and <span class="tt"><a href="FTY____DEFOPTION.html">defoption</a></span>. We show here an example for 
  each type.</p> 
 
<h4>defprod</h4> 
<p>Define the function <span class="v">x^2+y^2</span></p> 
<pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> x^2+y^2 (x y)
       (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP_____A2.html">*</a> x x) (<a href="COMMON-LISP_____A2.html">*</a> y y)))</pre> 
 
<p>Define the defprod <span class="v">sandwich</span></p> 
<pre class="code">nil</pre> 
 
<p>Then define the theorem to prove:</p> 
<pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fty-defprod-theorem
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SANDWICH-P.html">sandwich-p</a> s1) (<a href="SMT____SANDWICH-P.html">sandwich-p</a> s2))
                 (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> (x^2+y^2 (<a href="SMT____SANDWICH-_E3BREAD.html">sandwich-&gt;bread</a> s1)
                              (<a href="SMT____SANDWICH-_E3BREAD.html">sandwich-&gt;bread</a> s2))
                     0))
        :hints (("Goal" :smtlink (:fty (<a href="SMT____SANDWICH.html">sandwich</a>))))
        :rule-classes nil)</pre> 
 
<p>This theorem says, given two <span class="v">sandwich-p</span>, then the square sum of the 
bread field of the two sandwiches should be non-negative. This example doesn't 
quite make sense.  Here we use this as an example to show how <span class="v">defprod</span> 
defined types can be used in a theorem to be discharged by Smtlink.</p> 
 
<p>We notice the <span class="v">:fty</span> hint is used to tell Smtlink which set of FTY types 
we will use in proving this theorem. Here, we use the FTY type 
<span class="v">sandwich</span>. Smtlink will check <span class="v">fty::flextypes-table</span> for information 
about this FTY type.</p> 
 
<p>Counter-examples for defprods like like:</p> 
<pre class="code">Possible counter-example found:
((S2 (<a href="SMT____SANDWICH.html">SANDWICH</a> 0 (SYM 2))) (S1 (<a href="SMT____SANDWICH.html">SANDWICH</a> 0 (SYM 1))))</pre> 
 
 
<h4>deflist</h4> 
<p>Define the theorem to prove:</p> 
<pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 fty-deflist-theorem
 (<a href="ACL2____IMPLIES.html">implies</a>
  (<a href="COMMON-LISP____AND.html">and</a>
    (<a href="ACL2____INTEGER-LISTP.html">integer-listp</a> l)
    (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="ACL2____INTEGER-LIST-FIX.html">acl2::integer-list-fix</a> l))
    (<a href="COMMON-LISP____CONSP.html">consp</a>
         (<a href="ACL2____INTEGER-LIST-FIX.html">acl2::integer-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="ACL2____INTEGER-LIST-FIX.html">acl2::integer-list-fix</a> l)))))
  (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a>
   (x^2+y^2
    (<a href="COMMON-LISP____CAR.html">car</a> (<a href="ACL2____INTEGER-LIST-FIX.html">acl2::integer-list-fix</a> l))
    (<a href="COMMON-LISP____CAR.html">car</a> (<a href="ACL2____INTEGER-LIST-FIX.html">acl2::integer-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="ACL2____INTEGER-LIST-FIX.html">acl2::integer-list-fix</a> l)))))
   0))
 :hints (("Goal" :smtlink (:fty (<a href="ACL2____INTEGER-LIST.html">acl2::integer-list</a>))))
 :rule-classes nil)</pre> 
 
<p>This theorem says, given a list of integers, if there are at least two 
elements, then the square sum of the two elements should be non-negative.</p> 
 
<p>First, Smtlink only allows types defined by deflist that are <span class="tt"><a href="ACL2____TRUE-LISTP.html">true-listp</a></span>.  We notice the <span class="v">:fty</span> hint is used to tell Smtlink which set of 
FTY types we will use in proving this theorem. Here, we use the FTY type 
<span class="v">acl2::integer-list</span>. Smtlink will check <span class="v">fty::flextypes-table</span> to make 
sure the given deflist type is a true-listp.</p> 
 
<p>Second, we notice extra fixing functions <span class="tt"><a href="ACL2____INTEGER-LIST-FIX.html">ACL2::integer-list-fix</a></span> 
functions are added. This is because Z3 lists are typed. The polymorphic 
functions like <span class="v">car</span> when translated into Z3, also become typed. Therefore 
we need to inference which <span class="v">car</span> we want to apply here. Currently Smtlink 
doesn't have type inference ability, therefore it requires the user to add 
fixing functions for telling it the types.</p> 
 
<p>Counter-examples for deflists like like:</p> 
<pre class="code">Possible counter-example found: ((L (<a href="COMMON-LISP____CONS.html">CONS</a> 0 (<a href="COMMON-LISP____CONS.html">CONS</a> 0 NIL))))</pre> 
 
<h4>defalist</h4> 
<p>Define the defalist <span class="v">symbol-integer-alist</span></p> 
<pre class="code">(<a href="FTY____DEFALIST.html">defalist</a> symbol-integer-alist
          :key-type symbolp
          :val-type integerp
          :true-listp t)</pre> 
 
<p>Then define the theorem to prove:</p> 
<pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 fty-defalist-theorem
 (<a href="ACL2____IMPLIES.html">implies</a>
  (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____SYMBOL-INTEGER-ALIST-P.html">symbol-integer-alist-p</a> l)
       (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> s1)
       (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> s2)
       (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> s1 (<a href="SMT____SYMBOL-INTEGER-ALIST-FIX.html">symbol-integer-alist-fix</a> l))
                   (magic-fix 'symbolp_integerp nil)))
       (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> s2 (<a href="SMT____SYMBOL-INTEGER-ALIST-FIX.html">symbol-integer-alist-fix</a> l))
                   (magic-fix 'symbolp_integerp nil))))
  (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a>
   (x^2+y^2
    (<a href="COMMON-LISP____CDR.html">cdr</a> (magic-fix 'symbolp_integerp
                    (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> s1 (<a href="SMT____SYMBOL-INTEGER-ALIST-FIX.html">symbol-integer-alist-fix</a> l))))
    (<a href="COMMON-LISP____CDR.html">cdr</a> (magic-fix 'symbolp_integerp
                    (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> s2 (<a href="SMT____SYMBOL-INTEGER-ALIST-FIX.html">symbol-integer-alist-fix</a> l)))))
   0))
 :hints (("Goal" :smtlink (:fty (<a href="SMT____SYMBOL-INTEGER-ALIST.html">symbol-integer-alist</a>))))
 :rule-classes nil)</pre> 
 
<p>This theorem says, given a symbol-integer-alist l, two symbols s1 and s2, if 
one can find both s1 and s2 in the alist l, then the values satisfy that their 
square sum is non-negative. I hope the square sum example hasn't bored you yet 
at this point.</p> 
 
<p>Similar to deflists, we notice extra fixing functions 
<span class="v">symbol-integer-alist-fix</span> functions are added due to similar reasons. In 
addition, we notice ACL2 doesn't have a type specification for the thing 
returned by an assoc-equal. To make sure <span class="v">cdr</span> knows what its argument type 
is, we add a <span class="v">magic-fix</span> function.</p> 
 
<p>Counter-examples for defalists like like:</p> 
<pre class="code">((S2 (SYM 2)) (L (K SYMBOL (SOME 0))) (S1 (SYM 1)))</pre> 
 
<p>Here, the counter-example for alist l is</p> 
 <pre class="code">(K SYMBOL (SOME 0))</pre> 
<p>This means in Z3 a constant array mapping from symbols to the maybe integer 
 0. Also, <span class="v">SYM</span> stands for generated symbols for symbol 
 counter-examples.</p> 
 
<h4>defoption</h4> 
<p>Define the defoption <span class="v">maybe-integer</span></p> 
<pre class="code">(<a href="FTY____DEFOPTION.html">defoption</a> maybe-integer integerp
           :parents (<a href="SMT____TUTORIAL.html">tutorial</a>))</pre> 
 
<p>Define the fixed version of <span class="v">x^2+y^2</span></p> 
<pre class="code">(<a href="ACL2____DEFINE.html">define</a>
     x^2+y^2-fixed
     ((x maybe-integer-p)
      (y maybe-integer-p))
     :returns (res maybe-integer-p)
     (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="SMT____MAYBE-INTEGER-FIX.html">maybe-integer-fix</a> x))
          (y (<a href="SMT____MAYBE-INTEGER-FIX.html">maybe-integer-fix</a> y))
          ((<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> x (<a href="SMT____MAYBE-INTEGER-FIX.html">maybe-integer-fix</a> nil)))
           (<a href="SMT____MAYBE-INTEGER-FIX.html">maybe-integer-fix</a> nil))
          ((<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> y (<a href="SMT____MAYBE-INTEGER-FIX.html">maybe-integer-fix</a> nil)))
           (<a href="SMT____MAYBE-INTEGER-FIX.html">maybe-integer-fix</a> nil)))
         (<a href="SMT____MAYBE-INTEGER-SOME.html">maybe-integer-some</a> (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP_____A2.html">*</a> (<a href="SMT____MAYBE-INTEGER-SOME-_E3VAL.html">maybe-integer-some-&gt;val</a> x)
                                   (<a href="SMT____MAYBE-INTEGER-SOME-_E3VAL.html">maybe-integer-some-&gt;val</a> x))
                                (<a href="COMMON-LISP_____A2.html">*</a> (<a href="SMT____MAYBE-INTEGER-SOME-_E3VAL.html">maybe-integer-some-&gt;val</a> y)
                                   (<a href="SMT____MAYBE-INTEGER-SOME-_E3VAL.html">maybe-integer-some-&gt;val</a> y))))))</pre> 
 
<p>Then define the theorem to prove:</p> 
<pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fty-defoption-theorem
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____MAYBE-INTEGER-P.html">maybe-integer-p</a> m1)
                      (<a href="SMT____MAYBE-INTEGER-P.html">maybe-integer-p</a> m2)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> m1 (<a href="SMT____MAYBE-INTEGER-FIX.html">maybe-integer-fix</a> nil)))
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> m2 (<a href="SMT____MAYBE-INTEGER-FIX.html">maybe-integer-fix</a> nil))))
                 (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> (<a href="SMT____MAYBE-INTEGER-SOME-_E3VAL.html">maybe-integer-some-&gt;val</a> (x^2+y^2-fixed m1 m2))
                     0))
        :hints (("Goal" :smtlink (:fty (<a href="SMT____MAYBE-INTEGER.html">maybe-integer</a>))))
        :rule-classes nil)</pre> 
 
<p>This theorem says, given a maybe-integer m1 and a maybe-integer m2, if they 
are not nils, then the square sum of their values is non-negative.</p> 
 
<p>Similar to deflists and defalists, we notice extra fixing functions 
<span class="v">maybe-integer-fix</span> functions are added due to similar reasons. In addition, 
we notice in definition of function <span class="v">x^2+y^2-fixed</span>, even when one knows x 
and y are not nil, they are still maybe-integers. Therefore, field-accessors 
and constructors are required.</p> 
 
<p>Counter-examples for defalists like like:</p> 
<pre class="code">Possible counter-example found: ((M2 (SOME 0)) (M1 (SOME 0)))</pre> 
 

</body>
</html>
