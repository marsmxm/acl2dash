<html>
<head>
<meta charset="UTF-8">
<title>Fgl-testbenches</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=FGL____FGL-TESTBENCHES">Click for Fgl-testbenches in the Full Manual</a></h3>

<p>Advanced extralogical programming of FGL.</p> 
 
<p>While FGL can be used to symbolically simulate logical terms and bitblast 
theorems, it can also be used as a programming platform for advanced algorithms 
involving SAT checks and a mix of logical and extralogical code.</p> 
 
<h3>Basic Example</h3>  
 
<p> Suppose we want to check whether several conditions are satisfiable, 
summarize the results in an object and pretty-print that summary. </p> 
 
<pre class="code">;; Suppose (my-test-condition n x) gives the nth condition to be tested.
(<a href="COMMON-LISP____DEFUN.html">defun</a> my-test-condition (n x) ...)

;; Iterate from M-1 down to 0 testing each condition and collect a list of the
;; indices of all those that were invalid.
(<a href="FGL____DEF-FGL-PROGRAM.html">def-fgl-program</a> test-my-conditions (m x)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> m)
      nil
    (<a href="COMMON-LISP____LET_A2.html">let*</a> ((next-m (<a href="COMMON-LISP____1-.html">1-</a> m))
           ;; Narrow the equivalence context from UNEQUIV to IFF to ensure
           ;; that an accurate result is produced for my-test-condition.
           (testcond (<a href="FGL____NARROW-EQUIV.html">narrow-equiv</a> '(<a href="ACL2____IFF.html">iff</a>) (my-test-condition next-m x)))
           (validity-check-result (fgl-validity-check
                                   (<a href="FGL____MAKE-FGL-IPASIR-CONFIG.html">make-fgl-ipasir-config</a>)
                                   testcond))
           ;; Note: validity-check-result is syntactically T if the validity
           ;; check was successful.  If not, it's some symbolic truth value
           ;; represented as a g-boolean object.
           (valid (<a href="FGL____SYNTAX-INTERP.html">syntax-interp</a> (<a href="COMMON-LISP____EQ.html">eq</a> validity-check-result t))))
       (<a href="COMMON-LISP____IF.html">if</a> valid
           (test-my-conditions next-m x)
         (<a href="COMMON-LISP____CONS.html">cons</a> next-m (test-my-conditions next-m x))))))

;; Summarize the list of non-valid condition indices.
(<a href="COMMON-LISP____DEFUN.html">defun</a> my-print-test-condition-results (indices-list) ...)

;; Run a fake proof in which the conditions are tested.
(fgl-thm
  :hyp t
  :concl (<a href="FGL____FGL-PROG2.html">fgl-prog2</a> (<a href="COMMON-LISP____LET.html">let</a> ((conds (test-my-conditions 100 x)))
                      (my-print-test-condition-results conds))
                    t))</pre> 
 
<p>In the <span class="v">fgl-thm</span> form, <span class="v">fgl-prog2</span> is used to enter an <span class="v">unequiv</span> 
equivalence context, which allows the use of extralogical forms such as 
<span class="v">syntax-interp</span>.  (Since every pair of objects are <span class="v">unequiv</span>, an 
<span class="v">unequiv</span> context allows any term to be rewritten to any other term, or 
interpreted in any way that might be desired.  Thus <span class="v">syntax-interp</span>, which 
logically just returns <span class="v">nil</span>, can be used to run an arbitrary computation 
with no logical meaning and return its result.</p> 
 
<p>The <span class="v">fgl-prog2</span> calls <span class="v">test-my-conditions</span>, which successively checks 
the validity of 100 test conditions.  The use of <span class="v">narrow-equiv</span> inside 
<span class="v">test-my-conditions</span> ensures that <span class="v">my-test-condition</span> is interpreted 
under an <span class="v">iff</span> context instead of an <span class="v">unequiv</span> context.  We then use 
<span class="v">fgl-validity-check</span> to check whether the resulting condition is always 
non-nil.  If this is found to be true, then <span class="v">fgl-validity-check</span> will return 
<span class="v">t</span>, that is, the constant-<span class="v">t</span> symbolic object; otherwise, it will return 
some other symbolic Boolean object: either <span class="v">nil</span> or a non-constant 
<span class="v">g-boolean</span> object.  To check whether the condition was found to be always 
true, we check whether the object resulting from <span class="v">fgl-validity-check</span> is 
syntactically <span class="v">t</span>.  We collect the indices of those conditions that are not 
constant-true.</p> 
 
<p>Note that the body for <span class="v">test-my-conditions</span> above could not exist if 
<span class="v">test-my-conditions</span> were to be interpreted under <span class="v">equal</span> rather than 
<span class="v">unequiv</span>: it could produce different results on the same inputs depending 
on the behavior of <span class="v">fgl-validity-check</span>, which could fail or succeed based 
on (for example) the current contents of the interpreter state.  Thus, 
logically speaking, <span class="v">test-my-conditions</span> isn't a function.  But under an 
<span class="v">unequiv</span> context we can still interpret it as though it were.</p> 
 
<h3>More Examples</h3> 
 
<p>Examining counterexamples: The following example shows how to generate all 
of the Pythagorean triples of a given size, by checking repeatedly whether 
there exists another triple that is missing from the list.</p> 
 
<pre class="code">(<a href="ACL2____DEFINE.html">define</a> pythag-triple-p ((x natp) (y natp) (z natp))
  (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> 0 (<a href="ACL2____LNFIX.html">lnfix</a> x))
       (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____LNFIX.html">lnfix</a> x) (<a href="ACL2____LNFIX.html">lnfix</a> y))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP_____A2.html">*</a> (<a href="ACL2____LNFIX.html">lnfix</a> z) (<a href="ACL2____LNFIX.html">lnfix</a> z))
              (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP_____A2.html">*</a> (<a href="ACL2____LNFIX.html">lnfix</a> x) (<a href="ACL2____LNFIX.html">lnfix</a> x))
                 (<a href="COMMON-LISP_____A2.html">*</a> (<a href="ACL2____LNFIX.html">lnfix</a> y) (<a href="ACL2____LNFIX.html">lnfix</a> y))))))

(<a href="FGL____DEF-FGL-PROGRAM.html">def-fgl-program</a> find-all-pythag-triples (x y z found)
  (<a href="ACL2____B_A2.html">b*</a> ((<a href="COMMON-LISP____COND.html">cond</a> (<a href="FGL____NARROW-EQUIV.html">narrow-equiv</a> '(<a href="ACL2____IFF.html">iff</a>)
                           (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> (<a href="COMMON-LISP____LIST.html">list</a> x y z) found))
                                (pythag-triple-p x y z))))
       (config  (<a href="FGL____MAKE-FGL-IPASIR-CONFIG.html">make-fgl-ipasir-config</a>))
       (sat-res (<a href="FGL____FGL-SAT-CHECK.html">fgl-sat-check</a> config cond))
       (unsat (<a href="FGL____SYNTAX-INTERP.html">syntax-interp</a> (<a href="COMMON-LISP____NOT.html">not</a> sat-res)))
       ((when unsat)
        found)
       ((<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____LIST.html">list</a> error bindings ?vars) &amp;)
        (<a href="FGL____SYNTAX-INTERP.html">syntax-interp</a> (show-counterexample-bind config interp-st state)))
       ((when error)
        (<a href="ACL2____CW.html">cw</a> "Error: ~x0~%" error))
       (xval (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="COMMON-LISP____ASSOC.html">assoc</a> 'x bindings)))
       (yval (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="COMMON-LISP____ASSOC.html">assoc</a> 'y bindings)))
       (zval (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="COMMON-LISP____ASSOC.html">assoc</a> 'z bindings)))
       (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____LIST.html">list</a> xval yval zval))
       ((unless (<a href="COMMON-LISP____AND.html">and</a> (pythag-triple-p xval yval zval)
                     (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> list found))))
        (<a href="FGL____FGL-PROG2.html">fgl-prog2</a> (<a href="FGL____SYNTAX-INTERP.html">syntax-interp</a> (<a href="ACL2____CW.html">cw</a> "Bad: result: ~x0 found: ~x1~%" list found))
                   nil)))
    (find-all-pythag-triples x y z (<a href="COMMON-LISP____CONS.html">cons</a> list found))))

(<a href="FGL____DEF-FGL-PROGRAM.html">def-fgl-program</a> add-scratch-pair (key val)
  (<a href="FGL____SYNTAX-INTERP.html">syntax-interp</a>
   (interp-st-put-user-scratch key val interp-st)))

(<a href="ACL2____LOCAL.html">local</a> (<a href="ACL2____IN-THEORY.html">in-theory</a> (<a href="ACL2____DISABLE.html">disable</a> w)))
(fancy-ev-add-primitive interp-st-put-user-scratch t)
(def-fancy-ev-primitives mine)

(fgl-thm
 :hyp (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> 7 x)
           (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> 7 y)
           (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> 7 z))
 :concl (<a href="FGL____FGL-PROG2.html">fgl-prog2</a> (<a href="ACL2____B_A2.html">b*</a> ((trips (find-all-pythag-triples x y z nil)))
                     ;; Store the generated triples in the user-scratch
                     ;; field of the interp-st.
                     (<a href="FGL____FGL-PROG2.html">fgl-prog2</a> (add-scratch-pair :pythag-triples trips)
                                (<a href="ACL2____CW.html">cw</a> "trips: ~x0~%" trips)))
                   t))

(<a href="ACL2____MAKE-EVENT.html">make-event</a>
 ;; Fetch the stored triples from the user-scratch field.
 (<a href="ACL2____B_A2.html">b*</a> ((trips (<a href="FGL____G-CONCRETE-_E3VAL.html">g-concrete-&gt;val</a>
              (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="ACL2____HONS-GET.html">hons-get</a> :pythag-triples
                             (interp-st-&gt;user-scratch interp-st))))))
   `(<a href="FGL____DEF-FGL-THM.html">def-fgl-thm</a> 7-bit-pythag-trips
      :hyp (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> 7 x)
                (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> 7 y)
                (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> 7 z))
      :concl (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> (<a href="COMMON-LISP____LIST.html">list</a> x y z) ',trips))
                      (<a href="COMMON-LISP____NOT.html">not</a> (pythag-triple-p x y z))))))</pre> 
 

</body>
</html>
