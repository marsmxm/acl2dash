<html>
<head>
<meta charset="UTF-8">
<title>Built-in-clause</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____BUILT-IN-CLAUSE">Click for Built-in-clause in the Full Manual</a></h3>

<p>To build a clause into the simplifier</p><p>See <a href="ACL2____RULE-CLASSES.html">rule-classes</a> for a general discussion of rule classes, 
 including how they are used to build rules from formulas and a discussion of 
 the various keywords in a rule class description.</p> 
 
 <pre class="code">Example:
(<a href="ACL2____DEFTHM.html">defthm</a> acl2-count-abl
  (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> x)
                     (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> x nil)))
                (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> (abl x))
                   (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> x)))
       (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> x)
                     (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> nil x)))
                (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> (abl x))
                   (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> x))))
  :rule-classes :built-in-clause)</pre> 
 
 <p>A <span class="v">:built-in-clause</span> rule can be built from any formula other than 
 propositional tautologies.  Roughly speaking, the system uses the list of 
 built-in clauses as the first method of proof when attacking a new goal.  Any 
 goal that is subsumed by a built in clause is proved ``silently.''</p> 
 
 <p>ACL2 maintains a set of ``built-in'' clauses that are used to short-circuit 
 certain theorem proving tasks.  We discuss this at length below.  When a 
 theorem is given the rule class <span class="v">:built-in-clause</span> ACL2 flattens the <span class="tt"><a href="ACL2____IMPLIES.html">implies</a></span> and <span class="tt"><a href="COMMON-LISP____AND.html">and</a></span> structure of the <span class="v">:</span><span class="tt"><a href="ACL2____COROLLARY.html">corollary</a></span> formula so 
 as to obtain a set of formulas whose conjunction is equivalent to the given 
 corollary.  It then converts each of these to clausal form and adds each 
 clause to the set of built-in clauses.</p> 
 
 <p>The example above (regardless of the definition of <span class="v">abl</span>) will build in 
 two clauses,</p> 
 
 <pre class="code">{(<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> x))
 (<a href="COMMON-LISP____EQUAL.html">equal</a> x nil)
 (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> (abl x)) (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> x))}</pre> 
 
 <p>and</p> 
 
 <pre class="code">{(<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> x))
 (<a href="COMMON-LISP____EQUAL.html">equal</a> nil x)
 (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> (abl x)) (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> x))}.</pre> 
 
 <p>We now give more background.</p> 
 
 <p>Recall that a clause is a set of terms, implicitly representing the 
 disjunction of the terms.  Clause <span class="v">c1</span> is ``subsumed'' by clause <span class="v">c2</span> if 
 some instance of <span class="v">c2</span> is a subset <span class="v">c1</span>.</p> 
 
 <p>For example, let <span class="v">c1</span> be</p> 
 
 <pre class="code">{(<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> l))
 (<a href="COMMON-LISP____EQUAL.html">equal</a> a (<a href="COMMON-LISP____CAR.html">car</a> l))
 (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> (<a href="COMMON-LISP____CDR.html">cdr</a> l)) (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> l))}.</pre> 
 
 <p>Then <span class="v">c1</span> is subsumed by <span class="v">c2</span>, shown below,</p> 
 
 <pre class="code">{(<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x))
 ; second term omitted here
 (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x)) (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> x))}</pre> 
 
 <p>because we can instantiate <span class="v">x</span> in <span class="v">c2</span> with <span class="v">l</span> to obtain a subset 
 of <span class="v">c1</span>.</p> 
 
 <p>Observe that <span class="v">c1</span> is the clausal form of</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> l)
              (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> a (<a href="COMMON-LISP____CAR.html">car</a> l))))
         (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> (<a href="COMMON-LISP____CDR.html">cdr</a> l)) (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> l))),</pre> 
 
 <p><span class="v">c2</span> is the clausal form of</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____CONSP.html">consp</a> l)
         (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> (<a href="COMMON-LISP____CDR.html">cdr</a> l)) (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> l)))</pre> 
 
 <p>and the subsumption property just means that <span class="v">c1</span> follows trivially from 
 <span class="v">c2</span> by instantiation.</p> 
 
 <p>The set of built-in clauses is just a set of known theorems in clausal 
 form.  Any formula that is subsumed by a built-in clause is thus a theorem. 
 If the set of built-in theorems is reasonably small, this little theorem 
 prover is fast.  ACL2 uses the ``built-in clause check'' in four places: (1) 
 at the top of the iteration in the prover â€” thus if a built-in clause is 
 generated as a subgoal it will be recognized when that goal is considered, (2) 
 within the simplifier so that no built-in clause is ever generated by 
 simplification, (3) as a filter on the clauses generated to prove the 
 termination of recursively <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span>'d functions and (4) as a filter on 
 the clauses generated to verify the guards of a function.</p> 
 
 <p>The latter two uses are the ones that most often motivate an extension to 
 the set of built-in clauses.  Frequently a given formalization problem 
 requires the definition of many functions which require virtually identical 
 termination and/or guard proofs.  These proofs can be short-circuited by 
 extending the set of built-in clauses to contain the most general forms of the 
 clauses generated by the definitional schemes in use.</p> 
 
 <p>The attentive user might have noticed that there are some recursive 
 schemes, e.g., recursion by <span class="tt"><a href="COMMON-LISP____CDR.html">cdr</a></span> after testing <span class="tt"><a href="COMMON-LISP____CONSP.html">consp</a></span>, that ACL2 
 just seems to ``know'' are ok, while for others it generates measure clauses 
 to prove.  Actually, it always generates measure clauses but then filters out 
 any that pass the built-in clause check.  When ACL2 is initialized, the clause 
 justifying <span class="tt"><a href="COMMON-LISP____CDR.html">cdr</a></span> recursion after a <span class="tt"><a href="COMMON-LISP____CONSP.html">consp</a></span> test is added to the 
 set of built-in clauses.  (That clause is <span class="v">c2</span> above.)</p> 
 
 <p>Note that only a subsumption check is made; no rewriting or simplification 
 is done.  Thus, if we want the system to ``know'' that <span class="tt"><a href="COMMON-LISP____CDR.html">cdr</a></span> recursion 
 is ok after a negative <span class="tt"><a href="COMMON-LISP____ATOM.html">atom</a></span> test (which, by the definition of <span class="tt"><a href="COMMON-LISP____ATOM.html">atom</a></span>, is the same as a <span class="tt"><a href="COMMON-LISP____CONSP.html">consp</a></span> test), we have to build in a second 
 clause.  The subsumption algorithm does not ``know'' about commutative 
 functions.  Thus, for predictability, we have built in commuted versions of 
 each clause involving commutative functions.  For example, we build in 
 both</p> 
 
 <pre class="code">{(<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x))
 (<a href="COMMON-LISP_____C3.html">&lt;</a> 0 x)
 (<a href="COMMON-LISP_____D3.html">=</a> x 0)
 (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> (<a href="COMMON-LISP_____B2.html">+</a> -1 x)) (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> x))}</pre> 
 
 <p>and the commuted version</p> 
 
 <pre class="code">{(<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> x))
 (<a href="COMMON-LISP_____C3.html">&lt;</a> 0 x)
 (<a href="COMMON-LISP_____D3.html">=</a> 0 x)
 (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> (<a href="COMMON-LISP_____B2.html">+</a> -1 x)) (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> x))}</pre> 
 
 <p>so that the user need not worry whether to write <span class="v">(<a href="COMMON-LISP_____D3.html">=</a> x 0)</span> or <span class="v">(<a href="COMMON-LISP_____D3.html">=</a> 0
 x)</span> in definitions.</p> 
 
 <p><span class="v">:built-in-clause</span> rules added by the user can be enabled and 
 disabled.</p>
</body>
</html>
