<html>
<head>
<meta charset="UTF-8">
<title>Rlp-encode-trees-injectivity-proof</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ETHEREUM____RLP-ENCODE-TREES-INJECTIVITY-PROOF">Click for Rlp-encode-trees-injectivity-proof in the Full Manual</a></h3>

<p>Injectivity of <span class="tt"><a href="ETHEREUM____RLP-ENCODE-TREE.html">rlp-encode-tree</a></span> 
          and <span class="tt"><a href="ETHEREUM____RLP-ENCODE-TREE-LIST.html">rlp-encode-tree-list</a></span>, 
          over the encodable trees and lists thereof.</p><p>This is proved by induction. 
     There are two theorems: 
     one for <span class="tt"><a href="ETHEREUM____RLP-ENCODE-TREE.html">rlp-encode-tree</a></span> 
     and one for <span class="tt"><a href="ETHEREUM____RLP-ENCODE-TREE-LIST.html">rlp-encode-tree-list</a></span>. 
     The theorems are formulated similarly to 
     the one for <span class="tt"><a href="ETHEREUM____RLP-ENCODE-BYTES.html">rlp-encode-bytes</a></span>.</p><p>Since the theorems involve two variables (two trees or two lists of trees), 
     we locally define mutually recursive functions <span class="v">tree</span> and <span class="v">tree-list</span> 
     to obtain and use an induction scheme that applies to two variables; 
     we use the flag theorem macro generated by this local <span class="tt"><a href="ACL2____DEFINES.html">defines</a></span>.</p><p>Attempting to induct according to the mutually recursive encoding functions 
     only applies to one variable, 
     leaving the other variable unchanged in the hypotheses and conclusions 
     of the induction steps: 
     then the same unchanged variable cannot suitably ``relate'' 
     to the different instances of the changing variable 
     in the hypotheses and conclusions. 
     Submitting the injectivity theorems 
     via the flag theorem macro of the encoding functions, 
     an examining the induction scheme printed by ACL2, 
     should make the problem apparent.</p><p>The induction proof makes use of two helper lemmas.</p><p>The first helper lemma applies to the two cases in which 
     <span class="v">x</span> is a leaf tree and <span class="v">y</span> is a leaf tree. 
     Commenting out this helper lemma from the hints of the induction theorem 
     shows the two corresponding subgoals, 
     in which the hypothesis that <span class="v">x</span> or <span class="v">y</span> is a leaf tree 
     causes <span class="tt"><a href="ETHEREUM____RLP-ENCODE-TREE.html">rlp-encode-tree</a></span> to expand on <span class="v">x</span> or <span class="v">y</span>, 
     generating a call to <span class="tt"><a href="ETHEREUM____RLP-ENCODE-BYTES.html">rlp-encode-bytes</a></span> on the subtrees. 
     This motivates the formulation of the first helper lemma, 
     whose variable <span class="v">xy</span> stands for <span class="v">x</span> or <span class="v">y</span> 
     and whose variable <span class="v">yx</span> stands for <span class="v">y</span> or <span class="v">x</span>, 
     i.e. the other variable whose <span class="tt"><a href="ETHEREUM____RLP-ENCODE-TREE.html">rlp-encode-tree</a></span> in the subgoal 
     is not expanded. 
     We use an expansion hint to expand that; an enable hint does not suffice. 
     If <span class="v">yx</span> is also a leaf tree, 
     <span class="tt"><a href="ETHEREUM____RLP-ENCODE-TREE.html">rlp-encode-tree</a></span> reduces to <span class="tt"><a href="ETHEREUM____RLP-ENCODE-BYTES.html">rlp-encode-bytes</a></span> on the subtrees 
     and the injectivity theorem of <span class="tt"><a href="ETHEREUM____RLP-ENCODE-BYTES.html">rlp-encode-bytes</a></span> applies. 
     Otherwise, the expansion starts with a byte that is at least 192 or 247, 
     which is incompatible with 
     the starting byte of <span class="tt"><a href="ETHEREUM____RLP-ENCODE-BYTES.html">rlp-encode-bytes</a></span> on (the subtrees of) <span class="v">xy</span>: 
     the linear rule <span class="v">car-of-rlp-encode-bytes-upper-bound-when-no-error</span> 
     does not apply here, 
     so we use a <span class="v">:use</span> hint with a suitable instantiation.</p><p>The second helper lemma applies to the case in which 
     the lists of trees <span class="v">xs</span> and <span class="v">ys</span> are not empty. 
     In this case, their encodings are the <span class="tt"><a href="COMMON-LISP____APPEND.html">append</a></span>s 
     of the encodings of their <span class="tt"><a href="COMMON-LISP____CAR.html">car</a></span>s and of their <span class="tt"><a href="COMMON-LISP____CDR.html">cdr</a></span>s. 
     Commenting out this helper lemma from the hints of the induction theorem 
     shows a subgoal that involves these <span class="tt"><a href="COMMON-LISP____APPEND.html">append</a></span>s. 
     To use the induction hypotheses, 
     we need to decompose the equality of the <span class="tt"><a href="COMMON-LISP____APPEND.html">append</a></span>s 
     into the equalities of their <span class="tt"><a href="COMMON-LISP____CAR.html">car</a></span> and <span class="tt"><a href="COMMON-LISP____CDR.html">cdr</a></span> encodings, 
     via the rule <span class="v">equal-of-appends-decompose</span> 
     that we also used to prove the injectivity of <span class="tt"><a href="ETHEREUM____RLP-ENCODE-BYTES.html">rlp-encode-bytes</a></span>. 
     For this, we need to relieve the hypothesis of that rule 
     that the lenghts of the encodings of the <span class="tt"><a href="COMMON-LISP____CAR.html">car</a></span>s are equal: 
     this is done by the lemma <span class="v">car-encodings-same-len</span>.</p><p>The key to proving <span class="v">car-encodings-same-len</span> 
     is the fact that the lengths of the encodings of the <span class="tt"><a href="COMMON-LISP____CAR.html">car</a></span>s 
     are completely determined by the first (few) bytes of the encodings, 
     as expressed by the rule <span class="v">len-of-rlp-encode-tree-from-prefix</span>, 
     which we therefore enable to prove <span class="v">car-encodings-same-len</span>. 
     This rule rewrites the two lengths to prove equal 
     in terms of the first (few) bytes of the encodings 
     of the <span class="tt"><a href="COMMON-LISP____CAR.html">car</a></span>s of <span class="v">xs</span> and <span class="v">ys</span>: 
     if we knew that those encodings were equal, we would be done. 
     But we only know (see hypothesis in <span class="v">car-encodings-same-len</span>) 
     that the <span class="tt"><a href="COMMON-LISP____APPEND.html">append</a></span>s of the encodings of the <span class="tt"><a href="COMMON-LISP____CAR.html">car</a></span>s 
     with something else (the encodings of the <span class="tt"><a href="COMMON-LISP____CDR.html">cdr</a></span>s) are equal. 
     Fortunately, the first (few) bytes of the encodings of the <span class="tt"><a href="COMMON-LISP____CAR.html">car</a></span>s 
     are also the first (few) bytes of the <span class="tt"><a href="COMMON-LISP____APPEND.html">append</a></span>s. 
     So we use the rules 
     <span class="v">expand-to-car-of-append</span> and <span class="v">expand-to-take-of-append</span> 
     to express the first (few) bytes that describe the lengths 
     in terms of the <span class="tt"><a href="COMMON-LISP____APPEND.html">append</a></span>s; 
     note that these two rules have a strictly more complex right hand side, 
     so they are generally undesirable, 
     yet they are useful in this proof. 
     We disable the rules 
     <span class="v">acl2::car-of-append</span> and <span class="v">acl2::take-of-append</span>, 
     which work ``against'' 
     <span class="v">expand-to-car-of-append</span> and <span class="v">expand-to-take-of-append</span>, 
     to prevent the rewriter from looping.</p><p>The two helper lemmas are enabled 
     in the proof by induction of the injectivity lemmas, 
     along with the rule <span class="v">true-listp-when-byte-listp-rewrite</span>, 
     which serves to prove another subgoal 
     (visible by commenting out this rule in the hints), 
     similar to the one proved via the second helper lemma, 
     but simpler due to an extra hypothesis <span class="v">(<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CDR.html">cdr</a> xs) (<a href="COMMON-LISP____CDR.html">cdr</a> ys))</span>.</p><p>Similarly to the injectivity theorem for <span class="tt"><a href="ETHEREUM____RLP-ENCODE-BYTES.html">rlp-encode-bytes</a></span>, 
     the injectivity theorems 
     for <span class="tt"><a href="ETHEREUM____RLP-ENCODE-TREE.html">rlp-encode-tree</a></span> and <span class="tt"><a href="ETHEREUM____RLP-ENCODE-TREE-LIST.html">rlp-encode-tree-list</a></span> 
     omit the <span class="tt"><a href="ETHEREUM____RLP-TREEP.html">rlp-treep</a></span> and <span class="tt"><a href="ETHEREUM____RLP-TREE-LISTP.html">rlp-tree-listp</a></span> hypotheses 
     and weaken the equality 
     with <span class="tt"><a href="ETHEREUM____RLP-TREE-FIX.html">rlp-tree-fix</a></span> and <span class="tt"><a href="ETHEREUM____RLP-TREE-LIST-FIX.html">rlp-tree-list-fix</a></span>. 
     These theorems subsume the lemmas, 
     but attempting to prove directly the theorems by induction fails.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Theorem: </b>rlp-encode-tree-injective</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rlp-encode-tree-injective
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> 0 (<a href="ETHEREUM____RLP-ENCODE-TREE.html">rlp-encode-tree</a> x)))
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> 0 (<a href="ETHEREUM____RLP-ENCODE-TREE.html">rlp-encode-tree</a> y))))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> 1 (<a href="ETHEREUM____RLP-ENCODE-TREE.html">rlp-encode-tree</a> x))
                               (<a href="ACL2____MV-NTH.html">mv-nth</a> 1 (<a href="ETHEREUM____RLP-ENCODE-TREE.html">rlp-encode-tree</a> y)))
                        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ETHEREUM____RLP-TREE-FIX.html">rlp-tree-fix</a> x)
                               (<a href="ETHEREUM____RLP-TREE-FIX.html">rlp-tree-fix</a> y)))))</pre> 
<p><b>Theorem: </b>rlp-encode-tree-list-injective</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rlp-encode-tree-list-injective
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> 0 (<a href="ETHEREUM____RLP-ENCODE-TREE-LIST.html">rlp-encode-tree-list</a> xs)))
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> 0 (<a href="ETHEREUM____RLP-ENCODE-TREE-LIST.html">rlp-encode-tree-list</a> ys))))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> 1 (<a href="ETHEREUM____RLP-ENCODE-TREE-LIST.html">rlp-encode-tree-list</a> xs))
                               (<a href="ACL2____MV-NTH.html">mv-nth</a> 1 (<a href="ETHEREUM____RLP-ENCODE-TREE-LIST.html">rlp-encode-tree-list</a> ys)))
                        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ETHEREUM____RLP-TREE-LIST-FIX.html">rlp-tree-list-fix</a> xs)
                               (<a href="ETHEREUM____RLP-TREE-LIST-FIX.html">rlp-tree-list-fix</a> ys)))))</pre> 

</body>
</html>
