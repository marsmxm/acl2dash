<html>
<head>
<meta charset="UTF-8">
<title>Oprewrite</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=VL2014____OPREWRITE">Click for Oprewrite in the Full Manual</a></h3>

<p>Rewrite expressions to eliminate various operators.</p><p>We transform expressions by applying the following rewrite rules. 
Note that we do not expect any widths to have been computed at the time this 
operation is performed, and so we do not try to preserve any widths.</p> 
 
<p>For our translation to be correct, each of these rules needs to be sound. 
That is, choose any Verilog bit vectors for a, b, and c.  Then, it needs to be 
the case that each left-hand side, above, evaluates to the same thing as its 
corresponding right-hand side.</p> 
 
<p>After reading the Verilog spec, we think this is true.  In addition, we have 
constructed a Verilog test harness (see xf-oprewrite.v) which checks that this 
is the case for all Verilog bit vectors of length 4 (i.e., vectors whose bits 
are 0, 1, x, or z), and we have established that there are no 4-bit violations 
on Cadence.</p> 
 
<h4>Operator Elimination Rules</h4> 
 
<p>The following rules are useful in that the operators on the left are 
completely erased from the parse tree.  Hence, we do not need to consider 
how to synthesize them or handle them at all!</p> 
 
<ul> 
<li>
<span class="v">+a</span>     --&gt; <span class="v">a + 1'sb0</span>
</li> 
<li>
<span class="v">-a</span>     --&gt; <span class="v">1'sb0 - a</span>
</li> 
 
<li>
<span class="v">a &amp;&amp; b</span> --&gt; <span class="v">(|a) &amp; (|b)</span>
</li> 
<li>
<span class="v">a || b</span> --&gt; <span class="v">(|a) | (|b)</span>
</li> 
<li>
<span class="v">!a</span>     --&gt; <span class="v">{~(|a)}</span>
</li> 
 
<li>
<span class="v">~&amp; (a)</span> --&gt; <span class="v">{~( &amp;a )}</span>
</li> 
<li>
<span class="v">~| (a)</span> --&gt; <span class="v">{~( |a )}</span>
</li> 
<li>
<span class="v">~^ (a)</span> --&gt; <span class="v">{~( ^a )}</span>
</li> 
 
<li>
<span class="v">a &lt; b</span>  --&gt; <span class="v">{~(a &gt;= b)}</span>
</li> 
<li>
<span class="v">a &gt; b</span>  --&gt; <span class="v">{~(b &gt;= a)}</span>
</li> 
<li>
<span class="v">a &lt;= b</span> --&gt; <span class="v">b &gt;= a</span>
</li> 
 
<li>
<span class="v">a == b</span> --&gt; <span class="v">&amp;(a ~^ b)</span>
</li> 
<li>
<span class="v">a != b</span> --&gt; <span class="v">|(a ^ b)</span>
</li> 
 
<li>
<span class="v">a !== b</span> --&gt; <span class="v">{~(a === b)}</span>
</li> 
</ul> 
 
<h4>Additional Rules</h4> 
 
<p>We also have a couple of rules that help to standardize conditional 
expressions.  In particular, the first rule here ensures that when we go to 
synthesize a conditional operation, we can assume that the "test" argument 
has a width of 1.  The second rule ensures that if we encounter a (<b>BOZO</b> 
is that the right name for this kind of thing?) then then Z is always in the 
false branch.</p> 
 
<ul> 
<li>
<span class="v">a ? b : c</span> --&gt; <span class="v">(|a) ? b : c</span>
</li> 
<li>
<span class="v">a ? z : c</span> --&gt; <span class="v">~(|a) ? c : z</span>
</li> 
</ul> 
 
<p>We also consolidate multiple-concatenations of constint and weirdint values 
into a single values.  This is important for properly recognizing zatoms in 
occform, since designers sometimes write things like</p> 
 
<pre class="code">assign foo = a ? b : width{ 1'bz }</pre> 
 
<p>Here, if we don't consolidate <span class="v">width{1'bz}</span>, we're not going to recognize 
it as a zatom and occform it correctly.</p>
</body>
</html>
