<html>
<head>
<meta charset="UTF-8">
<title>Introduction-to-the-database</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____INTRODUCTION-TO-THE-DATABASE">Click for Introduction-to-the-database in the Full Manual</a></h3>

<p>How to update the database</p><p>We assume you've read <a href="ACL2____INTRODUCTION-TO-REWRITE-RULES-PART-1.html">introduction-to-rewrite-rules-part-1</a> 
 and <a href="ACL2____INTRODUCTION-TO-KEY-CHECKPOINTS.html">introduction-to-key-checkpoints</a>.</p> 
 
 <p>The theorem prover's heuristics are influenced by the database of rules and 
 the enabled/disabled status of the rules.  You can think of the database as a 
 <i>global</i> hint, potentially affecting all parts of a proof attempt.</p> 
 
 <p>However, in addition to the ``global hint,'' it is possible to give 
 <i>local</i> hints that affect the theorem prover's behavior on specific 
 subgoals.  We discuss the database here and discuss local hints later in the 
 tutorial.</p> 
 
 <p>The theorem prover's ``database'' is called the <i>ACL2 world</i>.  You 
 change the world by issuing commands called <i>events</i>.  The most common 
 events are <span class="v">defun</span> for defining new functions (and predicates) and 
 <span class="v">defthm</span> for proving new theorems.  Both add rules to the database.  Here 
 are some commonly used events.</p> 
 
 <p>We recommend that upon the first reading of this tutorial you do not follow 
 the links shown below!  The links take you into the hypertext reference 
 manual, where it is easy to get lost unless you're looking for detail about 
 one specific feature.</p> 
 
 <p>See <a href="COMMON-LISP____DEFUN.html">defun</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a> to define a new function or predicate symbol. 
 Definitional axioms are just a kind of <span class="v">rewrite</span> rule, but <span class="v">defun</span> may 
 also add rules affecting the determination of the type of a term and rules 
 affecting the induction analysis.  When you issue a <span class="v">defun</span> command you 
 will always supply the <i>name</i> of the function or predicate, the list of 
 <i>formal parameters</i>, <i>v1,...vn</i>, and the <i>body</i>:</p> 
 
 <pre class="code">(defun <i>name</i> (<i>v1 ... vn</i>) 
   <i>body</i>) 
</pre> 
 
 <p>If the event is accepted, a <i>definitional axiom</i> is added to the 
 world, <span class="v">(</span><i>name</i> <i>v1...vn</i><span class="v">)</span>=<i>body</i>, stored as a special 
 kind of unconditional rewrite rule.  However, the <span class="v">defun</span> event may require 
 theorems to be proved.  Specifically, <i>measure theorems</i> must be proved 
 to establish that recursively defined functions always terminate, by proving 
 that an <i>ordinal</i> measure of the formal parameters decreases in a 
 <i>well-founded</i> way in every recursive call.  In addition, if 
 <i>guards</i> are being used to declare the <i>expected domain</i> of the 
 newly defined function, <i>guard theorems</i> might be proved to establish 
 that all functions stay within their expected domains.  In any case, you may 
 provide additional information to the <span class="v">defun</span> event, coded as part of the 
 <span class="v">declaration</span> that Common Lisp allows:</p> 
 
 <pre class="code">(defun <i>name</i> (<i>v1 ... vn</i>) 
   (declare (xargs ...)) 
   <i>body</i>) 
</pre> 
 
 <p>The <span class="v">xargs</span> (``extra arguments to <span class="v">defun</span>'') entry may specify, among 
 other things, the measure to use in the termination proof, hints for use by 
 the prover during the termination proof, the guard of the new function, and 
 hints for use by the prover during the guard verification step.</p> 
 
 <p>See <a href="ACL2____DEFTHM.html">defthm</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a> to prove a theorem and to add it as a rule of one 
 or more specified rule-classes.  When you issue a <span class="v">defthm</span> command you 
 always specify a <i>name</i> for the theorem you're trying to prove and a 
 <i>formula</i> stating the theorem.  You may optionally supply some local 
 hints as we describe later in the tutorial.  You may also optionally supply 
 some <i>rule classes</i> indicating how you want your formula stored as a 
 rule, after it is proved.  We discuss the <span class="v">defthm</span> <i>rule classes</i> 
 below.</p> 
 
 <p>See <a href="ACL2____IN-THEORY.html">in-theory</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a> to enable or disable rules.  Rules have names 
 derived from the names you give to functions and theorems, e.g., <span class="v">(:REWRITE
 LEFT-IDENTITY-OF-FOO . 2)</span> for the second rewrite rule you created from the 
 theorem named <span class="v">LEFT-IDENTITY-OF-FOO</span>.  Rule names are called <i>runes</i>. 
 A <i>theory</i> is just a set (list) of runes.  The <i>current theory</i> is 
 the list of enabled runes and the <span class="v">in-theory</span> event can add runes to or 
 delete runes from the current theory.</p> 
 
 <p>See <a href="ACL2____INCLUDE-BOOK.html">include-book</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a> to change the world by loading a 
 certified file of other events.  The most common use of <span class="v">include-book</span> is 
 to load ``community books'' â€” books written by other ACL2 users who have 
 released them for distribution to the community.  The most common books loaded 
 are probably the arithmetic books:</p> 
 
 <pre class="code">; * for the most elementary arithmetic, needed for any problem 
;   that involves even simple addition and multiplication like 
; <span class="v">(<a href="COMMON-LISP_____B2.html">+</a> x (<a href="COMMON-LISP_____A2.html">*</a> 2 y) -3)</span>: 
 
    (include-book "arithmetic/top-with-meta" :dir :system) 
 
; * for more complicated arithmetic involving non-linear terms like 
; <span class="v">(<a href="COMMON-LISP_____A2.html">*</a> x y)</span>, <span class="v">(<a href="COMMON-LISP____EXPT.html">expt</a> x (<a href="COMMON-LISP_____B2.html">+</a> i j))</span>, and <span class="v">floor</span> and <span class="v">mod</span> 
 
    (include-book "arithmetic-5/top" :dir :system) 
</pre> 
 
 <p>But for a complete list of system books, see <a href="ACL2____BOOKS.html">books</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a>.</p> 
 
 <p>See <a href="ACL2____CERTIFY-BOOK.html">certify-book</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a> to 
 certify a file of events for reuse later.</p> 
 
 <p>See <a href="ACL2____DEFCONST.html">defconst</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a> to define a new constant, allowing you to write a 
 symbol, e.g., <span class="v">*weekdays*</span> in place of some object, e.g., <span class="v">'(MON TUE WED
 THU FRI)</span> in formulas.</p> 
 
 <p>See <a href="COMMON-LISP____DEFMACRO.html">defmacro</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a> to define a new syntactic abbreviation.  The macro 
 facility in Lisp is quite powerful, allowing you to <i>compute</i> the form to 
 which some type-in expands.  For example, the primitive macro <span class="v">COND</span> is 
 defined so that <span class="v">(<a href="COMMON-LISP____COND.html">COND</a> ((P X) 1)((<a href="ACL2____Q.html">Q</a> X) 2)(T 3))</span> expands to <span class="v">(<a href="COMMON-LISP____IF.html">IF</a> (P X)
 1 (<a href="COMMON-LISP____IF.html">IF</a> (<a href="ACL2____Q.html">Q</a> X) 2 3))</span>.</p> 
 
 <p>See <a href="ACL2____DEFSTOBJ.html">defstobj</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a> to introduce a <i>single-threaded object</i> that 
 your functions may modify ``destructively'' provided they follow strict 
 syntactic rules.</p> 
 
 <p>See <a href="ACL2____EVENTS.html">events</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a> for a complete list of the ACL2 events.  There are 
 events to allow mutually recursive definitions, to introduce some new function 
 symbols constrained to satisfy given axioms, to allow the temporary 
 introduction of a ``local'' event to help prove some goal theorem and then 
 disappear, to provide the power of first-order quantification and a choice 
 operator, and many other features.</p> 
 
 <p>There are also commands that allow you to inspect the world, e.g., to print 
 the command that introduced a given name, to show all the commands back to a 
 certain one, undo the last command or more generally roll-back to an earlier 
 command.  See <a href="ACL2____HISTORY.html">history</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a>.</p> 
 
 <p><b>The Defthm Rule-Classes</b></p> 
 
 <p>We've already discussed the key role that rules play in controlling the 
 behavior of the system.  New rules are introduced primarily with the 
 <span class="v">defthm</span> event, though <span class="v">defun</span> and other events may introduce rules.</p> 
 
 <p>To prove <i>formula</i> and generate, say a <span class="v">:rewrite</span> rule and a 
 <span class="v">:generalize</span> rule from it, you would write</p> 
 
 <pre class="code">(defthm <i>name</i> 
        <i>formula</i> 
        :rule-classes (:rewrite :generalize)) 
</pre> 
 
 <p>If you wanted to rearrange the shape of the formula before generating the 
 <span class="v">:rewrite</span> rule you could provide a <span class="v">:corollary</span> modifier to the 
 <span class="v">:rewrite</span> rule class:</p> 
 
 <pre class="code">(defthm <i>name</i> 
        <i>formula</i> 
        :rule-classes ((:rewrite :corollary ...) 
                       :generalize)). 
</pre> 
 
 <p>There are many classes of rules, affecting different parts of the system. 
 Each class is denoted by a keyword, e.g., <span class="v">:REWRITE</span>, <span class="v">:LINEAR</span>, etc. 
 You are responsible for specifying the class(es) of rules to be generated from 
 a given formula and several different rules (possibly of different classes) 
 may be derived from a single formula.  Each class admits optional modifiers 
 that allow you finer control over each rule.  Each class admits the 
 <span class="v">:corollary</span> modifier with which you can rearrange the formula before a 
 rule of that class is generated.  This allows you to state a theorem in its 
 most elegant form for publication purposes but store it as a rule with the 
 most appropriate hypotheses and conclusion.  Other modifiers tend to be 
 specific to certain rule classes, but for example, <span class="v">:rewrite</span> rule 
 modifiers include an optional limit on the depth of backchaining and options 
 for handling free variables.</p> 
 
 <p>We give some links below to other classes of rules.  However, we recommend 
 that you not follow these links upon your first reading of this tutorial!</p> 
 
 <p>See <a href="ACL2____REWRITE.html">rewrite</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a> for a description of how to create a rewrite 
 rule.</p> 
 
 <p>See <a href="ACL2____LINEAR.html">linear</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a> for a description of how to store theorems 
 concluding with arithmetic inequalities.  The trouble with storing</p> 
 
 <pre class="code">(<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____LEN.html">len</a> (delete e x)) (<a href="ACL2____LEN.html">len</a> x))</pre> 
 
 <p>as a rewrite rule is that it only matches instances of that inequality and 
 thus fails to match</p> 
 
 <pre class="code">(<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____LEN.html">LEN</a> (DELETE E X)) (<a href="COMMON-LISP_____B2.html">+</a> 1 (<a href="ACL2____LEN.html">LEN</a> X)))</pre> 
 
 <p>ACL2 contains an extensible linear arithmetic decision procedure and by 
 storing inequalities as <span class="v">:linear</span> rules you can make that decision 
 procedure aware of the basic inequalities between non-primitive numerically 
 valued terms.</p> 
 
 <p>See <a href="ACL2____EQUIVALENCE.html">equivalence</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a>, see <a href="ACL2____CONGRUENCE.html">congruence</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a>, 
 and see <a href="ACL2____REFINEMENT.html">refinement</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a> to learn how to introduce a new equivalence 
 relation to the rewriter.  For example, suppose you define <span class="v">set-equal</span> so 
 that it returns t precisely if its two arguments are lists containing the same 
 elements, regardless of order or number of occurrences.  Note that under this 
 sense of ``equivalence'', <span class="v">(<a href="ACL2____REV.html">rev</a> x)</span> is the identity function and 
 <span class="v">append</span> is commutative, for example.</p> 
 
 <pre class="code">(set-equal (<a href="ACL2____REV.html">rev</a> x) x)

(set-equal (<a href="COMMON-LISP____APPEND.html">append</a> x y) (<a href="COMMON-LISP____APPEND.html">append</a> y x))</pre> 
 
 <p>You can make ACL2 use these two theorems as <span class="v">:rewrite</span> rules to replace 
 instances of <span class="v">(<a href="ACL2____REV.html">REV</a> x)</span> and <span class="v">(<a href="COMMON-LISP____APPEND.html">APPEND</a> x y)</span> by <span class="v">set-equal</span> terms, even 
 though the results are not actually <span class="v">EQUAL</span>.  This is possible provided the 
 target occurs in a context admitting <span class="v">set-equal</span> as a congruence relation. 
 For example, the congruence rule:</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (set-equal a b)
         (<a href="ACL2____IFF.html">iff</a> (<a href="COMMON-LISP____MEMBER.html">member</a> e a)
              (<a href="COMMON-LISP____MEMBER.html">member</a> e b)))</pre> 
 
 <p>gives the rewriter permission to use the above <span class="v">set-equal</span> rules as 
 rewrite rules in the second argument of any <span class="v">member</span> expression being used 
 in a propositional way.</p> 
 
 <p>See <a href="ACL2____ELIM.html">elim</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a> for a description of how to make the system adopt a 
 ``change of variable'' tactic that can trade in <i>destructor</i> functions 
 for <i>constructor</i> functions.  In analogy with how ACL2 eliminates <span class="v">(<a href="COMMON-LISP____CAR.html">CAR</a>
 X)</span> and <span class="v">(<a href="COMMON-LISP____CDR.html">CDR</a> X)</span> by replacing <span class="v">X</span> with <span class="v">(<a href="COMMON-LISP____CONS.html">CONS</a> A B)</span>, you can make 
 it eliminate other destructors.  For example, the community book 
 <span class="v">"arithmetic-5/top"</span> provides an <span class="v">elim</span> rule that eliminates <span class="v">(<a href="COMMON-LISP____FLOOR.html">floor</a>
 x y)</span> and <span class="v">(<a href="COMMON-LISP____MOD.html">mod</a> x y)</span> by replacing <span class="v">x</span> by <span class="v">(<a href="COMMON-LISP_____B2.html">+</a> r (<a href="COMMON-LISP_____A2.html">*</a> y q))</span>, so that 
 the <span class="v">floor</span> expression becomes <span class="v">q</span> and the <span class="v">mod</span> expression becomes 
 <span class="v">r</span>.  When introducing your own <span class="v">elim</span> rules you will probably also need 
 to introduce <span class="v">generalize</span> rules (see below) so that the new variables are 
 appropriately constrained.</p> 
 
 <p>See <a href="ACL2____GENERALIZE.html">generalize</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a> for a description of how you can make ACL2 restrict 
 the new variables it introduces when generalizing.  ACL2 will sometimes 
 replace a term by a new variable and with <span class="v">generalize</span> rules you can ensure 
 that the new variable symbol has certain properties of the term it 
 replaces.</p> 
 
 <p>See <a href="ACL2____INDUCTION.html">induction</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a> for a description of how to tailor the inductions 
 suggested by a term.  Most of the time when ACL2 chooses the ``wrong'' 
 induction, the easiest fix is with a local <span class="v">:induct</span> hint (see below).  But 
 if the same problem arises repeatedly in several theorems, you might want to 
 ``educate'' ACL2's induction heuristic.</p> 
 
 <p>For a complete list of rule-classes, See <a href="ACL2____RULE-CLASSES.html">rule-classes</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a>.</p> 
 
 <p>If you are reading this as part of the tutorial introduction to the theorem 
 prover, use your browser's <b>Back Button</b> now to return to <a href="ACL2____INTRODUCTION-TO-THE-THEOREM-PROVER.html">introduction-to-the-theorem-prover</a>.</p>
</body>
</html>
