<html>
<head>
<meta charset="UTF-8">
<title>Simpcode</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=AIGNET____SIMPCODE">Click for Simpcode in the Full Manual</a></h3>

<p>An 4-bit unsigned bitstruct type.</p><p>This is a bitstruct type introduced by <a href="FTY____DEFBITSTRUCT.html">fty::defbitstruct</a>, represented as a unsigned 4-bit integer.</p> 
<h5>Fields</h5> 
<dl>
<dt>neg — <span class="tt">bit</span>
</dt> 
 
<dt>xor — <span class="tt">bit</span>
</dt> 
 
<dt>identity — <span class="tt">bit</span>
</dt> 
 
<dt>choice — <span class="tt">bit</span>
</dt> 
 
</dl> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>simpcode-p</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> simpcode-p (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'simpcode-p))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> 4 x)
                 :exec (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> x) (<a href="COMMON-LISP_____C3.html">&lt;</a> x 16)))))</pre> 
<p><b>Theorem: </b>simpcode-p-when-unsigned-byte-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-p-when-unsigned-byte-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> 4 x)
                 (<a href="AIGNET____SIMPCODE-P.html">simpcode-p</a> x)))</pre> 
<p><b>Theorem: </b>unsigned-byte-p-when-simpcode-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> unsigned-byte-p-when-simpcode-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="AIGNET____SIMPCODE-P.html">simpcode-p</a> x)
                 (<a href="ACL2____UNSIGNED-BYTE-P.html">unsigned-byte-p</a> 4 x)))</pre> 
<p><b>Theorem: </b>simpcode-p-compound-recognizer</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-p-compound-recognizer
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="AIGNET____SIMPCODE-P.html">simpcode-p</a> x) (<a href="ACL2____NATP.html">natp</a> x))
        :rule-classes :compound-recognizer)</pre> 
<p><b>Function: </b>simpcode-fix</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> simpcode-fix (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="AIGNET____SIMPCODE-P.html">simpcode-p</a> x)))
       (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'simpcode-fix))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____LOGHEAD.html">loghead</a> 4 x) :exec x)))</pre> 
<p><b>Theorem: </b>simpcode-p-of-simpcode-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-p-of-simpcode-fix
        (<a href="ACL2____B_A2.html">b*</a> ((fty::fixed (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x)))
            (<a href="AIGNET____SIMPCODE-P.html">simpcode-p</a> fty::fixed))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>simpcode-fix-when-simpcode-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-fix-when-simpcode-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="AIGNET____SIMPCODE-P.html">simpcode-p</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x) x)))</pre> 
<p><b>Function: </b>simpcode-equiv$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> simpcode-equiv$inline (x acl2::y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="AIGNET____SIMPCODE-P.html">simpcode-p</a> x)
                                   (<a href="AIGNET____SIMPCODE-P.html">simpcode-p</a> acl2::y))))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x)
              (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> acl2::y)))</pre> 
<p><b>Theorem: </b>simpcode-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (simpcode-equiv x y))
             (simpcode-equiv x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (simpcode-equiv x y)
                      (simpcode-equiv y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (simpcode-equiv x y)
                           (simpcode-equiv y z))
                      (simpcode-equiv x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>simpcode-equiv-implies-equal-simpcode-fix-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-equiv-implies-equal-simpcode-fix-1
        (<a href="ACL2____IMPLIES.html">implies</a> (simpcode-equiv x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x)
                        (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>simpcode-fix-under-simpcode-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-fix-under-simpcode-equiv
        (simpcode-equiv (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x) x)
        :rule-classes (:rewrite :rewrite-quoted-constant))</pre> 
<p><b>Theorem: </b>simpcode-fix-of-simpcode-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-fix-of-simpcode-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x))
               (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x)))</pre> 
<p><b>Theorem: </b>simpcode-fix-simpcode-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-fix-simpcode-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (simpcode-equiv x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x)
                        (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>simpcode</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     simpcode (neg xor identity choice)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BITP.html">bitp</a> neg)
                                 (<a href="ACL2____BITP.html">bitp</a> xor)
                                 (<a href="ACL2____BITP.html">bitp</a> identity)
                                 (<a href="ACL2____BITP.html">bitp</a> choice))))
     (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'simpcode))
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
          (<a href="ACL2____B_A2.html">b*</a> ((neg (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____BFIX.html">bfix</a> neg) :exec neg))
               (<a href="ACL2____XOR.html">xor</a> (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____BFIX.html">bfix</a> xor) :exec xor))
               (<a href="COMMON-LISP____IDENTITY.html">identity</a> (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____BFIX.html">bfix</a> identity)
                              :exec identity))
               (choice (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____BFIX.html">bfix</a> choice)
                            :exec choice)))
              (<a href="ACL2____LOGAPP.html">logapp</a> 1 neg
                      (<a href="ACL2____LOGAPP.html">logapp</a> 1 xor (<a href="ACL2____LOGAPP.html">logapp</a> 1 identity choice))))))</pre> 
<p><b>Theorem: </b>simpcode-p-of-simpcode</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-p-of-simpcode
        (<a href="ACL2____B_A2.html">b*</a> ((<a href="AIGNET____SIMPCODE.html">simpcode</a> (<a href="AIGNET____SIMPCODE.html">simpcode</a> neg xor identity choice)))
            (<a href="AIGNET____SIMPCODE-P.html">simpcode-p</a> simpcode))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>simpcode-of-bfix-neg</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-of-bfix-neg
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE.html">simpcode</a> (<a href="ACL2____BFIX.html">bfix</a> neg)
                         xor identity choice)
               (<a href="AIGNET____SIMPCODE.html">simpcode</a> neg xor identity choice)))</pre> 
<p><b>Theorem: </b>simpcode-bit-equiv-congruence-on-neg</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-bit-equiv-congruence-on-neg
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____BIT-EQUIV.html">bit-equiv</a> neg neg-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE.html">simpcode</a> neg xor identity choice)
                        (<a href="AIGNET____SIMPCODE.html">simpcode</a> neg-equiv xor identity choice)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>simpcode-of-bfix-xor</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-of-bfix-xor
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE.html">simpcode</a> neg (<a href="ACL2____BFIX.html">bfix</a> xor)
                         identity choice)
               (<a href="AIGNET____SIMPCODE.html">simpcode</a> neg xor identity choice)))</pre> 
<p><b>Theorem: </b>simpcode-bit-equiv-congruence-on-xor</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-bit-equiv-congruence-on-xor
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____BIT-EQUIV.html">bit-equiv</a> xor xor-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE.html">simpcode</a> neg xor identity choice)
                        (<a href="AIGNET____SIMPCODE.html">simpcode</a> neg xor-equiv identity choice)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>simpcode-of-bfix-identity</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-of-bfix-identity
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE.html">simpcode</a> neg xor (<a href="ACL2____BFIX.html">bfix</a> identity)
                         choice)
               (<a href="AIGNET____SIMPCODE.html">simpcode</a> neg xor identity choice)))</pre> 
<p><b>Theorem: </b>simpcode-bit-equiv-congruence-on-identity</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-bit-equiv-congruence-on-identity
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____BIT-EQUIV.html">bit-equiv</a> identity identity-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE.html">simpcode</a> neg xor identity choice)
                        (<a href="AIGNET____SIMPCODE.html">simpcode</a> neg xor identity-equiv choice)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>simpcode-of-bfix-choice</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-of-bfix-choice
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE.html">simpcode</a> neg xor identity (<a href="ACL2____BFIX.html">bfix</a> choice))
               (<a href="AIGNET____SIMPCODE.html">simpcode</a> neg xor identity choice)))</pre> 
<p><b>Theorem: </b>simpcode-bit-equiv-congruence-on-choice</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-bit-equiv-congruence-on-choice
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____BIT-EQUIV.html">bit-equiv</a> choice choice-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE.html">simpcode</a> neg xor identity choice)
                        (<a href="AIGNET____SIMPCODE.html">simpcode</a> neg xor identity choice-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>simpcode-equiv-under-mask</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> simpcode-equiv-under-mask (x x1 mask)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="AIGNET____SIMPCODE-P.html">simpcode-p</a> x)
                                   (<a href="AIGNET____SIMPCODE-P.html">simpcode-p</a> x1)
                                   (<a href="COMMON-LISP____INTEGERP.html">integerp</a> mask))))
       (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'simpcode-equiv-under-mask))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
            (fty::int-equiv-under-mask (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x)
                                       (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x1)
                                       mask)))</pre> 
<p><b>Theorem: </b>simpcode-equiv-under-mask-of-simpcode-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-equiv-under-mask-of-simpcode-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (simpcode-equiv-under-mask (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x)
                                          x1 mask)
               (simpcode-equiv-under-mask x x1 mask)))</pre> 
<p><b>Theorem: </b>simpcode-equiv-under-mask-simpcode-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     simpcode-equiv-under-mask-simpcode-equiv-congruence-on-x
     (<a href="ACL2____IMPLIES.html">implies</a> (simpcode-equiv x x-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (simpcode-equiv-under-mask x x1 mask)
                     (simpcode-equiv-under-mask x-equiv x1 mask)))
     :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>simpcode-equiv-under-mask-of-simpcode-fix-x1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-equiv-under-mask-of-simpcode-fix-x1
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (simpcode-equiv-under-mask x (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x1)
                                          mask)
               (simpcode-equiv-under-mask x x1 mask)))</pre> 
<p><b>Theorem: </b>simpcode-equiv-under-mask-simpcode-equiv-congruence-on-x1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     simpcode-equiv-under-mask-simpcode-equiv-congruence-on-x1
     (<a href="ACL2____IMPLIES.html">implies</a> (simpcode-equiv x1 x1-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (simpcode-equiv-under-mask x x1 mask)
                     (simpcode-equiv-under-mask x x1-equiv mask)))
     :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>simpcode-equiv-under-mask-of-ifix-mask</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-equiv-under-mask-of-ifix-mask
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (simpcode-equiv-under-mask x x1 (<a href="ACL2____IFIX.html">ifix</a> mask))
               (simpcode-equiv-under-mask x x1 mask)))</pre> 
<p><b>Theorem: </b>simpcode-equiv-under-mask-int-equiv-congruence-on-mask</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     simpcode-equiv-under-mask-int-equiv-congruence-on-mask
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____INT-EQUIV.html">int-equiv</a> mask mask-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (simpcode-equiv-under-mask x x1 mask)
                     (simpcode-equiv-under-mask x x1 mask-equiv)))
     :rule-classes :congruence)</pre> 
<p><b>Function: </b>simpcode-&gt;neg</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> simpcode-&gt;neg (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="AIGNET____SIMPCODE-P.html">simpcode-p</a> x)))
       (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="COMMON-LISP____LET.html">let</a> ((x (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x)))
                        (<a href="ACL2____PART-SELECT.html">part-select</a> x :low 0 :width 1))
            :exec (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 1)
                       (<a href="COMMON-LISP____LOGAND.html">logand</a> (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 1) 1)
                               (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 4) x)))))</pre> 
<p><b>Theorem: </b>bitp-of-simpcode-&gt;neg</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bitp-of-simpcode-&gt;neg
        (<a href="ACL2____B_A2.html">b*</a> ((neg (<a href="AIGNET____SIMPCODE-_E3NEG.html">simpcode-&gt;neg</a> x)))
            (<a href="ACL2____BITP.html">bitp</a> neg))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>simpcode-&gt;neg-of-simpcode-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-&gt;neg-of-simpcode-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE-_E3NEG.html">simpcode-&gt;neg</a> (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x))
               (<a href="AIGNET____SIMPCODE-_E3NEG.html">simpcode-&gt;neg</a> x)))</pre> 
<p><b>Theorem: </b>simpcode-&gt;neg-simpcode-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-&gt;neg-simpcode-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (simpcode-equiv x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE-_E3NEG.html">simpcode-&gt;neg</a> x)
                        (<a href="AIGNET____SIMPCODE-_E3NEG.html">simpcode-&gt;neg</a> x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>simpcode-&gt;neg-of-simpcode</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-&gt;neg-of-simpcode
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE-_E3NEG.html">simpcode-&gt;neg</a> (<a href="AIGNET____SIMPCODE.html">simpcode</a> neg xor identity choice))
               (<a href="ACL2____BFIX.html">bfix</a> neg)))</pre> 
<p><b>Theorem: </b>simpcode-&gt;neg-of-write-with-mask</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 simpcode-&gt;neg-of-write-with-mask
 (<a href="ACL2____IMPLIES.html">implies</a>
  (<a href="COMMON-LISP____AND.html">and</a>
   (fty::bitstruct-read-over-write-hyps x simpcode-equiv-under-mask)
   (simpcode-equiv-under-mask x acl2::y fty::mask)
   (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____LOGAND.html">logand</a> (<a href="COMMON-LISP____LOGNOT.html">lognot</a> fty::mask) 1) 0))
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE-_E3NEG.html">simpcode-&gt;neg</a> x)
         (<a href="AIGNET____SIMPCODE-_E3NEG.html">simpcode-&gt;neg</a> acl2::y))))</pre> 
<p><b>Function: </b>simpcode-&gt;xor</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 simpcode-&gt;xor (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="AIGNET____SIMPCODE-P.html">simpcode-p</a> x)))
 (<a href="ACL2____MBE.html">mbe</a>
     :logic (<a href="COMMON-LISP____LET.html">let</a> ((x (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x)))
                 (<a href="ACL2____PART-SELECT.html">part-select</a> x :low 1 :width 1))
     :exec (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 1)
                (<a href="COMMON-LISP____LOGAND.html">logand</a> (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 1) 1)
                        (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 3)
                             (<a href="COMMON-LISP____ASH.html">ash</a> (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 4) x) -1))))))</pre> 
<p><b>Theorem: </b>bitp-of-simpcode-&gt;xor</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bitp-of-simpcode-&gt;xor
        (<a href="ACL2____B_A2.html">b*</a> ((<a href="ACL2____XOR.html">xor</a> (<a href="AIGNET____SIMPCODE-_E3XOR.html">simpcode-&gt;xor</a> x)))
            (<a href="ACL2____BITP.html">bitp</a> xor))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>simpcode-&gt;xor-of-simpcode-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-&gt;xor-of-simpcode-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE-_E3XOR.html">simpcode-&gt;xor</a> (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x))
               (<a href="AIGNET____SIMPCODE-_E3XOR.html">simpcode-&gt;xor</a> x)))</pre> 
<p><b>Theorem: </b>simpcode-&gt;xor-simpcode-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-&gt;xor-simpcode-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (simpcode-equiv x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE-_E3XOR.html">simpcode-&gt;xor</a> x)
                        (<a href="AIGNET____SIMPCODE-_E3XOR.html">simpcode-&gt;xor</a> x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>simpcode-&gt;xor-of-simpcode</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-&gt;xor-of-simpcode
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE-_E3XOR.html">simpcode-&gt;xor</a> (<a href="AIGNET____SIMPCODE.html">simpcode</a> neg xor identity choice))
               (<a href="ACL2____BFIX.html">bfix</a> xor)))</pre> 
<p><b>Theorem: </b>simpcode-&gt;xor-of-write-with-mask</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 simpcode-&gt;xor-of-write-with-mask
 (<a href="ACL2____IMPLIES.html">implies</a>
  (<a href="COMMON-LISP____AND.html">and</a>
   (fty::bitstruct-read-over-write-hyps x simpcode-equiv-under-mask)
   (simpcode-equiv-under-mask x acl2::y fty::mask)
   (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____LOGAND.html">logand</a> (<a href="COMMON-LISP____LOGNOT.html">lognot</a> fty::mask) 2) 0))
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE-_E3XOR.html">simpcode-&gt;xor</a> x)
         (<a href="AIGNET____SIMPCODE-_E3XOR.html">simpcode-&gt;xor</a> acl2::y))))</pre> 
<p><b>Function: </b>simpcode-&gt;identity</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 simpcode-&gt;identity (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="AIGNET____SIMPCODE-P.html">simpcode-p</a> x)))
 (<a href="ACL2____MBE.html">mbe</a>
     :logic (<a href="COMMON-LISP____LET.html">let</a> ((x (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x)))
                 (<a href="ACL2____PART-SELECT.html">part-select</a> x :low 2 :width 1))
     :exec (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 1)
                (<a href="COMMON-LISP____LOGAND.html">logand</a> (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 1) 1)
                        (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 2)
                             (<a href="COMMON-LISP____ASH.html">ash</a> (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 4) x) -2))))))</pre> 
<p><b>Theorem: </b>bitp-of-simpcode-&gt;identity</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bitp-of-simpcode-&gt;identity
        (<a href="ACL2____B_A2.html">b*</a> ((<a href="COMMON-LISP____IDENTITY.html">identity</a> (<a href="AIGNET____SIMPCODE-_E3IDENTITY.html">simpcode-&gt;identity</a> x)))
            (<a href="ACL2____BITP.html">bitp</a> identity))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>simpcode-&gt;identity-of-simpcode-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-&gt;identity-of-simpcode-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE-_E3IDENTITY.html">simpcode-&gt;identity</a> (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x))
               (<a href="AIGNET____SIMPCODE-_E3IDENTITY.html">simpcode-&gt;identity</a> x)))</pre> 
<p><b>Theorem: </b>simpcode-&gt;identity-simpcode-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-&gt;identity-simpcode-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (simpcode-equiv x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE-_E3IDENTITY.html">simpcode-&gt;identity</a> x)
                        (<a href="AIGNET____SIMPCODE-_E3IDENTITY.html">simpcode-&gt;identity</a> x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>simpcode-&gt;identity-of-simpcode</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     simpcode-&gt;identity-of-simpcode
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE-_E3IDENTITY.html">simpcode-&gt;identity</a> (<a href="AIGNET____SIMPCODE.html">simpcode</a> neg xor identity choice))
            (<a href="ACL2____BFIX.html">bfix</a> identity)))</pre> 
<p><b>Theorem: </b>simpcode-&gt;identity-of-write-with-mask</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 simpcode-&gt;identity-of-write-with-mask
 (<a href="ACL2____IMPLIES.html">implies</a>
  (<a href="COMMON-LISP____AND.html">and</a>
   (fty::bitstruct-read-over-write-hyps x simpcode-equiv-under-mask)
   (simpcode-equiv-under-mask x acl2::y fty::mask)
   (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____LOGAND.html">logand</a> (<a href="COMMON-LISP____LOGNOT.html">lognot</a> fty::mask) 4) 0))
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE-_E3IDENTITY.html">simpcode-&gt;identity</a> x)
         (<a href="AIGNET____SIMPCODE-_E3IDENTITY.html">simpcode-&gt;identity</a> acl2::y))))</pre> 
<p><b>Function: </b>simpcode-&gt;choice</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 simpcode-&gt;choice (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="AIGNET____SIMPCODE-P.html">simpcode-p</a> x)))
 (<a href="ACL2____MBE.html">mbe</a>
     :logic (<a href="COMMON-LISP____LET.html">let</a> ((x (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x)))
                 (<a href="ACL2____PART-SELECT.html">part-select</a> x :low 3 :width 1))
     :exec (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 1)
                (<a href="COMMON-LISP____LOGAND.html">logand</a> (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 1) 1)
                        (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 1)
                             (<a href="COMMON-LISP____ASH.html">ash</a> (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 4) x) -3))))))</pre> 
<p><b>Theorem: </b>bitp-of-simpcode-&gt;choice</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bitp-of-simpcode-&gt;choice
        (<a href="ACL2____B_A2.html">b*</a> ((choice (<a href="AIGNET____SIMPCODE-_E3CHOICE.html">simpcode-&gt;choice</a> x)))
            (<a href="ACL2____BITP.html">bitp</a> choice))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>simpcode-&gt;choice-of-simpcode-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-&gt;choice-of-simpcode-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE-_E3CHOICE.html">simpcode-&gt;choice</a> (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x))
               (<a href="AIGNET____SIMPCODE-_E3CHOICE.html">simpcode-&gt;choice</a> x)))</pre> 
<p><b>Theorem: </b>simpcode-&gt;choice-simpcode-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-&gt;choice-simpcode-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (simpcode-equiv x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE-_E3CHOICE.html">simpcode-&gt;choice</a> x)
                        (<a href="AIGNET____SIMPCODE-_E3CHOICE.html">simpcode-&gt;choice</a> x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>simpcode-&gt;choice-of-simpcode</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-&gt;choice-of-simpcode
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE-_E3CHOICE.html">simpcode-&gt;choice</a> (<a href="AIGNET____SIMPCODE.html">simpcode</a> neg xor identity choice))
               (<a href="ACL2____BFIX.html">bfix</a> choice)))</pre> 
<p><b>Theorem: </b>simpcode-&gt;choice-of-write-with-mask</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 simpcode-&gt;choice-of-write-with-mask
 (<a href="ACL2____IMPLIES.html">implies</a>
  (<a href="COMMON-LISP____AND.html">and</a>
   (fty::bitstruct-read-over-write-hyps x simpcode-equiv-under-mask)
   (simpcode-equiv-under-mask x acl2::y fty::mask)
   (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____LOGAND.html">logand</a> (<a href="COMMON-LISP____LOGNOT.html">lognot</a> fty::mask) 8) 0))
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE-_E3CHOICE.html">simpcode-&gt;choice</a> x)
         (<a href="AIGNET____SIMPCODE-_E3CHOICE.html">simpcode-&gt;choice</a> acl2::y))))</pre> 
<p><b>Theorem: </b>simpcode-fix-in-terms-of-simpcode</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-fix-in-terms-of-simpcode
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x)
               (change-simpcode x)))</pre> 
<p><b>Function: </b>!simpcode-&gt;neg</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     !simpcode-&gt;neg (neg x)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BITP.html">bitp</a> neg) (<a href="AIGNET____SIMPCODE-P.html">simpcode-p</a> x))))
     (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((neg (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____BFIX.html">bfix</a> neg) :exec neg))
                      (x (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x)))
                     (<a href="ACL2____PART-INSTALL.html">part-install</a> neg x :width 1 :low 0))
          :exec (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 4)
                     (<a href="COMMON-LISP____LOGIOR.html">logior</a> (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 4)
                                  (<a href="COMMON-LISP____LOGAND.html">logand</a> (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 4) x)
                                          (<a href="COMMON-LISP____THE.html">the</a> (signed-byte 2) -2)))
                             (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 1) neg)))))</pre> 
<p><b>Theorem: </b>simpcode-p-of-!simpcode-&gt;neg</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-p-of-!simpcode-&gt;neg
        (<a href="ACL2____B_A2.html">b*</a> ((new-x (<a href="AIGNET_____12SIMPCODE-_E3NEG.html">!simpcode-&gt;neg</a> neg x)))
            (<a href="AIGNET____SIMPCODE-P.html">simpcode-p</a> new-x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>!simpcode-&gt;neg-of-bfix-neg</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> !simpcode-&gt;neg-of-bfix-neg
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET_____12SIMPCODE-_E3NEG.html">!simpcode-&gt;neg</a> (<a href="ACL2____BFIX.html">bfix</a> neg) x)
               (<a href="AIGNET_____12SIMPCODE-_E3NEG.html">!simpcode-&gt;neg</a> neg x)))</pre> 
<p><b>Theorem: </b>!simpcode-&gt;neg-bit-equiv-congruence-on-neg</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> !simpcode-&gt;neg-bit-equiv-congruence-on-neg
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____BIT-EQUIV.html">bit-equiv</a> neg neg-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET_____12SIMPCODE-_E3NEG.html">!simpcode-&gt;neg</a> neg x)
                        (<a href="AIGNET_____12SIMPCODE-_E3NEG.html">!simpcode-&gt;neg</a> neg-equiv x)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>!simpcode-&gt;neg-of-simpcode-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> !simpcode-&gt;neg-of-simpcode-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET_____12SIMPCODE-_E3NEG.html">!simpcode-&gt;neg</a> neg (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x))
               (<a href="AIGNET_____12SIMPCODE-_E3NEG.html">!simpcode-&gt;neg</a> neg x)))</pre> 
<p><b>Theorem: </b>!simpcode-&gt;neg-simpcode-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> !simpcode-&gt;neg-simpcode-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (simpcode-equiv x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET_____12SIMPCODE-_E3NEG.html">!simpcode-&gt;neg</a> neg x)
                        (<a href="AIGNET_____12SIMPCODE-_E3NEG.html">!simpcode-&gt;neg</a> neg x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>!simpcode-&gt;neg-is-simpcode</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> !simpcode-&gt;neg-is-simpcode
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET_____12SIMPCODE-_E3NEG.html">!simpcode-&gt;neg</a> neg x)
               (change-simpcode x :neg neg)))</pre> 
<p><b>Theorem: </b>simpcode-&gt;neg-of-!simpcode-&gt;neg</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-&gt;neg-of-!simpcode-&gt;neg
        (<a href="ACL2____B_A2.html">b*</a> ((?new-x (<a href="AIGNET_____12SIMPCODE-_E3NEG.html">!simpcode-&gt;neg</a> neg x)))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE-_E3NEG.html">simpcode-&gt;neg</a> new-x)
                   (<a href="ACL2____BFIX.html">bfix</a> neg))))</pre> 
<p><b>Theorem: </b>!simpcode-&gt;neg-equiv-under-mask</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> !simpcode-&gt;neg-equiv-under-mask
        (<a href="ACL2____B_A2.html">b*</a> ((?new-x (<a href="AIGNET_____12SIMPCODE-_E3NEG.html">!simpcode-&gt;neg</a> neg x)))
            (simpcode-equiv-under-mask new-x x -2)))</pre> 
<p><b>Function: </b>!simpcode-&gt;xor</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 !simpcode-&gt;xor (<a href="ACL2____XOR.html">xor</a> x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BITP.html">bitp</a> xor) (<a href="AIGNET____SIMPCODE-P.html">simpcode-p</a> x))))
 (<a href="ACL2____MBE.html">mbe</a>
    :logic (<a href="ACL2____B_A2.html">b*</a> ((<a href="ACL2____XOR.html">xor</a> (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____BFIX.html">bfix</a> xor) :exec xor))
                (x (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x)))
               (<a href="ACL2____PART-INSTALL.html">part-install</a> xor x :width 1 :low 1))
    :exec (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 4)
               (<a href="COMMON-LISP____LOGIOR.html">logior</a> (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 4)
                            (<a href="COMMON-LISP____LOGAND.html">logand</a> (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 4) x)
                                    (<a href="COMMON-LISP____THE.html">the</a> (signed-byte 3) -3)))
                       (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 2)
                            (<a href="COMMON-LISP____ASH.html">ash</a> (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 1) xor) 1))))))</pre> 
<p><b>Theorem: </b>simpcode-p-of-!simpcode-&gt;xor</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-p-of-!simpcode-&gt;xor
        (<a href="ACL2____B_A2.html">b*</a> ((new-x (<a href="AIGNET_____12SIMPCODE-_E3XOR.html">!simpcode-&gt;xor</a> xor x)))
            (<a href="AIGNET____SIMPCODE-P.html">simpcode-p</a> new-x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>!simpcode-&gt;xor-of-bfix-xor</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> !simpcode-&gt;xor-of-bfix-xor
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET_____12SIMPCODE-_E3XOR.html">!simpcode-&gt;xor</a> (<a href="ACL2____BFIX.html">bfix</a> xor) x)
               (<a href="AIGNET_____12SIMPCODE-_E3XOR.html">!simpcode-&gt;xor</a> xor x)))</pre> 
<p><b>Theorem: </b>!simpcode-&gt;xor-bit-equiv-congruence-on-xor</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> !simpcode-&gt;xor-bit-equiv-congruence-on-xor
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____BIT-EQUIV.html">bit-equiv</a> xor xor-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET_____12SIMPCODE-_E3XOR.html">!simpcode-&gt;xor</a> xor x)
                        (<a href="AIGNET_____12SIMPCODE-_E3XOR.html">!simpcode-&gt;xor</a> xor-equiv x)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>!simpcode-&gt;xor-of-simpcode-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> !simpcode-&gt;xor-of-simpcode-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET_____12SIMPCODE-_E3XOR.html">!simpcode-&gt;xor</a> xor (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x))
               (<a href="AIGNET_____12SIMPCODE-_E3XOR.html">!simpcode-&gt;xor</a> xor x)))</pre> 
<p><b>Theorem: </b>!simpcode-&gt;xor-simpcode-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> !simpcode-&gt;xor-simpcode-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (simpcode-equiv x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET_____12SIMPCODE-_E3XOR.html">!simpcode-&gt;xor</a> xor x)
                        (<a href="AIGNET_____12SIMPCODE-_E3XOR.html">!simpcode-&gt;xor</a> xor x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>!simpcode-&gt;xor-is-simpcode</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> !simpcode-&gt;xor-is-simpcode
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET_____12SIMPCODE-_E3XOR.html">!simpcode-&gt;xor</a> xor x)
               (change-simpcode x :xor xor)))</pre> 
<p><b>Theorem: </b>simpcode-&gt;xor-of-!simpcode-&gt;xor</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-&gt;xor-of-!simpcode-&gt;xor
        (<a href="ACL2____B_A2.html">b*</a> ((?new-x (<a href="AIGNET_____12SIMPCODE-_E3XOR.html">!simpcode-&gt;xor</a> xor x)))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE-_E3XOR.html">simpcode-&gt;xor</a> new-x)
                   (<a href="ACL2____BFIX.html">bfix</a> xor))))</pre> 
<p><b>Theorem: </b>!simpcode-&gt;xor-equiv-under-mask</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> !simpcode-&gt;xor-equiv-under-mask
        (<a href="ACL2____B_A2.html">b*</a> ((?new-x (<a href="AIGNET_____12SIMPCODE-_E3XOR.html">!simpcode-&gt;xor</a> xor x)))
            (simpcode-equiv-under-mask new-x x -3)))</pre> 
<p><b>Function: </b>!simpcode-&gt;identity</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
  !simpcode-&gt;identity (<a href="COMMON-LISP____IDENTITY.html">identity</a> x)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BITP.html">bitp</a> identity) (<a href="AIGNET____SIMPCODE-P.html">simpcode-p</a> x))))
  (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((<a href="COMMON-LISP____IDENTITY.html">identity</a> (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____BFIX.html">bfix</a> identity)
                                  :exec identity))
                   (x (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x)))
                  (<a href="ACL2____PART-INSTALL.html">part-install</a> identity x
                                :width 1
                                :low 2))
       :exec (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 4)
                  (<a href="COMMON-LISP____LOGIOR.html">logior</a> (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 4)
                               (<a href="COMMON-LISP____LOGAND.html">logand</a> (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 4) x)
                                       (<a href="COMMON-LISP____THE.html">the</a> (signed-byte 4) -5)))
                          (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 3)
                               (<a href="COMMON-LISP____ASH.html">ash</a> (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 1) identity)
                                    2))))))</pre> 
<p><b>Theorem: </b>simpcode-p-of-!simpcode-&gt;identity</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-p-of-!simpcode-&gt;identity
        (<a href="ACL2____B_A2.html">b*</a> ((new-x (<a href="AIGNET_____12SIMPCODE-_E3IDENTITY.html">!simpcode-&gt;identity</a> identity x)))
            (<a href="AIGNET____SIMPCODE-P.html">simpcode-p</a> new-x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>!simpcode-&gt;identity-of-bfix-identity</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> !simpcode-&gt;identity-of-bfix-identity
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET_____12SIMPCODE-_E3IDENTITY.html">!simpcode-&gt;identity</a> (<a href="ACL2____BFIX.html">bfix</a> identity) x)
               (<a href="AIGNET_____12SIMPCODE-_E3IDENTITY.html">!simpcode-&gt;identity</a> identity x)))</pre> 
<p><b>Theorem: </b>!simpcode-&gt;identity-bit-equiv-congruence-on-identity</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> !simpcode-&gt;identity-bit-equiv-congruence-on-identity
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____BIT-EQUIV.html">bit-equiv</a> identity identity-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET_____12SIMPCODE-_E3IDENTITY.html">!simpcode-&gt;identity</a> identity x)
                        (<a href="AIGNET_____12SIMPCODE-_E3IDENTITY.html">!simpcode-&gt;identity</a> identity-equiv x)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>!simpcode-&gt;identity-of-simpcode-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> !simpcode-&gt;identity-of-simpcode-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET_____12SIMPCODE-_E3IDENTITY.html">!simpcode-&gt;identity</a> identity (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x))
               (<a href="AIGNET_____12SIMPCODE-_E3IDENTITY.html">!simpcode-&gt;identity</a> identity x)))</pre> 
<p><b>Theorem: </b>!simpcode-&gt;identity-simpcode-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> !simpcode-&gt;identity-simpcode-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (simpcode-equiv x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET_____12SIMPCODE-_E3IDENTITY.html">!simpcode-&gt;identity</a> identity x)
                        (<a href="AIGNET_____12SIMPCODE-_E3IDENTITY.html">!simpcode-&gt;identity</a> identity x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>!simpcode-&gt;identity-is-simpcode</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> !simpcode-&gt;identity-is-simpcode
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET_____12SIMPCODE-_E3IDENTITY.html">!simpcode-&gt;identity</a> identity x)
               (change-simpcode x :identity identity)))</pre> 
<p><b>Theorem: </b>simpcode-&gt;identity-of-!simpcode-&gt;identity</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-&gt;identity-of-!simpcode-&gt;identity
        (<a href="ACL2____B_A2.html">b*</a> ((?new-x (<a href="AIGNET_____12SIMPCODE-_E3IDENTITY.html">!simpcode-&gt;identity</a> identity x)))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE-_E3IDENTITY.html">simpcode-&gt;identity</a> new-x)
                   (<a href="ACL2____BFIX.html">bfix</a> identity))))</pre> 
<p><b>Theorem: </b>!simpcode-&gt;identity-equiv-under-mask</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> !simpcode-&gt;identity-equiv-under-mask
        (<a href="ACL2____B_A2.html">b*</a> ((?new-x (<a href="AIGNET_____12SIMPCODE-_E3IDENTITY.html">!simpcode-&gt;identity</a> identity x)))
            (simpcode-equiv-under-mask new-x x -5)))</pre> 
<p><b>Function: </b>!simpcode-&gt;choice</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
   !simpcode-&gt;choice (choice x)
   (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BITP.html">bitp</a> choice) (<a href="AIGNET____SIMPCODE-P.html">simpcode-p</a> x))))
   (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((choice (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____BFIX.html">bfix</a> choice) :exec choice))
                    (x (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x)))
                   (<a href="ACL2____PART-INSTALL.html">part-install</a> choice x :width 1 :low 3))
        :exec (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 4)
                   (<a href="COMMON-LISP____LOGIOR.html">logior</a> (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 4)
                                (<a href="COMMON-LISP____LOGAND.html">logand</a> (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 4) x)
                                        (<a href="COMMON-LISP____THE.html">the</a> (signed-byte 5) -9)))
                           (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 4)
                                (<a href="COMMON-LISP____ASH.html">ash</a> (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 1) choice)
                                     3))))))</pre> 
<p><b>Theorem: </b>simpcode-p-of-!simpcode-&gt;choice</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-p-of-!simpcode-&gt;choice
        (<a href="ACL2____B_A2.html">b*</a> ((new-x (<a href="AIGNET_____12SIMPCODE-_E3CHOICE.html">!simpcode-&gt;choice</a> choice x)))
            (<a href="AIGNET____SIMPCODE-P.html">simpcode-p</a> new-x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>!simpcode-&gt;choice-of-bfix-choice</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> !simpcode-&gt;choice-of-bfix-choice
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET_____12SIMPCODE-_E3CHOICE.html">!simpcode-&gt;choice</a> (<a href="ACL2____BFIX.html">bfix</a> choice) x)
               (<a href="AIGNET_____12SIMPCODE-_E3CHOICE.html">!simpcode-&gt;choice</a> choice x)))</pre> 
<p><b>Theorem: </b>!simpcode-&gt;choice-bit-equiv-congruence-on-choice</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> !simpcode-&gt;choice-bit-equiv-congruence-on-choice
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____BIT-EQUIV.html">bit-equiv</a> choice choice-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET_____12SIMPCODE-_E3CHOICE.html">!simpcode-&gt;choice</a> choice x)
                        (<a href="AIGNET_____12SIMPCODE-_E3CHOICE.html">!simpcode-&gt;choice</a> choice-equiv x)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>!simpcode-&gt;choice-of-simpcode-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> !simpcode-&gt;choice-of-simpcode-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET_____12SIMPCODE-_E3CHOICE.html">!simpcode-&gt;choice</a> choice (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x))
               (<a href="AIGNET_____12SIMPCODE-_E3CHOICE.html">!simpcode-&gt;choice</a> choice x)))</pre> 
<p><b>Theorem: </b>!simpcode-&gt;choice-simpcode-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> !simpcode-&gt;choice-simpcode-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (simpcode-equiv x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET_____12SIMPCODE-_E3CHOICE.html">!simpcode-&gt;choice</a> choice x)
                        (<a href="AIGNET_____12SIMPCODE-_E3CHOICE.html">!simpcode-&gt;choice</a> choice x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>!simpcode-&gt;choice-is-simpcode</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> !simpcode-&gt;choice-is-simpcode
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET_____12SIMPCODE-_E3CHOICE.html">!simpcode-&gt;choice</a> choice x)
               (change-simpcode x :choice choice)))</pre> 
<p><b>Theorem: </b>simpcode-&gt;choice-of-!simpcode-&gt;choice</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-&gt;choice-of-!simpcode-&gt;choice
        (<a href="ACL2____B_A2.html">b*</a> ((?new-x (<a href="AIGNET_____12SIMPCODE-_E3CHOICE.html">!simpcode-&gt;choice</a> choice x)))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="AIGNET____SIMPCODE-_E3CHOICE.html">simpcode-&gt;choice</a> new-x)
                   (<a href="ACL2____BFIX.html">bfix</a> choice))))</pre> 
<p><b>Theorem: </b>!simpcode-&gt;choice-equiv-under-mask</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> !simpcode-&gt;choice-equiv-under-mask
        (<a href="ACL2____B_A2.html">b*</a> ((?new-x (<a href="AIGNET_____12SIMPCODE-_E3CHOICE.html">!simpcode-&gt;choice</a> choice x)))
            (simpcode-equiv-under-mask new-x x 7)))</pre> 
<p><b>Function: </b>simpcode-debug</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 simpcode-debug (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="AIGNET____SIMPCODE-P.html">simpcode-p</a> x)))
 (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'simpcode-debug))
      (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
      (<a href="ACL2____B_A2.html">b*</a> (((<a href="AIGNET____SIMPCODE.html">simpcode</a> x)))
          (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'neg x.neg)
                (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'xor x.xor)
                      (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'identity x.identity)
                            (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'choice x.choice) nil)))))))</pre> 
<p><b>Theorem: </b>simpcode-debug-of-simpcode-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-debug-of-simpcode-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (simpcode-debug (<a href="AIGNET____SIMPCODE-FIX.html">simpcode-fix</a> x))
               (simpcode-debug x)))</pre> 
<p><b>Theorem: </b>simpcode-debug-simpcode-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> simpcode-debug-simpcode-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (simpcode-equiv x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (simpcode-debug x)
                        (simpcode-debug x-equiv)))
        :rule-classes :congruence)</pre> 

</body>
</html>
