<html>
<head>
<meta charset="UTF-8">
<title>Static-semantics</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=SYNTHETO____STATIC-SEMANTICS">Click for Static-semantics in the Full Manual</a></h3>

<p>Static semantics of Syntheto.</p><p>We formalize the constraints that Syntheto code must satisfy 
     in order to be well-formed and have a formal semantics.</p><p>The constraints include type requirements, 
     according to Syntheto's strong typing. 
     Since the Syntheto type system includes 
     predicate subtypes and product/sum type invariants, 
     the static semantics is undecidable, 
     because it may involve general theorem proving. 
     We handle this situation by splitting the static semantics 
     into a decidable and an undecidable part, 
     similar to systems like PVS and Specware. 
     The decidable part handles most of the constraints, 
     generating proof obligations for the undecidable parts. 
     Proof obligations are Syntheto boolean expressions 
     universally quantified over its explicitly typed free variables.</p><p>The constraints of the static semantics are checked 
     in the context of variables, types, and other entities 
     that are in scope and can be referenced. 
     We represent the context as an explicit data structure, 
     which is passed to the ACL2 functions that check the constraints 
     and which is updated by some of these functions 
     as more entities come into scope. 
     In addition to the entities mentioned above, 
     since we need to generate proof obligations, 
     the context also includes conditions (boolean expressions) 
     collected as expressions are traversed.</p>
</body>
</html>
