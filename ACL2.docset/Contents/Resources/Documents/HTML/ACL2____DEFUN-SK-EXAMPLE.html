<html>
<head>
<meta charset="UTF-8">
<title>Defun-sk-example</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____DEFUN-SK-EXAMPLE">Click for Defun-sk-example in the Full Manual</a></h3>

<p>A simple example using <span class="tt"><a href="ACL2____DEFUN-SK.html">defun-sk</a></span></p><p>For a more through, systematic beginner's introduction to 
 quantification in ACL2, see <a href="ACL2____QUANTIFIER-TUTORIAL.html">quantifier-tutorial</a>.</p> 
 
 <p>The following example illustrates how to do proofs about functions defined 
 with <span class="tt"><a href="ACL2____DEFUN-SK.html">defun-sk</a></span>.  The events below can be put into a certifiable book 
 (see <a href="ACL2____BOOKS.html">books</a>).  The example is contrived and rather silly, in that it 
 shows how to prove that a quantified notion implies itself, where the 
 antecedent and conclusion are defined with different <span class="tt"><a href="ACL2____DEFUN-SK.html">defun-sk</a></span> events. 
 But it illustrates the formulas that are generated by <span class="tt"><a href="ACL2____DEFUN-SK.html">defun-sk</a></span>, and 
 how to use them.  Thanks to Julien Schmaltz for presenting this example as a 
 challenge.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____IN-PACKAGE.html">in-package</a> "ACL2")

(<a href="ACL2____ENCAPSULATE.html">encapsulate</a>
 (((p *) =&gt; *)
  ((expr *) =&gt; *))

 (<a href="ACL2____LOCAL.html">local</a> (<a href="COMMON-LISP____DEFUN.html">defun</a> p (x) x))
 (<a href="ACL2____LOCAL.html">local</a> (<a href="COMMON-LISP____DEFUN.html">defun</a> expr (x) x)))

(<a href="ACL2____DEFUN-SK.html">defun-sk</a> forall-expr1 (x)
  (<a href="ACL2____FORALL.html">forall</a> (y) (<a href="ACL2____IMPLIES.html">implies</a> (p x) (expr y))))

(<a href="ACL2____DEFUN-SK.html">defun-sk</a> forall-expr2 (x)
  (<a href="ACL2____FORALL.html">forall</a> (y) (<a href="ACL2____IMPLIES.html">implies</a> (p x) (expr y)))))

; We want to prove the theorem my-theorem below.  What axioms are there that
; can help us?  If you submit the command

; :pcb! forall-expr1

; then you will see the following two key events.  (They are completely
; analogous of course for FORALL-EXPR2.)

;   (<a href="COMMON-LISP____DEFUN.html">DEFUN</a> FORALL-EXPR1 (X)
;     (<a href="COMMON-LISP____LET.html">LET</a> ((Y (FORALL-EXPR1-WITNESS X)))
;          (<a href="ACL2____IMPLIES.html">IMPLIES</a> (P X) (EXPR Y))))
;
;   (<a href="ACL2____DEFTHM.html">DEFTHM</a> FORALL-EXPR1-NECC
;     (<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____NOT.html">NOT</a> (<a href="ACL2____IMPLIES.html">IMPLIES</a> (P X) (EXPR Y)))
;              (<a href="COMMON-LISP____NOT.html">NOT</a> (FORALL-EXPR1 X)))
;     :HINTS
;     (("Goal" :USE FORALL-EXPR1-WITNESS)))

; We see that the latter has value when FORALL-EXPR1 occurs negated in a
; conclusion, or (therefore) positively in a hypothesis.  A good rule to
; remember is that the former has value in the opposite circumstance: negated
; in a hypothesis or positively in a conclusion.

; In our theorem, FORALL-EXPR2 occurs positively in the conclusion, so its
; definition should be of use.  We therefore leave its definition enabled,
; and disable the definition of FORALL-EXPR1.

;   (<a href="ACL2____THM.html">thm</a>
;     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (p x) (forall-expr1 x))
;              (forall-expr2 x))
;     :hints (("Goal" :in-theory (<a href="ACL2____DISABLE.html">disable</a> forall-expr1))))
;
;   ; which yields this unproved subgoal:
;
;   (<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____AND.html">AND</a> (P X) (FORALL-EXPR1 X))
;            (EXPR (FORALL-EXPR2-WITNESS X)))

; Now we can see how to use FORALL-EXPR1-NECC to complete the proof, by
; binding y to (FORALL-EXPR2-WITNESS X).

; We use defthmd below so that the following doesn't interfere with the
; second proof, in my-theorem-again that follows.
(<a href="ACL2____DEFTHMD.html">defthmd</a> my-theorem
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (p x) (forall-expr1 x))
           (forall-expr2 x))
  :hints (("Goal"
           :use ((:instance forall-expr1-necc
                            (x x)
                            (y (forall-expr2-witness x)))))))

; The following illustrates a more advanced technique to consider in such
; cases.  If we disable forall-expr1, then we can similarly succeed by having
; FORALL-EXPR1-NECC applied as a :rewrite rule, with an appropriate hint in how
; to instantiate its free variable.  See :doc hints.

(<a href="ACL2____DEFTHM.html">defthm</a> my-theorem-again
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (P x) (forall-expr1 x))
           (forall-expr2 x))
  :hints (("Goal"
           :in-theory (<a href="ACL2____DISABLE.html">disable</a> forall-expr1)
           :restrict ((forall-expr1-necc
                       ((y (forall-expr2-witness x))))))))</pre>
</body>
</html>
