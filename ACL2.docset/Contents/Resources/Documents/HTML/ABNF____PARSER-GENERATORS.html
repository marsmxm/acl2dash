<html>
<head>
<meta charset="UTF-8">
<title>Parser-generators</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ABNF____PARSER-GENERATORS">Click for Parser-generators in the Full Manual</a></h3>

<p>Tools to generate parsing functions.</p><p>We provide tools to generate parsing functions from ABNF grammar rules. 
     This is not a full parser generator, but it is a start towards one.</p><p>The ABNF grammar of interest must be in an ACL2 named constant called 
     <span class="v">abnf::*def-parse-grammar*</span> 
     (note that it is in the <span class="v">"ABNF"</span> package). 
     This constant is implicitly referenced by the parsing generation macros. 
     If the grammar is in a differently named constant, 
     it is easy to define the required constant to be equal to that one. 
     This restriction may be lifted in the future, 
     to allow any user-specified named constant.</p><p>The macro <span class="tt"><a href="ABNF____DEF-PARSE-RULENAME.html">def-parse-rulename</a></span> is used to generate 
     a parsing function for the specified rule name, 
     which is passed as an ACL2 string (not as a <span class="tt"><a href="ABNF____RULENAME.html">rulename</a></span>). 
     If the rule name is <span class="v">&lt;R&gt;</span>, 
     the parsing function is called <span class="v">&lt;parse&gt;-&lt;R&gt;</span>, 
     where <span class="v">&lt;parse&gt;</span> is a symbol that must be 
     the value of a named constant called <span class="v">abnf::*def-parse-fn-name*</span>: 
     for example, this could be 
     the symbol <span class="v">parse</span> for a parser, or <span class="v">lex</span> for a lexer. 
     The <span class="tt"><a href="ABNF____DEF-PARSE-RULENAME.html">def-parse-rulename</a></span> macro 
     looks up the grammar rule(s) for <span class="v">&lt;R&gt;</span> in the grammar 
     collecting the alternation that defines the rule name 
     (including any incremental rule). 
     The generated function attempts to parse each alternative in order, 
     backtracking if the parsing of an alternative fails, 
     stopping when either the parsing of an alternative succeeds 
     or there are no more alternatives (in which case parsing fails). 
     The macro <span class="tt"><a href="ABNF____DEF-PARSE-RULENAME.html">def-parse-rulename</a></span> also takes a keyword argument 
     to optionally specify a reordering of the alternatives: 
     the value of this argument must be a permutation of <span class="v">(1 2 ... n)</span> 
     where <span class="v">n</span> is the number of alternatives that define <span class="v">&lt;R&gt;</span>. 
     The reordering is useful to enforce extra-grammatical requirements 
     that provide disambiguation (e.g. parse the longest parsable text), 
     or for greater efficiency (e.g. parse the more common alternative first).</p><p>The generated <span class="v">&lt;parse&gt;-&lt;R&gt;</span> function attempts to parse each alternative, 
     which is a concatenation of repetitions, 
     by attempting to parse the repetitions in order. 
     Repetitions are often singletons, i.e. they are effectively elements: 
     in this case, <span class="v">&lt;parse&gt;-&lt;R&gt;</span> directly attempts to parse the element. 
     An element may be a rule name <span class="v">&lt;S&gt;</span>, 
     in which case the corresponding <span class="v">&lt;parse&gt;-&lt;S&gt;</span> function is called, 
     whose name is known because it is derived from <span class="v">&lt;S&gt;</span> 
     similarly to how the name of <span class="v">&lt;parse&gt;-&lt;R&gt;</span> is derived from <span class="v">&lt;R&gt;</span>. 
     For elements that are groups or options, 
     or for repetitions that are not singletons, 
     the name of the corresponding parsing function 
     must be specified by the user. 
     This is done via three ACL2 named constants called 
     <span class="v">abnf::*def-parse-group-fns*</span>, 
     <span class="v">abnf::*def-parse-option-fns*</span>, and 
     <span class="v">abnf::*def-parse-repetition-fns*</span> 
     (note that they are in the <span class="v">"ABNF"</span> package). 
     These are alists from groups or options or repetitions, 
     represented as ABNF abstract syntax 
     (i.e. values of type <span class="tt"><a href="ABNF____ALTERNATION.html">alternation</a></span> for groups and options, 
     and values of type <span class="tt"><a href="ABNF____REPETITION.html">repetition</a></span> for repetitions) 
     to symbols that are the names of the corresponding parsing functions. 
     These three constants are implicitly referenced 
     by the parsing generation macros. 
     Future extensions of these parser generation tools 
     may allow user-defined names for these constants. 
     Future extensions of these parser generation tools 
     may also automate the generation of these function names.</p><p>The <span class="tt"><a href="ABNF____DEF-PARSE-_A2-RULENAME.html">def-parse-*-rulename</a></span> macro generates a parsing function for 
     a repetition of zero or more instances of the specified rule name. 
     It uses <span class="v">abnf::*def-parse-repetition-fns*</span> to retrieve 
     the name of the parsing function to generate. 
     If the rule name is <span class="v">&lt;R&gt;</span>, 
     the generated function calls <span class="v">&lt;parse&gt;-&lt;R&gt;</span> 
     for as long as that succeeds.</p><p>The <span class="tt"><a href="ABNF____DEF-PARSE-GROUP.html">def-parse-group</a></span> macro is similar to <span class="tt"><a href="ABNF____DEF-PARSE-RULENAME.html">def-parse-rulename</a></span>, 
     but it retrieves the name of the function to generate 
     from <span class="v">abnf::*def-parse-group-fns*</span>; 
     the macro takes the group as an argument, 
     which is used as a key in the alist. 
     It attempts to parse each alternative, 
     in the order in which the alternatives appear in the group, 
     unless a reordering keyword argument is passed, 
     which works in the same way as in <span class="tt"><a href="ABNF____DEF-PARSE-RULENAME.html">def-parse-rulename</a></span>.</p><p>The <span class="tt"><a href="ABNF____DEF-PARSE-_A2-GROUP.html">def-parse-*-group</a></span> macro 
     is similar to <span class="tt"><a href="ABNF____DEF-PARSE-_A2-RULENAME.html">def-parse-*-rulename</a></span>, 
     but it repeatedly uses the parsing function for the group. 
     The name of the generated function is retrieved from 
     <span class="v">abnf::*def-parse-repetition-fns*</span>.</p><p>The <span class="tt"><a href="ABNF____DEF-PARSE-OPTION.html">def-parse-option</a></span> macro is similar to <span class="tt"><a href="ABNF____DEF-PARSE-GROUP.html">def-parse-group</a></span>, 
     but its name is retrieved from <span class="v">abnf::*def-parse-option-fns*</span>. 
     Furthermore, if no alternative can be parsed, 
     parsing succeeds because an instance of an option may be absent in fact.</p><p>The alists of function names are used in two circumstances: 
     when generating a parsing function for a group or option or repetition; 
     and when generating a parsing function 
     that must parse an instance of that group or option or repetition. 
     These alists should be normally defined prior to 
     the calls of the macros that generate the parsing functions.</p><p>Singleton repetitions do not need to be in the alist for repetitions. 
     Singleton repetitions are handled as their underlying elements 
     in the generated parsing functions.</p><p>The parsing functions must be generated in the usual ACL2 order, 
     i.e. if a parsing function must call another one, 
     the latter must be generated before generating the former. 
     Thus, these macros currently cannot generate 
     mutually recursive parsing functions. 
     This is clearly a severe limitation for typical parsing, 
     but it is still useful for generating lexers, 
     which often have less mutual recursion. 
     Single recursion is supported, in the form or repetitions. 
     We plan to extend these parser generation tools 
     to support mutual recursion.</p><p>Not all the parsing functions need to be generated via the macros. 
     Some may be handwritten, e.g. if they are mutually recursive. 
     So long as the names of these handwritten functions 
     have the form <span class="v">&lt;parse&gt;-&lt;R&gt;</span> for a rule name <span class="v">&lt;R&gt;</span> 
     or are recorded in the alists for groups, options, and repetitions, 
     generated parsing functions can seamlessly call handwritten ones.</p><p>Numeric and character terminal notations 
     are handled automatically by these parser generation tools. 
     That is, code to parse instances of those is automatically generated; 
     the user does not have to generate any parsing functions for those, 
     and does not need to specify any parsing function names for those 
     (no parsing functions are generated for those; 
     the parsing code for those is generated within larger parsing functions).</p><p>All of the three named constants 
     <span class="v">abnf::*def-parse-group-fns*</span>, 
     <span class="v">abnf::*def-parse-option-fns*</span>, and 
     <span class="v">abnf::*def-parse-repetition-fns*</span> 
     must be defined even if any of them is empty, 
     i.e. if the user does not want or need to generate or use 
     parsing functions for groups, options, or repetitions. 
     The named constant <span class="v">abnf::*def-parse-fn-name*</span> must be also defined; 
     there is no default. 
     Finally, the named constant <span class="v">abnf::*def-parse-grammar*</span> 
     must be also defined, as there is no default or implicit grammar.</p><p>The ACL2 functions generated by these parser generation tools 
     are defined via <span class="tt"><a href="ACL2____DEFINE.html">define</a></span> and include <span class="v">:hooks (:fix)</span>. 
     The latter causes the generation of fixing theorems, 
     which say that the functions fix their arguments to their types. 
     These theorems are expected to be proved automatically 
     so long as all the parsing functions called by the generated functions 
     include those fixing theorems. 
     Thus, if some parsing functions are hand-written, 
     and called by generated parsing functions, 
     the hand-written functions must include <span class="v">:hooks (:fix)</span> 
     in order for all the fixing theorems to be proved.</p><p>All in all, these parser generation tools are quite preliminary, 
     but they have been already useful to generate most of 
     a lexer for a real (i.e. not toy) programming language. 
     We plan to extend these tools more and more towards 
     a customizable parser generator.</p>
</body>
</html>
