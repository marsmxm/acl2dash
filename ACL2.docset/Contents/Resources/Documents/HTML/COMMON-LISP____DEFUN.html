<html>
<head>
<meta charset="UTF-8">
<title>Defun</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=COMMON-LISP____DEFUN">Click for Defun in the Full Manual</a></h3>

<p>Define a function symbol</p><pre class="code">Examples:
(<a href="COMMON-LISP____DEFUN.html">defun</a> app (x y)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x)
      (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> x) (app (<a href="COMMON-LISP____CDR.html">cdr</a> x) y))
      y))

(<a href="COMMON-LISP____DEFUN.html">defun</a> fact (n)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> n)
                              (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> n 0))))
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____ZP.html">zp</a> n)
      1
      (<a href="COMMON-LISP_____A2.html">*</a> n (fact (<a href="COMMON-LISP____1-.html">1-</a> n)))))

General Form:
(<a href="COMMON-LISP____DEFUN.html">defun</a> fn (var1 ... varn) doc-string dcl ... dcl body),</pre> 
 
 <p>where <span class="v">fn</span> is the symbol you wish to define and is a new symbolic name 
 (see <a href="ACL2____NAME.html">name</a>), <span class="v">(var1 ... varn)</span> is its list of formal parameters (see 
 <a href="ACL2____NAME.html">name</a>), and <span class="v">body</span> is its body.  The definitional axiom is logically 
 admissible provided certain restrictions are met.  These are sketched 
 below.</p> 
 
 <p>Note that ACL2 does not support the use of <span class="v">lambda-list</span> keywords (such 
 as <span class="v">&amp;optional</span>) in the formals list of functions.  We do support some such 
 keywords in macros and often you can achieve the desired syntax by defining a 
 macro in addition to the general version of your function.  See <a href="COMMON-LISP____DEFMACRO.html">defmacro</a>.  <span class="v">Doc-string</span>, if non-<span class="v">nil</span>, is an optional string that can 
 provide documentation but is essentially ignored by ACL2.</p> 
 
 <p>The <i>declarations</i> (see <a href="COMMON-LISP____DECLARE.html">declare</a>), <span class="v">dcl</span>, are also optional. 
 If more than one <span class="v">dcl</span> form appears, they are effectively grouped together 
 as one.  Perhaps the most commonly used ACL2 specific declaration is of the 
 form <span class="v">(<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard g :measure m))</span>.  This declaration in the 
 <span class="v">defun</span> of some function <span class="v">fn</span> has the effect of making the ``<a href="ACL2____GUARD.html">guard</a>'' for <span class="v">fn</span> be the term <span class="v">g</span> and the ``measure'' be the term 
 <span class="v">m</span>.  The notion of ``measure'' is crucial to ACL2's definitional 
 principle.  The notion of ``guard'' is not, and is discussed elsewhere; see 
 <a href="ACL2____VERIFY-GUARDS.html">verify-guards</a> and see <a href="ACL2____SET-VERIFY-GUARDS-EAGERNESS.html">set-verify-guards-eagerness</a>.  Note that a 
 <span class="v">:measure</span> is not allowed for a non-recursive definition unless it is part 
 of a <span class="tt"><a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a></span> (exception: a measure of <span class="v">nil</span> is treated as 
 though the <span class="v">measure</span> was omitted); moreover, if a <span class="v">:measure</span> is 
 supplied, then it must be a legal term.  Apart from these restrictions, the 
 <span class="v">:measure</span> is ignored in <span class="v">:</span><span class="tt"><a href="ACL2____PROGRAM.html">program</a></span> mode; see <a href="ACL2____DEFUN-MODE.html">defun-mode</a>.</p> 
 
 <p>We now briefly discuss the ACL2 definitional principle, using the following 
 definition form which is offered as a more or less generic example.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> fn (x y)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____G.html">g</a> x y)
                  :measure (m x y)))
  (<a href="COMMON-LISP____IF.html">if</a> (test x y)
      (stop x y)
    (step (fn (d x) y))))</pre> 
 
 <p>Note that in our generic example, <span class="v">fn</span> has just two arguments, <span class="v">x</span> 
 and <span class="v">y</span>, the <a href="ACL2____GUARD.html">guard</a> and measure terms involve both of them, and the 
 body is a simple case split on <span class="v">(test x y)</span> leading to a ``non-recursive'' 
 branch, <span class="v">(stop x y)</span>, and a ``recursive'' branch.  In the recursive branch, 
 <span class="v">fn</span> is called after ``decrementing'' <span class="v">x</span> to <span class="v">(d x)</span> and some step 
 function is applied to the result.  Of course, this generic example is quite 
 specific in form but is intended to illustrate the more general case.</p> 
 
 <p>Provided this definition is admissible under the logic, as outlined below, 
 it adds the following axiom to the logic.</p> 
 
 <pre class="code">Defining Axiom:
(fn x y)
  =
(<a href="COMMON-LISP____IF.html">if</a> (test x y)
    (stop x y)
  (step (fn (d x) y)))</pre> 
 
 <p>Note that the <a href="ACL2____GUARD.html">guard</a> of <span class="v">fn</span> has no bearing on this logical 
 axiom.</p> 
 
 <p>This defining axiom is actually implemented in the ACL2 system by a 
 <span class="v">:</span><span class="tt"><a href="ACL2____DEFINITION.html">definition</a></span> rule, namely</p> 
 
 <pre class="code">(<a href="COMMON-LISP____EQUAL.html">equal</a> (fn x y)
       (<a href="COMMON-LISP____IF.html">if</a> (test a b)
           (stop a b)
         (step (fn (d a) b)))).</pre> 
 
 <p>See <a href="ACL2____DEFINITION.html">definition</a> for a discussion of how definition rules are applied. 
 Roughly speaking, the rule causes certain instances of <span class="v">(fn x y)</span> to be 
 replaced by the corresponding instances of the body above.  This is called 
 ``opening up'' <span class="v">(fn x y)</span>.  The instances of <span class="v">(fn x y)</span> opened are 
 chosen primarily by heuristics which determine that the recursive calls of 
 <span class="v">fn</span> in the opened body (after simplification) are more desirable than the 
 unopened call of <span class="v">fn</span>.</p> 
 
 <p>This discussion has assumed that the definition of <span class="v">fn</span> was admissible. 
 Exactly what does that mean?  First, <span class="v">fn</span> must be a previously 
 unaxiomatized function symbol (however, see <a href="ACL2____LD-REDEFINITION-ACTION.html">ld-redefinition-action</a>). 
 Second, the formal parameters must be distinct variable names.  Third, the 
 <a href="ACL2____GUARD.html">guard</a>, measure, and body should all be terms and should mention no free 
 variables except the formal parameters.  Thus, for example, body may not 
 contain references to ``global'' or ``special'' variables; ACL2 constants or 
 additional formals should be used instead.</p> 
 
 <p>The final conditions on admissibility concern the termination of the 
 recursion.  Roughly put, all applications of <span class="v">fn</span> must terminate.  In 
 particular, there must exist a binary relation, <span class="v">rel</span>, and some unary 
 predicate <span class="v">mp</span> such that <span class="v">rel</span> is well-founded on objects satisfying 
 <span class="v">mp</span>, the measure term <span class="v">m</span> must always produce something satisfying 
 <span class="v">mp</span>, and the measure term must decrease according to <span class="v">rel</span> in each 
 recursive call, under the hypothesis that all the tests ruling the call are 
 satisfied (see <a href="ACL2____RULERS.html">rulers</a>).  By the meaning of well-foundedness, we know 
 there are no infinitely descending chains of successively <span class="v">rel</span>-smaller 
 <span class="v">mp</span>-objects.  Thus, the recursion must terminate.</p> 
 
 <p>The default well-founded relation is <span class="tt"><a href="ACL2____O_C3.html">o&lt;</a></span>, an ``ordinal less-than'' 
 relation (discussed further below) that reduces to ordinary <span class="v">&lt;</span> on the 
 natural numbers.  The default measure term is <span class="v">(<a href="ACL2____ACL2-COUNT.html">acl2-count</a> var)</span>, where 
 <span class="v">var</span> is a formal parameter that is chosen heuristically: roughly speaking, 
 it is the first formal that is tested along every branch and changed in each 
 recursive call.</p> 
 
 <p>The only primitive well-founded relation in ACL2 is <span class="tt"><a href="ACL2____O_C3.html">o&lt;</a></span>, which is 
 known to be well-founded on the <span class="tt"><a href="ACL2____O-P.html">o-p</a></span>s.  For the proof of 
 well-foundedness, see <a href="ACL2____PROOF-OF-WELL-FOUNDEDNESS.html">proof-of-well-foundedness</a>.  However it is 
 possible to add new well-founded relations.  For details, see <a href="ACL2____WELL-FOUNDED-RELATION.html">well-founded-relation</a>.  We discuss later how to specify which well-founded 
 relation is selected by <span class="v">defun</span> and in the present discussion we assume, 
 without loss of generality, that it is <span class="tt"><a href="ACL2____O_C3.html">o&lt;</a></span> on the <span class="tt"><a href="ACL2____O-P.html">o-p</a></span>s.</p> 
 
 <p>For example, for our generic definition of <span class="v">fn</span> above, with measure term 
 <span class="v">(m x y)</span>, two theorems must be proved.  The first establishes that <span class="v">m</span> 
 produces an ordinal:</p> 
 
 <pre class="code">(<a href="ACL2____O-P.html">o-p</a> (m x y)).</pre> 
 
 <p>The second shows that <span class="v">m</span> decreases in the (only) recursive call of 
 <span class="v">fn</span>:</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (test x y))
         (<a href="ACL2____O_C3.html">o&lt;</a> (m (d x) y) (m x y))).</pre> 
 
 <p>Observe that in the latter formula we must show that the ``<span class="v">m</span>-size'' of 
 <span class="v">(d x)</span> and <span class="v">y</span> is ``smaller than'' the <span class="v">m</span>-size of <span class="v">x</span> and 
 <span class="v">y</span>, provided the test, <span class="v">(test x y)</span>, in the body fails, thus leading to 
 the recursive call <span class="v">(fn (d x) y)</span>.</p> 
 
 <p>See <a href="ACL2____O_C3.html">o&lt;</a> for a discussion of this notion of ``smaller than.''  It 
 should be noted that the most commonly used ordinals are the natural numbers 
 and that on natural numbers, <span class="tt"><a href="ACL2____O_C3.html">o&lt;</a></span> is just the familiar ``less than'' 
 relation (<span class="tt"><a href="COMMON-LISP_____C3.html">&lt;</a></span>).  Thus, it is very common to use a measure <span class="v">m</span> that 
 returns a nonnegative integer, for then <span class="v">(<a href="ACL2____O-P.html">o-p</a> (m x y))</span> becomes a simple 
 conjecture about the type of <span class="v">m</span> and the second formula above becomes a 
 conjecture about the less-than relationship of nonnegative integer 
 arithmetic.</p> 
 
 <p>The most commonly used measure function is <span class="tt"><a href="ACL2____ACL2-COUNT.html">ACL2-count</a></span>, which 
 computes a nonnegative integer size for all ACL2 objects.  See <a href="ACL2____ACL2-COUNT.html">ACL2-count</a>.</p> 
 
 <p>Probably the most common recursive scheme in Lisp <a href="ACL2____PROGRAMMING.html">programming</a> is 
 when some formal is supposed to be a list and in the recursive call it is 
 replaced by its <span class="tt"><a href="COMMON-LISP____CDR.html">cdr</a></span>.  For example, <span class="v">(test x y)</span> might be simply 
 <span class="v">(<a href="COMMON-LISP____ATOM.html">atom</a> x)</span> and <span class="v">(d x)</span> might be <span class="v">(<a href="COMMON-LISP____CDR.html">cdr</a> x)</span>.  In that case, 
 <span class="v">(<a href="ACL2____ACL2-COUNT.html">acl2-count</a> x)</span> is a suitable measure because the <span class="tt"><a href="ACL2____ACL2-COUNT.html">ACL2-count</a></span> of a 
 <span class="tt"><a href="COMMON-LISP____CONS.html">cons</a></span> is strictly larger than the <span class="tt"><a href="ACL2____ACL2-COUNT.html">ACL2-count</a></span>s of its <span class="tt"><a href="COMMON-LISP____CAR.html">car</a></span> and <span class="tt"><a href="COMMON-LISP____CDR.html">cdr</a></span>.  Thus, ``recursion by <span class="tt"><a href="COMMON-LISP____CAR.html">car</a></span>'' and ``recursion by 
 <span class="tt"><a href="COMMON-LISP____CDR.html">cdr</a></span>'' are trivially admitted if <span class="tt"><a href="ACL2____ACL2-COUNT.html">ACL2-count</a></span> is used as the 
 measure and the definition protects every recursive call by a test insuring 
 that the decremented argument is a <span class="tt"><a href="COMMON-LISP____CONSP.html">consp</a></span>.  Similarly, ``recursion by 
 <span class="tt"><a href="COMMON-LISP____1-.html">1-</a></span>'' in which a positive integer formal is decremented by one in 
 recursion, is also trivially admissible.  See <a href="ACL2____BUILT-IN-CLAUSE.html">built-in-clause</a> to extend 
 the class of trivially admissible recursive schemes.</p> 
 
 <p>We now turn to the question of which well-founded relation <span class="v">defun</span> uses. 
 It should first be observed that <span class="v">defun</span> must actually select both a 
 relation (e.g., <span class="tt"><a href="ACL2____O_C3.html">o&lt;</a></span>) and a domain predicate (e.g., <span class="tt"><a href="ACL2____O-P.html">o-p</a></span>) on 
 which that relation is known to be well-founded.  But, as noted elsewhere (see 
 <a href="ACL2____WELL-FOUNDED-RELATION-RULE.html">well-founded-relation-rule</a>), every known well-founded relation has a 
 unique domain predicate associated with it and so it suffices to identify 
 simply the relation here.</p> 
 
 <p>The <span class="tt"><a href="ACL2____XARGS.html">xargs</a></span> field of a <span class="tt"><a href="COMMON-LISP____DECLARE.html">declare</a></span> permits the explicit 
 specification of any known well-founded relation with the keyword 
 <span class="v">:well-founded-relation</span>.  An example is given below.  If the <span class="tt"><a href="ACL2____XARGS.html">xargs</a></span> 
 for a <span class="v">defun</span> specifies a well-founded relation, that relation and its 
 associated domain predicate are used in generating the termination conditions 
 for the definition.</p> 
 
 <p>If no <span class="v">:well-founded-relation</span> is specified, <span class="v">defun</span> uses the 
 <span class="v">:well-founded-relation</span> specified in the <span class="tt"><a href="ACL2____ACL2-DEFAULTS-TABLE.html">ACL2-defaults-table</a></span>.  See 
 <a href="ACL2____SET-WELL-FOUNDED-RELATION.html">set-well-founded-relation</a> to see how to set the default well-founded 
 relation (and, implicitly, its domain predicate).  The initial default 
 well-founded relation is <span class="tt"><a href="ACL2____O_C3.html">o&lt;</a></span> (with domain predicate <span class="tt"><a href="ACL2____O-P.html">o-p</a></span>).</p> 
 
 <p>This completes the brief sketch of the ACL2 definitional principle. 
 Optionally, see <a href="ACL2____RULERS.html">rulers</a> for a more detailed discussion of the 
 termination analysis and resulting proof obligations for admissibility, as 
 well as a discussion of the relation to how ACL2 stores induction schemes.</p> 
 
 <p>On very rare occasions ACL2 will seem to "hang" when processing a 
 definition, especially if there are many subexpressions of the body whose 
 function symbol is <span class="tt"><a href="COMMON-LISP____IF.html">if</a></span> (or which macroexpand to such an expression). 
 In those cases you may wish to supply the following to <span class="tt"><a href="ACL2____XARGS.html">xargs</a></span>: 
 <span class="v">:normalize nil</span>.  This is an advanced feature that turns off certain 
 simplification of <a href="ACL2____DEFINITION.html">definition</a> bodies and <a href="ACL2____GUARD.html">guard</a>s; <a href="ACL2____NORMALIZE.html">normalize</a>.</p> 
 
 <p>When a <span class="v">defun</span> form is submitted, ACL2 sometimes computes and stores a 
 <a href="ACL2____TYPE-PRESCRIPTION.html">type-prescription</a> rule for the function.  See <a href="ACL2____TYPE-PRESCRIPTION-DEBUGGING.html">type-prescription-debugging</a> for relevant discussion.</p> 
 
 <p>The following example illustrates all of the available declarations and 
 most hint keywords, but is completely nonsensical.  For documentation, see 
 <a href="ACL2____XARGS.html">xargs</a> and see <a href="ACL2____HINTS.html">hints</a>.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> example (x y z a b c i j)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORE.html">ignore</a> a b c)
           (<a href="COMMON-LISP____TYPE.html">type</a> integer i j)
           (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> x)
                  :loop$-recursion t
                  :measure (<a href="COMMON-LISP____-.html">-</a> i j)
                  :ruler-extenders :basic
                  :well-founded-relation my-wfr
                  :hints (("Goal"
                           :do-not-induct t
                           :do-not '(<a href="ACL2____GENERALIZE.html">generalize</a> fertilize)
                           :expand ((<a href="COMMON-LISP____ASSOC.html">assoc</a> x a) (<a href="COMMON-LISP____MEMBER.html">member</a> y z))
                           :restrict ((&lt;-trans ((x x) (y (foo x)))))
                           :hands-off (<a href="COMMON-LISP____LENGTH.html">length</a> binary-append)
                           :in-theory (<a href="ACL2____SET-DIFFERENCE-THEORIES.html">set-difference-theories</a>
                                        (<a href="ACL2____CURRENT-THEORY.html">current-theory</a> :here)
                                        '(<a href="COMMON-LISP____ASSOC.html">assoc</a>))
                           :induct (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NTH.html">nth</a> n a) (<a href="COMMON-LISP____NTH.html">nth</a> n b))
                           :use ((:instance assoc-of-append
                                            (x a) (y b) (z c))
                                 (:functional-instance
                                   (:instance p-f (x a) (y b))
                                   (p consp)
                                   (f assoc)))))
                  :guard-hints (("Subgoal *1/3'"
                                 :use ((:instance assoc-of-append
                                                  (x a) (y b) (z c)))))
                  :mode :logic
                  :normalize nil
                  :verify-guards nil
                  :non-executable t
                  :type-prescription (<a href="ACL2____NATP.html">natp</a> (example x y z a b c i j))
                  :otf-flg t))
  (example-body x y z i j))</pre>
</body>
</html>
