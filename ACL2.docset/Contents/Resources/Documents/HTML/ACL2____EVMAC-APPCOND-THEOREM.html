<html>
<head>
<meta charset="UTF-8">
<title>Evmac-appcond-theorem</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____EVMAC-APPCOND-THEOREM">Click for Evmac-appcond-theorem in the Full Manual</a></h3>

<p>Generate a theorem event for an applicability condition.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(evmac-appcond-theorem appcond hints names-to-avoid print ctx state) 
  → 
(mv event thm-name new-hints updated-names-to-avoid)</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">appcond</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____EVMAC-APPCONDP.html">evmac-appcondp</a> appcond)</span>.</font>
</dd> 
  <dd>
<span class="tt">hints</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____EVMAC-INPUT-HINTS-P.html">evmac-input-hints-p</a> hints)</span>.</font>
</dd> 
  <dd>
<span class="tt">names-to-avoid</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> names-to-avoid)</span>.</font>
</dd> 
  <dd>
<span class="tt">print</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____EVMAC-INPUT-PRINT-P.html">evmac-input-print-p</a> print)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">event</span> — A <span class="tt"><a href="ACL2____PSEUDO-EVENT-FORMP.html">pseudo-event-formp</a></span>.</dd> 
<dd>
<span class="tt">thm-name</span> — A <span class="tt"><a href="COMMON-LISP____SYMBOLP.html">symbolp</a></span>.</dd> 
<dd>
<span class="tt">new-hints</span> — An <span class="tt"><a href="ACL2____EVMAC-INPUT-HINTS-P.html">evmac-input-hints-p</a></span>.</dd> 
<dd>
<span class="tt">updated-names-to-avoid</span> — A <span class="tt"><a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a></span>.</dd> 
 
</dl></div> 
<p>We generate a name for the theorem that is not in the world 
     and that is distinct from the given list of names to avoid; 
     the latter are names not yet in the world, 
     but are names of other events 
     that will be added to the world together with this theorem, 
     and that therefore must be all distinct. 
     We return an updated list of names to avoid that includes the new name, 
     so that future calls of this function, or of other event-generating code, 
     can use the updated list to avoid conflicts with this new name. 
     The new theorem name is also returned as a result as a convenience 
     (it could be extracted from the returned event instead); 
     the event macro may reference this name in generated proofs 
     (see <span class="tt"><a href="ACL2____EVMAC-APPCOND-THEOREM-LIST.html">evmac-appcond-theorem-list</a></span> for more discussion on this). 
     The theorem name is the same as 
     the keyword that names the applicability condition, 
     if fresh, otherwise <span class="v">$</span> characters are appended to it until it is fresh. 
     The theorem name is in the <span class="v">"ACL2"</span> package, 
     which seems like a good general choice; 
     the event macro, or the application where the event macro is used, 
     may be in an arbitrary package.</p><p>We untranslate the formula so that it is more readable 
     if printed on the screen. 
     The use of <span class="tt"><a href="ACL2____UNTRANSLATE.html">untranslate</a></span> forces this function and its callers 
     into program mode. 
     An alternative could be to use a more limited, logic-mode untranslation.</p><p>If the event macro's hints are an alist from keywords to true lists, 
     we extract the ones associated to the applicability conditions 
     (if any, otherwise we get <span class="v">nil</span>) and use those to prove the theorem; 
     we also remove the pair from the alist, and return the updated alist. 
     By threading the hints alist through calls of this functions, 
     one for each applicability condition, 
     at the end the event macro can detect if there were unused hints 
     (e.g. for applicability conditions that were not actually present), 
     and issue a warning or error in that case 
     (see <span class="tt"><a href="ACL2____EVMAC-ENSURE-NO-EXTRA-HINTS.html">evmac-ensure-no-extra-hints</a></span>). 
     If the event macro's hints are not an alist from keywords to true lists, 
     we use those in their entirety to prove the theorem, 
     and we return them unchanged.</p><p>The theorem has no rule classes, 
     because it is meant to be referenced in <span class="v">:use</span> hints 
     in proofs generated by the event macro. 
     Not having rule classes avoids any restrictions on the formula, 
     such as having a conclusion <span class="v">(<a href="COMMON-LISP____EQUAL.html">equal</a> var ...)</span> for a rewrite rule.</p><p>The theorem is wrapped into <span class="tt"><a href="ACL2____TRY-EVENT.html">try-event</a></span> 
     in order to provide a terser error message if the proof fails. 
     This wrapping is not performed if <span class="v">:print</span> is <span class="v">:all</span>, 
     to avoid the suppression of the error output done by <span class="tt"><a href="ACL2____TRY-EVENT.html">try-event</a></span>. 
     This causes the print levels to be not quite ``monotonic'', 
     in the sense that <span class="v">:print :all</span> will not print 
     the custom error message passed to <span class="tt"><a href="ACL2____TRY-EVENT.html">try-event</a></span>. 
     This choice may be revisited at some point.</p><p>This function also takes a print specifier as input, 
     meant to be one of the inputs of the event macro. 
     This is used to determine whether 
     events that show progress messages should be generated or not. 
     Since this is a binary choice, 
     the input of this function could be a boolean flag 
     instead of a print specifier. 
     However, having a print specifier makes things more modular 
     (e.g. if print specifiers are extended with more options in the future). 
     If an event macro does not have a print specifier input (perhaps yet), 
     the caller of this function can still set one adequate to 
     whether progress messages must be shown or not.</p><p>The returned event, which consists of the theorem 
     and the optional show-progress events, 
     is local (to the <span class="tt"><a href="ACL2____ENCAPSULATE.html">encapsulate</a></span> that the event macro expands to). 
     This is why the exact name of the theorem is not too important, 
     so long as it is valid and does not clash with others. 
     If an event macro should generate 
     (some of) its applicability conditions as persistent events, 
     the best course of action is to still use this function 
     to generate local theorems with no rule classes, 
     and then do another pass over such applicability conditions 
     to generate non-local theorems 
     with the same formulas, 
     without hints (thus keeping the history ``clean'') 
     and with the desired names and rule classes. 
     These non-local theorems can be easily proved via <span class="v">:by</span> hints: 
     to avoid their appearance in the history, 
     the theorems with the desired names can be introduced twice, 
     once locally with the <span class="v">:by</span> hints, 
     and once non-locally and redundantly without hints. 
     Perhaps there should be a utility to do this, 
     if the task becomes common among event macros.</p><p>So this function generates a little more than just a theorem event, 
     because of the surrounding things generated. 
     However, those surrounding things are auxiliary: 
     it is still, mainly, a theorem event.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>evmac-appcond-theorem</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 evmac-appcond-theorem
 (appcond hints names-to-avoid print ctx state)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (<a href="ACL2____STATE.html">state</a>)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____EVMAC-APPCONDP.html">evmac-appcondp</a> appcond)
                             (<a href="ACL2____EVMAC-INPUT-HINTS-P.html">evmac-input-hints-p</a> hints)
                             (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> names-to-avoid)
                             (<a href="ACL2____EVMAC-INPUT-PRINT-P.html">evmac-input-print-p</a> print))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((__function__ 'evmac-appcond-theorem))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
  (<a href="ACL2____B_A2.html">b*</a>
   ((wrld (<a href="ACL2____W.html">w</a> state))
    ((<a href="ACL2____EVMAC-APPCOND.html">evmac-appcond</a> appcond) appcond)
    ((<a href="ACL2____MV.html">mv</a> thm-name updated-names-to-avoid)
     (<a href="ACL2____FRESH-LOGICAL-NAME-WITH-_42S-SUFFIX.html">fresh-logical-name-with-$s-suffix</a>
          (<a href="ACL2____INTERN-IN-PACKAGE-OF-SYMBOL.html">intern-in-package-of-symbol</a> (<a href="COMMON-LISP____SYMBOL-NAME.html">symbol-name</a> appcond.name)
                                       (<a href="ACL2____PKG-WITNESS.html">pkg-witness</a> "ACL2"))
          nil names-to-avoid wrld))
    (<a href="ACL2____THM-FORMULA.html">thm-formula</a> (<a href="ACL2____UNTRANSLATE.html">untranslate</a> appcond.formula t wrld))
    ((<a href="ACL2____MV.html">mv</a> thm-hints new-hints)
     (<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____KEYWORD-TRUELIST-ALISTP.html">keyword-truelist-alistp</a> hints)
         (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="ACL2____ASSOC-EQ.html">assoc-eq</a> appcond.name hints))
             (<a href="ACL2____REMOVE-ASSOC-EQ.html">remove-assoc-eq</a> appcond.name hints))
         (<a href="ACL2____MV.html">mv</a> hints hints)))
    (thm-event
     (<a href="COMMON-LISP____CONS.html">cons</a>
      'defthm
      (<a href="COMMON-LISP____CONS.html">cons</a>
       thm-name
       (<a href="COMMON-LISP____CONS.html">cons</a>
           thm-formula
           (<a href="COMMON-LISP____CONS.html">cons</a> ':rule-classes
                 (<a href="COMMON-LISP____CONS.html">cons</a> 'nil
                       (<a href="COMMON-LISP____AND.html">and</a> thm-hints (<a href="COMMON-LISP____LIST.html">list</a> :hints thm-hints))))))))
    (error-msg
     (<a href="ACL2____MSG.html">msg</a>
       "The proof of the ~x0 applicability condition fails:~%~X12~|"
       appcond.name thm-formula nil))
    (try?-thm-event (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQ.html">eq</a> print :all)
                        thm-event
                        (<a href="ACL2____TRY-EVENT.html">try-event</a> thm-event ctx t nil error-msg)))
    (show-progress-p (<a href="ACL2____MEMBER-EQ.html">member-eq</a> print '(:info :all)))
    (progress-start?
     (<a href="COMMON-LISP____AND.html">and</a>
      show-progress-p
      (<a href="COMMON-LISP____CONS.html">cons</a>
       (<a href="COMMON-LISP____CONS.html">cons</a>
        'cw-event
        (<a href="COMMON-LISP____CONS.html">cons</a>
         '"~%Attempting to prove the ~x0 ~
                                 applicability condition:~%~X12~|"
         (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'quote (<a href="COMMON-LISP____CONS.html">cons</a> appcond.name 'nil))
               (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'quote (<a href="COMMON-LISP____CONS.html">cons</a> thm-formula 'nil))
                     (<a href="COMMON-LISP____CONS.html">cons</a> 'nil 'nil)))))
       'nil)))
    (progress-end?
         (<a href="COMMON-LISP____AND.html">and</a> show-progress-p
              (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'cw-event (<a href="COMMON-LISP____CONS.html">cons</a> '"Done.~%" 'nil))
                    'nil)))
    (<a href="ACL2____EVENT.html">event</a>
     (<a href="COMMON-LISP____CONS.html">cons</a> 'local
           (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'progn
                       (<a href="COMMON-LISP____APPEND.html">append</a> progress-start?
                               (<a href="COMMON-LISP____CONS.html">cons</a> try?-thm-event progress-end?)))
                 'nil))))
   (<a href="ACL2____MV.html">mv</a> event thm-name
       new-hints updated-names-to-avoid))))</pre> 

</body>
</html>
