<html>
<head>
<meta charset="UTF-8">
<title>Wr16</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=X86ISA____WR16">Click for Wr16 in the Full Manual</a></h3>

<p>Write to word general-purpose registers</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(wr16 reg val x86) → x86</pre></dt> 
</dl></div> 
<p>Note Intel Vol. 1 Sec. 3.4.1.1 
    p. 3-17, which says the following about 64-bit mode:</p> 
 
    <p>8-bit and 16-bit operands generate an 8-bit or 16-bit result. 
    The upper 56 or 48 bits (respectively) of the destination general-purpose 
    register are not modified by the operation.</p> 
 
    <p>This is also confirmed by AMD manual, Jun'15, Vol. 3, App. B.1, under 
    ‘No Extension of 8-Bit and 16-Bit Results’.</p> 
 
    <p>In 32-bit mode, the upper 32 bits are undefined, as specified by 
    the following quote from the same page as above:</p> 
 
    <p>Because the upper 32 bits of 64-bit general-purpose registers are 
    undefined in 32-bit modes, the upper 32 bits of any general-purpose 
    register are not preserved when switching from 64-bit mode to a 32-bit 
    mode (to protected mode or compatibility mode). Software must not depend on 
    these bits to maintain a value after a 64-bit to 32-bit mode 
    switch.</p> 
 
    <p>This function is used both in 64-bit mode and in 32-bit mode. Since in 
    32-bit mode the high 32 bits of general-purpose registers are not 
    accessible, it is fine for this function to leave those bits unchanged, as 
    opposed to, for example, setting them to undefined values as done by the 
    semantic functions of certain instructions for certain flags. The switching 
    from 32-bit mode to 64-bit mode (when modeled) will set the high 32 bits of 
    general-purpose registers to undefined values.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>wr16$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 wr16$inline (reg val x86)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs (x86)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 4) reg)
          (<a href="COMMON-LISP____TYPE.html">type</a> (unsigned-byte 16) val))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((qword (<a href="COMMON-LISP____THE.html">the</a> (signed-byte 64) (rgfi reg x86))))
  (!rgfi
   reg
   (<a href="X86ISA____N64-TO-I64.html">n64-to-i64</a>
    (<a href="ACL2____MBE.html">mbe</a>
       :logic (<a href="ACL2____PART-INSTALL.html">part-install</a> val (<a href="ACL2____PART-SELECT.html">part-select</a> qword :low 0 :width 64)
                            :low 0
                            :width 16)
       :exec (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 64)
                  (<a href="COMMON-LISP____LOGIOR.html">logior</a> (<a href="COMMON-LISP____THE.html">the</a> (unsigned-byte 64)
                               (<a href="COMMON-LISP____LOGAND.html">logand</a> qword 18446744073709486080))
                          val))))
   x86)))</pre> 
<p><b>Theorem: </b>x86p-wr16</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> x86p-wr16
        (<a href="ACL2____IMPLIES.html">implies</a> (x86p x86)
                 (x86p (<a href="X86ISA____WR16.html">wr16</a> reg val x86))))</pre> 

</body>
</html>
