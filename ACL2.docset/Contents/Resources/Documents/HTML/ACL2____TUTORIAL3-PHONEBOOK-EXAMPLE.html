<html>
<head>
<meta charset="UTF-8">
<title>Tutorial3-phonebook-example</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____TUTORIAL3-PHONEBOOK-EXAMPLE">Click for Tutorial3-phonebook-example in the Full Manual</a></h3>

<p>A Phonebook Specification</p><p>The other tutorial examples are rather small and entirely self 
 contained.  The present example is rather more elaborate, and makes use of a 
 feature that really adds great power and versatility to ACL2, namely: the use 
 of previously defined collections of lemmas, in the form of ``<a href="ACL2____BOOKS.html">books</a>.''</p> 
 
 <p>This example was written almost entirely by Bill Young of Computational 
 Logic, Inc.</p> 
 
 <p>This example is based on one developed by Ricky Butler and Sally Johnson of 
 NASA Langley for the PVS system, and subsequently revised by Judy Crow, <i>et 
 al</i>, at SRI.  It is a simple phone book specification.  We will not bother 
 to follow their versions closely, but will instead present a style of 
 specification natural for ACL2.</p> 
 
 <p>The idea is to model an electronic phone book with the following 
 properties.</p> 
 
 <blockquote> 
 
 <p>Our phone book will store the phone numbers of a city.</p> 
 
 <p>It must be possible to retrieve a phone number, given a name.</p> 
 
 <p>It must be possible to add and delete entries.</p> 
 
 </blockquote> 
 
 <p>Of course, there are numerous ways to construct such a model.  A natural 
 approach within the Lisp/ACL2 context is to use ``association lists'' or 
 ``alists.''  Briefly, an alist is a list of pairs <span class="v">(key .  value)</span> 
 associating a value with a key.  A phone book could be an alist of pairs 
 <span class="v">(<a href="ACL2____NAME.html">name</a> . pnum)</span>.  To find the phone number associated with a given name, we 
 merely search the alist until we find the appropriate pair.  For a large city, 
 such a linear list would not be efficient, but at this point we are interested 
 only in <b>modeling</b> the problem, not in deriving an efficient 
 implementation.  We could address that question later by proving our alist 
 model equivalent, in some desired sense, to a more efficient data 
 structure.</p> 
 
 <p>We could build a theory of alists from scratch, or we can use a previously 
 constructed theory (book) of alist definitions and facts.  By using an 
 existing book, we build upon the work of others, start our specification and 
 proof effort from a much richer foundation, and hopefully devote more of our 
 time to the problem at hand.  Unfortunately, it is not completely simple for 
 the new user to know what <a href="ACL2____BOOKS.html">books</a> are available and what they contain. 
 We hope later to improve the documentation of the growing collection of 
 <a href="ACL2____COMMUNITY-BOOKS.html">community-books</a> that are typically downloaded with ACL2; for now, the 
 reader is encouraged to look in the README.html file in the books' top-level 
 directory.  For present purposes, the beginning user can simply take our word 
 that a book exists containing useful alist definitions and facts.  These 
 definitions and lemmas can be introduced into the current theory using the 
 <a href="ACL2____COMMAND.html">command</a>:</p> 
 
 <pre class="code">(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "data-structures/alist-defthms" :dir :system)</pre> 
 
 <p>This book has been ``certified,'' which means that the definitions and 
 lemmas have been mechanically checked and stored in a safe manner.  (See <a href="ACL2____BOOKS.html">books</a> and see <a href="ACL2____INCLUDE-BOOK.html">include-book</a> for details.)</p> 
 
 <p>Including this book makes available a collection of functions including the 
 following:</p> 
 
 <pre class="code">(<a href="ACL2____ALISTP.html">ALISTP</a> A)    ; is A an alist (actually a primitive ACL2 function)

(BIND X V A)  ; associate the key X with value V in alist A

(BINDING X A) ; return the value associated with key X in alist A

(BOUND? X A)  ; is key X associated with any value in alist A

(DOMAIN A)    ; return the list of keys bound in alist A

(RANGE A)     ; return the list of values bound to keys in alist A

(REMBIND X A) ; remove the binding of key X in alist A</pre> 
 
 <p>Along with these function definitions, the book also provides a number of 
 proved lemmas that aid in simplifying expressions involving these functions. 
 (See <a href="ACL2____RULE-CLASSES.html">rule-classes</a> for the way in which lemmas are used in 
 simplification and rewriting.)  For example,</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bound?-bind
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (bound? x (bind y v a))
         (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> x y)
             (bound? x a))))</pre> 
 
 <p>asserts that <span class="v">x</span> will be bound in <span class="v">(bind y v a)</span> if and only if: 
 either <span class="v">x = y</span> or <span class="v">x</span> was already bound in <span class="v">a</span>.  Also,</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> binding-bind
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (binding x (bind y v a))
         (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> x y)
             v
           (binding x a))))</pre> 
 
 <p>asserts that the resulting binding will be <span class="v">v</span>, if <span class="v">x = y</span>, or the 
 binding that <span class="v">x</span> had in <span class="v">a</span> already, if not.</p> 
 
 <p>Thus, the inclusion of this book essentially extends our specification and 
 reasoning capabilities by the addition of new operations and facts about these 
 operations that allow us to build further specifications on a richer and 
 possibly more intuitive foundation.</p> 
 
 <p>However, it must be admitted that the use of a book such as this has two 
 potential limitations:</p> 
 
 <blockquote> 
 
 <p>the definitions available in a book may not be ideal for your particular 
 problem;</p> 
 
 <p>it is (extremely) likely that some useful facts (especially, <a href="ACL2____REWRITE.html">rewrite</a> 
 rules) are not available in the book and will have to be proved.</p> 
 
 </blockquote> 
 
 <p>For example, what is the value of <span class="v">binding</span> when given a key that is not 
 bound in the alist?  We can find out by examining the function definition. 
 Look at the definition of the <span class="v">binding</span> function (or any other defined 
 function), using the <span class="v">:</span><span class="tt"><a href="ACL2____PE.html">pe</a></span> command:</p> 
 
 <pre class="code">ACL2 !&gt;:pe binding
   d     33  (<a href="ACL2____INCLUDE-BOOK.html">INCLUDE-BOOK</a>
                  "/slocal/src/acl2/v1-9/books/public/alist-defthms")

&gt;V d          (<a href="COMMON-LISP____DEFUN.html">DEFUN</a> BINDING (X A)
                     "The value bound to X in alist A."
                     (<a href="COMMON-LISP____DECLARE.html">DECLARE</a> (<a href="ACL2____XARGS.html">XARGS</a> :GUARD (<a href="ACL2____ALISTP.html">ALISTP</a> A)))
                     (<a href="COMMON-LISP____CDR.html">CDR</a> (<a href="ACL2____ASSOC-EQUAL.html">ASSOC-EQUAL</a> X A)))</pre> 
 
 <p>This tells us that <span class="v">binding</span> was introduced by the given <span class="tt"><a href="ACL2____INCLUDE-BOOK.html">include-book</a></span> form, is currently <a href="ACL2____DISABLE.html">disable</a>d in the current theory, and 
 has the definition given by the displayed <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> form.  We see that 
 <span class="v">binding</span> is actually defined in terms of the primitive <span class="tt"><a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a></span> 
 function.  If we look at the definition of <span class="tt"><a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a></span>:</p> 
 
 <pre class="code">ACL2 !&gt;:pe assoc-equal
 V     -489  (<a href="COMMON-LISP____DEFUN.html">DEFUN</a> ASSOC-EQUAL (X ALIST)
                    (<a href="COMMON-LISP____DECLARE.html">DECLARE</a> (<a href="ACL2____XARGS.html">XARGS</a> :GUARD (<a href="ACL2____ALISTP.html">ALISTP</a> ALIST)))
                    (<a href="COMMON-LISP____COND.html">COND</a> ((<a href="COMMON-LISP____ENDP.html">ENDP</a> ALIST) NIL)
                          ((<a href="COMMON-LISP____EQUAL.html">EQUAL</a> X (<a href="COMMON-LISP____CAR.html">CAR</a> (<a href="COMMON-LISP____CAR.html">CAR</a> ALIST)))
                           (<a href="COMMON-LISP____CAR.html">CAR</a> ALIST))
                          (T (<a href="ACL2____ASSOC-EQUAL.html">ASSOC-EQUAL</a> X (<a href="COMMON-LISP____CDR.html">CDR</a> ALIST)))))</pre> 
 
 <p>we can see that <span class="tt"><a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a></span> returns <span class="v">nil</span> upon reaching the end 
 of an unsuccessful search down the alist.  So <span class="v">binding</span> returns <span class="v">(<a href="COMMON-LISP____CDR.html">cdr</a>
 nil)</span> in that case, which is <span class="v">nil</span>.  Notice that we could also have 
 investigated this question by trying some simple examples.</p> 
 
 <pre class="code">ACL2 !&gt;(binding 'a nil)
NIL

ACL2 !&gt;(binding 'a (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'b 2)))
NIL</pre> 
 
 <p>These definitions aren't ideal for all purposes. For one thing, there's 
 nothing that keeps us from having <span class="v">nil</span> as a value bound to some key in the 
 alist.  Thus, if <span class="v">binding</span> returns <span class="v">nil</span> we don't always know if that is 
 the value associated with the key in the alist, or if that key is not bound. 
 We'll have to keep that ambiguity in mind whenever we use <span class="v">binding</span> in our 
 specification.  Suppose instead that we wanted <span class="v">binding</span> to return some 
 error string on unbound keys.  Well, then we'd just have to write our own 
 version of <span class="v">binding</span>.  But then we'd lose much of the value of using a 
 previously defined book.  As with any specification technique, certain 
 tradeoffs are necessary.</p> 
 
 <p>Why not take a look at the definitions of other alist functions and see how 
 they work together to provide the ability to construct and search alists? 
 We'll be using them rather heavily in what follows so it will be good if you 
 understand basically how they work.  Simply start up ACL2 and execute the form 
 shown earlier, but substituting our directory name for the top-level ACL2 
 directory with yours.  Alternatively, just</p> 
 
 <pre class="code">(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "data-structures/alist-defthms" :dir :system)</pre> 
 
 <p>Then, you can use <span class="v">:</span><a href="ACL2____PE.html">pe</a> to look at function definitions.  You'll 
 soon discover that almost all of the definitions are built on definitions of 
 other, more primitive functions, as <span class="v">binding</span> is built on <span class="tt"><a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a></span>.  You can look at those as well, of course, or in many cases 
 visit their documentation.</p> 
 
 <p>The other problem with using a predefined book is that it will seldom be 
 ``sufficiently complete,'' in the sense that the collection of <a href="ACL2____REWRITE.html">rewrite</a> 
 rules supplied won't be adequate to prove everything we'd like to know about 
 the interactions of the various functions.  If it were, there'd be no real 
 reason to know that <span class="v">binding</span> is built on top of <span class="tt"><a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a></span>, 
 because everything we'd need to know about <span class="v">binding</span> would be nicely 
 expressed in the collection of theorems supplied with the book.  However, 
 that's very seldom the case.  Developing such a collection of rules is 
 currently more art than science and requires considerable experience.  We'll 
 encounter examples later of ``missing'' facts about <span class="v">binding</span> and our other 
 alist functions.  So, let's get on with the example.</p> 
 
 <p>Notice that alists are mappings of keys to values; but, there is no notion 
 of a ``type'' associated with the keys or with the values.  Our phone book 
 example, however, does have such a notion of types; we map names to phone 
 numbers.  We can introduce these ``types'' by explicitly defining them, e.g., 
 names are strings and phone numbers are integers.  Alternatively, we can 
 <b>partially define</b> or axiomatize a recognizer for names without giving a 
 full definition.  A way to safely introduce such ``constrained'' function 
 symbols in ACL2 is with the <span class="tt"><a href="ACL2____ENCAPSULATE.html">encapsulate</a></span> form.  For example, consider 
 the following form.</p> 
 
 <pre class="code">(<a href="ACL2____ENCAPSULATE.html">encapsulate</a>
  ;; Introduce a recognizer for names and give a ``type'' lemma.
  (((namep *) =&gt; *))
  ;;
  (<a href="ACL2____LOCAL.html">local</a> (<a href="COMMON-LISP____DEFUN.html">defun</a> namep (x)
           ;; This declare is needed to tell
           ;; ACL2 that we're aware that the
           ;; argument x is not used in the body
           ;; of the function.
           (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORE.html">ignore</a> x))
           t))
  ;;
  (<a href="ACL2____DEFTHM.html">defthm</a> namep-booleanp
    (<a href="ACL2____BOOLEANP.html">booleanp</a> (namep x))))</pre> 
 
 <p>This <span class="tt"><a href="ACL2____ENCAPSULATE.html">encapsulate</a></span> form introduces the new function <span class="v">namep</span> of one 
 argument and one result and constrains <span class="v">(namep x)</span> to be Boolean, for all 
 inputs <span class="v">x</span>.  More generally, an encapsulation establishes an environment in 
 which functions can be defined and theorems and rules added without 
 necessarily introducing those functions, theorems, and rules into the 
 environment outside the encapsulation.  To be admissible, all the events in 
 the body of an encapsulate must be admissible.  But the effect of an 
 encapsulate is to assume only the non-local events.</p> 
 
 <p>The first ``argument'' to <span class="v">encapsulate</span>, <span class="v">(((namep *) =&gt; *))</span> above, 
 declares the intended <a href="ACL2____SIGNATURE.html">signature</a>s of new function symbols that will be 
 ``exported'' from the encapsulation without definition.  The <span class="tt"><a href="ACL2____LOCAL.html">local</a></span> 
 <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> of <span class="v">name</span> defines name within the encapsulation always to 
 return <span class="v">t</span>.  The <span class="v">defthm</span> event establishes that <span class="v">namep</span> is Boolean. 
 By making the <span class="v">defun</span> local but the <span class="v">defthm</span> non-<span class="v">local</span> this 
 encapsulate constrains the undefined function <span class="v">namep</span> to be Boolean; the 
 admissibility of the encapsulation establishes that there exists a Boolean 
 function (namely the constant function returning <span class="v">t</span>).</p> 
 
 <p>We can subsequently use <span class="v">namep</span> as we use any other Boolean function, 
 with the proviso that we know nothing about it except that it always returns 
 either <span class="v">t</span> or <span class="v">nil</span>.  We use <span class="v">namep</span> to ``recognize'' legal keys for 
 our phonebook alist.</p> 
 
 <p>We wish to do something similar to define what it means to be a legal phone 
 number.  We submit the following form to ACL2:</p> 
 
 <pre class="code">(<a href="ACL2____ENCAPSULATE.html">encapsulate</a>
  ;; Introduce a recognizer for phone numbers.
  (((pnump *) =&gt; *))
  ;;
  (<a href="ACL2____LOCAL.html">local</a> (<a href="COMMON-LISP____DEFUN.html">defun</a> pnump (x)
           (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> x nil))))
  ;;
  (<a href="ACL2____DEFTHM.html">defthm</a> pnump-booleanp
    (<a href="ACL2____BOOLEANP.html">booleanp</a> (pnump x)))
  ;;
  (<a href="ACL2____DEFTHM.html">defthm</a> nil-not-pnump
    (<a href="COMMON-LISP____NOT.html">not</a> (pnump nil)))).</pre> 
 
 <p>This introduces a Boolean-valued recognizer <span class="v">pnump</span>, with the additional 
 proviso that the constant <span class="v">nil</span> is not a <span class="v">pnump</span>.  We impose this 
 restriction to guarantee that we'll never bind a name to <span class="v">nil</span> in our phone 
 book and thereby introduce the kind of ambiguity described above regarding the 
 use of <span class="v">binding</span>.</p> 
 
 <p>Now a legal phone book is an alist mapping from <span class="v">namep</span>s to <span class="v">pnump</span>s. 
 We can define this as follows:</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> name-phonenum-pairp (x)
  ;; Recognizes a pair of (<a href="ACL2____NAME.html">name</a> . pnum).
  (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x)
       (namep (<a href="COMMON-LISP____CAR.html">car</a> x))
       (pnump (<a href="COMMON-LISP____CDR.html">cdr</a> x))))

(<a href="COMMON-LISP____DEFUN.html">defun</a> phonebookp (l)
  ;; Recognizes a list of such pairs.
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> l))
      (<a href="COMMON-LISP____NULL.html">null</a> l)
    (<a href="COMMON-LISP____AND.html">and</a> (name-phonenum-pairp (<a href="COMMON-LISP____CAR.html">car</a> l))
         (phonebookp (<a href="COMMON-LISP____CDR.html">cdr</a> l)))))</pre> 
 
 <p>Thus, a phone book is really a list of pairs <span class="v">(<a href="ACL2____NAME.html">name</a> . pnum)</span>.  Notice 
 that we have not assumed that the keys of the phone book are distinct.  We'll 
 worry about that question later.  (It is not always desirable to insist that 
 the keys of an alist be distinct.  But it may be a useful requirement for our 
 specific example.)</p> 
 
 <p>Now we are ready to define some of the functions necessary for our 
 phonebook example.  The functions we need are:</p> 
 
 <pre class="code">(IN-BOOK? NM BK)          ; does NM have a phone number in BK

(FIND-PHONE NM BK)        ; find NM's phone number in phonebook BK

(ADD-PHONE NM PNUM BK)    ; give NM the phone number PNUM in BK

(CHANGE-PHONE NM PNUM BK) ; change NM's phone number to PNUM in BK

(DEL-PHONE NM PNUM)       ; remove NM's phone number from BK</pre> 
 
 <p>Given our underlying theory of alists, it is easy to write these functions. 
 But we must take care to specify appropriate ``boundary'' behavior.  Thus, 
 what behavior do we want when, say, we try to change the phone number of a 
 client who is not currently in the book?  As usual, there are numerous 
 possibilities; here we'll assume that we return the phone book unchanged if we 
 try anything ``illegal.''</p> 
 
 <p>Possible definitions of our phone book functions are as follows. 
 (Remember, an <span class="v">include-book</span> form such as the ones shown earlier must be 
 executed in order to provide definitions for functions such as 
 <span class="v">bound?</span>.)</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> in-book? (nm bk)
  (bound? nm bk))

(<a href="COMMON-LISP____DEFUN.html">defun</a> find-phone (nm bk)
  (binding nm bk))

(<a href="COMMON-LISP____DEFUN.html">defun</a> add-phone (nm pnum bk)
  ;; If nm already in-book?, make no change.
  (<a href="COMMON-LISP____IF.html">if</a> (in-book? nm bk)
      bk
    (bind nm pnum bk)))

(<a href="COMMON-LISP____DEFUN.html">defun</a> change-phone (nm pnum bk)
  ;; Make a change only if nm already has a phone number.
  (<a href="COMMON-LISP____IF.html">if</a> (in-book? nm bk)
      (bind nm pnum bk)
    bk))

(<a href="COMMON-LISP____DEFUN.html">defun</a> del-phone (nm bk)
  ;; Remove the binding from bk, if there is one.
  (rembind nm bk))</pre> 
 
 <p>Notice that we don't have to check whether a name is in the book before 
 deleting, because <span class="v">rembind</span> is essentially a no-op if <span class="v">nm</span> is not bound 
 in <span class="v">bk</span>.</p> 
 
 <p>In some sense, this completes our specification.  But we can't have any 
 real confidence in its correctness without validating our specification in 
 some way.  One way to do so is by proving some properties of our 
 specification.  Some candidate properties are:</p> 
 
 <blockquote> 
 
 <p>1. A name will be in the book after we add it.</p> 
 
 <p>2. We will find the most recently added phone number for a client.</p> 
 
 <p>3. If we change a number, we'll find the change.</p> 
 
 <p>4. Changing and then deleting a number is the same as just deleting.</p> 
 
 <p>5. A name will not be in the book after we delete it.</p>
</blockquote> 
 
 <p>Let's formulate some of these properties.  The first one, for example, 
 is:</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> add-in-book
  (in-book? nm (add-phone nm pnum bk))).</pre> 
 
 <p>You may wonder why we didn't need any hypotheses about the ``types'' of the 
 arguments.  In fact, <span class="v">add-in-book</span> is really expressing a property that is 
 true of alists in general, not just of the particular variety of alists we are 
 dealing with.  Of course, we could have added some extraneous hypotheses and 
 proved:</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> add-in-book
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (namep nm)
                (pnump pnum)
                (phonebookp bk))
           (in-book? nm (add-phone nm pnum bk)))),</pre> 
 
 <p>but that would have yielded a weaker and less useful lemma because it would 
 apply to fewer situations.  In general, it is best to state lemmas in the most 
 general form possible and to eliminate unnecessary hypotheses whenever 
 possible.  The reason for that is simple: lemmas are usually stored as rules 
 and used in later proofs.  For a lemma to be used, its hypotheses must be 
 relieved (proved to hold in that instance); extra hypotheses require extra 
 work.  So we avoid them whenever possible.</p> 
 
 <p>There is another, more important observation to make about our lemma.  Even 
 in its simpler form (without the extraneous hypotheses), the lemma 
 <span class="v">add-in-book</span> may be useless as a <a href="ACL2____REWRITE.html">rewrite</a> rule.  Notice that it is 
 stated in terms of the non-recursive functions <span class="v">in-book?</span> and 
 <span class="v">add-phone</span>.  If such functions appear in the left hand side of the 
 conclusion of a lemma, the lemma may not ever be used.  Suppose in a later 
 proof, the theorem prover encountered a <a href="ACL2____TERM.html">term</a> of the form:</p> 
 
 <pre class="code">(in-book? nm (add-phone nm pnum bk)).</pre> 
 
 <p>Since we've already proved <span class="v">add-in-book</span>, you'd expect that this would 
 be immediately reduced to true.  However, the theorem prover will often 
 ``expand'' the non-recursive definitions of <span class="v">in-book?</span>  and <span class="v">add-phone</span> 
 using their definitions <b>before</b> it attempts rewriting with lemmas. 
 After this expansion, lemma <span class="v">add-in-book</span> won't ``match'' the <a href="ACL2____TERM.html">term</a> 
 and so won't be applied.  Look back at the proof script for <span class="v">add-in-proof</span> 
 and you'll notice that at the very end the prover warned you of this potential 
 difficulty when it printed:</p> 
 
 <pre class="code">Warnings:  Non-rec
Time:  0.18 seconds (prove: 0.05, print: 0.00, other: 0.13)
ADD-IN-BOOK</pre> 
 
 <p>The ``Warnings'' line notifies you that there are non-recursive function 
 calls in the left hand side of the conclusion and that this problem might 
 arise.  Of course, it may be that you don't ever plan to use the lemma for 
 rewriting or that your intention is to <a href="ACL2____DISABLE.html">disable</a> these functions.  <a href="ACL2____DISABLE.html">Disable</a>d functions are not expanded and the lemma should apply.  However, you 
 should always take note of such warnings and consider an appropriate response. 
 By the way, we noted above that <span class="v">binding</span> is <a href="ACL2____DISABLE.html">disable</a>d.  If it were 
 not, none of the lemmas about <span class="v">binding</span> in the book we included would 
 likely be of much use for exactly the reason we just gave.</p> 
 
 <p>For our current example, let's assume that we're just investigating the 
 properties of our specifications and not concerned about using our lemmas for 
 rewriting.  So let's go on.  If we really want to avoid the warnings, we can 
 add <span class="v">:rule-classes nil</span> to each <span class="v">defthm</span> event; see <a href="ACL2____RULE-CLASSES.html">rule-classes</a>.</p> 
 
 <p>Property 2 is: we always find the most recently added phone number for a 
 client.  Try the following formalization:</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> find-add-first-cut
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (find-phone nm (add-phone nm pnum bk))
         pnum))</pre> 
 
 <p>and you'll find that the proof attempt fails.  Examining the proof attempt 
 and our function definitions, we see that the lemma is false if <span class="v">nm</span> is 
 already in the book.  We can remedy this situation by reformulating our lemma 
 in at least two different ways:</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> find-add1
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (in-book? nm bk))
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (find-phone nm (add-phone nm pnum bk))
                  pnum)))

(<a href="ACL2____DEFTHM.html">defthm</a> find-add2
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (find-phone nm (add-phone nm pnum bk))
         (<a href="COMMON-LISP____IF.html">if</a> (in-book? nm bk)
             (find-phone nm bk)
             pnum)))</pre> 
 
 <p>For technical reasons, lemmas such as <span class="v">find-add2</span>, i.e., which do not 
 have hypotheses, are usually slightly preferable.  This lemma is stored as an 
 ``unconditional'' <a href="ACL2____REWRITE.html">rewrite</a> rule (i.e., has no hypotheses) and, 
 therefore, will apply more often than <span class="v">find-add1</span>.  However, for our 
 current purposes either version is all right.</p> 
 
 <p>Property 3 says: If we change a number, we'll find the change.  This is 
 very similar to the previous example.  The formalization is as follows.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> find-change
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (find-phone nm (change-phone nm pnum bk))
         (<a href="COMMON-LISP____IF.html">if</a> (in-book? nm bk)
             pnum
           (find-phone nm bk))))</pre> 
 
 <p>Property 4 says: changing and then deleting a number is the same as just 
 deleting.  We can model this as follows.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> del-change
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (del-phone nm (change-phone nm pnum bk))
         (del-phone nm bk)))</pre> 
 
 <p>Unfortunately, when we try to prove this, we encounter subgoals that seem 
 to be true, but for which the prover is stumped.  For example, consider the 
 following goal.  (Note: <span class="v">endp</span> holds of lists that are empty.)</p> 
 
 <pre class="code">Subgoal *1/4
(<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____AND.html">AND</a> (<a href="COMMON-LISP____NOT.html">NOT</a> (<a href="COMMON-LISP____ENDP.html">ENDP</a> BK))
              (<a href="COMMON-LISP____NOT.html">NOT</a> (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> NM (<a href="COMMON-LISP____CAAR.html">CAAR</a> BK)))
              (<a href="COMMON-LISP____NOT.html">NOT</a> (BOUND? NM (<a href="COMMON-LISP____CDR.html">CDR</a> BK)))
              (BOUND? NM BK))
         (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (REMBIND NM (BIND NM PNUM BK))
                (REMBIND NM BK))).</pre> 
 
 <p>Our intuition about <span class="v">rembind</span> and <span class="v">bind</span> tells us that this goal 
 should be true even without the hypotheses.  We attempt to prove the following 
 lemma.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rembind-bind
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (rembind nm (bind nm pnum bk))
         (rembind nm bk)))</pre> 
 
 <p>The prover proves this by induction, and stores it as a rewrite rule. 
 After that, the prover has no difficulty in proving <span class="v">del-change</span>.</p> 
 
 <p>The need to prove lemma <span class="v">rembind-bind</span> illustrates a point we made early 
 in this example: the collection of <a href="ACL2____REWRITE.html">rewrite</a> rules supplied by a 
 previously certified book will almost never be everything you'll need.  It 
 would be nice if we could operate purely in the realm of names, phone numbers, 
 and phone books without ever having to prove any new facts about alists. 
 Unfortunately, we needed a fact about the relation between <span class="v">rembind</span> and 
 <span class="v">bind</span> that wasn't supplied with the alists theory.  Hopefully, such 
 omissions will be rare.</p> 
 
 <p>Finally, let's consider our property 5 above: a name will not be in the 
 book after we delete it.  We formalize this as follows:</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> in-book-del
  (<a href="COMMON-LISP____NOT.html">not</a> (in-book? nm (del-phone nm bk))))</pre> 
 
 <p>This proves easily.  But notice that it's only true because <span class="v">del-phone</span> 
 (actually <span class="v">rembind</span>) removes <b>all</b> occurrences of a name from the 
 phone book.  If it only removed, say, the first one it encountered, we'd need 
 a hypothesis that said that <span class="v">nm</span> occurs at most once in <span class="v">bk</span>.  Ah, maybe 
 that's a property you hadn't considered.  Maybe you want to ensure that 
 <b>any</b> name occurs at most once in any valid phonebook.</p> 
 
 <p>To complete this example, let's consider adding an <b>invariant</b> to our 
 specification.  In particular, suppose we want to assure that no client has 
 more than one associated phone number.  One way to ensure this is to require 
 that the domain of the alist is a ``set'' (has no duplicates).</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> setp (l)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> l)
      (<a href="COMMON-LISP____NULL.html">null</a> l)
    (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> (<a href="COMMON-LISP____CAR.html">car</a> l) (<a href="COMMON-LISP____CDR.html">cdr</a> l)))
         (setp (<a href="COMMON-LISP____CDR.html">cdr</a> l)))))

(<a href="COMMON-LISP____DEFUN.html">defun</a> valid-phonebookp (bk)
  (<a href="COMMON-LISP____AND.html">and</a> (phonebookp bk)
       (setp (domain bk))))</pre> 
 
 <p>Now, we want to show under what conditions our operations preserve the 
 property of being a <span class="v">valid-phonebookp</span>.  The operations <span class="v">in-book?</span>  and 
 <span class="v">find-phone</span> don't return a phone book, so we don't really need to worry 
 about them.  Since we're really interested in the ``types'' of values 
 preserved by our phonebook functions, let's look at the types of those 
 operations as well.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> in-book-booleanp
  (<a href="ACL2____BOOLEANP.html">booleanp</a> (in-book? nm bk)))

(<a href="ACL2____DEFTHM.html">defthm</a> in-book-namep
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (phonebookp bk)
                (in-book? nm bk))
           (namep nm))
  :hints (("Goal" :in-theory (<a href="ACL2____ENABLE.html">enable</a> bound?))))

(<a href="ACL2____DEFTHM.html">defthm</a> find-phone-pnump
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (phonebookp bk)
                (in-book? nm bk))
           (pnump (find-phone nm bk)))
  :hints (("Goal" :in-theory (<a href="ACL2____ENABLE.html">enable</a> bound? binding))))</pre> 
 
 <p>Note the ``<span class="v">:</span><span class="tt"><a href="ACL2____HINTS.html">hints</a></span>'' on the last two lemmas.  Neither of these 
 would prove without these <a href="ACL2____HINTS.html">hints</a>, because once again there are some 
 facts about <span class="v">bound?</span> and <span class="v">binding</span> not available in our current context. 
 Now, we could figure out what those facts are and try to prove them. 
 Alternatively, we can <a href="ACL2____ENABLE.html">enable</a> <span class="v">bound?</span> and <span class="v">binding</span> and hope that 
 by opening up these functions, the conjectures will reduce to versions that 
 the prover does know enough about or can prove by induction.  In this case, 
 this strategy works.  The hints tell the prover to <a href="ACL2____ENABLE.html">enable</a> the functions 
 in question when considering the designated goal.</p> 
 
 <p>Below we develop the theorems showing that <span class="v">add-phone</span>, 
 <span class="v">change-phone</span>, and <span class="v">del-phone</span> preserve our proposed invariant.  Notice 
 that along the way we have to prove some subsidiary facts, some of which are 
 pretty ugly.  It would be a good idea for you to try, say, 
 <span class="v">add-phone-preserves-invariant</span> without introducing the following four 
 lemmas first.  See if you can develop the proof and only add these lemmas as 
 you need assistance.  Then try <span class="v">change-phone-preserves-invariant</span> and 
 <span class="v">del-phone-preserves-invariant</span>.  They will be easier.  It is illuminating 
 to think about why <span class="v">del-phone-preserves-invariant</span> does not need any 
 ``type'' hypotheses.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bind-preserves-phonebookp
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (phonebookp bk)
                (namep nm)
                (pnump num))
           (phonebookp (bind nm num bk))))

(<a href="ACL2____DEFTHM.html">defthm</a> member-equal-strip-cars-bind
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> x y))
                (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> x (<a href="ACL2____STRIP-CARS.html">strip-cars</a> a))))
           (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> x (<a href="ACL2____STRIP-CARS.html">strip-cars</a> (bind y z a))))))

(<a href="ACL2____DEFTHM.html">defthm</a> bind-preserves-domain-setp
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____ALISTP.html">alistp</a> bk)
                (setp (domain bk)))
           (setp (domain (bind nm num bk))))
  :hints (("Goal" :in-theory (<a href="ACL2____ENABLE.html">enable</a> domain))))

(<a href="ACL2____DEFTHM.html">defthm</a> phonebookp-alistp
  (<a href="ACL2____IMPLIES.html">implies</a> (phonebookp bk)
           (<a href="ACL2____ALISTP.html">alistp</a> bk)))

(<a href="ACL2____DEFTHM.html">defthm</a> ADD-PHONE-PRESERVES-INVARIANT
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (valid-phonebookp bk)
                (namep nm)
                (pnump num))
           (valid-phonebookp (add-phone nm num bk)))
  :hints (("Goal" :in-theory (<a href="ACL2____DISABLE.html">disable</a> domain-bind))))

(<a href="ACL2____DEFTHM.html">defthm</a> CHANGE-PHONE-PRESERVES-INVARIANT
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (valid-phonebookp bk)
                (namep nm)
                (pnump num))
           (valid-phonebookp (change-phone nm num bk)))
  :hints (("Goal" :in-theory (<a href="ACL2____DISABLE.html">disable</a> domain-bind))))

(<a href="ACL2____DEFTHM.html">defthm</a> remove-equal-preserves-setp
  (<a href="ACL2____IMPLIES.html">implies</a> (setp l)
           (setp (<a href="ACL2____REMOVE-EQUAL.html">remove-equal</a> x l))))

(<a href="ACL2____DEFTHM.html">defthm</a> rembind-preserves-phonebookp
  (<a href="ACL2____IMPLIES.html">implies</a> (phonebookp bk)
           (phonebookp (rembind nm bk))))

(<a href="ACL2____DEFTHM.html">defthm</a> DEL-PHONE-PRESERVES-INVARIANT
  (<a href="ACL2____IMPLIES.html">implies</a> (valid-phonebookp bk)
           (valid-phonebookp (del-phone nm bk))))</pre> 
 
 <p>As a final test of your understanding, try to formulate and prove an 
 invariant that says that no phone number is assigned to more than one name. 
 The following hints may help.</p> 
 
 <blockquote> 
 
 <p>1. Define the appropriate invariant.  (Hint: remember the function 
 <span class="v">range</span>.)</p> 
 
 <p>2. Do our current definitions of <span class="v">add-phone</span> and <span class="v">change-phone</span> 
 necessarily preserve this property?  If not, consider what hypotheses are 
 necessary in order to guarantee that they do preserve this property.</p> 
 
 <p>3. Study the definition of the function <span class="v">range</span> and notice that it is 
 defined in terms of the function <span class="tt"><a href="ACL2____STRIP-CDRS.html">strip-cdrs</a></span>.  Understand how this 
 defines the range of an alist.</p> 
 
 <p>4. Formulate the correctness theorems and attempt to prove them.  You'll 
 probably benefit from studying the invariant proof above.  In particular, you 
 may need some fact about the function <span class="tt"><a href="ACL2____STRIP-CDRS.html">strip-cdrs</a></span> analogous to the 
 lemma <span class="v">member-equal-strip-cars-bind</span> above.</p> 
 
 </blockquote> 
 
 <p>Below is one solution to this exercise.  Don't look at the solution, 
 however, until you've struggled a bit with it.  Notice that we didn't actually 
 change the definitions of <span class="v">add-phone</span> and <span class="v">change-phone</span>, but added a 
 hypothesis saying that the number is ``new.''  We could have changed the 
 definitions to check this and return the phonebook unchanged if the number was 
 already in use.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> pnums-in-use (bk)
  (range bk))

(<a href="COMMON-LISP____DEFUN.html">defun</a> phonenums-unique (bk)
  (setp (pnums-in-use bk)))

(<a href="COMMON-LISP____DEFUN.html">defun</a> new-pnump (pnum bk)
  (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> pnum (pnums-in-use bk))))

(<a href="ACL2____DEFTHM.html">defthm</a> member-equal-strip-cdrs-rembind
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> x (<a href="ACL2____STRIP-CDRS.html">strip-cdrs</a> y)))
           (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> x (<a href="ACL2____STRIP-CDRS.html">strip-cdrs</a> (rembind z y))))))

(<a href="ACL2____DEFTHM.html">defthm</a> DEL-PHONE-PRESERVES-PHONENUMS-UNIQUE
  (<a href="ACL2____IMPLIES.html">implies</a> (phonenums-unique bk)
           (phonenums-unique (del-phone nm bk)))
  :hints (("Goal" :in-theory (<a href="ACL2____ENABLE.html">enable</a> range))))

(<a href="ACL2____DEFTHM.html">defthm</a> strip-cdrs-bind-non-member
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (bound? x a))
                (<a href="ACL2____ALISTP.html">alistp</a> a))
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____STRIP-CDRS.html">strip-cdrs</a> (bind x y a))
                  (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="ACL2____STRIP-CDRS.html">strip-cdrs</a> a) (<a href="COMMON-LISP____LIST.html">list</a> y))))
  :hints (("Goal" :in-theory (<a href="ACL2____ENABLE.html">enable</a> bound?))))

(<a href="ACL2____DEFTHM.html">defthm</a> setp-append-list
  (<a href="ACL2____IMPLIES.html">implies</a> (setp l)
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (setp (<a href="COMMON-LISP____APPEND.html">append</a> l (<a href="COMMON-LISP____LIST.html">list</a> x)))
                  (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> x l)))))

(<a href="ACL2____DEFTHM.html">defthm</a> ADD-PHONE-PRESERVES-PHONENUMS-UNIQUE
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (phonenums-unique bk)
                (new-pnump pnum bk)
                (<a href="ACL2____ALISTP.html">alistp</a> bk))
           (phonenums-unique (add-phone nm pnum bk)))
  :hints (("Goal" :in-theory (<a href="ACL2____ENABLE.html">enable</a> range))))

(<a href="ACL2____DEFTHM.html">defthm</a> member-equal-strip-cdrs-bind
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> z (<a href="ACL2____STRIP-CDRS.html">strip-cdrs</a> a)))
                (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> z y)))
           (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> z (<a href="ACL2____STRIP-CDRS.html">strip-cdrs</a> (bind x y a))))))

(<a href="ACL2____DEFTHM.html">defthm</a> CHANGE-PHONE-PRESERVES-PHONENUMS-UNIQUE
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (phonenums-unique bk)
                (new-pnump pnum bk)
                (<a href="ACL2____ALISTP.html">alistp</a> bk))
           (phonenums-unique (change-phone nm pnum bk)))
  :hints (("Goal" :in-theory (<a href="ACL2____ENABLE.html">enable</a> range))))</pre>
</body>
</html>
