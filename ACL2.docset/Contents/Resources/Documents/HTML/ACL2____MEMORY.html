<html>
<head>
<meta charset="UTF-8">
<title>Memory</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____MEMORY">Click for Memory in the Full Manual</a></h3>

<p>Special records designed for array-like usage.</p><p>Loading the library:</p> 
 
<pre class="code">(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "data-structures/memories" :dir :system)</pre> 
 
<p>Memories are specialized records that are designed for array-like usage. 
Memories have a fixed size, and elements are accessed by the natural numbers 0, 
1, ..., size-1, where size is the maximum size of the memory.</p> 
 
<p>Unlike arrays, memories are based on trees.  As a result, loading and 
storing into memories is slower than array access in a typical programming 
language, and requires an O(log_2 n) search for the right element.  However, 
there are benefits to this system as well.  We populate the tree structure as 
needed when writes occur, allowing us to conceptually represent very large 
arrays so long as we use them sparesely.  Hence, memories are well suited for 
uses such as simulating the memory systems of processors or virtual machines 
with many gigabytes of memory, only some of which is used during simulation.</p> 
 
<p>Memories are as easy to reason about as records (see misc/records.lisp) and 
we provide the same core 'record theorems' about them.  However, the load and 
store operations on memories are guarded more strongly than the records book, 
in order to achieve efficiency.</p> 
 
<p>See also <a href="ACL2____ARRAYS.html">ACL2::arrays</a> and <a href="ACL2____STOBJ.html">ACL2::stobj</a>s for more efficient 
implementations of small arrays.  The records book, <span class="v">misc/records.lisp</span>, 
provides the same reasoning strategy as memories, and may be an appropriate 
substitution for memories depending upon your needs.</p>
</body>
</html>
