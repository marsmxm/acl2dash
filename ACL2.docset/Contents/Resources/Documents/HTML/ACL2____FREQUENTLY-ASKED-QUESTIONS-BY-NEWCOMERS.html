<html>
<head>
<meta charset="UTF-8">
<title>Frequently-asked-questions-by-newcomers</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____FREQUENTLY-ASKED-QUESTIONS-BY-NEWCOMERS">Click for Frequently-asked-questions-by-newcomers in the Full Manual</a></h3>

<p>Some questions newcomers frequently ask</p><p>This FAQ is for people who've read through all the other sections 
 of the tutorial introduction to the theorem prover (see <a href="ACL2____INTRODUCTION-TO-THE-THEOREM-PROVER.html">introduction-to-the-theorem-prover</a> and all the links from it that are not 
 marked with the little warning sign (``<a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a>''). 
 Do not expect to understand our answers if you haven't taken the time to read 
 through the tutorial.  In the answers below you will see more links into the 
 hypertext reference manual.  While such links were marked ``<a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a>'' 
 in the tutorial, they are not marked that way here.  When you enter the 
 reference manual be prepared to explore and assemble a mini-course on the 
 topic of interest, not a quick fix.</p> 
 
 <p><b>Q</b>.  How do I find something in the <b>ACL2 documentation</b>? 
 <b>A</b>.  Try the ``Jump to'' or ``Search'' boxes at the <a href="http://www.cs.utexas.edu/users/moore/acl2/current/combined-manual/index.html" target="_blank"><nobr>ACL2+Books Manual<img src="../Icon_External_Link.png" title="External link to http://www.cs.utexas.edu/users/moore/acl2/current/combined-manual/index.html"></nobr></a>.</p> 
 
 <p><b>Q</b>.  How does the theorem prover work?  <b>A</b>.  We really don't 
 think you need to know much about the inner workings of the prover to become 
 an effective user.  That doesn't mean the system is self-explanatory!  It 
 means that stuff you need to learn is not how the theorem prover works but how 
 to interact with it!  That is what <a href="ACL2____INTRODUCTION-TO-THE-THEOREM-PROVER.html">introduction-to-the-theorem-prover</a> 
 is about.  However, if you want the most basic overview of the prover, see 
 <a href="ACL2____ARCHITECTURE-OF-THE-PROVER.html">architecture-of-the-prover</a>.</p> 
 
 <p><b>Q</b>. How do I <b>define a new function</b>?  <b>A</b>. See <a href="COMMON-LISP____DEFUN.html">defun</a>.</p> 
 
 <p><b>Q</b>. How do I <b>define a new predicate</b>?  <b>A</b>. See <a href="COMMON-LISP____DEFUN.html">defun</a>.</p> 
 
 <p><b>Q</b>. How do I <b>define a new relation</b>?  <b>A</b>. See <a href="COMMON-LISP____DEFUN.html">defun</a>.</p> 
 
 <p><b>Q</b>. How do I define a <b>function or predicate that takes a varying 
 number of arguments</b>?  <b>A</b>. You can't.  However, see <a href="COMMON-LISP____DEFMACRO.html">defmacro</a> 
 to learn how to define a macro that takes a varying number of arguments and 
 expands into an arbitrary term that you compute.</p> 
 
 <p><b>Q</b>. How do I define a <b>macro that is sensitive to the state</b>? 
 <b>A</b>.  You can't.  However, advanced users should consider <span class="tt"><a href="ACL2____MAKE-EVENT.html">make-event</a></span>.</p> 
 
 <p><b>Q</b>. How do I define <b>mutually recursive</b> functions?  <b>A</b>. 
 See <a href="ACL2____MUTUAL-RECURSION.html">mutual-recursion</a>.  However, you should realize that when two 
 functions, say <span class="v">f</span> and <span class="v">g</span>, are mutually recursive, properties of <span class="v">f</span> 
 generally have to be stated simultaneously with properties of <span class="v">g</span>, since 
 inductive proofs about one function require inductive hypotheses about the 
 other.  Furthermore, ACL2 does not know how to do inductions for mutually 
 recursive functions and must be told.  See <a href="ACL2____MUTUAL-RECURSION-PROOF-EXAMPLE.html">mutual-recursion-proof-example</a>.</p> 
 
 <p><b>Q</b>. How do I declare the <b>type signature of a function</b>? 
 <b>A</b>.  You can't.  ACL2 is a syntactically untyped language and all 
 functions are defined on all objects in the ACL2 universe.  We recommend that 
 the new user get used to this and only then explore the use of ACL2 to express 
 and enforce a type regime.  In ACL2, the <i>guard</i> of a function is akin to 
 the type signature of a function in typed languages.  However, ACL2 guards may 
 be arbitrary terms, not just type conditions, they only concern the inputs to 
 the function (not its result), and do not affect the axiom defining the 
 function â€” all functions are defined on every combination of objects. 
 You may, of course, prove theorems that establish that every function called 
 in a definition or theorem is supplied with input satisfying its guards (which 
 necessarily involves describe the outputs too).  These formulas are called 
 <i>guard conjectures</i> and the process of proving them is called <i>guard 
 verification</i>.  Since guards are arbitrary ACL2 formulas, the ``type 
 regimes'' one tends to enforce in ACL2 can be much for flexible and expressive 
 than those in most programming languages.  However, that expressibility also 
 means guard verification can be challenging (indeed undecidable).  On the 
 other hand, if one limits oneself to simple type-like guards, lemmas can be 
 proved that make most guard verification fully automatic and one can configure 
 ACL2 to do guard verification automatically at <span class="v">defun</span>-time.  One may also 
 delay guard verification until ``the right'' lemmas have been proved.  By 
 doing guard verification one can make functions execute faster by allowing the 
 code to avoid runtime checks.  This is especially valuable to industrial users 
 who have large models used both in verification and as simulation engines for 
 designed artifacts.  In addition, guard verification can give you the 
 assurance that you are using your functions within their intended domains and 
 hence is a form of functional specification and verification.  However, all 
 these advantages aside, it is remarkably easy to drift away from the simplest 
 type regimes and write a guard that raises deep mathematical problems.  New 
 users should not try to confront these problems until they are comfortable 
 with the theorem prover and with lemma development.  Therefore, we 
 <b>strongly</b> recommend that you forget about types and guards and get used 
 to reasoning about total functions.  When you do decide to learn about them, 
 be prepared for a complex story involving specification, execution efficiency, 
 and proof management.  See <a href="ACL2____GUARD.html">guard</a>.</p> 
 
 <p><b>Q</b>. How do I tell <span class="v">defun</span> <b>what measure to use</b>? 
 <b>A</b>. See <a href="ACL2____XARGS.html">xargs</a>, specifically <span class="v">:measure</span>.</p> 
 
 <p><b>Q</b>.  I specified a measure that always returns a natural number but 
 ACL2 is acting like it's not a natural number.  <b>A</b>.  There are two 
 likely problems.  The most likely one is that your measure isn't really always 
 a natural!  Suppose the formals of your <span class="v">defun</span> are <span class="v">x</span> and <span class="v">y</span> and 
 your measure is <span class="v">(m x y)</span>.  Suppose the recursive calls of your function 
 are protected by tests that ensure that <span class="v">x</span> and <span class="v">y</span> are naturals.  Then 
 you might assume <span class="v">x</span> and <span class="v">y</span> are naturals in the measure.  But ACL2 has 
 to prove <span class="v">(<a href="ACL2____O-P.html">o-p</a> (m x y))</span>, where <span class="tt"><a href="ACL2____O-P.html">o-p</a></span> is the predicate that 
 recognizes ordinals (and naturals are ordinals).  Note that the theorem 
 doesn't have any hypotheses!  You might intuitively think that your measure 
 has to be an ordinal just under the conditions that lead to recursive calls. 
 That's not what ACL2 enforces.  It has to be an ordinal, always.  So you must 
 change your specified measure.  For example, consider wrapping <span class="tt"><a href="ACL2____NFIX.html">nfix</a></span> 
 around it or around its uses of <span class="v">x</span> and <span class="v">y</span> to coerce those quantities 
 to naturals.  The second most likely explanation is that your measure returns 
 a natural, always, but ACL2 doesn't know that and it takes induction to prove. 
 This might happen if <span class="v">m</span> involves some recursive functions.  In this case, 
 prove <span class="v">(<a href="ACL2____NATP.html">natp</a> (m x y))</span> before your <span class="v">defun</span>.  Perhaps you should consider 
 making the <span class="v">natp</span> lemma a <span class="v">:</span><span class="tt"><a href="ACL2____TYPE-PRESCRIPTION.html">type-prescription</a></span> lemma to make 
 ACL2's typing algorithm aware of it.</p> 
 
 <p><b>Q</b>. How do I tell <span class="v">defun</span> <b>what well-founded relation to 
 use</b>?  <b>A</b>. See <a href="ACL2____XARGS.html">xargs</a>, specifically 
 <span class="v">:well-founded-relation</span>.</p> 
 
 <p><b>Q</b>. How do I show that a <b>relation is well-founded</b>? 
 <b>A</b>. Prove a theorem establishing that there is an order preserving 
 embedding into the ordinals and store it with <span class="v">:rule-classes</span> 
 <span class="v">:well-founded-relation</span> <a href="ACL2____WELL-FOUNDED-RELATION-RULE.html">well-founded-relation-rule</a>.</p> 
 
 <p><b>Q</b>.  What is an <b>ordinal</b>?  What does it mean to be 
 <b>well-founded</b>?  <b>A</b>.  Ordinals are an extension of the natural 
 numbers used to ensure that a process can't go on forever.  Like naturals, 
 they can be added, multiplied, and exponentiated.  There is a sense of one 
 ordinal being less than another.  Unlike the naturals, each of which is 
 finite, the ordinals include infinite objects.  Now imagine ``standing'' on an 
 ordinal and ``stepping'' to a smaller one.  Like the naturals, this ``walk 
 down the ordinals'' can't go on forever, even if you start on an infinite 
 ordinal.  That is because the ordinals are <i>well-founded</i>.  See <span class="tt"><a href="ACL2____O-P.html">o-p</a></span> for more information about ordinals in ACL2 and about well-foundedness. 
 See <a href="ACL2____ORDINALS.html">ordinals</a> for a deeper discussion and a discussion of books that can 
 help configure ACL2 to reason about ordinals.</p> 
 
 <p><b>Q</b>. How can provide <b>hints for the termination proofs</b> in 
 <span class="v">defun</span>?  <b>A</b>. See <a href="ACL2____XARGS.html">xargs</a>, specifically <span class="v">:hints</span> (for the 
 termination proofs) and <span class="v">:guard-hints</span> (for the guard verification 
 proofs).</p> 
 
 <p><b>Q</b>. How do I define a <b>constant</b> (something like a <b>global 
 variable</b>)?  <b>A</b>. See <a href="ACL2____DEFCONST.html">defconst</a>.  But remember that as an 
 applicative programming language, ACL2 does not have global variables!  You 
 can define a symbol to have a fixed value and use the symbol sort of like a 
 global variable in function definitions: you may refer to the value of the 
 symbol in your functions without passing the variable in as formal parameter. 
 But you may not ever change the value of the symbol!</p> 
 
 <p><b>Q</b>. How do I save the value of a top-level computation for future 
 use?  <b>A</b>. See <a href="ACL2____ASSIGN.html">assign</a> and see <a href="ACL2_____04.html">@</a>.</p> 
 
 <p><b>Q</b>. How do I introduce <b>new syntactic form</b> or 
 <b>abbreviation</b>?  <b>A</b>. See <a href="COMMON-LISP____DEFMACRO.html">defmacro</a>.</p> 
 
 <p><b>Q</b>.  How can create and modify an array?  <b>A</b>.  ACL2 is a 
 functional language, so it is impossible to destructively modify an existing 
 object; technically, all ``updates'' to objects must be implemented by 
 ``copy-on-write'' semantics.  That said, ACL2 provides support for <a href="ACL2____ARRAYS.html">arrays</a>, provided you use them in a restricted way.  They give you 
 constant-time access and change under the use restrictions.</p> 
 
 <p><b>Q</b>.  How do I read from or write to a file?  How do I do IO? 
 <b>A</b>.  To manipulate files, your function must have <span class="tt"><a href="ACL2____STATE.html">state</a></span> as an 
 argument, so you should read about the restrictions that imposes.  For 
 input/output facilities, see <a href="ACL2____IO.html">io</a>.</p> 
 
 <p><b>Q</b>. How do I define a <b>structure that can be destructively 
 modified</b>?  <b>A</b>. ACL2 is an <i>applicative programming language</i>. 
 You can't modify objects arbitrarily!  You basically have to ``copy on 
 write,'' which means you construct new objects from old ones, making the 
 changes you want in the new one.  If the <span class="v">car</span> of some object is <span class="v">1</span> at 
 one moment and <span class="v">2</span> later, then the basic logical axiom <span class="v">(<a href="COMMON-LISP____CAR.html">car</a> x)</span> = 
 <span class="v">(<a href="COMMON-LISP____CAR.html">car</a> x)</span> is violated!  However, if the only reference to the old object, 
 e.g., <i>x</i>, was to pass it to the code that copied and ``changed'' it, 
 then ACL2 can re-use the old object to produce the new one and the axioms 
 would not object.  Such syntactic restrictions can make <i>x</i> a modifiable 
 structure but they will impose a heavy burden on you as a programmer: if pass 
 such an <i>x</i> to a function and the function modifies it, then you must 
 pass <i>x</i> only to that function and you must return the modified value and 
 use it henceforth.  Such objects are said to be <i>single threaded</i>.  See 
 <a href="ACL2____DEFSTOBJ.html">defstobj</a>.</p> 
 
 <p><b>Q</b>.  How do I write a universal quantifier?  An existential 
 quantifier?  How can I say ``for all'' or ``there exists''?  <b>A</b> You 
 can't literally write quantifiers.  But ACL2 has the power of full first order 
 logic with quantification.  See <a href="ACL2____QUANTIFIERS.html">quantifiers</a>.</p> 
 
 <p><b>Q</b>.  How do I introduce an undefined or uninterpreted function 
 symbol?  Can I constrain it to have certain properties?  <b>A</b>.  See <a href="ACL2____ENCAPSULATE.html">encapsulate</a>.</p> 
 
 <p><b>Q</b>.  How can I hide a lemma?  I want to prove a lemma temporarily to 
 use in another proof but I don't want the lemma around thereafter.  <b>A</b>. 
 One way to get a similar effect is to prove the lemma and then disable it with 
 an <span class="v">(<a href="ACL2____IN-THEORY.html">in-theory</a> (<a href="ACL2____DISABLE.html">disable</a> ...))</span> event; see <a href="ACL2____IN-THEORY.html">in-theory</a>.  Another way is 
 to put the lemma and the theorem that needs it into an <span class="tt"><a href="ACL2____ENCAPSULATE.html">encapsulate</a></span> and 
 wrap a <span class="tt"><a href="ACL2____LOCAL.html">local</a></span> around the lemma.</p> 
 
 <p><b>Q</b>. What is an <b>event</b>?  <b>A</b>. An <i>event</i> is a command 
 that adds information to the ACL2 database (the ``logical world''), like 
 <span class="v">defun</span> or <span class="v">defthm</span>.  See <a href="ACL2____EVENTS.html">events</a>.</p> 
 
 <p><b>Q</b>. How do I say that I <b>do not want a rewrite rule</b> generated 
 from a theorem?  <b>A</b>. The command</p> 
 
 <pre class="code">(defthm <i>name</i> <i>formula</i> 
        :rule-classes nil) 
</pre> 
 
 <p>will attempt to prove <i>formula</i> and, if successful, give 
 <i>formula</i> the name <i>name</i>, which you may use in hints as a theorem, 
 but it will build no rules from the formula.</p> 
 
 <p><b>Q</b>. How do I say that I want a formula to be <b>stored as a rewrite 
 rule</b>?  <b>A</b>. The command</p> 
 
 <pre class="code">(defthm <i>name</i> <i>formula</i>) 
</pre> 
 
 <p>will attempt to prove <i>formula</i> and, if successful, it will give 
 <i>formula</i> the name <i>name</i> and generate a rewrite rule from it, with 
 the runic name <span class="v">(:rewrite </span><i>name</i>)].  It could happen that 
 <i>formula</i> generates more than one rewrite rule, e.g., this happens if the 
 conclusion is an <span class="v">AND</span>.  In this case, each conjunctive branch through the 
 conclusion generates a rule named <span class="v">(:rewrite </span><i>name</i><span class="v"> . i)</span>, for 
 <i>i</i>=1,2,...  For more details, see <a href="ACL2____REWRITE.html">rewrite</a>.</p> 
 
 <p><b>Q</b>. How do I say that I want a formula to be <b>stored as a rewrite 
 rule</b> <b>and some other kinds of rules</b>?  <b>A</b>. The command</p> 
 
 <pre class="code">(defthm <i>name</i> <i>formula</i> 
        :rule-classes (<i>:class1</i> ... <i>classk</i>)) 
</pre> 
 
 <p>will attempt to prove <i>formula</i> and, if successful, it will give 
 <i>formula</i> the name <i>name</i> and generate a rule of each <i>:classi</i> 
 specified.  Each <i>:classi</i> should either be a keyword, like <span class="v">:REWRITE</span> 
 or <span class="v">:GENERALIZE</span>, naming a rule class (see <a href="ACL2____RULE-CLASSES.html">rule-classes</a>), or else 
 should be a list that starts with a rule class and then lists the relevant 
 modifiers.  Be sure to include <span class="v">:REWRITE</span> among the rule classes if you 
 want the formula to generate a rewrite rule.  It doesn't do that automatically 
 if you explicitly specify <span class="v">:rule-classes</span>!</p> 
 
 <p><b>Q</b>. How do I <b>rearrange</b> the shape of a formula before 
 generating a rule from it?  <b>A</b>. See <a href="ACL2____RULE-CLASSES.html">rule-classes</a> and read about 
 the <span class="v">:corollary</span> modifier.</p> 
 
 <p><b>Q</b>. What is a <b>type-prescription</b>?  <b>A</b>. ACL2 has an 
 algorithm for determining the type of object returned by a term, where a type 
 is one of the Common Lisp primitive datatypes such as natural, integer, 
 Boolean, cons, true-listp, etc.  Rules provided by you can influence this 
 algorithm.  See <a href="ACL2____TYPE-PRESCRIPTION.html">type-prescription</a>.</p> 
 
 <p><b>Q</b>. How do <b>rewrite rules work</b>?  <b>A</b>. Re-read the tutorial 
 sections: <a href="ACL2____INTRODUCTION-TO-REWRITE-RULES-PART-1.html">introduction-to-rewrite-rules-part-1</a> and <a href="ACL2____INTRODUCTION-TO-REWRITE-RULES-PART-2.html">introduction-to-rewrite-rules-part-2</a>.</p> 
 
 <p><b>Q</b>. How do I <b>see what's in the database</b>?  <b>A</b>. You can't 
 look at the entire database with user-friendly tools.  You can print the 
 command that introduced a particular name, print the entire sequence of user 
 commands, print the commands in the region between two commands, print all the 
 rewrite rules that apply to a given term or function symbol, and many other 
 options.  See <a href="ACL2____HISTORY.html">history</a>.  If you have loaded a book from another user, 
 you might wish to read the source file.  For example, the source file for 
 <span class="v">(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "arithmetic-5/top" :dir :system)</span> is the file named 
 <span class="v">arithmetic-5/top.lisp</span> on the <span class="v">acl2-sources/books/</span> directory where 
 ever your ACL2 sources are installed.  Often, books are well-documented by 
 comments by their authors.  Some books have <span class="v">Readme</span> or <span class="v">README</span> files 
 on the same directory.</p> 
 
 <p><b>Q</b>. How do I <b>undo</b> a command?  <b>A</b>. See <a href="ACL2____HISTORY.html">history</a>, 
 especially see <a href="ACL2____U.html">u</a> (``undo'') and see <a href="ACL2____UBT.html">ubt</a> (``undo back 
 through''). <b>Q</b>. What <b>rewrite rules match</b> a given term? 
 <b>A</b>. See <a href="ACL2____PL.html">pl</a>.</p> 
 
 <p><b>Q</b>.  What were those <b>questions to ask when looking at key 
 checkpoints</b>?  <b>A</b>.  See <a href="ACL2____INTRODUCTION-TO-KEY-CHECKPOINTS.html">introduction-to-key-checkpoints</a>.</p> 
 
 <p><b>Q</b>. How do I figure out <b>why a rewrite rule won't fire</b>? 
 <b>A</b>. If you activate rewrite rule monitoring (see <a href="ACL2____BRR.html">brr</a>) and then 
 install a monitor (see <a href="ACL2____MONITOR.html">monitor</a>) on the rule in question, ACL2 will 
 enter an interactive break whenever the pattern of the rule is matched against 
 a target in a proof.  So after installing the monitor, re-try the proof and 
 then interact with the rewriter via break commands (see <a href="ACL2____BRR-COMMANDS.html">brr-commands</a>). 
 Like all trace and break packages, you have to know what you're doing to use 
 the break rewrite facility, so read the material in the reference manual.  If 
 no interactive break happens after you've installed the monitor on your rule 
 and re-tried the proof, it means no suitable target ever arose.  Don't forget 
 to turn off monitoring when you're done as it slows down the system.</p> 
 
 <p><b>Q</b>. <b>Why is a proof taking so long?</b> <b>A</b>. Unexpectedly poor 
 performance on simple problems is usually a sign of cyclic rewriting or 
 combinatoric explosion.  See <a href="ACL2____DMR.html">dmr</a> and see <a href="ACL2____ACCUMULATED-PERSISTENCE.html">accumulated-persistence</a>.</p> 
 
 <p><b>Q</b>. How do I tell ACL2 <b>what induction to do</b> for a particular 
 formula?  <b>A</b>. When issuing the <span class="v">defthm</span> command for the formula, 
 supply an <span class="v">:induct</span> hint:</p> 
 
 <pre class="code">(defthm <i>name</i> 
        <i>formula</i> 
        :hints (("Goal" :induct (f x1 ... xn)))) 
</pre> 
 
 <p>where <span class="v">f</span> is a function that recurs the way you want the induction to 
 unfold and <span class="v">x1 ... xn</span> are the relevant variables in <i>formula</i>.  You 
 usually have to define <span class="v">f</span> appropriately for each formula that needs an 
 induct hint, though sometimes you can re-use an earlier <span class="v">f</span> or one of the 
 functions in the formula itself.  It doesn't matter what value <span class="v">(f x1
 ... xn)</span> returns.  All that matters is how it recurs.  The termination 
 analysis for <span class="v">f</span> justifies the induction done.  See <a href="ACL2____HINTS.html">hints</a>, 
 especially the section on <span class="v">:induct</span> hints; also see <a href="ACL2____INDUCTION.html">induction</a>.</p> 
 
 <p><b>Q</b>. ACL2 doesn't know <b>simple arithmetic</b> that can simplify the 
 term <span class="v">(<a href="COMMON-LISP_____B2.html">+</a> 1 -1 x)</span>.  <b>A</b>.  You should load an arithmetic book whenever 
 you're dealing with an arithmetic problem.  The simplest arithmetic book is 
 typically loaded with the event <span class="v">(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "arithmetic/top-with-meta"
 :dir :system)</span>.  If you're using <span class="v">floor</span> and <span class="v">mod</span> or non-linear 
 arithmetic like <span class="v">(<a href="COMMON-LISP_____A2.html">*</a> x y)</span> you should use <span class="v">(<a href="ACL2____INCLUDE-BOOK.html">include-book</a>
 "arithmetic-5/top" :dir :system)</span>.  See also the discussion of arithmetic 
 books under the ``Lemma Libraries and Utilities'' link of the ACL2 home page, 
 and see <a href="ACL2____COMMUNITY-BOOKS.html">community-books</a>.</p> 
 
 <p><b>Q</b>. ACL2 is not using an <b>arithmetic lemma</b> that I proved. 
 <b>A</b>. Lemmas concluding with arithmetic inequalities, like</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____MEMBER.html">member</a> e x)
         (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____LEN.html">len</a> (delete e x)) (<a href="ACL2____LEN.html">len</a> x)))</pre> 
 
 <p>are not good rewrite rules because they rarely match targets because of 
 intervening arithmetic operators.  For example, the above conclusion doesn't 
 match <span class="v">(<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____LEN.html">LEN</a> (DELETE E X)) (<a href="COMMON-LISP_____B2.html">+</a> 1 (<a href="ACL2____LEN.html">LEN</a> X)))</span>.  You should store such lemmas 
 as <span class="v">:linear</span> rules by using the command:</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> len-delete
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____MEMBER.html">member</a> e x)
           (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____LEN.html">len</a> (delete e x)) (<a href="ACL2____LEN.html">len</a> x)))
  :rule-classes :linear)</pre> 
 
 <p>See <a href="ACL2____LINEAR.html">linear</a>.</p> 
 
 <p><b>Q</b>.  What is a <b>linear rule</b>?  <b>A</b>.  See <a href="ACL2____LINEAR.html">linear</a>.</p> 
 
 <p><b>Q</b>. How do I make ACL2 <b>treat a relation as an equality</b>? 
 <b>A</b>. We assume you mean to treat the relation as an equivalence, i.e., 
 replace one term by another when they are equivalent under your relation.  See 
 <a href="ACL2____EQUIVALENCE.html">equivalence</a>, see <a href="ACL2____CONGRUENCE.html">congruence</a>, and see <a href="ACL2____REFINEMENT.html">refinement</a>.</p> 
 
 <p><b>Q</b>. One of my rewrite rules has a <b>hypothesis that doesn't 
 rewrite</b> to true.  What do I do?  <b>A</b>. Prove a rewrite rule that 
 establishes that hypothesis under the relevant assumptions from the context of 
 the intended target.  Alternatively, undo the rule and restate it with a 
 <span class="tt"><a href="ACL2____FORCE.html">force</a></span> around the problematic hypothesis, making ACL2 assume the 
 hypothesis when the rule is applied and raising the truth of the hypothesis as 
 an explicit subgoal of the proof.  See also <span class="tt"><a href="ACL2____CASE-SPLIT.html">case-split</a></span>.  Of course, 
 you should always state the strongest rewrite rules you can think of, 
 eliminating hypotheses or shifting them to the right-hand side inside of 
 <span class="v">IF</span>s; see <a href="ACL2____STRONG-REWRITE-RULES.html">strong-rewrite-rules</a>.</p> 
 
 <p><b>Q</b>. How do I make ACL2 ``guess'' the <b>right instantiation of a free 
 variable</b>?  <b>A</b>. You can provide a <span class="v">:restrict</span> hint that names the 
 problematic lemma and provides an instantiation of the free variable.  See 
 <a href="ACL2____HINTS.html">hints</a>, specifically <span class="v">:restrict</span>.  You could alternatively give a 
 hint that <span class="v">:uses</span> the rule and provides the appropriate instantiation in 
 full.  See <a href="ACL2____HINTS.html">hints</a>, specifically <span class="v">:use</span>.  Recall that ACL2 guesses 
 free variable instantiations by matching the problematic hypothesis to the 
 assumptions in the context of the target.  If the appropriate assumption is 
 present but ACL2 is finding another one, try undoing the problematic rule and 
 proving it again, specifying the <span class="v">:match-free :all</span> modifier of the 
 <span class="v">:rewrite</span> or <span class="v">:linear</span> rule class.  See <a href="ACL2____RULE-CLASSES.html">rule-classes</a>. 
 Alternatively, undo and prove the problematic rule again and use a <span class="tt"><a href="ACL2____BIND-FREE.html">bind-free</a></span> form to compute the appropriate instantiation.</p> 
 
 <p><b>Q</b>. How can I make ACL2 do a <b>case split</b> to prove a certain 
 subgoal?  <b>A</b>. See <a href="ACL2____HINTS.html">hints</a>, specifically <span class="v">:cases</span>.</p> 
 
 <p><b>Q</b>. How can I <b>prevent ACL2 from using a rewrite rule</b>? 
 <b>A</b>.  See <a href="ACL2____HINTS.html">hints</a>, specifically <span class="v">:in-theory (<a href="ACL2____DISABLE.html">disable</a> ...)</span>.  If 
 the use of the rule is problematic in only one subgoal and the lemma is needed 
 in other subgoals, disable the lemma only in the problematic subgoal by 
 specifying the subgoal name (e.g., <span class="v">"Subgoal 1/3.2.1"</span>) as the goal 
 specifier in the hint.  If the rule isn't needed anywhere in the proof, you 
 could use the specifier <span class="v">"Goal"</span>.  If you don't think the rule will ever 
 be needed for a while, you could globally disable it with the event 
 <span class="v">(<a href="ACL2____IN-THEORY.html">in-theory</a> (<a href="ACL2____DISABLE.html">disable</a> ...))</span>  (see <a href="ACL2____IN-THEORY.html">in-theory</a>) executed before the 
 first problematic proof.  If the rule has never been used or must always be 
 disabled, undo it and prove it again with <span class="v">:</span><span class="tt"><a href="ACL2____RULE-CLASSES.html">rule-classes</a></span> 
 <span class="v">nil</span>.</p> 
 
 <p><b>Q</b>.  How can I prevent ACL2 from running a definition on constants? 
 I tried disabling the function but that didn't work.  <b>A</b>.  If you have a 
 function named <span class="v">f</span> then disabling <span class="v">f</span> will disable the definitional 
 axiom about <span class="v">f</span>.  But ACL2 has another kind of rule about <span class="v">f</span>, telling 
 it how to evaluate <span class="v">f</span>.  The <a href="ACL2____RUNE.html">rune</a> of this rule is 
 <span class="v">(:executable-counterpart f)</span>.  Try disabling that, as in the <span class="v">:</span><span class="tt"><a href="ACL2____HINTS.html">hints</a></span> <span class="v">((</span>...  <span class="v">:in-theory (<a href="ACL2____DISABLE.html">disable</a> (:executable-counterpart f))
 ...c[))</span>.</p> 
 
 <p><b>Q</b>. How can I make ACL2 <b>use a rule</b> in a proof?  <b>A</b>. See 
 <a href="ACL2____HINTS.html">hints</a>, specifically <span class="v">:use</span>.</p> 
 
 <p><b>Q</b>.  How can I make ACL2 expand a function call in a proof? 
 <b>A</b>.  You can give an <span class="v">:</span>See <a href="ACL2____EXPAND.html">expand</a> hint.</p> 
 
 <p><b>Q</b>.  ACL2 sometimes aborts the proof attempt before showing me all of 
 the subgoals.  How can I make it just keep going instead of aborting early? 
 <b>A</b>. See <a href="ACL2____OTF-FLG.html">otf-flg</a>, which stands for Onward Thru the Fog FLaG.</p> 
 
 <p><b>Q</b>. How can I <b>compute when I want a rule to fire</b>?  <b>A</b>. 
 See <a href="ACL2____SYNTAXP.html">syntaxp</a>.</p> 
 
 <p><b>Q</b>.  How can I add <b>pragmatic advice to a lemma after it has been 
 proved</b>?  For example, how can add a forced hypothesis, a backchain limit, 
 or a <span class="v">syntaxp</span> test?  <b>A</b>.  You can't.  You can undo the lemma, 
 restate it appropriately, and prove it again.  This produces the cleanest 
 database.  Alternatively, you can prove the restated lemma under a new name 
 â€” a task that should be easy since the old version is in the database 
 and will presumably make the proof trivial â€” and then disable the old 
 name.</p> 
 
 <p><b>Q</b>. How can I <b>stop ACL2 from rewriting a term</b>?  <b>A</b>. If 
 you need rewriting done but want to prevent some particular terms from being 
 rewritten, see <a href="ACL2____HINTS.html">hints</a>, specifically <span class="v">:hands-off</span>.  Alternatively, 
 consider embedding the problematic term in a <span class="tt"><a href="ACL2____HIDE.html">hide</a></span>.  Users sometime 
 develop special theories (see <a href="ACL2____THEORY.html">theory</a>) containing just the rules they 
 want and then use hints to switch to those theories on the appropriate 
 subgoals.</p> 
 
 <p><b>Q</b>.  Can I <b>compute which subgoals a hint refers to</b>?  <b>A</b>. 
 Yes, see <a href="ACL2____COMPUTED-HINTS.html">computed-hints</a>.  This topic is for advanced users but knowing 
 that it is possible might come in handy someday.</p> 
 
 <p><b>Q</b>.  I want the rewriter to <b>always use one theory and then switch 
 to another</b> so that it doesn't use my most complicated before until doing 
 the simple things.  <b>A</b>.  This is possible but is something for the 
 advanced user.  It can be done using a form of <a href="ACL2____COMPUTED-HINTS.html">computed-hints</a>.  See 
 <a href="ACL2____USING-COMPUTED-HINTS-7.html">using-computed-hints-7</a>.</p> 
 
 <p><b>Q</b>.  Is there a way to attach <b>the same hint to every defthm</b>? 
 <b>A</b>.  See <a href="ACL2____DEFAULT-HINTS.html">default-hints</a>.</p> 
 
 <p><b>Q</b>.  How can I just tell ACL2 the proof steps?  <b>A</b>.  See <a href="ACL2____VERIFY.html">verify</a> and see <a href="ACL2____PROOF-BUILDER.html">proof-builder</a>.</p> 
 
 <p><b>Q</b>. How can I write <b>my own simplifier</b>?  <b>A</b>.  See <a href="ACL2____META.html">meta</a>.</p> 
 
 <p><b>Q</b>. How can I add an axiom or just assume some lemma without proof? 
 <b>A</b>. This is very dangerous but is a good strategy for exploring whether 
 or not a certain set of lemmas (and their rules) is sufficient to prove your 
 goal.  See <a href="ACL2____DEFAXIOM.html">defaxiom</a> and see <a href="ACL2____SKIP-PROOFS.html">skip-proofs</a>.</p> 
 
 <p><b>Q</b>. How can redefine a user-defined function?  <b>A</b>.  This is 
 tricky.  What if you've already proved theorems about the old definition and 
 then wish to change it?  There are several options.  See <a href="ACL2____LD-REDEFINITION-ACTION.html">ld-redefinition-action</a> (and note specifically the discussion of updater 
 function for it, <span class="v">set-ld-redefinition-action</span>); also see <a href="ACL2____REDEF.html">redef</a>, see 
 <a href="ACL2____REDEF_12.html">redef!</a>, see <a href="ACL2____REDEF_B2.html">redef+</a>, and see <a href="ACL2____REDEF-.html">redef-</a>.</p> 
 
 <p><b>Q</b>. How do I <b>change a function from</b> <span class="v">:program</span> <b>mode 
 to</b> <span class="v">:logic</span> <b>mode</b>?  <b>A</b>. See <a href="ACL2____VERIFY-TERMINATION.html">verify-termination</a>.</p> 
 
 <p><b>Q</b>. How do I <b>change the guards</b> on a function?  <b>A</b>. You 
 can't.  Undo it and redefine it.</p> 
 
 <p><b>Q</b>. What is <b>program mode</b>?  <b>A</b>. See <a href="ACL2____PROGRAM.html">program</a>.</p> 
 
 <p><b>Q</b>. What does the ACL2 <b>prompt</b> mean?  <b>A</b>.  See <a href="ACL2____INTRODUCTION-TO-A-FEW-SYSTEM-CONSIDERATIONS.html">introduction-to-a-few-system-considerations</a> or, specifically, see <a href="ACL2____PROMPT.html">prompt</a>.</p> 
 
 <p><b>Q</b>. What is <b>logic mode</b>?  <b>A</b>. See <a href="ACL2____LOGIC.html">logic</a>.</p> 
 
 <p><b>Q</b>. How do I <b>get into or out of</b> <span class="v">:program</span> <b>mode?</b> 
 <span class="v">:Logic</span> <b>mode?</b> <b>A</b>. See <a href="ACL2____PROGRAM.html">program</a> and see <a href="ACL2____LOGIC.html">logic</a>. 
 You can enter these modes temporarily for a particular <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> by using 
 <span class="v">(<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :mode :program))</span> or <span class="v">(<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :mode :logic))</span> 
 after the list of formal parameters to the definition.</p> 
 
 <p><b>Q</b>.  How do I quit from ACL2?  <b>A</b>.  This varies depending on 
 the interface you're using.  See <a href="ACL2____INTRODUCTION-TO-A-FEW-SYSTEM-CONSIDERATIONS.html">introduction-to-a-few-system-considerations</a>.</p> 
 
 <p><b>Q</b>. How do I <b>load a file</b> of definitions and theorems created 
 by someone else?  <b>A</b>. See <a href="ACL2____INCLUDE-BOOK.html">include-book</a>.</p> 
 
 <p><b>Q</b>. How do I <b>create my own book</b> of definitions and theorems? 
 <b>A</b>. See <a href="ACL2____BOOKS.html">books</a>.</p> 
 
 <p><b>Q</b>. Where are the books referenced by <b>:dir :system</b> on my 
 machine?  <b>A</b>. If your ACL2 is installed on the directory 
 <i>dir</i><span class="v">/acl2-sources</span> and you follow the standard installation 
 instructions, then the books are typically the files under the directory 
 <i>dir</i><span class="v">/acl2-sources/books/</span>.</p> 
 
 <p><b>Q</b>. How can I find out <b>what books are available</b>?  <b>A</b>. Go 
 to the ACL2 home page, <span class="v">http://www.cs.utexas.edu/u/moore/acl2/</span> and look at 
 the link labeled ``Lemma Libraries and Utilities.''</p> 
 
 <p><b>Q</b>. How do I <b>produce my own book</b>?  <b>A</b>. See <a href="ACL2____BOOKS.html">books</a>.</p> 
 
 <p><b>Q</b>. What is a <b>decision procedure</b>?  What <b>decision procedures 
 does ACL2 have</b>?  <b>A</b>. A <i>decision procedure</i> is an algorithm 
 that given enough time and space can determine, for all the formulas in a 
 certain syntactic class of formulas, whether the formula is a theorem or not. 
 The most well-known decision procedure is for propositional calculus: by 
 testing a formula under all the combinations Boolean assignments to the 
 variables, one can decide if a propositional formula is a theorem.  The 
 syntactic class consists of all formulas you can write using just variables, 
 constants, and compositions of the functions <span class="v">and</span>, <span class="v">or</span>, <span class="v">not</span>, 
 <span class="v">implies</span>, <span class="v">iff</span>, and <span class="v">if</span>.  There are, of course, an exponential 
 number of different assignments so the algorithm can be slow.  ACL2 contains a 
 propositional decision procedure based on symbolic normalization that can be 
 faster than trying all the combinations of truth values â€” but is not 
 guaranteed to be faster.  ACL2 also contains an optional <a href="ACL2____BDD.html">bdd</a> procedure. 
 ACL2 also contains a decision procedure for rational arithmetic involving 
 variables, rational constants, addition, multiplication by rational constants, 
 equality, and the various versions of arithmetic inequality (<span class="v">&lt;</span>, <span class="v">&lt;=</span>, 
 <span class="v">&gt;=</span>, and <span class="v">&gt;</span>).  It can be extended with <span class="v">:</span><span class="tt"><a href="ACL2____LINEAR.html">linear</a></span> lemmas. 
 ACL2 is complete for equality over uninterpreted (e.g., undefined and 
 unconstrained) function symbols using an algorithm based on transitive closure 
 of equivalence classes under functional substitutivity.  Finally, you can make 
 ACL2 use other decision procedures, even ones implemented outside of ACL2; see 
 <a href="ACL2____CLAUSE-PROCESSOR.html">clause-processor</a>.</p> 
 
 <p><b>Q</b>. ACL2 has the <b>change of variable</b> trick (<b>destructor 
 elimination</b>) that it does to get rid of <span class="v">(<a href="COMMON-LISP____CAR.html">CAR</a> X)</span> and <span class="v">(<a href="COMMON-LISP____CDR.html">CDR</a> X)</span> by 
 replacing <span class="v">x</span> by <span class="v">(<a href="COMMON-LISP____CONS.html">CONS</a> A B)</span>.  Is there a way to make ACL2 do that for 
 other terms?  <b>A</b>. Yes.  See <a href="ACL2____ELIM.html">elim</a>.</p> 
 
 <p><b>Q</b>. How can I <b>prevent destructor elimination</b>?  <b>A</b>. See 
 <a href="ACL2____HINTS.html">hints</a>, specifically <span class="v">:do-not '(eliminate-destructors)</span>.</p> 
 
 <p><b>Q</b>. How can I <b>prevent cross-fertilization</b>?  <b>A</b>. See 
 <a href="ACL2____HINTS.html">hints</a>, specifically <span class="v">:do-not '(fertilize)</span>.</p> 
 
 <p><b>Q</b>. How can I <b>prevent generalization</b>?  <b>A</b>. See <a href="ACL2____HINTS.html">hints</a>, specifically <span class="v">:do-not '(<a href="ACL2____GENERALIZE.html">generalize</a>)</span>.</p> 
 
 <p><b>Q</b>. How can I make ACL2 <b>impose a restriction on a new variable</b> 
 introduced by destructor elimination or generalization?  <b>A</b>.  See <a href="ACL2____GENERALIZE.html">generalize</a>.</p> 
 
 <p><b>Q</b>. What <b>rule classes</b> are there?  <b>A</b>. See <a href="ACL2____RULE-CLASSES.html">rule-classes</a>.</p> 
 
 <p><b>Q</b>. What is a <b>theory</b>?  <b>A</b>. See <a href="ACL2____THEORIES.html">theories</a>.</p> 
 
 <p><b>Q</b>. How are <b>hints inherited by the children of a subgoal</b>? 
 <b>A</b>. See <a href="ACL2____HINTS-AND-THE-WATERFALL.html">hints-and-the-waterfall</a>.</p> 
 
 <p><b>Q</b>.  How do I use ACL2 under <b>Emacs</b>?  <b>A</b>. See <a href="ACL2____EMACS.html">emacs</a>.</p> 
 
 <p><b>Q</b>.  How do I use ACL2 under <b>Eclipse</b>?  <b>A</b>. See <a href="ACL2____ACL2-SEDAN.html">ACL2-Sedan</a>.</p> 
 
 <p><b>Q</b>.  How do I interrupt the prover?  <b>A</b>.  The keyboard sequence 
 for interrupting a running process depends your operating system, host Common 
 Lisp, and user interface (e.g., Emacs, Eclipse, etc.).  But perhaps a few 
 examples will help you discover what you need to know.  If your host Common 
 Lisp is GCL or Allegro and you are typing directly to the Common Lisp process, 
 then you can interrupt a computation by typing ``ctrl-c'' (hold down the 
 Control key and hit the ``c'' key once).  But other Lisps may require some 
 other control sequence.  If you are typing to an Emacs process which is 
 running the GCL or Allegro Common Lisp process in a shell buffer, you should 
 type ctrl-c ctrl-c â€” that is, you have to type the previously mentioned 
 sequence twice in succession.  If you are running the ACL2 Sedan, you can use 
 the <i>Interrupt Session</i> button on the tool bar.  The environment you 
 enter when you interrupt depends on various factors and basically you should 
 endeavor to get back to the top level ACL2 command loop, perhaps by typing 
 some kind of Lisp dependent ``abort'' command like <span class="v">:q</span> or <span class="v">:a</span>.  You 
 can usually determine what environment you're in by paying attention to the 
 prompt.</p> 
 
 <p><b>Q</b>.  What is the <b>ACL2 loop</b>?  <b>A</b>.  That is the name given 
 to the interactive environment ACL2 provides, a ``read-eval-print loop'' in 
 which the user submits successive commands by typing ACL2 expressions and 
 keyword commands.  See <a href="ACL2____INTRODUCTION-TO-A-FEW-SYSTEM-CONSIDERATIONS.html">introduction-to-a-few-system-considerations</a>.</p> 
 
 <p><b>Q</b>.  What is <b>raw lisp</b>?  <b>A</b>.  That is our name for the 
 host Common Lisp in which ACL2 is implemented.  See <a href="ACL2____INTRODUCTION-TO-A-FEW-SYSTEM-CONSIDERATIONS.html">introduction-to-a-few-system-considerations</a>.  There is an ACL2 mode named 
 <i>raw mode</i> which is different from ``raw lisp.''  See <a href="ACL2____SET-RAW-MODE.html">set-raw-mode</a>.</p> 
 
 <p><b>Q</b>.  Can I get a tree-like view of a proof?  <b>A</b>.  See <a href="ACL2____PROOF-TREE.html">proof-tree</a> for an Emacs utility that displays proof trees and allows you to 
 navigate through a proof from the proof tree.  The ACL2 Sedan also supports 
 proof trees and you should see the ACL2s documentation on that topic.</p> 
 
 <p><b>Q</b>.  I used the earlier Boyer-Moore theorem prover, Nqthm.  How is 
 ACL2 different?  <b>A</b>. See <a href="ACL2____NQTHM-TO-ACL2.html">nqthm-to-ACL2</a>.</p> 
 
 <p>If you are reading this as part of the tutorial introduction to the theorem 
 prover, use your browser's <b>Back Button</b> now to return to <a href="ACL2____INTRODUCTION-TO-THE-THEOREM-PROVER.html">introduction-to-the-theorem-prover</a>.</p>
</body>
</html>
