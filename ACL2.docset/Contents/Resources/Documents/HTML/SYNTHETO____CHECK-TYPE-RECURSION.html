<html>
<head>
<meta charset="UTF-8">
<title>Check-type-recursion</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=SYNTHETO____CHECK-TYPE-RECURSION">Click for Check-type-recursion in the Full Manual</a></h3>

<p>Check if a type recursion is statically well-formed.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(check-type-recursion typerec ctxt) → (mv err? obligs)</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">typerec</span> — <font color="#606060">Guard <span class="v">(<a href="SYNTHETO____TYPE-RECURSIONP.html">type-recursionp</a> typerec)</span>.</font>
</dd> 
  <dd>
<span class="tt">ctxt</span> — <font color="#606060">Guard <span class="v">(<a href="SYNTHETO____CONTEXTP.html">contextp</a> ctxt)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">obligs</span> — <font color="#606060">Type <span class="v">(<a href="SYNTHETO____PROOF-OBLIGATION-LISTP.html">proof-obligation-listp</a> obligs)</span>.</font>
</dd> 
 
</dl></div> 
<p>A type recursion is a top-level construct, 
     so the context has no 
     types or functions being defined, 
     no variables in scope, 
     and no obligation variables and hypotheses. 
     This motivates the guard of this ACL2 function.</p><p>We ensure that there are at least two types 
     and that their names are all distinct. 
     We add the names to the context and we check the type definitions.</p><p>For now we allow any form of mutual recursion, 
     but we will add check to constrain the allowed forms 
     so that we can generate ACL2 termination proofs. 
     For now, ACL2 will stop with an error if it cannot prove termination.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>check-type-recursion</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 check-type-recursion (typerec ctxt)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SYNTHETO____TYPE-RECURSIONP.html">type-recursionp</a> typerec)
                             (<a href="SYNTHETO____CONTEXTP.html">contextp</a> ctxt))))
 (<a href="COMMON-LISP____DECLARE.html">declare</a>
      (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NULL.html">null</a> (<a href="SYNTHETO____CONTEXT-_E3TYPES.html">context-&gt;types</a> ctxt))
                         (<a href="COMMON-LISP____NULL.html">null</a> (<a href="SYNTHETO____CONTEXT-_E3FUNCTIONS.html">context-&gt;functions</a> ctxt))
                         (<a href="OMAP____EMPTY.html">omap::empty</a> (<a href="SYNTHETO____CONTEXT-_E3VARIABLES.html">context-&gt;variables</a> ctxt))
                         (<a href="COMMON-LISP____NULL.html">null</a> (<a href="SYNTHETO____CONTEXT-_E3OBLIGATION-VARS.html">context-&gt;obligation-vars</a> ctxt))
                         (<a href="COMMON-LISP____NULL.html">null</a> (<a href="SYNTHETO____CONTEXT-_E3OBLIGATION-HYPS.html">context-&gt;obligation-hyps</a> ctxt)))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((__function__ 'check-type-recursion))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
  (<a href="ACL2____B_A2.html">b*</a> ((typedefs (<a href="SYNTHETO____TYPE-RECURSION-_E3DEFINITIONS.html">type-recursion-&gt;definitions</a> typerec))
       (names (<a href="SYNTHETO____TYPE-DEFINITION-LIST-_E3NAME-LIST.html">type-definition-list-&gt;name-list</a> typedefs))
       ((unless (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> (<a href="ACL2____LEN.html">len</a> names) 2))
        (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____LIST.html">list</a> :type-recursion-with-less-than-two-types typedefs)
            nil))
       ((unless (<a href="ACL2____NO-DUPLICATESP-EQUAL.html">no-duplicatesp-equal</a> names))
        (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____LIST.html">list</a> :duplicate-recursive-types names)
            nil))
       (ctxt (<a href="SYNTHETO____CHANGE-CONTEXT.html">change-context</a> ctxt :types names)))
      (<a href="SYNTHETO____CHECK-TYPE-DEFINITION-LIST-IN-RECURSION.html">check-type-definition-list-in-recursion</a> typedefs ctxt))))</pre> 
<p><b>Theorem: </b>proof-obligation-listp-of-check-type-recursion.obligs</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> proof-obligation-listp-of-check-type-recursion.obligs
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?err? ?obligs)
              (<a href="SYNTHETO____CHECK-TYPE-RECURSION.html">check-type-recursion</a> typerec ctxt)))
            (<a href="SYNTHETO____PROOF-OBLIGATION-LISTP.html">proof-obligation-listp</a> obligs))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>check-type-recursion-of-type-recursion-fix-typerec</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> check-type-recursion-of-type-recursion-fix-typerec
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____CHECK-TYPE-RECURSION.html">check-type-recursion</a> (<a href="SYNTHETO____TYPE-RECURSION-FIX.html">type-recursion-fix</a> typerec)
                                     ctxt)
               (<a href="SYNTHETO____CHECK-TYPE-RECURSION.html">check-type-recursion</a> typerec ctxt)))</pre> 
<p><b>Theorem: </b>check-type-recursion-type-recursion-equiv-congruence-on-typerec</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     check-type-recursion-type-recursion-equiv-congruence-on-typerec
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SYNTHETO____TYPE-RECURSION-EQUIV.html">type-recursion-equiv</a> typerec typerec-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____CHECK-TYPE-RECURSION.html">check-type-recursion</a> typerec ctxt)
                     (<a href="SYNTHETO____CHECK-TYPE-RECURSION.html">check-type-recursion</a> typerec-equiv ctxt)))
     :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>check-type-recursion-of-context-fix-ctxt</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> check-type-recursion-of-context-fix-ctxt
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____CHECK-TYPE-RECURSION.html">check-type-recursion</a> typerec (<a href="SYNTHETO____CONTEXT-FIX.html">context-fix</a> ctxt))
               (<a href="SYNTHETO____CHECK-TYPE-RECURSION.html">check-type-recursion</a> typerec ctxt)))</pre> 
<p><b>Theorem: </b>check-type-recursion-context-equiv-congruence-on-ctxt</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> check-type-recursion-context-equiv-congruence-on-ctxt
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SYNTHETO____CONTEXT-EQUIV.html">context-equiv</a> ctxt ctxt-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SYNTHETO____CHECK-TYPE-RECURSION.html">check-type-recursion</a> typerec ctxt)
                        (<a href="SYNTHETO____CHECK-TYPE-RECURSION.html">check-type-recursion</a> typerec ctxt-equiv)))
        :rule-classes :congruence)</pre> 

</body>
</html>
