<html>
<head>
<meta charset="UTF-8">
<title>Pedersen-segment-scalar-bound</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ZCASH____PEDERSEN-SEGMENT-SCALAR-BOUND">Click for Pedersen-segment-scalar-bound in the Full Manual</a></h3>

<p>Bound on the value of <span class="tt"><a href="ZCASH____PEDERSEN-SEGMENT-SCALAR.html">pedersen-segment-scalar</a></span>.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(pedersen-segment-scalar-bound segment) → bound</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">segment</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____BIT-LISTP.html">bit-listp</a> segment)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">bound</span> — <font color="#606060">Type <span class="v">(<a href="ACL2____NATP.html">natp</a> bound)</span>.</font>
</dd> 
 
</dl></div> 
<p>Theorem 5.4.1 in [ZPS:5.4.1.7] defines @$(\Delta$) as 
     a bound on the value of the encoding function \langle\cdot\rangle: 
     the value of the function is between -\Delta and \Delta. 
     In [ZPS], \Delta is a constant because \langle\cdot\rangle 
     is defined over segments of maximum size 3c. 
     However, our <span class="tt"><a href="ZCASH____PEDERSEN-SEGMENT-SCALAR.html">pedersen-segment-scalar</a></span> is more generally defined 
     over segments of any length that is a multiple of 3. 
     Accordingly, we define a function that expresses \Delta 
     in terms of (the length of) the segment. 
     Since <span class="tt"><a href="ZCASH____PEDERSEN-SEGMENT-SCALAR.html">pedersen-segment-scalar</a></span> is defined in terms of 
     an auxiliary recursive function that is defined even more generally 
     over not only a segment of length multiple of 3 
     but also the index j of the chunk of 3 bits, 
     we also introduce a function that expresses 
     the bound on the recursive function.</p><p>Based on the summation that defines \Delta in [ZPS], 
     we define the bound for the recursive function 
     by recursively adding 4\cdot2^{4\cdot(j-1)} 
     while j is incremented until there is no 3-bit chunk left. 
     The bound for <span class="tt"><a href="ZCASH____PEDERSEN-SEGMENT-SCALAR.html">pedersen-segment-scalar</a></span> is obtained from that 
     by setting j to 1.</p><p>To prove that these are actual bounds, 
     we start with a proof by induction for the recursive function and bound. 
     We need a lemma about the length of <span class="v">(<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> 3 x)</span> being a multiple of 3 
     when the length of <span class="v">x</span> is: 
     this serves to relieve the hypothesis of the induction hypothesis. 
     We also need a lemma saying that <span class="v">(<a href="ACL2____TAKE.html">take</a> 3 segment)</span> is a list of bits 
     under the hypothesis of the theorem: 
     this is needed for the base case, 
     to relieve the hypothesis of the bound rules of <span class="tt"><a href="ZCASH____PEDERSEN-ENC.html">pedersen-enc</a></span>. 
     (These two lemmas are at the beginning of this file.) 
     We also need a few arithmetic lemmas 
     to nudge the proof in the right direction. 
     (These arithmetic lemmas are below.) 
     With linear bound rules for the recursive function in hand, 
     the bound proofs for <span class="tt"><a href="ZCASH____PEDERSEN-SEGMENT-SCALAR.html">pedersen-segment-scalar</a></span> are automatic.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>pedersen-segment-scalar-loop-bound</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 pedersen-segment-scalar-loop-bound
 (j segment)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____POSP.html">posp</a> j) (<a href="ACL2____BIT-LISTP.html">bit-listp</a> segment))))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____INTEGERP.html">integerp</a> (<a href="COMMON-LISP_____F2.html">/</a> (<a href="ACL2____LEN.html">len</a> segment) 3))))
 (<a href="COMMON-LISP____LET.html">let</a>
     ((__function__ 'pedersen-segment-scalar-loop-bound))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
     (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____CONSP.html">consp</a> segment)
         (<a href="COMMON-LISP_____B2.html">+</a> (<a href="COMMON-LISP_____A2.html">*</a> 4 (<a href="COMMON-LISP____EXPT.html">expt</a> 2 (<a href="COMMON-LISP_____A2.html">*</a> 4 (<a href="COMMON-LISP____1-.html">1-</a> j))))
            (pedersen-segment-scalar-loop-bound (<a href="COMMON-LISP____1_B2.html">1+</a> j)
                                                (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> 3 segment)))
         0)))</pre> 
<p><b>Theorem: </b>natp-of-pedersen-segment-scalar-loop-bound</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   natp-of-pedersen-segment-scalar-loop-bound
   (<a href="ACL2____IMPLIES.html">implies</a>
        (<a href="ACL2____POSP.html">posp</a> j)
        (<a href="ACL2____B_A2.html">b*</a> ((bound (pedersen-segment-scalar-loop-bound j segment)))
            (<a href="ACL2____NATP.html">natp</a> bound)))
   :rule-classes :rewrite)</pre> 
<p><b>Function: </b>pedersen-segment-scalar-bound</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> pedersen-segment-scalar-bound (segment)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____BIT-LISTP.html">bit-listp</a> segment)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____INTEGERP.html">integerp</a> (<a href="COMMON-LISP_____F2.html">/</a> (<a href="ACL2____LEN.html">len</a> segment) 3))))
       (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'pedersen-segment-scalar-bound))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
            (pedersen-segment-scalar-loop-bound 1 segment)))</pre> 
<p><b>Theorem: </b>natp-of-pedersen-segment-scalar-bound</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> natp-of-pedersen-segment-scalar-bound
        (<a href="ACL2____B_A2.html">b*</a> ((bound (<a href="ZCASH____PEDERSEN-SEGMENT-SCALAR-BOUND.html">pedersen-segment-scalar-bound</a> segment)))
            (<a href="ACL2____NATP.html">natp</a> bound))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>pedersen-segment-scalar-loop-upper-bound</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     pedersen-segment-scalar-loop-upper-bound
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____POSP.html">posp</a> j)
                   (<a href="ACL2____BIT-LISTP.html">bit-listp</a> segment)
                   (<a href="COMMON-LISP____INTEGERP.html">integerp</a> (<a href="COMMON-LISP_____F2.html">/</a> (<a href="ACL2____LEN.html">len</a> segment) 3))
                   (<a href="COMMON-LISP____CONSP.html">consp</a> segment))
              (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (pedersen-segment-scalar-loop j segment)
                  (pedersen-segment-scalar-loop-bound j segment)))
     :rule-classes :linear)</pre> 
<p><b>Theorem: </b>pedersen-segment-scalar-loop-lower-bound</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     pedersen-segment-scalar-loop-lower-bound
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____POSP.html">posp</a> j)
                   (<a href="ACL2____BIT-LISTP.html">bit-listp</a> segment)
                   (<a href="COMMON-LISP____INTEGERP.html">integerp</a> (<a href="COMMON-LISP_____F2.html">/</a> (<a href="ACL2____LEN.html">len</a> segment) 3))
                   (<a href="COMMON-LISP____CONSP.html">consp</a> segment))
              (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="COMMON-LISP____-.html">-</a> (pedersen-segment-scalar-loop-bound j segment))
                  (pedersen-segment-scalar-loop j segment)))
     :rule-classes :linear)</pre> 
<p><b>Theorem: </b>pedersen-segment-scalar-upper-bound</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pedersen-segment-scalar-upper-bound
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BIT-LISTP.html">bit-listp</a> segment)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> (<a href="COMMON-LISP_____F2.html">/</a> (<a href="ACL2____LEN.html">len</a> segment) 3))
                      (<a href="COMMON-LISP____CONSP.html">consp</a> segment))
                 (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ZCASH____PEDERSEN-SEGMENT-SCALAR.html">pedersen-segment-scalar</a> segment)
                     (<a href="ZCASH____PEDERSEN-SEGMENT-SCALAR-BOUND.html">pedersen-segment-scalar-bound</a> segment)))
        :rule-classes :linear)</pre> 
<p><b>Theorem: </b>pedersen-segment-scalar-lower-bound</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pedersen-segment-scalar-lower-bound
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BIT-LISTP.html">bit-listp</a> segment)
                      (<a href="COMMON-LISP____INTEGERP.html">integerp</a> (<a href="COMMON-LISP_____F2.html">/</a> (<a href="ACL2____LEN.html">len</a> segment) 3))
                      (<a href="COMMON-LISP____CONSP.html">consp</a> segment))
                 (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="COMMON-LISP____-.html">-</a> (<a href="ZCASH____PEDERSEN-SEGMENT-SCALAR-BOUND.html">pedersen-segment-scalar-bound</a> segment))
                     (<a href="ZCASH____PEDERSEN-SEGMENT-SCALAR.html">pedersen-segment-scalar</a> segment)))
        :rule-classes :linear)</pre> 

</body>
</html>
