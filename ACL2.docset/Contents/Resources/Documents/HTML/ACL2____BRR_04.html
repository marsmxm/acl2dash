<html>
<head>
<meta charset="UTF-8">
<title>Brr@</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____BRR_04">Click for Brr@ in the Full Manual</a></h3>

<p>To access context sensitive information within <span class="tt"><a href="ACL2____BREAK-REWRITE.html">break-rewrite</a></span></p><pre class="code">Example:
(<a href="ACL2____BRR_04.html">brr@</a> :target)      ; the term being rewritten
(<a href="ACL2____BRR_04.html">brr@</a> :unify-subst) ; the unifying substitution

General Form:
(<a href="ACL2____BRR_04.html">brr@</a> :symbol)</pre> 
 
 <p>where <span class="v">:symbol</span> is one of the keywords displayed below.  This utility 
 may be most useful for system hackers; see <a href="ACL2____BRR-COMMANDS.html">brr-commands</a> for queries 
 that are more at a user level.  In particular, keywords marked below with 
 <span class="v">*</span> probably require an implementor's knowledge of the system to use 
 effectively.  They are supported but not well documented.  More is said on 
 this topic following the table.  For background on the notion of 
 ``translated'' term, see <a href="ACL2____TERM.html">term</a>.</p> 
 
 <pre class="code">:symbol             (<a href="ACL2____BRR_04.html">brr@</a> :symbol)
-------             ---------------------

:target             the term to be rewritten.  This term is an
                    instantiation of the left-hand side of the
                    conclusion of the rewrite-rule being broken.
                    This term is in translated form!  Thus, if
                    you are expecting (<a href="COMMON-LISP____EQUAL.html">equal</a> x nil) -- and your
                    expectation is almost right -- you will see
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> x 'nil); similarly, instead of (<a href="COMMON-LISP____CADR.html">cadr</a> a)
                    you will see (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CDR.html">cdr</a> a)).  In translated
                    forms, all constants are quoted (even nil, t,
                    strings and numbers) and all macros are
                    expanded.

:unify-subst        the substitution that, when applied to :target,
                    produces the left-hand side of the rule being
                    broken.  This substitution is an alist pairing
                    variable symbols to translated (!) terms.

:wonp               t or nil indicating whether the rune was
                    successfully applied.  (<a href="ACL2____BRR_04.html">brr@</a> :wonp) returns
                    nil if evaluated before :EVALing the rule.

:rewritten-rhs      the result of successfully applying the rewrite
                    rule or else nil if (<a href="ACL2____BRR_04.html">brr@</a> :wonp) is nil.  The
                    result of successfully applying the rule is
                    always a translated (!) term and is never nil.

:poly-list          the result of successfully applying the linear
                    rule or else nil if (<a href="ACL2____BRR_04.html">brr@</a> :wonp) is nil.  This
                    result represents the list of polynomials
                    produced by the rule application.  The leading
                    term of each polynomial is enclosed in an extra
                    set of parentheses.

:failure-reason     some non-nil lisp object indicating why the rule
                    was not applied or else nil.  Before the rule is
                    :EVALed, (<a href="ACL2____BRR_04.html">brr@</a> :failure-reason) is nil.  After
                    :EVALing the rule, (<a href="ACL2____BRR_04.html">brr@</a> :failure-reason) is nil
                    if (<a href="ACL2____BRR_04.html">brr@</a> :wonp) is t.  Rather than document the
                    various non-nil objects returned as the failure
                    reason, we encourage you simply to evaluate
                    (<a href="ACL2____BRR_04.html">brr@</a> :failure-reason) in the contexts of interest.
                    Alternatively, study the ACL2 function tilde-@-
                    failure-reason-phrase.

:lemma           *  the rewrite rule being broken.  For example,
                    (<a href="ACL2____ACCESS.html">access</a> rewrite-rule (<a href="ACL2____BRR_04.html">brr@</a> :lemma) :lhs) will
                    return the left-hand side of the conclusion
                    of the rule.

:type-alist      *  a display of the type-alist governing :target.
                    Elements on the displayed list are of the form
                    (<a href="ACL2____TERM.html">term</a> type), where term is a term and type
                    describes information about term assumed to hold in
                    the current context.  (See also the documentation for
                    type-alist.)  The type-alist may be used to determine
                    the current assumptions, e.g., whether A is a CONSP.

:ancestors       *  a stack of frames indicating the backchain history
                    of the current context.  The theorem prover is in
                    the process of trying to establish each hypothesis
                    in this stack.  Thus, the negation of each hypothesis
                    can be assumed false.  Each frame also records the
                    rules on behalf of which this backchaining is being
                    done and the weight (function symbol count) of the
                    hypothesis.  All three items are involved in the
                    heuristic for preventing infinite backchaining.
                    Exception:  Some frames are ``binding hypotheses''
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> var term) or (equiv var (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> term))
                    that bind variable var to the result of rewriting
                    term.  The ACL2 source code has a definition
                    (<a href="ACL2____DEFREC.html">defrec</a> ancestor ...) that may provide some relevant
                    insight.

:initial-ttree   *  the initial and (after :EVAL) final tag trees,
:final-ttree        respectively.  (<a href="ACL2____TAG.html">Tag</a> trees are low-level data structures
                    that store lemmas used and other information, as
                    documented in topic TTREE.)

:gstack          *  the current goal stack.  The gstack is maintained
                    by rewrite and is the data structure printed as the
                    current ``path.''  Thus, any information derivable
                    from the :path brr command is derivable from gstack.
                    For example, from gstack one might determine that
                    the current term is the second hypothesis of a
                    certain rewrite rule.</pre> 
 
 <p>In general <span class="v">brr@-expressions</span> are used in break conditions, the 
 expressions that determine whether interactive breaks occur when <a href="ACL2____MONITOR.html">monitor</a>ed <a href="ACL2____RUNE.html">rune</a>s are applied.  See <a href="ACL2____MONITOR.html">monitor</a>.  For example, you 
 might want to break only those attempts in which one particular term is being 
 rewritten or only those attempts in which the binding for the variable <span class="v">a</span> 
 is known to be a <span class="tt"><a href="COMMON-LISP____CONSP.html">consp</a></span>.  Such conditions can be expressed using ACL2 
 system functions and the information provided by <span class="v">brr@</span>.  Unfortunately, 
 digging some of this information out of the internal data structures may be 
 awkward or may, at least, require intimate knowledge of the system functions. 
 But since conditional expressions may employ arbitrary functions and macros, 
 we anticipate that a set of convenient primitives will gradually evolve within 
 the ACL2 community.  It is to encourage this evolution that <span class="v">brr@</span> provides 
 access to the <span class="v">*</span>'d data.</p>
</body>
</html>
