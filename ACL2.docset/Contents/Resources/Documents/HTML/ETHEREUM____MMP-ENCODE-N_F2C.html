<html>
<head>
<meta charset="UTF-8">
<title>Mmp-encode-n/c</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ETHEREUM____MMP-ENCODE-N_F2C">Click for Mmp-encode-n/c in the Full Manual</a></h3>

<p>Definition of n [YP:(193)] and c [YP:(194)].</p><p><span class="tt"><a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a></span> corresponds to n, 
     while <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a></span> corresponds to c. 
     <span class="tt"><a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a></span> corresponds to the ``local function'' u 
     used in the third case of the definition of c: 
     since there are always exactly 16 calls to this function, 
     we could have avoided introducing <span class="tt"><a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a></span> 
     and just included 16 calls of <span class="tt"><a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a></span> 
     in the definition of <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a></span>, 
     but instead we just include 1 call of <span class="tt"><a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a></span>, 
     which recursively performs the 16 iterations itself. 
     Introducing <span class="tt"><a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a></span> seems clearer and more elegant 
     than including 16 calls of <span class="tt"><a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a></span>.</p><p>Here \mathfrak{I} is the argument <span class="v">map</span> of all these functions, 
     i is the argument <span class="v">i</span> of all these functions, 
     and j in the third case of the definition of c 
     is the argument <span class="v">nibble-counter</span> of <span class="tt"><a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a></span>.</p><p>In [YP], n and c just return byte arrays, 
     which are the ``roots'' of the MMP trees. 
     However, their computation relies on the database: 
     every call of Keccak-256 implicitly adds a pair to the database: 
     the pair associates the result of the call of Keccak-256 (key) 
     to the argument of the call of Keccak-256 (value). 
     This is implicit in [YP], 
     which mentions `prescience of the byte array' just before [YP:(193)]. 
     In our formalization, we explicate the database, 
     by having 
     <span class="tt"><a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a></span>, <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a></span>, and <span class="tt"><a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a></span> 
     all return a database, which they construct. 
     This returned database contains all and only the pairs 
     necessary to encode <span class="v">map</span>.</p><p>Since we cannot ignore the mathematical possibility of hash collisions, 
     <span class="tt"><a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a></span>, <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a></span>, and <span class="tt"><a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a></span> 
     all return an error flag that, when equal to <span class="v">:collision</span>, 
     indicates that a collision in the constructed database took place. 
     In practice, we do not expect to ever see this flag be <span class="v">:collision</span>, 
     but the mathematical possibility remains. 
     Databases constructed by sub-computations are merged, 
     when no collisions occur (i.e. when the two databases are compatible maps). 
     If a collision occurs, 
     <span class="v">nil</span> is returned as both root and database; 
     these values are irrelevant. 
     Note that a collision happens if not only a key is already in the database, 
     but also the associated value in the database differs 
     from the one that is to be added to the database; 
     this check is performed in <span class="tt"><a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a></span>, 
     the only function that directly extends the database 
     (the other functions merge databases from sub-computations). 
     If the key is already in the database but the value does not differ, 
     then there is no collision, and no change to the database; 
     if we view hashes as implementation-independent pointers 
     (which is a way to view MMP trees), 
     this situation just corresponding to two aliased pointers.</p><p>Since c involves RLP encoding, 
     and since RLP encoding may fail (see <span class="tt"><a href="ETHEREUM____RLP-ENCODE-TREE.html">rlp-encode-tree</a></span>), 
     the error flag returned by our functions 
     is <span class="v">:rlp</span> when an RLP encoding fails. 
     In this case, <span class="v">nil</span> is returned as both root and database; 
     these values are irrelevant.</p><p>If no hash collisions occur and all RLP encodings succeed, 
     the error flag returned by our functions is <span class="v">nil</span>, 
     indicating no error.</p><p>The definition of <span class="tt"><a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a></span> follows 
     the definition of n [YP:(193)] rather closely, 
     with the additional propagation of errors 
     from the recursive call of <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a></span>, 
     the additional propagation of the database from <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a></span>, 
     and the additional extension of the database mentioned above.</p><p>The definition of <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a></span> follows 
     the definition of c [YP:(194)] also rather closely. 
     However, since all three cases of the definition of c 
     apply RLP encoding at the end, 
     we factor that out of the three cases. 
     First, <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a></span> calculates 
     an error flag, an RLP tree, and a database according to the three cases. 
     Then, <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a></span> RLP encodes the tree. 
     If an error occurs prior to RLP encoding, 
     the ``inner'' computation of <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a></span> returns 
     an RLP tree consisting of an empty byte array and an empty database, 
     but these values are irrelevant. 
     Because of this factoring, 
     and because some tests relevant to termination (see section below) 
     appear in this factored code, 
     we need to extend the <a href="ACL2____RULERS.html">ACL2::rulers</a> of <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a></span> 
     with <span class="v">:lambdas</span>.</p><p>The first case of the definition of c 
     includes an existential quantifier for I 
     whose scope does not actually extend 
     to the use of I in \mathtt{RLP}(\ldots). 
     In our definition we do not use an existential quantifier: 
     we test whether the size of the map is 1 
     and then we extract its only key and value if the test succeeds.</p><p>We use <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C-MAX.html">mmp-encode-c-max</a></span> to calculate the variable j 
     (which is the variable <span class="v">j</span> in <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a></span>) 
     in the second case of the definition of c. 
     As discussed in <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C-MAX.html">mmp-encode-c-max</a></span>, 
     the map must be non-empty for this <span class="v">j</span> to be well-defined. 
     Thus, we add this non-emptiness condition 
     to the guard of <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a></span>.</p><p>Note that the scope of the universal quantifier 
     in the second case of the definition of c 
     does not actually extend 
     to the use of I in \mathtt{RLP}(\ldots): 
     in this expression, I may be any pair in the map, 
     because by the definition of j we know that 
     all the keys in the map have the same nibbles 
     at indices i through j-1. 
     In our definition, we pick the first key in the map.</p><p>Note that the j in the third case of the definition of c 
     has no relationship to the j 
     in the second case of the definition of c. 
     As stated above, the j in the third case 
     is the argument <span class="v">nibble-counter</span> of <span class="tt"><a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a></span>; 
     this function corresponds to 
     the ``local function'' u 
     in the third case of the definition of c. 
     The nibble counter argument is initialized to 0 
     by <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a></span>, when it calls <span class="tt"><a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a></span>. 
     The latter function returns, 
     essentially (but see below for more precision), u(0),\ldots,u(15), 
     along with an error flag 
     and with the database resulting from all the 16 computations.</p><p><span class="tt"><a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a></span> loops through nibble 0 to 15, 
     extracting submaps and recursively calling <span class="tt"><a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a></span> on them. 
     Errors are propagated and databases are merged, checking for collisions. 
     <span class="tt"><a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a></span> does not quite return 
     the list of roots u(0),\ldots,u(15): 
     more precisely, it returns a list of RLP leaf trees 
     containing those byte arrays; 
     the byte arrays and the RLP leaf trees are isomorphic, 
     but the calling <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a></span> can more easily assemble the trees 
     into an RLP (branching) tree.</p><p>The variable v in the third case of the definition of c 
     is the value associated to the key of length i in the map, 
     if it exists, in which case it is unique, 
     because it is an invariant that all the keys 
     have the same first i nibbles (see below). 
     We pick the first key in the map (but any other would do), 
     we take its first <span class="v">i</span> nibbles, 
     and we see if the resulting key has an associated value in the map. 
     Note that we do not need 
     the existential quantifier in the third case of the definition of c, 
     whose scope does not extend to 
     the expression I_1 that defines v anyways.</p><p>It is not clear whether () 
     in the second case of the definition of v 
     in the third case of the definition of c 
     is the empty byte array in \mathbb{B} [YP:(178)] 
     or the empty tuple in \mathbb{L} [YP:(177)]. 
     The empty byte array is consistent with the fact that 
     the I_1 in the first case of the definition of v 
     is also a byte array. 
     However, in this case maps \mathfrak{I} some of whose keys 
     have the empty byte array associated as value 
     cannot be unambiguously encoded as MMP trees, 
     because we would be unable to distinguish 
     between the two cases in the definition of v. 
     This ambiguity does not exist 
     if instead the () denotes the empty tuple; 
     note that the first paragraph of [YP:D] mentions 
     maps between arbitrary-length byte arrays 
     (suggesting that zero lengths are allowed), 
     and that in the third case of the definition of c, 
     the argument tuple of \mathtt{RLP}, 
     whose last component is v, 
     is well-formed whether v is a byte array or a tuple. 
     So for now we interpret the () as the empty tuple.</p><h4>Termination</h4><p>The termination of 
     <span class="tt"><a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a></span>, <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a></span>, and <span class="tt"><a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a></span> 
     is proved via a lexicographic measure 
     that consists of three components.</p><p>This termination proof relies on 
     some invariants satisfied by the arguments of these functions. 
     These invariants are added as guards, 
     and tested with <span class="tt"><a href="ACL2____MBT.html">mbt</a></span> at the beginning of the functions. 
     An invariant that applies to all three functions is that 
     all the keys in the map have the same first <span class="v">i</span> nibbles: 
     this is expressed by 
     <a href="ETHEREUM____MMP-ENCODE-C-MAX.html"><span class="v">mmp-encode-c-max.elementp</span></a>. 
     An invariant that applies to <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a></span> and <span class="tt"><a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a></span> 
     is that the map is not empty. 
     An invariant that applies to <span class="tt"><a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a></span> is that 
     the map is not a singleton.</p><p><span class="tt"><a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a></span> calls <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a></span> 
     with the same arguments <span class="v">map</span> and <span class="v">i</span>, 
     and therefore the measure must involve the fact that 
     <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a></span> is ``smaller'' than <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a></span>. 
     Similarly, <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a></span> calls <span class="tt"><a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a></span> 
     with the same arguments <span class="v">map</span> and <span class="v">i</span>, 
     and therefore the measure must involve the fact that 
     <span class="tt"><a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a></span> is ``smaller'' than <span class="tt"><a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a></span>. 
     Thus, we order these functions by assigning 0, 1, and 2 to them: 
     this is the second component of the lexicographic measure.</p><p>Since <span class="tt"><a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a></span> calls <span class="tt"><a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a></span> 
     and <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a></span> calls <span class="tt"><a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a></span>, 
     the relative ordering of these functions cannot be 
     the first component of the lexicographic measure. 
     Instead, the first component involves <span class="v">map</span> and <span class="v">i</span>. 
     In the calls just mentioned, 
     the recursion makes progress because <span class="v">i</span> strictly increases: 
     it becomes either <span class="v">(<a href="COMMON-LISP____1_B2.html">1+</a> i)</span> or <span class="v">j</span>. 
     Before calling <span class="tt"><a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a></span>, 
     <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a></span> checks that <span class="v">j</span> is not <span class="v">i</span>. 
     The reason why it <span class="v">j</span> is larger than <span class="v">i</span> in this case 
     is the aforementioned invariant about <span class="v">i</span> and the definition of <span class="v">j</span>: 
     all the keys in the map have the same <span class="v">i</span> nibbles, 
     and <span class="v">j</span> is, by definition, the maximum length of the common prefix 
     of the keys in the map: 
     thus, <span class="v">j</span> is greater than or equal to <span class="v">i</span>, 
     and since it is different, it is larger.</p><p>The increase of <span class="v">i</span> in the recursive calls is bounded by 
     <span class="tt"><a href="ETHEREUM____NIBBLELIST-BYTELIST-MAP-SUP-LEN-KEY.html">nibblelist-bytelist-map-sup-len-key</a></span>: 
     the first component of the lexicographic measure is 
     the difference between that and <span class="v">i</span>. 
     When <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a></span> calls <span class="tt"><a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a></span>, 
     <span class="tt"><a href="ETHEREUM____NIBBLELIST-BYTELIST-MAP-SUP-LEN-KEY.html">nibblelist-bytelist-map-sup-len-key</a></span> remains the same; 
     since it is greater than or equal to <span class="v">j</span>, 
     and <span class="v">i</span> is strictly less than <span class="v">j</span>, 
     the first component of the measure strictly decreases. 
     When <span class="tt"><a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a></span> calls <span class="tt"><a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a></span>, 
     <span class="tt"><a href="ETHEREUM____NIBBLELIST-BYTELIST-MAP-SUP-LEN-KEY.html">nibblelist-bytelist-map-sup-len-key</a></span> 
     either stays the same or becomes smaller, 
     as proved in <span class="tt"><a href="ETHEREUM____MMP-ENCODE-U-MAP.html">mmp-encode-u-map</a></span>, 
     because we are calling <span class="tt"><a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a></span> on a submap of the map; 
     to show that the first component of the measure strictly decreases 
     as <span class="v">i</span> becomes <span class="v">(<a href="COMMON-LISP____1_B2.html">1+</a> i)</span>, 
     we use the fact that <span class="v">i</span> is strictly less than 
     <span class="tt"><a href="ETHEREUM____NIBBLELIST-BYTELIST-MAP-SUP-LEN-KEY.html">nibblelist-bytelist-map-sup-len-key</a></span>, 
     as proved in <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C-MAX.html">mmp-encode-c-max</a></span>, 
     given that the map has at least two elements, 
     as asserted by the invariant of <span class="tt"><a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a></span>.</p><h4>Guard Verification</h4><p>The guard verification of 
     <span class="tt"><a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a></span>, <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a></span>, and <span class="tt"><a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a></span> 
     involves proving the preservation, in the recursive calls, 
     of the invariants used for the termination proof, mentioned above.</p><p>This is easy for most recursive calls, 
     where <span class="v">map</span> and <span class="v">i</span> do not change.</p><p>In the call of <span class="tt"><a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a></span> from <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a></span>, 
     <span class="v">map</span> stays the same, while <span class="v">i</span> changes to the maximum <span class="v">j</span>; 
     since in this case the maximum exists, 
     it is in the set.</p><p>In the call of <span class="tt"><a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a></span> from <span class="tt"><a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a></span>, 
     the map becomes the submap and <span class="v">i</span> becomes <span class="v">(<a href="COMMON-LISP____1_B2.html">1+</a> i)</span>. 
     We start with the fact that 
     all the keys in the map have the same first <span class="v">i</span> nibbles, 
     By construction, 
     the submap has keys with the same nibble at position <span class="v">i</span>. 
     Therefore, all the keys in the submap has the first <span class="v">(<a href="COMMON-LISP____1_B2.html">1+</a> i)</span> nibbles, 
     and thus <span class="v">(<a href="COMMON-LISP____1_B2.html">1+</a> i)</span> is in the set.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>mmp-encode-n</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     mmp-encode-n (map i)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MAPP.html">nibblelist-bytelist-mapp</a> map)
                                 (<a href="ACL2____NATP.html">natp</a> i))))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (mmp-encode-c-max.elementp map i)))
     (<a href="ACL2____B_A2.html">b*</a> (((unless (<a href="ACL2____MBT.html">mbt</a> (mmp-encode-c-max.elementp map i)))
           (<a href="ACL2____MV.html">mv</a> nil nil nil))
          ((when (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____MBT.html">mbt</a> (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MAPP.html">nibblelist-bytelist-mapp</a> map)))
                     (<a href="OMAP____EMPTY.html">omap::empty</a> map)))
           (<a href="ACL2____MV.html">mv</a> nil nil nil))
          ((<a href="ACL2____MV.html">mv</a> c-error? c-root c-database)
           (<a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a> map i))
          ((when c-error?) (<a href="ACL2____MV.html">mv</a> c-error? nil nil))
          ((when (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____LEN.html">len</a> c-root) 32))
           (<a href="ACL2____MV.html">mv</a> nil c-root c-database))
          (hash (keccak-256-bytes c-root))
          (pair? (<a href="OMAP____IN.html">omap::in</a> hash c-database))
          (collisionp (<a href="COMMON-LISP____AND.html">and</a> pair? (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CDR.html">cdr</a> pair?) c-root))))
          ((when collisionp)
           (<a href="ACL2____MV.html">mv</a> :collision nil nil))
          (<a href="ETHEREUM____DATABASE.html">database</a> (<a href="OMAP____UPDATE.html">omap::update</a> hash c-root c-database)))
         (<a href="ACL2____MV.html">mv</a> nil hash database)))</pre> 
<p><b>Function: </b>mmp-encode-c</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 mmp-encode-c (map i)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MAPP.html">nibblelist-bytelist-mapp</a> map)
                             (<a href="ACL2____NATP.html">natp</a> i))))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (mmp-encode-c-max.elementp map i)
                             (<a href="COMMON-LISP____NOT.html">not</a> (<a href="OMAP____EMPTY.html">omap::empty</a> map)))))
 (<a href="ACL2____B_A2.html">b*</a>
  (((unless (<a href="ACL2____MBT.html">mbt</a> (<a href="COMMON-LISP____AND.html">and</a> (mmp-encode-c-max.elementp map i)
                      (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MAPP.html">nibblelist-bytelist-mapp</a> map)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="OMAP____EMPTY.html">omap::empty</a> map)))))
    (<a href="ACL2____MV.html">mv</a> nil nil nil))
   ((<a href="ACL2____MV.html">mv</a> error? rlp-tree database)
    (<a href="ACL2____B_A2.html">b*</a>
       (((when (<a href="COMMON-LISP_____D3.html">=</a> (<a href="OMAP____SIZE.html">omap::size</a> map) 1))
         (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> key val) (<a href="OMAP____HEAD.html">omap::head</a> map))
              (key-rest (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> i key)))
             (<a href="ACL2____MV.html">mv</a> nil
                 (<a href="ETHEREUM____RLP-TREE-BRANCH.html">rlp-tree-branch</a>
                      (<a href="COMMON-LISP____LIST.html">list</a> (<a href="ETHEREUM____RLP-TREE-LEAF.html">rlp-tree-leaf</a> (<a href="ETHEREUM____HP-ENCODE.html">hp-encode</a> key-rest t))
                            (<a href="ETHEREUM____RLP-TREE-LEAF.html">rlp-tree-leaf</a> val)))
                 nil)))
        (j (<a href="ETHEREUM____MMP-ENCODE-C-MAX.html">mmp-encode-c-max</a> map))
        ((when (<a href="COMMON-LISP_____F2_D3.html">/=</a> (<a href="ACL2____NFIX.html">nfix</a> i) j))
         (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> n-error? n-root n-database)
               (<a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a> map j))
              ((when n-error?)
               (<a href="ACL2____MV.html">mv</a> n-error? (<a href="ETHEREUM____RLP-TREE-LEAF.html">rlp-tree-leaf</a> nil) nil))
              ((<a href="ACL2____MV.html">mv</a> any-key &amp;) (<a href="OMAP____HEAD.html">omap::head</a> map))
              (key-part (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> i (<a href="ACL2____TAKE.html">take</a> j any-key))))
             (<a href="ACL2____MV.html">mv</a> nil
                 (<a href="ETHEREUM____RLP-TREE-BRANCH.html">rlp-tree-branch</a>
                      (<a href="COMMON-LISP____LIST.html">list</a> (<a href="ETHEREUM____RLP-TREE-LEAF.html">rlp-tree-leaf</a> (<a href="ETHEREUM____HP-ENCODE.html">hp-encode</a> key-part nil))
                            (<a href="ETHEREUM____RLP-TREE-LEAF.html">rlp-tree-leaf</a> n-root)))
                 n-database)))
        ((<a href="ACL2____MV.html">mv</a> u-error? u-trees u-database)
         (<a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a> map i 0))
        ((when u-error?)
         (<a href="ACL2____MV.html">mv</a> u-error? (<a href="ETHEREUM____RLP-TREE-LEAF.html">rlp-tree-leaf</a> nil) nil))
        ((<a href="ACL2____MV.html">mv</a> any-key &amp;) (<a href="OMAP____HEAD.html">omap::head</a> map))
        (key-prefix (<a href="ACL2____TAKE.html">take</a> i any-key))
        (pair (<a href="OMAP____IN.html">omap::in</a> key-prefix map))
        (v (<a href="COMMON-LISP____AND.html">and</a> pair (<a href="COMMON-LISP____CDR.html">cdr</a> pair)))
        (v-tree (<a href="COMMON-LISP____IF.html">if</a> v (<a href="ETHEREUM____RLP-TREE-LEAF.html">rlp-tree-leaf</a> v)
                    (<a href="ETHEREUM____RLP-TREE-BRANCH.html">rlp-tree-branch</a> nil))))
       (<a href="ACL2____MV.html">mv</a> nil
           (<a href="ETHEREUM____RLP-TREE-BRANCH.html">rlp-tree-branch</a> (<a href="ACL2____RCONS.html">rcons</a> v-tree u-trees))
           u-database)))
   ((when error?) (<a href="ACL2____MV.html">mv</a> error? nil nil))
   ((<a href="ACL2____MV.html">mv</a> rlp-error? rlp-encoding)
    (<a href="ETHEREUM____RLP-ENCODE-TREE.html">rlp-encode-tree</a> rlp-tree))
   ((when rlp-error?) (<a href="ACL2____MV.html">mv</a> :rlp nil nil)))
  (<a href="ACL2____MV.html">mv</a> nil rlp-encoding database)))</pre> 
<p><b>Function: </b>mmp-encode-u</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     mmp-encode-u (map i nibble-counter)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MAPP.html">nibblelist-bytelist-mapp</a> map)
                                 (<a href="ACL2____NATP.html">natp</a> i)
                                 (<a href="ACL2____NATP.html">natp</a> nibble-counter))))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (mmp-encode-c-max.elementp map i)
                                 (<a href="COMMON-LISP____NOT.html">not</a> (<a href="OMAP____EMPTY.html">omap::empty</a> map))
                                 (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="OMAP____SIZE.html">omap::size</a> map) 1)))))
     (<a href="ACL2____B_A2.html">b*</a> (((unless (<a href="ACL2____MBT.html">mbt</a> (<a href="COMMON-LISP____AND.html">and</a> (mmp-encode-c-max.elementp map i)
                             (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MAPP.html">nibblelist-bytelist-mapp</a> map)
                             (<a href="COMMON-LISP____NOT.html">not</a> (<a href="OMAP____EMPTY.html">omap::empty</a> map))
                             (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="OMAP____SIZE.html">omap::size</a> map) 1)))))
           (<a href="ACL2____MV.html">mv</a> nil nil nil))
          ((when (<a href="COMMON-LISP_____E3.html">&gt;</a> (<a href="ACL2____NFIX.html">nfix</a> nibble-counter) 15))
           (<a href="ACL2____MV.html">mv</a> nil nil nil))
          (submap (<a href="ETHEREUM____MMP-ENCODE-U-MAP.html">mmp-encode-u-map</a> map i nibble-counter))
          ((<a href="ACL2____MV.html">mv</a> n-error? n-root n-database)
           (<a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a> submap (<a href="COMMON-LISP____1_B2.html">1+</a> (<a href="ACL2____NFIX.html">nfix</a> i))))
          ((when n-error?) (<a href="ACL2____MV.html">mv</a> n-error? nil nil))
          ((<a href="ACL2____MV.html">mv</a> u-error? u-trees u-database)
           (<a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a> map i (<a href="COMMON-LISP____1_B2.html">1+</a> (<a href="ACL2____NFIX.html">nfix</a> nibble-counter))))
          ((when u-error?) (<a href="ACL2____MV.html">mv</a> u-error? nil nil))
          ((unless (<a href="OMAP____COMPATIBLEP.html">omap::compatiblep</a> n-database u-database))
           (<a href="ACL2____MV.html">mv</a> :collision nil nil))
          (trees (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="ETHEREUM____RLP-TREE-LEAF.html">rlp-tree-leaf</a> n-root) u-trees))
          (<a href="ETHEREUM____DATABASE.html">database</a> (<a href="OMAP____UPDATE_A2.html">omap::update*</a> n-database u-database)))
         (<a href="ACL2____MV.html">mv</a> nil trees database)))</pre> 
 
 
<p><b>Theorem: </b>return-type-of-mmp-encode-n.error?</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> return-type-of-mmp-encode-n.error?
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?error? ?root ?database)
              (<a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a> map i)))
            (<a href="ACL2____MEMBER-EQ.html">member-eq</a> error? '(nil :collision :rlp)))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>return-type-of-mmp-encode-n.root</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> return-type-of-mmp-encode-n.root
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?error? ?root ?database)
              (<a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a> map i)))
            (<a href="ACL2____BYTE-LISTP.html">byte-listp</a> root))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>return-type-of-mmp-encode-n.database</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> return-type-of-mmp-encode-n.database
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?error? ?root ?database)
              (<a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a> map i)))
            (<a href="ETHEREUM____DATABASEP.html">databasep</a> database))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>return-type-of-mmp-encode-c.error?</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> return-type-of-mmp-encode-c.error?
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?error? ?root ?database)
              (<a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a> map i)))
            (<a href="ACL2____MEMBER-EQ.html">member-eq</a> error? '(nil :collision :rlp)))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>return-type-of-mmp-encode-c.root</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> return-type-of-mmp-encode-c.root
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?error? ?root ?database)
              (<a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a> map i)))
            (<a href="ACL2____BYTE-LISTP.html">byte-listp</a> root))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>return-type-of-mmp-encode-c.database</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> return-type-of-mmp-encode-c.database
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?error? ?root ?database)
              (<a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a> map i)))
            (<a href="ETHEREUM____DATABASEP.html">databasep</a> database))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>return-type-of-mmp-encode-u.error?</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> return-type-of-mmp-encode-u.error?
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?error? ?trees ?database)
              (<a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a> map i nibble-counter)))
            (<a href="ACL2____MEMBER-EQ.html">member-eq</a> error? '(nil :collision :rlp)))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>return-type-of-mmp-encode-u.trees</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> return-type-of-mmp-encode-u.trees
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?error? ?trees ?database)
              (<a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a> map i nibble-counter)))
            (<a href="ETHEREUM____RLP-TREE-LISTP.html">rlp-tree-listp</a> trees))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>return-type-of-mmp-encode-u.database</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> return-type-of-mmp-encode-u.database
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?error? ?trees ?database)
              (<a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a> map i nibble-counter)))
            (<a href="ETHEREUM____DATABASEP.html">databasep</a> database))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>mmp-encode-n-of-nibblelist-bytelist-mfix-map</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-n-of-nibblelist-bytelist-mfix-map
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a> (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MFIX.html">nibblelist-bytelist-mfix</a> map)
                             i)
               (<a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a> map i)))</pre> 
<p><b>Theorem: </b>mmp-encode-n-of-nfix-i</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-n-of-nfix-i
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a> map (<a href="ACL2____NFIX.html">nfix</a> i))
               (<a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a> map i)))</pre> 
<p><b>Theorem: </b>mmp-encode-c-of-nibblelist-bytelist-mfix-map</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-c-of-nibblelist-bytelist-mfix-map
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a> (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MFIX.html">nibblelist-bytelist-mfix</a> map)
                             i)
               (<a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a> map i)))</pre> 
<p><b>Theorem: </b>mmp-encode-c-of-nfix-i</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-c-of-nfix-i
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a> map (<a href="ACL2____NFIX.html">nfix</a> i))
               (<a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a> map i)))</pre> 
<p><b>Theorem: </b>mmp-encode-u-of-nibblelist-bytelist-mfix-map</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-u-of-nibblelist-bytelist-mfix-map
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a> (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MFIX.html">nibblelist-bytelist-mfix</a> map)
                             i nibble-counter)
               (<a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a> map i nibble-counter)))</pre> 
<p><b>Theorem: </b>mmp-encode-u-of-nfix-i</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-u-of-nfix-i
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a> map (<a href="ACL2____NFIX.html">nfix</a> i)
                             nibble-counter)
               (<a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a> map i nibble-counter)))</pre> 
<p><b>Theorem: </b>mmp-encode-u-of-nfix-nibble-counter</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-u-of-nfix-nibble-counter
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a> map i (<a href="ACL2____NFIX.html">nfix</a> nibble-counter))
               (<a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a> map i nibble-counter)))</pre> 
<p><b>Theorem: </b>mmp-encode-n-nibblelist-bytelist-mequiv-congruence-on-map</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-n-nibblelist-bytelist-mequiv-congruence-on-map
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MEQUIV.html">nibblelist-bytelist-mequiv</a> map map-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a> map i)
                        (<a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a> map-equiv i)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>mmp-encode-n-nat-equiv-congruence-on-i</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-n-nat-equiv-congruence-on-i
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____NAT-EQUIV.html">acl2::nat-equiv</a> i i-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a> map i)
                        (<a href="ETHEREUM____MMP-ENCODE-N.html">mmp-encode-n</a> map i-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>mmp-encode-c-nibblelist-bytelist-mequiv-congruence-on-map</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-c-nibblelist-bytelist-mequiv-congruence-on-map
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MEQUIV.html">nibblelist-bytelist-mequiv</a> map map-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a> map i)
                        (<a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a> map-equiv i)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>mmp-encode-c-nat-equiv-congruence-on-i</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-c-nat-equiv-congruence-on-i
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____NAT-EQUIV.html">acl2::nat-equiv</a> i i-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a> map i)
                        (<a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a> map i-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>mmp-encode-u-nibblelist-bytelist-mequiv-congruence-on-map</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-u-nibblelist-bytelist-mequiv-congruence-on-map
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MEQUIV.html">nibblelist-bytelist-mequiv</a> map map-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a> map i nibble-counter)
                        (<a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a> map-equiv i nibble-counter)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>mmp-encode-u-nat-equiv-congruence-on-i</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-u-nat-equiv-congruence-on-i
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____NAT-EQUIV.html">acl2::nat-equiv</a> i i-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a> map i nibble-counter)
                        (<a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a> map i-equiv nibble-counter)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>mmp-encode-u-nat-equiv-congruence-on-nibble-counter</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     mmp-encode-u-nat-equiv-congruence-on-nibble-counter
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____NAT-EQUIV.html">acl2::nat-equiv</a> nibble-counter nibble-counter-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a> map i nibble-counter)
                     (<a href="ETHEREUM____MMP-ENCODE-U.html">mmp-encode-u</a> map i nibble-counter-equiv)))
     :rule-classes :congruence)</pre> 

</body>
</html>
