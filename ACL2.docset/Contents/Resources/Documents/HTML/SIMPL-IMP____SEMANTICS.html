<html>
<head>
<meta charset="UTF-8">
<title>Semantics</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=SIMPL-IMP____SEMANTICS">Click for Semantics in the Full Manual</a></h3>

<p>Semantics of Imp.</p><p>Since Imp is so simple, 
     there is no need to explicitly define a static semantics, 
     i.e. constraints for the well-formedness and type correctness 
     of Imp programs. 
     The separation between the <span class="tt"><a href="SIMPL-IMP____AEXP.html">aexp</a></span> and <span class="tt"><a href="SIMPL-IMP____BEXP.html">bexp</a></span> fixtypes 
     provides an implicit typing of all the Imp expressions. 
     Therefore, in the context of Imp, 
     `semantics' always refer to dynamic (i.e. execution) semantics.</p><p>We formalize the variable store as an environment, 
     i.e. a finite map from (names of) variables to (integer values). 
     Imp commands operate on the environment.</p><p>We formalize the computation state as a configuration, 
     i.e. a pair consisting of a sequence of zero or more commands 
     and an environment. 
     The commands are the next ones to be executed, in order.</p><p>We formalize expression evaluation via ACL2 functions 
     from expressions and environments to values. 
     This is possible because 
     the evaluation of Imp expressions always terminates. 
     We use this modeling approach because it is simple 
     and we are currently not interested in 
     intermediate computation states during the evaluation of expressions, 
     but just in the final result of expression evaluation. 
     If we were interested in those intermediate computation states, 
     we would have to formalize expression evaluation as a multi-step process, 
     similarly to the execution of commands (as explained just below).</p><p>We formalize an operational semantics via an ACL2 function 
     that maps old configurations to new configurations. 
     This function performs one step of computation, 
     according to a reasonable level of granularity, 
     but it is possible to define finer- or coarser-grained steps; 
     for instance, 
     if expression evaluation were a multi-step process as mentioned above, 
     then we would have a finer-grained execution model. 
     We cannot have an always-terminating interpreter of Imp commands, 
     because its loops may not terminate. 
     Thus, having the step function, each of whose steps always terminates, 
     lets us talk about sequences of steps that may or may not terminate. 
     The step function captures a small-step operational semantics; 
     its sequentialization captures a big-step operational semantics.</p>
</body>
</html>
