<html>
<head>
<meta charset="UTF-8">
<title>Quantifiers-using-defun-sk-extended</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____QUANTIFIERS-USING-DEFUN-SK-EXTENDED">Click for Quantifiers-using-defun-sk-extended in the Full Manual</a></h3>

<p>Quantification example with details</p><p>See <a href="ACL2____QUANTIFIERS-USING-DEFUN-SK.html">quantifiers-using-defun-sk</a> for the context of this 
 example.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____IN-PACKAGE.html">in-package</a> "ACL2")

; We prove that if every member A of each of two lists satisfies the
; predicate (P A), then this holds of their append; and, conversely.

; Here is a solution using explicit quantification.

(<a href="ACL2____DEFSTUB.html">defstub</a> p (x) t)

(<a href="ACL2____DEFUN-SK.html">defun-sk</a> forall-p (x)
  (<a href="ACL2____FORALL.html">forall</a> a (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____MEMBER.html">member</a> a x)
                     (p a))))

; The defun-sk above introduces the following axioms.  The idea is that
; (FORALL-P-WITNESS X) picks a counterexample to (forall-p x) if there is one.

;   (<a href="COMMON-LISP____DEFUN.html">DEFUN</a> FORALL-P (X)
;     (<a href="COMMON-LISP____LET.html">LET</a> ((A (FORALL-P-WITNESS X)))
;          (<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____MEMBER.html">MEMBER</a> A X) (P A))))
;
;   (<a href="ACL2____DEFTHM.html">DEFTHM</a> FORALL-P-NECC
;     (<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____NOT.html">NOT</a> (<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____MEMBER.html">MEMBER</a> A X) (P A)))
;              (<a href="COMMON-LISP____NOT.html">NOT</a> (FORALL-P X)))
;     :HINTS (("Goal" :USE FORALL-P-WITNESS)))

; The following lemma seems critical.

(<a href="ACL2____DEFTHM.html">defthm</a> member-append
  (<a href="ACL2____IFF.html">iff</a> (<a href="COMMON-LISP____MEMBER.html">member</a> a (<a href="COMMON-LISP____APPEND.html">append</a> x1 x2))
       (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____MEMBER.html">member</a> a x1) (<a href="COMMON-LISP____MEMBER.html">member</a> a x2))))

; The proof of forall-p-append seems to go out to lunch, so we break into
; directions as shown below.

(<a href="ACL2____DEFTHM.html">defthm</a> forall-p-append-forward
  (<a href="ACL2____IMPLIES.html">implies</a> (forall-p (<a href="COMMON-LISP____APPEND.html">append</a> x1 x2))
           (<a href="COMMON-LISP____AND.html">and</a> (forall-p x1) (forall-p x2)))
  :hints (("Goal" ; ``should'' disable forall-p-necc, but no need
           :use
           ((:instance forall-p-necc
                       (x (<a href="COMMON-LISP____APPEND.html">append</a> x1 x2))
                       (a (forall-p-witness x1)))
            (:instance forall-p-necc
                       (x (<a href="COMMON-LISP____APPEND.html">append</a> x1 x2))
                       (a (forall-p-witness x2)))))))

(<a href="ACL2____DEFTHM.html">defthm</a> forall-p-append-reverse
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (forall-p x1) (forall-p x2))
           (forall-p (<a href="COMMON-LISP____APPEND.html">append</a> x1 x2)))
  :hints (("Goal"
           :use
           ((:instance forall-p-necc
                       (x x1)
                       (a (forall-p-witness (<a href="COMMON-LISP____APPEND.html">append</a> x1 x2))))
            (:instance forall-p-necc
                       (x x2)
                       (a (forall-p-witness (<a href="COMMON-LISP____APPEND.html">append</a> x1 x2))))))))

(<a href="ACL2____DEFTHM.html">defthm</a> forall-p-append
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (forall-p (<a href="COMMON-LISP____APPEND.html">append</a> x1 x2))
         (<a href="COMMON-LISP____AND.html">and</a> (forall-p x1) (forall-p x2)))
  :hints (("Goal" :use (forall-p-append-forward
                        forall-p-append-reverse))))</pre>
</body>
</html>
