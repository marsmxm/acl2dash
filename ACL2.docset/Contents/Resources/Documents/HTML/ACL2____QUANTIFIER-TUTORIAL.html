<html>
<head>
<meta charset="UTF-8">
<title>Quantifier-tutorial</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____QUANTIFIER-TUTORIAL">Click for Quantifier-tutorial in the Full Manual</a></h3>

<p>A Beginner's Guide to Reasoning about Quantification in ACL2</p><p>The initial version of this tutorial was written by Sandip Ray. 
 Additions and revisions are welcome.  Sandip has said:</p> 
 
 <blockquote><p>``This is a collection of notes that I wrote to remind myself 
 of how to reason about quantifiers when I just started.  Most users after they 
 have gotten the hang of quantifiers probably will not need this and will be 
 able to use their intuitions to guide them in the process.  But since many 
 ACL2 users are not used to quantification, I am hoping that this set of notes 
 might help them to think clearly while reasoning about quantifiers in 
 ACL2.''</p></blockquote> 
 
 <p>Many ACL2 papers start with the sentence ``ACL2 is a quantifier-free 
 first-order logic of recursive functions.''  It is true that the <i>syntax</i> 
 of ACL2 is quantifier-free; every formula is assumed to be universally 
 quantified over all free variables in the formula.  But the <i>logic</i> in 
 fact does afford arbitrary first-order quantification.  This is obtained in 
 ACL2 using a construct called <span class="v">defun-sk</span>.  See <a href="ACL2____DEFUN-SK.html">defun-sk</a>.</p> 
 
 <p>Many ACL2 users do not think in terms of <a href="ACL2____QUANTIFIERS.html">quantifiers</a>.  The focus is 
 almost always on defining recursive functions and reasoning about them using 
 induction.  That is entirely justified, in fact, since proving theorems about 
 recursive functions by induction plays to the strengths of the theorem prover. 
 Nevertheless there are situations where it is reasonable and often useful to 
 think in terms of quantifiers.  However, reasoning about quantifiers requires 
 that you get into the mindset of thinking about theorems in terms of 
 quantification.  This note is about how to do this effectively given ACL2's 
 implementation of quantification.  This does not discuss <span class="tt"><a href="ACL2____DEFUN-SK.html">defun-sk</a></span> in 
 detail, but merely shows some examples.  A detailed explanation of the 
 implementation is in the ACL2 <a href="COMMON-LISP____DOCUMENTATION.html">documentation</a> (see <a href="ACL2____DEFUN-SK.html">defun-sk</a>); also 
 see <a href="ACL2____CONSERVATIVITY-OF-DEFCHOOSE.html">conservativity-of-defchoose</a>.</p> 
 
 <p>[Note: Quantifiers can be used for some pretty cool things in ACL2. 
 Perhaps the most interesting example is the way of using quantifiers to 
 introduce arbitrary tail-recursive equations; see the paper ``Partial 
 Functions in ACL2'' by Panagiotis Manolios and J Strother Moore.  This note 
 does not address applications of quantifiers, but merely how you would reason 
 about them once you think you want to use them.]</p> 
 
 <p>Assume that you have some function <span class="v">P</span>.  I have just left <span class="v">P</span> as a 
 unary function stub below, since I do not care about what <span class="v">P</span> is.</p> 
 
 <pre class="code">(<a href="ACL2____DEFSTUB.html">defstub</a> P (<a href="COMMON-LISP_____A2.html">*</a>) =&gt; *)</pre> 
 
 <p>Now suppose you want to specify the concept that ``there exists some <span class="v">x</span> 
 such that <span class="v">(P x)</span> holds''.  ACL2 allows you to write that directly using 
 quantifiers.</p> 
 
 <pre class="code">(<a href="ACL2____DEFUN-SK.html">defun-sk</a> exists-P () (<a href="ACL2____EXISTS.html">exists</a> x (P x)))</pre> 
 
 <p>If you submit the above form in ACL2 you will see that the theorem prover 
 specifies two functions <span class="v">exists-p</span> and <span class="v">exists-p-witness</span>, and exports 
 the following constraints:</p> 
 
 <pre class="code">1.  (<a href="COMMON-LISP____DEFUN.html">defun</a> exists-P () (P (exists-P-witness)))
2.  (<a href="ACL2____DEFTHM.html">defthm</a> exists-P-suff (<a href="ACL2____IMPLIES.html">implies</a> (p x) (exists-p)))</pre> 
 
 <p>Here <span class="v">exists-P-witness</span> is a new function symbol in the current ACL2 
 theory.  What do the constraints above say?  Notice the constraint 
 <span class="v">exists-p-suff</span>.  It says that if you can provide any <span class="v">x</span> such that 
 <span class="v">(P x)</span> holds, then you know that <span class="v">exists-p</span> holds.  Think of the other 
 constraint (definition of <span class="v">exists-p</span>) as going the other way.  That is, it 
 says that if <span class="v">exists-p</span> holds, then there is some <span class="v">x</span>, call it 
 <span class="v">(exists-p-witness)</span>, for which <span class="v">P</span> holds.  Notice that nothing else is 
 known about <span class="v">exists-p-witness</span> than the two constraints above.</p> 
 
 <p>[Note: <span class="v">exists-p-witness</span> above is actually defined in ACL2 using a 
 special form called <span class="v">defchoose</span>.  See <a href="ACL2____DEFCHOOSE.html">defchoose</a>.  This note does not 
 talk about <span class="v">defchoose</span>.  So far as this note is concerned, think of 
 <span class="v">exists-p-witness</span> as a new function symbol that has been generated somehow 
 in ACL2, about which nothing other than the two facts above is known.]</p> 
 
 <p>Similarly, you can talk about the concept that ``for all <span class="v">x</span> <span class="v">(P x)</span> 
 holds.'' This can be specified in ACL2 by the form:</p> 
 
 <pre class="code">(<a href="ACL2____DEFUN-SK.html">defun-sk</a> forall-P () (<a href="ACL2____FORALL.html">forall</a> x (P x)))</pre> 
 
 <p>This produces the following two constraints:</p> 
 
 <pre class="code">1.  (<a href="COMMON-LISP____DEFUN.html">defun</a> forall-P () (P (forall-p-witness)))
2.  (<a href="ACL2____DEFTHM.html">defthm</a> forall-p-necc (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (P x)) (<a href="COMMON-LISP____NOT.html">not</a> (forall-p))))</pre> 
 
 <p>To understand these, think of <span class="v">forall-p-witness</span> as producing some 
 <span class="v">x</span> which does not satisfy <span class="v">P</span>, if such a thing exists.  The constraint 
 <span class="v">forall-p-necc</span> merely says that if <span class="v">forall-p</span> holds then <span class="v">P</span> is 
 satisfied for every <span class="v">x</span>.  (To see this more clearly, just think of the 
 contrapositive of the formula shown.) The other constraint (definition of 
 <span class="v">forall-p</span>) implies that if <span class="v">forall-p</span> does not hold then there is some 
 <span class="v">x</span>, call it <span class="v">(forall-p-witness)</span>, which does not satisfy <span class="v">P</span>.  To 
 see this, just consider the following formula which is immediately derivable 
 from the definition.</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (forall-p)) (<a href="COMMON-LISP____NOT.html">not</a> (P (forall-witness))))</pre> 
 
 <p>The description above suggests that to reason about quantifiers, the 
 following Rules of Thumb, familiar to most any student of logic, are 
 useful.</p> 
 
 <blockquote>
<p>RT1: To prove <span class="v">(exists-p)</span>, construct some object <span class="v">A</span> 
 such that <span class="v">P</span> holds for <span class="v">A</span> and then use <span class="v">exists-P-suff</span>.</p> 
 
 <p>RT2: If you assume <span class="v">exists-P</span> in your hypothesis, use the definition of 
 <span class="v">exists-p</span> to know that <span class="v">P</span> holds for <span class="v">exists-p-witness</span>.  To use 
 this to prove a theorem, you must be able to derive the theorem based on the 
 hypothesis that <span class="v">P</span> holds for something, whatever the something is.</p> 
 
 <p>RT3: To prove <span class="v">forall-P</span>, prove the theorem <span class="v">(P x)</span> (that is, that 
 <span class="v">P</span> holds for an arbitrary <span class="v">x</span>), and then simply instantiate the 
 definition of <span class="v">forall-p</span>, that is, show that <span class="v">P</span> holds for the 
 witness.</p> 
 
 <p>RT4: If you assume <span class="v">forall-p</span> in the hypothesis of the theorem, see how 
 you can prove your conclusion if indeed you were given <span class="v">(P x)</span> as a 
 theorem.  Possibly for the conclusion to hold, you needed that <span class="v">P</span> holds 
 for some specific set of <span class="v">x</span> values.  Then use the theorem 
 <span class="v">forall-p-necc</span> by instantiating it for the specific <span class="v">x</span> values you care 
 about.</p>
</blockquote> 
 
 <p>Perhaps the above is too terse.  In the remainder of the note, we will 
 consider several examples of how this is done to prove theorems in ACL2 that 
 involve quantified notions.</p> 
 
 <p>Let us consider two trivial theorems.  Assume that for some unary function 
 <span class="v">r</span>, you have proved <span class="v">(r x)</span> as a theorem.  Let us see how you can prove 
 that (1) there exists some x such that <span class="v">(r x)</span> holds, and (2) for all 
 <span class="v">x</span> <span class="v">(r x)</span> holds.</p> 
 
 <p>We first model these things using <span class="tt"><a href="ACL2____DEFUN-SK.html">defun-sk</a></span>.  Below, <span class="v">r</span> is 
 simply some function for which <span class="v">(r x)</span> is a theorem.</p> 
 
 <pre class="code">(<a href="ACL2____ENCAPSULATE.html">encapsulate</a>
 (((r *) =&gt; *))
 (<a href="ACL2____LOCAL.html">local</a> (<a href="COMMON-LISP____DEFUN.html">defun</a> r (x) (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORE.html">ignore</a> x)) t))
 (<a href="ACL2____DEFTHM.html">defthm</a> r-holds (r x)))

(<a href="ACL2____DEFUN-SK.html">defun-sk</a> exists-r () (<a href="ACL2____EXISTS.html">exists</a> x (r x)))
(<a href="ACL2____DEFUN-SK.html">defun-sk</a> forall-r () (<a href="ACL2____FORALL.html">forall</a> x (r x)))</pre> 
 
 <p>ACL2 does not have too much reasoning support for quantifiers.  So in most 
 cases, one would need <span class="v">:use</span> hints to reason about quantifiers.  In order 
 to apply <span class="v">:use</span> <a href="ACL2____HINTS.html">hints</a>, it is preferable to keep the function 
 definitions and theorems disabled.</p> 
 
 <pre class="code">(<a href="ACL2____IN-THEORY.html">in-theory</a> (<a href="ACL2____DISABLE.html">disable</a> exists-r exists-r-suff forall-r forall-r-necc))</pre> 
 
 <p>Let us now prove that there is some <span class="v">x</span> such that <span class="v">(r x)</span> holds. 
 Since we want to prove <span class="v">exists-r</span>, we must use <span class="v">exists-r-suff</span> by RT1. 
 We do not need to construct any instance here since <span class="v">r</span> holds for all 
 <span class="v">x</span> by the theorem above.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> exists-r-holds
  (exists-r)
  :hints (("Goal" :use ((:instance exists-r-suff)))))</pre> 
 
 <p>Let us now prove the theorem that for all <span class="v">x</span>, <span class="v">(r x)</span> holds.  By 
 RT3, we must be able to prove it by definition of <span class="v">forall-r</span>.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> forall-r-holds
  (forall-r)
  :hints (("Goal" :use ((:instance (:definition forall-r))))))</pre> 
 
 <p>[Note: Probably no ACL2 user in his or her right mind would prove the 
 theorems <span class="v">exists-r-holds</span> and <span class="v">forall-r-holds</span> above.  The theorems 
 shown are only for demonstration purposes.]</p> 
 
 <p>For the remainder of this note we will assume that we have two stubbed out 
 unary functions <span class="v">M</span> and <span class="v">N</span>, and we will look at proving some quantified 
 properties of these functions.</p> 
 
 <pre class="code">(<a href="ACL2____DEFSTUB.html">defstub</a> M (<a href="COMMON-LISP_____A2.html">*</a>) =&gt; *)
(<a href="ACL2____DEFSTUB.html">defstub</a> N (<a href="COMMON-LISP_____A2.html">*</a>) =&gt; *)</pre> 
 
 <p>Let us now define the predicates <span class="v">all-M</span>, <span class="v">all-N</span>, <span class="v">some-M</span>, and 
 <span class="v">some-N</span> specifying the various quantifications.</p> 
 
 <pre class="code">(<a href="ACL2____DEFUN-SK.html">defun-sk</a> all-M () (<a href="ACL2____FORALL.html">forall</a> x (M x)))
(<a href="ACL2____DEFUN-SK.html">defun-sk</a> all-N () (<a href="ACL2____FORALL.html">forall</a> x (N x)))
(<a href="ACL2____DEFUN-SK.html">defun-sk</a> some-M () (<a href="ACL2____EXISTS.html">exists</a> x (M x)))
(<a href="ACL2____DEFUN-SK.html">defun-sk</a> some-N () (<a href="ACL2____EXISTS.html">exists</a> x (N x)))

(<a href="ACL2____IN-THEORY.html">in-theory</a> (<a href="ACL2____DISABLE.html">disable</a> all-M all-N all-M-necc all-N-necc))
(<a href="ACL2____IN-THEORY.html">in-theory</a> (<a href="ACL2____DISABLE.html">disable</a> some-M some-N some-M-suff some-N-suff))</pre> 
 
 <p>Let us prove the classic distributive properties of quantification: the 
 distributivity of universal quantification over conjunction, and the 
 distributivity of existential quantification over disjunction.  We can state 
 these properties informally in ``pseudo ACL2'' notation as follows:</p> 
 
 <pre class="code">1.  (<a href="ACL2____EXISTS.html">exists</a> x: (M x)) or (<a href="ACL2____EXISTS.html">exists</a> x: (N x)) &lt;=&gt; (<a href="ACL2____EXISTS.html">exists</a> x: (M x) or (N x))
2.  (<a href="ACL2____FORALL.html">forall</a> x: (M x)) and (forall: x (N x)) &lt;=&gt; (<a href="ACL2____FORALL.html">forall</a> x: (M x) and (N x))</pre> 
 
 <p>To make these notions formal we of course need to define the formulas at 
 the right-hand sides of 1 and 2.  So we define <span class="v">some-MN</span> and <span class="v">all-MN</span> to 
 capture these concepts.</p> 
 
 <pre class="code">(<a href="ACL2____DEFUN-SK.html">defun-sk</a> some-MN () (<a href="ACL2____EXISTS.html">exists</a> x (<a href="COMMON-LISP____OR.html">or</a> (M x) (N x))))
(<a href="ACL2____DEFUN-SK.html">defun-sk</a> all-MN () (<a href="ACL2____FORALL.html">forall</a> x (<a href="COMMON-LISP____AND.html">and</a> (M x) (N x))))

(<a href="ACL2____IN-THEORY.html">in-theory</a> (<a href="ACL2____DISABLE.html">disable</a> all-MN all-MN-necc some-MN some-MN-suff))</pre> 
 
 <p>First consider proving property 1.  The formal statement of this theorem 
 would be: <span class="v">(<a href="ACL2____IFF.html">iff</a> (some-MN) (<a href="COMMON-LISP____OR.html">or</a> (some-M) (some-N)))</span>.</p> 
 
 <p>How do we prove this theorem?  Looking at RT1-RT4 above, note that they 
 suggest how one should reason about quantification when one has an 
 ``implication''.  But here we have an ``equivalence''.  This suggests another 
 rule of thumb.</p> 
 
 <blockquote><p>RT5: Whenever possible, prove an equivalence involving 
 quantifiers by proving two implications.</p></blockquote> 
 
 <p>Let us apply RT5 to prove the theorems above.  So we will first prove: 
 <span class="v">(<a href="ACL2____IMPLIES.html">implies</a> (some-MN) (<a href="COMMON-LISP____OR.html">or</a> (some-M) (some-N)))</span></p> 
 
 <p>How can we prove this?  This involves assuming a quantified predicate 
 <span class="v">(some-MN)</span>, so we must use RT2 and apply the definition of <span class="v">some-MN</span>. 
 Since the conclusion involves a disjunction of two quantified predicates, by 
 RT1 we must be able to construct two objects <span class="v">A</span> and <span class="v">B</span> such that 
 either <span class="v">M</span> holds for <span class="v">A</span> or <span class="v">N</span> holds for <span class="v">B</span>, so that we can then 
 invoke <span class="v">some-M-suff</span> and <span class="v">some-N-suff</span> to prove the conclusion.  But now 
 notice that if <span class="v">some-MN</span> is true, then there is already an object, in fact 
 <span class="v">some-MN-witness</span>, such that either <span class="v">M</span> holds for it, or <span class="v">N</span> holds 
 for it.  And we know this is the case from the definition of <span class="v">some-MN</span>! So 
 we will simply prove the theorem instantiating <span class="v">some-M-suff</span> and 
 <span class="v">some-N-suff</span> with this witness.  The conclusion is that the following 
 event will go through with ACL2.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> le1
  (<a href="ACL2____IMPLIES.html">implies</a> (some-MN)
           (<a href="COMMON-LISP____OR.html">or</a> (some-M) (some-N)))
  :rule-classes nil
  :hints (("Goal"
            :use ((:instance (:definition some-MN))
                  (:instance some-M-suff
                             (x (some-MN-witness)))
                  (:instance some-N-suff
                             (x (some-MN-witness)))))))</pre> 
 
 <p>This also suggests the following rule of thumb:</p> 
 
 <blockquote><p>RT6: If a conjecture involves assuming an existentially 
 quantified predicate in the hypothesis from which you are trying to prove an 
 existentially quantified predicate, use the witness of the existential 
 quantification in the hypothesis to construct the witness for the existential 
 quantification in the conclusion.</p></blockquote> 
 
 <p>Let us now try to prove the converse of le1, that is: <span class="v">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____OR.html">or</a>
 (some-M) (some-N)) (some-MN))</span></p> 
 
 <p>Since the hypothesis is a disjunction, we will just prove each case 
 individually instead of proving the theorem by a <span class="v">:</span><span class="v">cases</span> hint.  So we 
 prove the following two lemmas.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> le2
  (<a href="ACL2____IMPLIES.html">implies</a> (some-M) (some-MN))
  :rule-classes nil
  :hints (("Goal"
            :use ((:instance (:definition some-M))
                  (:instance some-MN-suff
                             (x (some-M-witness)))))))

(<a href="ACL2____DEFTHM.html">defthm</a> le3
  (<a href="ACL2____IMPLIES.html">implies</a> (some-N) (some-MN))
  :rule-classes nil
  :hints (("Goal"
            :use ((:instance (:definition some-N))
                  (:instance some-MN-suff
                             (x (some-N-witness)))))))</pre> 
 
 <p>Note that the hints above are simply applications of RT6 as in <span class="v">le1</span>. 
 With these lemmas, of course the main theorem is trivial.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHMD.html">defthmd</a> |some disjunction|
  (<a href="ACL2____IFF.html">iff</a> (some-MN) (<a href="COMMON-LISP____OR.html">or</a> (some-M) (some-N)))
  :hints (("Goal"
            :use ((:instance le1)
                  (:instance le2)
                  (:instance le3)))))</pre> 
 
 <p>Let us now prove the distributivity of universal quantification over 
 conjunction, that is, the formula: <span class="v">(<a href="ACL2____IFF.html">iff</a> (all-MN) (<a href="COMMON-LISP____AND.html">and</a> (all-M)
 (all-N)))</span></p> 
 
 <p>Applying RT5, we will again decompose this into two implications.  So 
 consider first the one-way implication: <span class="v">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (all-M) (all-N))
 (all-MN))</span>.</p> 
 
 <p>Here we get to assume <span class="v">all-M</span> and <span class="v">all-N</span>.  Thus by RT4 we can use 
 <span class="v">all-M-necc</span> and <span class="v">all-N-necc</span> to think as if we are given the formulas 
 <span class="v">(M x)</span> and <span class="v">(N x)</span> as theorems.  The conclusion here is also a 
 universal quantification, namely we have to prove <span class="v">all-MN</span>.  Then RT3 tells 
 us to proceed as follows.  Take any object <span class="v">y</span>.  Try to find an 
 instantiation <span class="v">z</span> of the hypothesis that implies <span class="v">(<a href="COMMON-LISP____AND.html">and</a> (M y) (N y))</span>. 
 Then instantiate <span class="v">y</span> with <span class="v">all-MN-witness</span>.  Note that the hypothesis 
 lets us assume <span class="v">(M x)</span> and <span class="v">(N x)</span> to be theorems.  Thus to justify we 
 need to instantiate <span class="v">x</span> with <span class="v">y</span>, and in this case, therefore, with 
 <span class="v">all-MN-witness</span>.  To make the long story short, the following event goes 
 through with ACL2:</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lf1
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (all-M) (all-N))
            (all-MN))
    :rule-classes nil
    :hints (("Goal"
              :use ((:instance (:definition all-MN))
                    (:instance all-M-necc (x (all-MN-witness)))
                    (:instance all-N-necc (x (all-MN-witness)))))))</pre> 
 
 <p>This suggests the following rule of thumb which is a dual of RT6:</p> 
 
 <blockquote><p>RT7: If a conjecture assumes some universally quantified 
 predicate in the hypothesis and its conclusion asserts a universally 
 quantified predicate, then instantiate the ``necessary condition'' 
 (<span class="v">forall-mn-necc</span>) of the hypothesis with the witness of the conclusion to 
 prove the conjecture.</p></blockquote> 
 
 <p>Applying RT7 now we can easily prove the other theorems that we need to 
 show that universal quantification distributes over conjunction.  Let us just 
 go through this motion in ACL2.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lf2
  (<a href="ACL2____IMPLIES.html">implies</a> (all-MN)
           (all-M))
  :rule-classes nil
  :hints (("Goal"
            :use ((:instance (:definition all-M))
                  (:instance all-MN-necc
                             (x (all-M-witness)))))))

(<a href="ACL2____DEFTHM.html">defthm</a> lf3
  (<a href="ACL2____IMPLIES.html">implies</a> (all-MN)
           (all-N))
  :rule-classes nil
  :hints (("Goal"
            :use ((:instance (:definition all-N))
                  (:instance all-MN-necc
                             (x (all-N-witness)))))))

(<a href="ACL2____DEFTHMD.html">defthmd</a> |all conjunction|
  (<a href="ACL2____IFF.html">iff</a> (all-MN)
       (<a href="COMMON-LISP____AND.html">and</a> (all-M) (all-N)))
 :hints (("Goal" :use ((:instance lf1)
                       (:instance lf2)
                       (:instance lf3)))))</pre> 
 
 <p>The rules of thumb for universal and existential quantification should make 
 you realize the duality of their use.  Every reasoning method about universal 
 quantification can be cast as a way of reasoning about existential 
 quantification, and vice versa.  Whether you reason using universal and 
 existential quantifiers depends on what is natural in a particular context. 
 But just for the sake of completeness let us prove the duality of universal 
 and existential quantifiers.  So what we want to prove is the following:</p> 
 
 <pre class="code">3.  (<a href="ACL2____FORALL.html">forall</a> x (<a href="COMMON-LISP____NOT.html">not</a> (M x))) = (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____EXISTS.html">exists</a> x (M x)))</pre> 
 
 <p>We first formalize the notion of <span class="v">(<a href="ACL2____FORALL.html">forall</a> x (<a href="COMMON-LISP____NOT.html">not</a> (M x)))</span> as a 
 quantification.</p> 
 
 <pre class="code">(<a href="ACL2____DEFUN-SK.html">defun-sk</a> none-M () (<a href="ACL2____FORALL.html">forall</a> x (<a href="COMMON-LISP____NOT.html">not</a> (M x))))
(<a href="ACL2____IN-THEORY.html">in-theory</a> (<a href="ACL2____DISABLE.html">disable</a> none-M none-M-necc))</pre> 
 
 <p>So we now want to prove: <span class="v">(<a href="COMMON-LISP____EQUAL.html">equal</a> (none-M) (<a href="COMMON-LISP____NOT.html">not</a> (some-M)))</span>.</p> 
 
 <p>As before, we should prove this as a pair of implications.  So let us prove 
 first: <span class="v">(<a href="ACL2____IMPLIES.html">implies</a> (none-M) (<a href="COMMON-LISP____NOT.html">not</a> (some-M)))</span>.</p> 
 
 <p>This may seem to assert an existential quantification in the conclusion, 
 but rather, it asserts the <i>negation</i> of an existential quantification. 
 We are now trying to prove that something does not exist.  How do we do that? 
 We can show that nothing satisfies <span class="v">M</span> by just showing that 
 <span class="v">(some-M-witness)</span> does not satisfy <span class="v">M</span>.  This suggests the following 
 rule of thumb:</p> 
 
 <blockquote><p>RT8: When you encounter the negation of an existential 
 quantification think in terms of a universal quantification, and 
 vice-versa.</p></blockquote> 
 
 <p>Ok, so now applying RT8 and RT3 you should be trying to apply the 
 definition of <span class="v">some-M</span>.  The hypothesis is just a pure (non-negated) 
 universal quantification so you should apply RT4.  A blind application lets us 
 prove the theorem as below.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nl1
  (<a href="ACL2____IMPLIES.html">implies</a> (none-M) (<a href="COMMON-LISP____NOT.html">not</a> (some-M)))
  :rule-classes nil
  :hints (("Goal"
            :use ((:instance (:definition some-M))
                  (:instance none-M-necc (x (some-M-witness)))))))</pre> 
 
 <p>How about the converse implication?  I have deliberately written it as 
 <span class="v">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (none-M)) (some-M))</span> instead of switching the left-hand and 
 right-hand sides of <span class="v">nl1</span>, which would have been equivalent.  Again, RH8 
 tells us how to reason about it, in this case using RH2, and we succeed.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nl2
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (none-M)) (some-M))
  :rule-classes nil
  :hints (("Goal"
            :use ((:instance (:definition none-M))
                  (:instance some-M-suff (x (none-M-witness)))))))</pre> 
 
 <p>So finally we just go through the motions of proving the equality.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHMD.html">defthmd</a> |forall not = not exists|
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (none-M) (<a href="COMMON-LISP____NOT.html">not</a> (some-M)))
  :hints (("Goal"
            :use ((:instance nl1)
                  (:instance nl2)))))</pre> 
 
 <p>Let us now see if we can prove a slightly more advanced theorem which can 
 be stated informally as: If there is a natural number <span class="v">x</span> which satisfies 
 <span class="v">M</span>, then there is a least natural number <span class="v">y</span> that satisfies <span class="v">M</span>.</p> 
 
 <p>[Note: Any time I have had to reason about existential quantification I 
 have had to do this particular style of reasoning and state that if there is 
 an object satisfying a predicate, then there is also a ``minimal'' object 
 satisfying the predicate.]</p> 
 
 <p>Let us formalize this concept.  We first define the concept of existence of 
 a natural number satisfying <span class="v">x</span>.</p> 
 
 <pre class="code">(<a href="ACL2____DEFUN-SK.html">defun-sk</a> some-nat-M () (<a href="ACL2____EXISTS.html">exists</a> x (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> x) (M x))))
(<a href="ACL2____IN-THEORY.html">in-theory</a> (<a href="ACL2____DISABLE.html">disable</a> some-nat-M some-nat-M-suff))</pre> 
 
 <p>We now talk about what it means to say that <span class="v">x</span> is the least number 
 satisfying <span class="v">M</span>.</p> 
 
 <pre class="code">(<a href="ACL2____DEFUN-SK.html">defun-sk</a> none-below (y)
  (<a href="ACL2____FORALL.html">forall</a> r (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> r) (<a href="COMMON-LISP_____C3.html">&lt;</a> r y)) (<a href="COMMON-LISP____NOT.html">not</a> (M r))))))
(<a href="ACL2____IN-THEORY.html">in-theory</a> (<a href="ACL2____DISABLE.html">disable</a> none-below none-below-necc))

(<a href="ACL2____DEFUN-SK.html">defun-sk</a> min-M () (<a href="ACL2____EXISTS.html">exists</a> y (<a href="COMMON-LISP____AND.html">and</a> (M y) (<a href="ACL2____NATP.html">natp</a> y) (none-below y))))
(<a href="ACL2____IN-THEORY.html">in-theory</a> (<a href="ACL2____DISABLE.html">disable</a> min-M min-M-suff))</pre> 
 
 <p>The predicate <span class="v">none-below</span> says that no natural number less than <span class="v">y</span> 
 satisfies <span class="v">M</span>.  The predicate <span class="v">min-M</span> says that there is some natural 
 number <span class="v">y</span> satisfying <span class="v">M</span> such that <span class="v">none-below</span> holds for 
 <span class="v">y</span>.</p> 
 
 <p>So the formula we want to prove is: <span class="v">(<a href="ACL2____IMPLIES.html">implies</a> (some-nat-M)
 (min-M))</span>.</p> 
 
 <p>Since the formula requires that we prove an existential quantification, RT1 
 tells us to construct some object satisfying the predicate over which we are 
 quantifying.  We should then be able to instantiate <span class="v">min-M-suff</span> with this 
 object.  That predicate says that the object must be the least natural number 
 that satisfies <span class="v">M</span>.  Since such an object is uniquely computable if we know 
 that there exists some natural number satisfying <span class="v">M</span>, let us just write a 
 recursive function to compute it.  This function is <span class="v">least-M</span> below.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> least-M-aux (i bound)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :measure (<a href="ACL2____NFIX.html">nfix</a> (<a href="COMMON-LISP____-.html">-</a> (<a href="COMMON-LISP____1_B2.html">1+</a> bound) i))))
  (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____NATP.html">natp</a> i))
             (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____NATP.html">natp</a> bound))
             (<a href="COMMON-LISP_____E3.html">&gt;</a> i bound))
         0)
       ((M i) i)
       (t (least-M-aux (<a href="COMMON-LISP_____B2.html">+</a> i 1) bound))))

(<a href="COMMON-LISP____DEFUN.html">defun</a> least-M (bound) (least-M-aux 0 bound))</pre> 
 
 <p>Let us now reason about this function as one does typically.  So we prove 
 that this object is indeed the least natural number that satisfies <span class="v">M</span>, 
 assuming that <span class="v">bound</span> is a natural number that satisfies <span class="v">M</span>.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> least-aux-produces-an-M
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> i)
                (<a href="ACL2____NATP.html">natp</a> bound)
                (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> i bound)
                (M bound))
           (M (least-M-aux i bound))))

(<a href="ACL2____DEFTHM.html">defthm</a> least-&lt;=bound
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 0 bound)
           (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (least-M-aux i bound) bound)))

(<a href="ACL2____DEFTHM.html">defthm</a> least-aux-produces-least
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> i)
                (<a href="ACL2____NATP.html">natp</a> j)
                (<a href="ACL2____NATP.html">natp</a> bound)
                (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> i j)
                (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> j bound)
                (M j))
            (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (least-M-aux i bound) j)))

(<a href="ACL2____DEFTHM.html">defthm</a> least-aux-produces-natp
  (<a href="ACL2____NATP.html">natp</a> (least-M-aux i bound)))

(<a href="ACL2____DEFTHMD.html">defthmd</a> least-is-minimal-satisfying-m
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> bound)
                (<a href="ACL2____NATP.html">natp</a> i)
                 (<a href="COMMON-LISP_____C3.html">&lt;</a> i (least-M bound)))
           (<a href="COMMON-LISP____NOT.html">not</a> (M i)))
  :hints (("Goal"
            :in-theory (<a href="ACL2____DISABLE.html">disable</a> least-aux-produces-least least-&lt;=bound)
            :use ((:instance least-&lt;=bound
                             (i 0))
                  (:instance least-aux-produces-least
                             (i 0)
                             (j i))))))

(<a href="ACL2____DEFTHM.html">defthm</a> least-has-m
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> bound)
                (m bound))
           (M (least-M bound))))

(<a href="ACL2____DEFTHM.html">defthm</a> least-is-natp
  (<a href="ACL2____NATP.html">natp</a> (least-M bound)))</pre> 
 
 <p>So we have done that, and hopefully this is all that we need about 
 <span class="v">least-M</span>.  So we disable everything.</p> 
 
 <pre class="code">(<a href="ACL2____IN-THEORY.html">in-theory</a> (<a href="ACL2____DISABLE.html">disable</a> least-M natp))</pre> 
 
 <p>Now of course we note that the statement of the conjecture we are 
 interested in has two quantifiers, an inner <span class="v">forall</span> (from <span class="v">none-below</span>) 
 and an outer <span class="v">exists</span> (from <span class="v">min-M</span>).  Since ACL2 is not very good with 
 quantification, we hold its hands to reason with the quantifier part.  So we 
 will first prove something about the <span class="v">forall</span> and then use it to prove what 
 we need about the <span class="v">exists</span>.</p> 
 
 <blockquote><p>RT9: When you face nested quantifiers, reason about each 
 nesting separately.</p></blockquote> 
 
 <p>So what do we want to prove about the inner quantifier?  Looking carefully 
 at the definition of <span class="v">none-below</span> we see that it is saying that for all 
 natural numbers <span class="v">r</span> &lt; <span class="v">y</span>, <span class="v">(M r)</span> does not hold.  Well, how would 
 we want to use this fact when we want to prove our final theorem?  We expect 
 that we will instantiate <span class="v">min-M-suff</span> with the object <span class="v">(least-M bound)</span> 
 where we know (via the outermost existential quantifier) that <span class="v">M</span> holds for 
 <span class="v">bound</span>, and we will then want to show that <span class="v">none-below</span> holds for 
 <span class="v">(least-M bound)</span>.  So let us prove that for any natural number (call it 
 <span class="v">bound</span>), <span class="v">none-below</span> holds for <span class="v">(least-M bound)</span>.  For the final 
 theorem we only need it for natural numbers satisfying <span class="v">M</span>, but note that 
 from the lemma <span class="v">least-is-minimal-satisfying-m</span> we really do not need that 
 <span class="v">bound</span> satisfies <span class="v">M</span>.</p> 
 
 <p>So we are now proving: <span class="v">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____NATP.html">natp</a> bound) (none-below (least-M
 bound)))</span>.</p> 
 
 <p>Well since this is a standard case of proving a universally quantified 
 predicate, we just apply RT3.  We have proved that for all naturals <span class="v">i</span> 
 &lt; <span class="v">(least-M bound)</span>, <span class="v">i</span> does not satisfy <span class="v">M</span> (lemma 
 <span class="v">least-is-minimal-satisfying-M</span>), so we merely need the instantiation of 
 that lemma with <span class="v">none-below-witness</span> of the thing we are trying to prove, 
 that is, <span class="v">(least-M bound)</span>.  The theorem below thus goes through.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> least-is-minimal
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____NATP.html">natp</a> bound)
           (none-below (least-M bound)))
  :hints (("Goal"
            :use ((:instance (:definition none-below)
                             (y (least-M bound)))
                  (:instance least-is-minimal-satisfying-m
                             (i (none-below-witness (least-M bound))))))))</pre> 
 
 <p>Finally we are in the outermost existential quantifier, and are in the 
 process of applying <span class="v">min-M-suff</span>.  What object should we instantiate it 
 with?  We must instantiate it with <span class="v">(least-M bound)</span> where <span class="v">bound</span> is an 
 object which must satisfy <span class="v">M</span> and is a natural.  We have such an object, 
 namely <span class="v">(some-nat-M-witness)</span> which we know have all these qualities given 
 the hypothesis.  So the proof now is just RT1 and RT2.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> |minimal exists|
  (<a href="ACL2____IMPLIES.html">implies</a> (some-nat-M) (min-M))
  :hints (("Goal"
            :use ((:instance min-M-suff
                             (y (least-M (some-nat-M-witness))))
                  (:instance (:definition some-nat-M))))))</pre> 
 
 <p>If you are comfortable with the reasoning above, then you are comfortable 
 with quantifiers and probably will not need these notes any more.  In my 
 opinion, the best way of dealing with ACL2 is to ask yourself why you think 
 something is a theorem, and the rules of thumb above are simply guides to the 
 questions that you need to ask when you are dealing with quantification.</p> 
 
 <p>Here are a couple of simple exercises for you to test if you understand the 
 reasoning process.</p> 
 
 <p><b>Exercise 1</b>.  Formalize and prove the following theorem.  Suppose 
 there exists <span class="v">x</span> such that <span class="v">(R x)</span> and suppose that all <span class="v">x</span> satisfy 
 <span class="v">(P x)</span>.  Then prove that there exists <span class="v">x</span> such that <span class="v">(P x) &amp; (R x)</span>. 
 (See <a href="http://www.cs.utexas.edu/users/moore/acl2/contrib/quantifier-exercise-1-solution.html" target="_blank"><nobr>http://www.cs.utexas.edu/users/moore/acl2/contrib/quantifier-exercise-1-solution.html<img src="../Icon_External_Link.png" title="External link to http://www.cs.utexas.edu/users/moore/acl2/contrib/quantifier-exercise-1-solution.html"></nobr></a> 
 for a solution.)</p> 
 
 <p><b>Exercise 2</b>.  Recall the example just before the preceding exercise, 
 where we showed that if there exists a natural number <span class="v">x</span> satisfying <span class="v">M</span> 
 then there is another natural number <span class="v">y</span> such that <span class="v">y</span> satisfies <span class="v">M</span> 
 and for every natural number <span class="v">z</span> &lt; <span class="v">y</span>, <span class="v">z</span> does not.  What would 
 happen if we remove the restriction of <span class="v">x</span>, <span class="v">y</span>, and <span class="v">z</span> being 
 naturals?  Of course, we will not talk about <span class="v">&lt;</span> any more, but suppose you 
 use a total order on all ACL2 objects such as <a href="ACL2_____C3_C3.html">&lt;&lt;</a>.  More concretely, 
 consider the definition of <span class="v">some-M</span> above.  Let us now define two other 
 functions:</p> 
 
 <pre class="code">(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "misc/total-order" :dir :system)

(<a href="ACL2____DEFUN-SK.html">defun-sk</a> none-below-2 (y)
  (<a href="ACL2____FORALL.html">forall</a> r (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2_____C3_C3.html">&lt;&lt;</a> r y) (<a href="COMMON-LISP____NOT.html">not</a> (M r)))))

(<a href="ACL2____DEFUN-SK.html">defun-sk</a> min-M2 () (<a href="ACL2____EXISTS.html">exists</a> y (<a href="COMMON-LISP____AND.html">and</a> (M y) (none-below-2 y))))</pre> 
 
 <p>The question is whether <span class="v">(<a href="ACL2____IMPLIES.html">implies</a> (some-M) (min-M2))</span> is a theorem.  Can 
 you prove it?  Can you disprove it?</p>
</body>
</html>
