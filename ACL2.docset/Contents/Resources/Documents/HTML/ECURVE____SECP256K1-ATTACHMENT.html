<html>
<head>
<meta charset="UTF-8">
<title>Secp256k1-attachment</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ECURVE____SECP256K1-ATTACHMENT">Click for Secp256k1-attachment in the Full Manual</a></h3>

<p>Executable attachments for the <a href="ECURVE____SECP256K1-INTERFACE.html">elliptic curve secp256k1 interface</a>.</p><p>We define an executable definition of private-to-public key conversion, 
     and attach it to the constrained function.</p><p>We define a wrapper of the curve group multiplication definition 
     and attach the wrapper to the constrained function. 
     The wrapper converts between the fixtype of points 
     and the representation of points 
     used by the definition of the curve group operations; 
     it also ensures that the starting point is on the curve, 
     as required by the guards of the defined curve group operation. 
     Note that <span class="v">secp256k1+</span> is never expected to return (0, 0), 
     because the point at infinity is represented as <span class="v">:infinity</span> 
     and the point (0, 0) is not on the curve; 
     to satisfy the guard of <span class="tt"><a href="ECURVE____POINTP-TO-SECP256K1-POINT.html">pointp-to-secp256k1-point</a></span>, 
     we check that at run time, raising an error if the test should ever fail 
     (which we never expect to).</p><p>We define a wrapper of the curve group addition definition 
     and attach the wrapper to the constrained function. 
     The wrapper converts between the fixtype of points 
     and the representation of points 
     used by the definition of the curve group operations; 
     it also ensures that the starting points are on the curve, 
     as required by the guards of the defined curve group operation. 
     Note that <span class="v">secp256k1+</span> is never expected to return (0, 0), 
     because the point at infinity is represented as <span class="v">:infinity</span> 
     and the point (0, 0) is not on the curve; 
     to satisfy the guard of <span class="tt"><a href="ECURVE____POINTP-TO-SECP256K1-POINT.html">pointp-to-secp256k1-point</a></span>, 
     we check that at run time, raising an error if the test should ever fail 
     (which we never expect to). 
     If we multiply the secp256k1 generator point by a private key, 
     we obtain a valid public key, 
     i.e. not the point at infinity. 
     At this time we do not have that theorem proved and available, 
     so for now we insert a run-time check that is never expected to fail.</p><p>For executable formal specifications, see the <a href="ECURVE____SECP256K1.html">library for the 
     Short Weierstrass elliptic curve secp256k1</a>.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>secp256k1-priv-to-pub-exec</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> secp256k1-priv-to-pub-exec (priv)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ECURVE____SECP256K1-PRIV-KEY-P.html">secp256k1-priv-key-p</a> priv)))
       (<a href="ACL2____B_A2.html">b*</a> ((priv (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ECURVE____SECP256K1-PRIV-KEY-FIX.html">secp256k1-priv-key-fix</a> priv)
                       :exec priv))
            (pub (<a href="ECURVE____SECP256K1-MUL.html">secp256k1-mul</a> priv (<a href="ECURVE____SECP256K1-POINT-GENERATOR.html">secp256k1-point-generator</a>))))
           pub))</pre> 
<p><b>Theorem: </b>secp256k1-pub-key-p-of-secp256k1-priv-to-pub-exec</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> secp256k1-pub-key-p-of-secp256k1-priv-to-pub-exec
        (<a href="ACL2____B_A2.html">b*</a> ((pub (secp256k1-priv-to-pub-exec priv)))
            (<a href="ECURVE____SECP256K1-PUB-KEY-P.html">secp256k1-pub-key-p</a> pub))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>secp256k1-priv-to-pub-exec-of-secp256k1-priv-key-fix-priv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   secp256k1-priv-to-pub-exec-of-secp256k1-priv-key-fix-priv
   (<a href="COMMON-LISP____EQUAL.html">equal</a> (secp256k1-priv-to-pub-exec (<a href="ECURVE____SECP256K1-PRIV-KEY-FIX.html">secp256k1-priv-key-fix</a> priv))
          (secp256k1-priv-to-pub-exec priv)))</pre> 
<p><b>Theorem: </b>secp256k1-priv-to-pub-exec-secp256k1-priv-key-equiv-congruence-on-priv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 secp256k1-priv-to-pub-exec-secp256k1-priv-key-equiv-congruence-on-priv
 (<a href="ACL2____IMPLIES.html">implies</a> (secp256k1-priv-key-equiv priv priv-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (secp256k1-priv-to-pub-exec priv)
                 (secp256k1-priv-to-pub-exec priv-equiv)))
 :rule-classes :congruence)</pre> 
<p><b>Function: </b>secp256k1-add-wrapper</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 secp256k1-add-wrapper
 (secp-point1 secp-point2)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ECURVE____SECP256K1-POINTP.html">secp256k1-pointp</a> secp-point1)
                             (<a href="ECURVE____SECP256K1-POINTP.html">secp256k1-pointp</a> secp-point2))))
 (<a href="COMMON-LISP____LET.html">let</a>
   ((acl2::__function__ 'secp256k1-add-wrapper))
   (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
   (<a href="ACL2____B_A2.html">b*</a> ((point1 (<a href="ECURVE____SECP256K1-POINT-TO-POINTP.html">secp256k1-point-to-pointp</a> secp-point1))
        (point2 (<a href="ECURVE____SECP256K1-POINT-TO-POINTP.html">secp256k1-point-to-pointp</a> secp-point2))
        ((unless (<a href="ECURVE____POINT-ON-WEIERSTRASS-ELLIPTIC-CURVE-P.html">point-on-weierstrass-elliptic-curve-p</a>
                      point1 (<a href="PRIMES____SECP256K1-FIELD-PRIME.html">secp256k1-field-prime</a>)
                      (<a href="ECURVE____SECP256K1-A.html">secp256k1-a</a>)
                      (<a href="ECURVE____SECP256K1-B.html">secp256k1-b</a>)))
         (<a href="ECURVE____SECP256K1-POINT.html">secp256k1-point</a> 1 1))
        ((unless (<a href="ECURVE____POINT-ON-WEIERSTRASS-ELLIPTIC-CURVE-P.html">point-on-weierstrass-elliptic-curve-p</a>
                      point2 (<a href="PRIMES____SECP256K1-FIELD-PRIME.html">secp256k1-field-prime</a>)
                      (<a href="ECURVE____SECP256K1-A.html">secp256k1-a</a>)
                      (<a href="ECURVE____SECP256K1-B.html">secp256k1-b</a>)))
         (<a href="ECURVE____SECP256K1-POINT.html">secp256k1-point</a> 1 1))
        (result (<a href="ECURVE____SECP256K1_B2.html">secp256k1+</a> point1 point2))
        ((when (<a href="COMMON-LISP____EQUAL.html">equal</a> result (<a href="COMMON-LISP____CONS.html">cons</a> 0 0)))
         (<a href="ACL2____RAISE.html">acl2::raise</a> "Internal error: SECP256K1+ produced (0, 0).")
         (<a href="ECURVE____SECP256K1-POINT.html">secp256k1-point</a> 1 1))
        (secp-result (<a href="ECURVE____POINTP-TO-SECP256K1-POINT.html">pointp-to-secp256k1-point</a> result)))
       secp-result)))</pre> 
<p><b>Theorem: </b>secp256k1-pointp-of-secp256k1-add-wrapper</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 secp256k1-pointp-of-secp256k1-add-wrapper
 (<a href="ACL2____B_A2.html">b*</a> ((secp-result (secp256k1-add-wrapper secp-point1 secp-point2)))
     (<a href="ECURVE____SECP256K1-POINTP.html">secp256k1-pointp</a> secp-result))
 :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>secp256k1-add-wrapper-of-secp256k1-point-fix-secp-point1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     secp256k1-add-wrapper-of-secp256k1-point-fix-secp-point1
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (secp256k1-add-wrapper (<a href="ECURVE____SECP256K1-POINT-FIX.html">secp256k1-point-fix</a> secp-point1)
                                   secp-point2)
            (secp256k1-add-wrapper secp-point1 secp-point2)))</pre> 
<p><b>Theorem: </b>secp256k1-add-wrapper-secp256k1-point-equiv-congruence-on-secp-point1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 secp256k1-add-wrapper-secp256k1-point-equiv-congruence-on-secp-point1
 (<a href="ACL2____IMPLIES.html">implies</a>
      (<a href="ECURVE____SECP256K1-POINT-EQUIV.html">secp256k1-point-equiv</a> secp-point1 secp-point1-equiv)
      (<a href="COMMON-LISP____EQUAL.html">equal</a> (secp256k1-add-wrapper secp-point1 secp-point2)
             (secp256k1-add-wrapper secp-point1-equiv secp-point2)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>secp256k1-add-wrapper-of-secp256k1-point-fix-secp-point2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    secp256k1-add-wrapper-of-secp256k1-point-fix-secp-point2
    (<a href="COMMON-LISP____EQUAL.html">equal</a> (secp256k1-add-wrapper secp-point1
                                  (<a href="ECURVE____SECP256K1-POINT-FIX.html">secp256k1-point-fix</a> secp-point2))
           (secp256k1-add-wrapper secp-point1 secp-point2)))</pre> 
<p><b>Theorem: </b>secp256k1-add-wrapper-secp256k1-point-equiv-congruence-on-secp-point2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 secp256k1-add-wrapper-secp256k1-point-equiv-congruence-on-secp-point2
 (<a href="ACL2____IMPLIES.html">implies</a>
      (<a href="ECURVE____SECP256K1-POINT-EQUIV.html">secp256k1-point-equiv</a> secp-point2 secp-point2-equiv)
      (<a href="COMMON-LISP____EQUAL.html">equal</a> (secp256k1-add-wrapper secp-point1 secp-point2)
             (secp256k1-add-wrapper secp-point1 secp-point2-equiv)))
 :rule-classes :congruence)</pre> 
<p><b>Function: </b>secp256k1-mul-wrapper</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 secp256k1-mul-wrapper (nat secp-point)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> nat)
                             (<a href="ECURVE____SECP256K1-POINTP.html">secp256k1-pointp</a> secp-point))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'secp256k1-mul-wrapper))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____B_A2.html">b*</a>
   ((nat (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____NFIX.html">nfix</a> nat) :exec nat))
    (<a href="ECURVE____POINT.html">point</a> (<a href="ECURVE____SECP256K1-POINT-TO-POINTP.html">secp256k1-point-to-pointp</a> secp-point))
    ((unless (<a href="ECURVE____POINT-ON-WEIERSTRASS-ELLIPTIC-CURVE-P.html">point-on-weierstrass-elliptic-curve-p</a>
                  point (<a href="PRIMES____SECP256K1-FIELD-PRIME.html">secp256k1-field-prime</a>)
                  (<a href="ECURVE____SECP256K1-A.html">secp256k1-a</a>)
                  (<a href="ECURVE____SECP256K1-B.html">secp256k1-b</a>)))
     (<a href="ECURVE____SECP256K1-POINT.html">secp256k1-point</a> 1 1))
    (result (<a href="ECURVE____SECP256K1_A2.html">secp256k1*</a> nat point))
    ((when (<a href="COMMON-LISP____EQUAL.html">equal</a> result (<a href="COMMON-LISP____CONS.html">cons</a> 0 0)))
     (<a href="ACL2____RAISE.html">acl2::raise</a> "Internal error: SECP256K1* produced (0, 0).")
     (<a href="ECURVE____SECP256K1-POINT.html">secp256k1-point</a> 1 1))
    (secp-result (<a href="ECURVE____POINTP-TO-SECP256K1-POINT.html">pointp-to-secp256k1-point</a> result))
    ((when (<a href="COMMON-LISP____AND.html">and</a> (<a href="ECURVE____SECP256K1-PRIV-KEY-P.html">secp256k1-priv-key-p</a> nat)
                (<a href="ECURVE____SECP256K1-POINT-EQUIV.html">secp256k1-point-equiv</a>
                     secp-point (<a href="ECURVE____SECP256K1-POINT-GENERATOR.html">secp256k1-point-generator</a>))
                (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ECURVE____SECP256K1-PUB-KEY-P.html">secp256k1-pub-key-p</a> secp-result))))
     (<a href="ACL2____RAISE.html">acl2::raise</a>
      "Internal error: ~
                        SECP256K1* on a private key and the generator ~
                        has produced ~x0, which is not a public key."
      secp-result)
     (<a href="ECURVE____SECP256K1-POINT.html">secp256k1-point</a> 1 1)))
   secp-result)))</pre> 
<p><b>Theorem: </b>secp256k1-pointp-of-secp256k1-mul-wrapper</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> secp256k1-pointp-of-secp256k1-mul-wrapper
        (<a href="ACL2____B_A2.html">b*</a> ((secp-result (secp256k1-mul-wrapper nat secp-point)))
            (<a href="ECURVE____SECP256K1-POINTP.html">secp256k1-pointp</a> secp-result))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>secp256k1-mul-wrapper-yields-pub-from-priv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  secp256k1-mul-wrapper-yields-pub-from-priv
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ECURVE____SECP256K1-PRIV-KEY-P.html">secp256k1-priv-key-p</a> nat)
                (<a href="COMMON-LISP____EQUAL.html">equal</a> point (<a href="ECURVE____SECP256K1-POINT-GENERATOR.html">secp256k1-point-generator</a>)))
           (<a href="ECURVE____SECP256K1-PUB-KEY-P.html">secp256k1-pub-key-p</a> (secp256k1-mul-wrapper nat point))))</pre> 
<p><b>Theorem: </b>secp256k1-mul-wrapper-of-nfix-nat</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> secp256k1-mul-wrapper-of-nfix-nat
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (secp256k1-mul-wrapper (<a href="ACL2____NFIX.html">nfix</a> nat)
                                      secp-point)
               (secp256k1-mul-wrapper nat secp-point)))</pre> 
<p><b>Theorem: </b>secp256k1-mul-wrapper-nat-equiv-congruence-on-nat</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     secp256k1-mul-wrapper-nat-equiv-congruence-on-nat
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____NAT-EQUIV.html">nat-equiv</a> nat nat-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (secp256k1-mul-wrapper nat secp-point)
                     (secp256k1-mul-wrapper nat-equiv secp-point)))
     :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>secp256k1-mul-wrapper-of-secp256k1-point-fix-secp-point</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 secp256k1-mul-wrapper-of-secp256k1-point-fix-secp-point
 (<a href="COMMON-LISP____EQUAL.html">equal</a> (secp256k1-mul-wrapper nat (<a href="ECURVE____SECP256K1-POINT-FIX.html">secp256k1-point-fix</a> secp-point))
        (secp256k1-mul-wrapper nat secp-point)))</pre> 
<p><b>Theorem: </b>secp256k1-mul-wrapper-secp256k1-point-equiv-congruence-on-secp-point</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 secp256k1-mul-wrapper-secp256k1-point-equiv-congruence-on-secp-point
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ECURVE____SECP256K1-POINT-EQUIV.html">secp256k1-point-equiv</a> secp-point secp-point-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (secp256k1-mul-wrapper nat secp-point)
                 (secp256k1-mul-wrapper nat secp-point-equiv)))
 :rule-classes :congruence)</pre> 

</body>
</html>
