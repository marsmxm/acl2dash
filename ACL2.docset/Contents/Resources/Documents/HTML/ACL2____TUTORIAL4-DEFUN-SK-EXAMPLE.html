<html>
<head>
<meta charset="UTF-8">
<title>Tutorial4-defun-sk-example</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____TUTORIAL4-DEFUN-SK-EXAMPLE">Click for Tutorial4-defun-sk-example in the Full Manual</a></h3>

<p>Example of quantified notions</p><p>This example illustrates the use of <span class="tt"><a href="ACL2____DEFUN-SK.html">defun-sk</a></span> and <span class="tt"><a href="ACL2____DEFTHM.html">defthm</a></span> <a href="ACL2____EVENTS.html">events</a> to reason about quantifiers.  See <a href="ACL2____DEFUN-SK.html">defun-sk</a>.  For 
 a more through, systematic beginner's introduction to quantification in ACL2, 
 see <a href="ACL2____QUANTIFIER-TUTORIAL.html">quantifier-tutorial</a>.</p> 
 
 <p>Many users prefer to avoid the use of quantifiers, since ACL2 provides only 
 very limited support for reasoning about quantifiers.</p> 
 
 <p>Here is a list of <a href="ACL2____EVENTS.html">events</a> that proves that if there are arbitrarily 
 large numbers satisfying the disjunction <span class="v">(<a href="COMMON-LISP____OR.html">OR</a> P R)</span>, then either there are 
 arbitrarily large numbers satisfying <span class="v">P</span> or there are arbitrarily large 
 numbers satisfying <span class="v">R</span>.</p> 
 
 <pre class="code">; Introduce undefined predicates p and r.
(<a href="ACL2____DEFSTUB.html">defstub</a> p (x) t)
(<a href="ACL2____DEFSTUB.html">defstub</a> r (x) t)

; Define the notion that something bigger than x satisfies p.
(<a href="ACL2____DEFUN-SK.html">defun-sk</a> some-bigger-p (x)
  (<a href="ACL2____EXISTS.html">exists</a> y (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> x y) (p y))))

; Define the notion that something bigger than x satisfies r.
(<a href="ACL2____DEFUN-SK.html">defun-sk</a> some-bigger-r (x)
  (<a href="ACL2____EXISTS.html">exists</a> y (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> x y) (r y))))

; Define the notion that arbitrarily large x satisfy p.
(<a href="ACL2____DEFUN-SK.html">defun-sk</a> arb-lg-p ()
  (<a href="ACL2____FORALL.html">forall</a> x (some-bigger-p x)))

; Define the notion that arbitrarily large x satisfy r.
(<a href="ACL2____DEFUN-SK.html">defun-sk</a> arb-lg-r ()
  (<a href="ACL2____FORALL.html">forall</a> x (some-bigger-r x)))

; Define the notion that something bigger than x satisfies p or r.
(<a href="ACL2____DEFUN-SK.html">defun-sk</a> some-bigger-p-or-r (x)
  (<a href="ACL2____EXISTS.html">exists</a> y (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> x y) (<a href="COMMON-LISP____OR.html">or</a> (p y) (r y)))))

; Define the notion that arbitrarily large x satisfy p or r.
(<a href="ACL2____DEFUN-SK.html">defun-sk</a> arb-lg-p-or-r ()
  (<a href="ACL2____FORALL.html">forall</a> x (some-bigger-p-or-r x)))

; Prove the theorem promised above.  Notice that the functions open
; automatically, but that we have to provide help for some rewrite
; rules because they have free variables in the hypotheses.  The
; ``witness functions'' mentioned below were introduced by DEFUN-SK.

(<a href="ACL2____THM.html">thm</a>
 (<a href="ACL2____IMPLIES.html">implies</a> (arb-lg-p-or-r)
          (<a href="COMMON-LISP____OR.html">or</a> (arb-lg-p)
              (arb-lg-r)))
 :hints (("Goal"
          :use
          ((:instance some-bigger-p-suff
                      (x (arb-lg-p-witness))
                      (y (some-bigger-p-or-r-witness
                          (<a href="COMMON-LISP____MAX.html">max</a> (arb-lg-p-witness)
                               (arb-lg-r-witness)))))
           (:instance some-bigger-r-suff
                      (x (arb-lg-r-witness))
                      (y (some-bigger-p-or-r-witness
                          (<a href="COMMON-LISP____MAX.html">max</a> (arb-lg-p-witness)
                               (arb-lg-r-witness)))))
           (:instance arb-lg-p-or-r-necc
                      (x (<a href="COMMON-LISP____MAX.html">max</a> (arb-lg-p-witness)
                              (arb-lg-r-witness))))))))

; And finally, here's a cute little example.  We have already
; defined above the notion (some-bigger-p x), which says that
; something bigger than x satisfies p.  Let us introduce a notion
; that asserts that there exists both y and z bigger than x which
; satisfy p.  On first glance this new notion may appear to be
; stronger than the old one, but careful inspection shows that y and
; z do not have to be distinct.  In fact ACL2 realizes this, and
; proves the theorem below automatically.

(<a href="ACL2____DEFUN-SK.html">defun-sk</a> two-bigger-p (x)
  (<a href="ACL2____EXISTS.html">exists</a> (y z) (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> x y) (p y) (<a href="COMMON-LISP_____C3.html">&lt;</a> x z) (p z))))

(<a href="ACL2____THM.html">thm</a> (<a href="ACL2____IMPLIES.html">implies</a> (some-bigger-p x) (two-bigger-p x)))

; A technical point:  ACL2 fails to prove the theorem above
; automatically if we take its contrapositive, unless we disable
; two-bigger-p as shown below.  That is because ACL2 needs to expand
; some-bigger-p before applying the rewrite rule introduced for
; two-bigger-p, which contains free variables.  The moral of the
; story is:  Don't expect too much automatic support from ACL2 for
; reasoning about quantified notions.

(<a href="ACL2____THM.html">thm</a> (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (two-bigger-p x)) (<a href="COMMON-LISP____NOT.html">not</a> (some-bigger-p x)))
     :hints (("Goal" :in-theory (<a href="ACL2____DISABLE.html">disable</a> two-bigger-p))))</pre>
</body>
</html>
