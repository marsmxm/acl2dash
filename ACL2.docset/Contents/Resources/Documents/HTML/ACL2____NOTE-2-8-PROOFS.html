<html>
<head>
<meta charset="UTF-8">
<title>Note-2-8-proofs</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____NOTE-2-8-PROOFS">Click for Note-2-8-proofs in the Full Manual</a></h3>

<p>ACL2 Version  2.8 Notes on Changes in Proof Engine</p><p>ACL2 now prevents certain rewriting loops; see <a href="ACL2____REWRITE-STACK-LIMIT.html">rewrite-stack-limit</a>.</p> 
 
 <p>During the computation of <span class="tt"><a href="ACL2____CONSTRAINT.html">constraint</a></span>s for functional instantiation, 
 <span class="v">(<a href="ACL2____PROG2_42.html">prog2$</a> term1 term2)</span> and <span class="v">(<a href="COMMON-LISP____THE.html">the</a> type term2)</span> are now treated as 
 <span class="v">term2</span>.</p> 
 
 <p>A change has been made in heuristics for controlling rewriting during 
 proofs by induction.  Formerly, during induction proofs, ACL2 suppressed 
 rewriting of certain ``induction hypothesis'' terms, and forced expansion of 
 certain ``induction conclusion'' terms, until rewriting had stabilized.  This 
 meddling with the rewriter is still turned off when rewriting has stabilized, 
 but it is now turned off earlier once an ancestor has been through the 
 rewriter and the current goal is free of ``induction conclusion'' terms. 
 Thanks to Dave Greve and Matt Wilding for providing an example and associated 
 analysis that led us to look for a heuristic modification.</p> 
 
 <p>A change has been made in the heuristics for handling certain ``weak'' 
 <a href="ACL2____COMPOUND-RECOGNIZER.html">compound-recognizer</a> rules when building contexts.  Those who want to 
 dig deeply into this change are welcome to look at the code following the call 
 of <span class="v">most-recent-enabled-recog-tuple</span> in the code for function 
 <span class="v">assume-true-false</span> in the ACL2 sources.</p> 
 
 <p>The handling of free variables in a hypothesis of a <a href="ACL2____REWRITE.html">rewrite</a> rule 
 (see <a href="ACL2____FREE-VARIABLES.html">free-variables</a>) has been improved in the case that the hypothesis 
 is of the form <span class="v">(equiv x y)</span>, where <span class="v">equiv</span> is a known equivalence 
 relation (see <a href="ACL2____EQUIVALENCE.html">equivalence</a>).  Previously, if the rewriter was attempting 
 to rewrite the hypothesis <span class="v">(equiv x y)</span> of a rewrite rule, in a context 
 where <span class="v">x'</span> is an instance of <span class="v">x</span>, then the rewriter could fail to notice 
 a term <span class="tt">(equiv x' y')</span> true in the current context where <span class="v">y'</span> is an 
 instance of <span class="v">y</span>, in the case that <span class="v">x'</span> precedes <span class="v">y'</span> in the <span class="tt"><a href="ACL2____TERM-ORDER.html">term-order</a></span>.  This has been remedied.  This improvement applies regardless of 
 whether <span class="v">x</span>, <span class="v">y</span>, or (we believe) both are already fully instantiated in 
 the present context.  Thanks to Joe Hendrix for bringing up an example and to 
 Vernon Austel for providing another, simple example.</p> 
 
 <p>A very minor change has been made to the rewriter in the case that an 
 equality appears on the left-hand side of a <span class="v">:</span><span class="tt"><a href="ACL2____REWRITE.html">rewrite</a></span> rule. 
 Formerly, when such an equality <span class="v">(<a href="COMMON-LISP____EQUAL.html">equal</a> x y)</span> was commuted to <span class="v">(<a href="COMMON-LISP____EQUAL.html">equal</a> y
 x)</span> in order for the rule to match the current term, then all equalities on 
 the instantiated right-hand side of the rule were commuted, except for those 
 occurring inside another equality.  The instantiated right-hand side is no 
 longer modified.  It seems very unlikely that this change will cause proofs to 
 fail, though we cannot completely rule out that possibility.</p> 
 
 <p>We have modified how the ACL2 simplifier handles the application of a 
 defined function symbol to constant arguments in certain cases, which we now 
 describe.  As before, ACL2 attempts to simplify such a function application by 
 evaluation, provided the <span class="v">:</span><span class="tt"><a href="ACL2____EXECUTABLE-COUNTERPART.html">executable-counterpart</a></span> of the function 
 is enabled.  And as before, if that evaluation fails due to a subroutine call 
 of a constrained function (introduced by <span class="tt"><a href="ACL2____ENCAPSULATE.html">encapsulate</a></span>), ACL2 may wrap a 
 call of <span class="v">hide</span> around this function application.  (See <a href="ACL2____HIDE.html">hide</a>.)  But 
 now, ACL2 attempts to apply definitions and rewrite rules in the case that 
 this evaluation fails, and only if the resulting term is unchanged does ACL2 
 wrap <span class="tt"><a href="ACL2____HIDE.html">hide</a></span> around this function application.  Thanks to Matt Wilding 
 for bringing up the idea of this modification.</p> 
 
 <p>The generation of "Goal" for recursive (and mutually-recursive) 
 definitions now uses the subsumption/replacement limitation (default 500). 
 See <a href="ACL2____CASE-SPLIT-LIMITATIONS.html">case-split-limitations</a>.</p> 
 
 <p>Default hints now apply to hints given in definitions, not just theorems. 
 See <a href="ACL2____DEFAULT-HINTS.html">default-hints</a>.</p> 
 
 <p>Thanks to Robert Krug for implementing the following two improvements 
 involving linear arithmetic reasoning: linear arithmetic now uses the 
 conclusions of <span class="tt"><a href="ACL2____FORWARD-CHAINING.html">forward-chaining</a></span> rules, and <span class="tt"><a href="ACL2____TYPE-SET.html">type-set</a></span> now uses a 
 small amount of linear reasoning when deciding inequalities.</p>
</body>
</html>
