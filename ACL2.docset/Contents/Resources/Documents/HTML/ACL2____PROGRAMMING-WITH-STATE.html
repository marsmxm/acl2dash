<html>
<head>
<meta charset="UTF-8">
<title>Programming-with-state</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____PROGRAMMING-WITH-STATE">Click for Programming-with-state in the Full Manual</a></h3>

<p>Programming using the von Neumannesque ACL2 <a href="ACL2____STATE.html">state</a> object</p><p>This <a href="COMMON-LISP____DOCUMENTATION.html">documentation</a> section introduces some common techniques 
 for programming using the ACL2 state object.  A prerequisite is thus a basic 
 understanding of that object; see <a href="ACL2____STATE.html">state</a>.  We hope this section is 
 useful, and we invite suggestions for improvements and additions.</p> 
 
 <p>A supplement to this section is the ACL2 source code, which uses most (and 
 probably all) of the techniques discussed here.  That code is thus a source of 
 many examples, which can serve as ``templates'' to guide one's own programming 
 with state.</p> 
 
 <p>Recall that ``ACL2'' stands for ``A Computational Logic for Applicative 
 Common Lisp''.  In particular, the language is applicative: there are no 
 global variables or side effects.  For many purposes this does not feel 
 restrictive; for example, an ACL2 user who is programming in raw Lisp may well 
 be more comfortable coding a factorial function applicatively, using 
 recursion, rather than using iteration with repeated assignment to the same 
 variable.</p> 
 
 <p>However, there are situations that call for reading or modifying the system 
 state, such as performing input and output, signaling errors, saving 
 information from one computation for use in a later one, or reading and 
 updating system-level or environmental data.  This section provides an 
 introductory guide for writing functions that traffic in state.  We emphasize 
 that this guide is intended as an introduction; more complete documentation 
 may often be found by following links to documentation of individual 
 utilities, and again, more examples may be found by searching the ACL2 source 
 code for uses of the functions and macros mentioned below.  The rest of this 
 section is organized as follows.</p> 
 
 <pre class="code">ENABLING PROGRAMMING WITH STATE
STATE GLOBALS AND THE ACL2 LOGICAL WORLD
A REMARK ON GUARDS
ERRORS AND ERROR TRIPLES
SEQUENTIAL PROGRAMMING
BINDING VARIABLES USING ERROR TRIPLES
BINDING STATE GLOBAL VARIABLES
INPUT AND OUTPUT
TIMINGS
ENVIRONMENT AND SYSTEM
REMARKS ON EVENTS AND LD
ADVANCED TOPICS</pre> 
 
 <p>ENABLING PROGRAMMING WITH STATE</p> 
 
 <p>In order to submit a definition that takes <span class="tt"><a href="ACL2____STATE.html">state</a></span> as a formal 
 parameter, you must either declare <span class="v">state</span> as a <span class="v">:</span><span class="tt"><a href="ACL2____STOBJ.html">stobj</a></span> (see 
 <a href="ACL2____XARGS.html">xargs</a>) or first evaluate the following form at the top level: 
 <span class="v">(<a href="ACL2____SET-STATE-OK.html">set-state-ok</a> t)</span>.</p> 
 
 <p>Consider for example the following trivial definition.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (<a href="ACL2____STATE.html">state</a>)
  (<a href="ACL2____MV.html">mv</a> 3 state))</pre> 
 
 <p>If you submit the above definition in a fresh ACL2 session, you will get 
 this error message.</p> 
 
 <pre class="code">ACL2 Error in ( DEFUN FOO ...):  The variable symbol STATE should not
be used as a formal parameter of a defined function unless you are
aware of its unusual status and the restrictions enforced on its use.
See :DOC set-state-ok.</pre> 
 
 <p>If first you evaluate <span class="v">(<a href="ACL2____SET-STATE-OK.html">set-state-ok</a> t)</span>, you can admit the above 
 definition.  Alternatively, you can declare <span class="v">state</span> as a <span class="v">:</span><span class="tt"><a href="ACL2____STOBJ.html">stobj</a></span>, as follows.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (<a href="ACL2____STATE.html">state</a>)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs state))
  (<a href="ACL2____MV.html">mv</a> 3 state))</pre> 
 
 <p>A difference in the two approaches is that for the latter, a <a href="ACL2____GUARD.html">guard</a> 
 proof obligation is generated by default.  See the section below entitled ``A 
 remark on guards''.</p> 
 
 <p>STATE GLOBALS AND THE ACL2 LOGICAL WORLD</p> 
 
 <p>Recall (see <a href="ACL2____STATE.html">state</a>) that one of the fields of the ACL2 state object 
 is the global-table, which logically is an alist associating symbols, known as 
 ``state globals'' or ``state global variables'', with values.  But no such 
 alist actually exists in the implementation.  Instead, ACL2 provides utilities 
 for reading state globals — see <a href="ACL2_____04.html">@</a> and see <a href="ACL2____F-GET-GLOBAL.html">f-get-global</a> 
 — and utilities for writing them — see <a href="ACL2____ASSIGN.html">assign</a> and see <a href="ACL2____F-PUT-GLOBAL.html">f-put-global</a>.  The following log shows how they work; further explanation 
 follows below.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="ACL2____ASSIGN.html">assign</a> my-var (<a href="COMMON-LISP_____B2.html">+</a> 3 4))
 7
ACL2 !&gt;(<a href="ACL2_____04.html">@</a> my-var)
7
ACL2 !&gt;(<a href="ACL2____F-PUT-GLOBAL.html">f-put-global</a> 'my-var (<a href="COMMON-LISP_____B2.html">+</a> 1 5) state)
&lt;state&gt;
ACL2 !&gt;(<a href="ACL2____F-GET-GLOBAL.html">f-get-global</a> 'my-var state)
6
ACL2 !&gt;</pre> 
 
 <p>Note that the first result is indented by one space.  This is ACL2's way to 
 indicate that the <span class="tt"><a href="ACL2____ASSIGN.html">assign</a></span> expression returned an ``error triple'' and 
 that no error was signaled.  We discuss error triples in more detail below; 
 also see <a href="ACL2____ERROR-TRIPLE.html">error-triple</a>.</p> 
 
 <p>As illustrated above, the output signatures of the utilities for assigning 
 to state globals differ from each other as follows: <span class="tt"><a href="ACL2____F-PUT-GLOBAL.html">f-put-global</a></span> 
 returns <span class="v">state</span>, but <span class="tt"><a href="ACL2____ASSIGN.html">assign</a></span> returns an error triple <span class="v">(<a href="ACL2____MV.html">mv</a> nil val
 state)</span> where <span class="v">val</span> is the value assigned to the state global.  The output 
 signatures of the utilities for reading, <span class="v">@</span> and <span class="v">f-get-global</span>, are 
 identical.  In fact, the form <span class="v">(<a href="ACL2____F-GET-GLOBAL.html">f-get-global</a> 'my-var state)</span> is the 
 single-step macroexpansion of the form <span class="v">(<a href="ACL2_____04.html">@</a> my-var)</span>, as can be confirmed 
 using <span class="tt"><a href="ACL2____TRANS1.html">trans1</a></span>.</p> 
 
 <pre class="code">ACL2 !&gt;:trans1 (<a href="ACL2_____04.html">@</a> my-var)
 (<a href="ACL2____F-GET-GLOBAL.html">F-GET-GLOBAL</a> 'MY-VAR STATE)
ACL2 !&gt;</pre> 
 
 <p>State globals are useful for conveying persistent state information. 
 Consider for example the utility <span class="tt"><a href="ACL2____SET-INHIBIT-OUTPUT-LST.html">set-inhibit-output-lst</a></span>.  The form 
 <span class="v">(<a href="ACL2____SET-INHIBIT-OUTPUT-LST.html">set-inhibit-output-lst</a> '(prove proof-tree))</span> is approximately equivalent 
 to (assign inhibit-output-lst '(prove proof-tree)).  We say ``approximately'' 
 because <span class="v">set-inhibit-output-lst</span> additionally does some error checking to 
 ensure that all the tokens in the new list are legal.  When deciding whether 
 to print output, the ACL2 system reads the value of state global variable 
 <span class="v">inhibit-output-lst</span>.</p> 
 
 <p>A particularly useful state global is <span class="v">current-acl2-world</span>, whose value 
 is the ACL2 logical <a href="ACL2____WORLD.html">world</a>.  Because the ACL2 world is commonly accessed 
 in applications that use the ACL2 state, ACL2 provides a function that returns 
 the world: <span class="v">(<a href="ACL2____W.html">w</a> state) = (<a href="ACL2____F-GET-GLOBAL.html">f-get-global</a> 'current-acl2-world state)</span>.  While 
 it is common to read the world, only functions <span class="v">set-w</span> and <span class="v">set-w!</span> are 
 available to write the world, but these are untouchable and should generally 
 be avoided except by system implementors (see <a href="ACL2____REMOVE-UNTOUCHABLE.html">remove-untouchable</a>).</p> 
 
 <p>You may wish to modify state globals within a book, but this can be 
 slightly problematic because only legal event forms (see <a href="ACL2____EMBEDDED-EVENT-FORM.html">embedded-event-form</a>) may go into <a href="ACL2____BOOKS.html">books</a>.  Fortunately there is a 
 workaround using <span class="v">make-event</span>; see <a href="ACL2____MAKE-EVENT.html">make-event</a>, in particular the 
 section ``Examples Illustrating How to Access State''.</p> 
 
 <p>A REMARK ON GUARDS</p> 
 
 <p>For a function definition (see <a href="COMMON-LISP____DEFUN.html">defun</a>), if <span class="v">state</span> is specified as 
 a <a href="ACL2____STOBJ.html">stobj</a> as with the form <span class="v">(<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs state))</span>, then the 
 <a href="ACL2____GUARD.html">guard</a> for that function is considered to include the condition 
 <span class="v">(state-p state)</span>.  By default, <a href="ACL2____GUARD.html">guard</a> verification will then be 
 performed.</p> 
 
 <p>We can illustrate this point by modifying the example above as follows, to 
 read the value of state global <span class="v">gag-mode</span>.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (<a href="ACL2____STATE.html">state</a>)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs state))
  (<a href="ACL2____F-GET-GLOBAL.html">f-get-global</a> 'gag-mode state))</pre> 
 
 <p>If you try this in a fresh ACL2 session, the proof will fail with the 
 following key checkpoint, which says that the state global <span class="v">gag-mode</span> is 
 bound in the global-table of the state.</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">IMPLIES</a> (STATE-P1 STATE)
         (<a href="ACL2____ASSOC-EQUAL.html">ASSOC-EQUAL</a> 'GAG-MODE (<a href="COMMON-LISP____NTH.html">NTH</a> 2 STATE)))</pre> 
 
 <p>How can we deal with this proof failure?  One way is simply to ignore the 
 issue by defining the function in <span class="v">:</span><span class="tt"><a href="ACL2____PROGRAM.html">program</a></span> mode, as follows.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (<a href="ACL2____STATE.html">state</a>)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :stobjs state
                  :mode :program))
  (<a href="ACL2____F-GET-GLOBAL.html">f-get-global</a> 'gag-mode state))</pre> 
 
 <p>Perhaps a better way is to strengthen the guard to assert that the 
 indicated state global is bound, as follows.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (<a href="ACL2____STATE.html">state</a>)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (boundp-global 'gag-mode state)
                  :stobjs state))
  (<a href="ACL2____F-GET-GLOBAL.html">f-get-global</a> 'gag-mode state))</pre> 
 
 <p>Also see <a href="ACL2____GUARD-MISCELLANY.html">guard-miscellany</a> for a discussion of how guards are 
 generated from <span class="tt"><a href="ACL2____XARGS.html">xargs</a></span> fields of <a href="COMMON-LISP____DECLARE.html">declare</a> forms, specifically, for 
 keywords <span class="v">:guard</span> and <span class="v">:stobjs</span>.</p> 
 
 <p>ERRORS AND ERROR TRIPLES</p> 
 
 <p>When evaluation returns three values, where the first two are ordinary 
 objects and the third is the ACL2 state, the result may be called an ``error 
 triple''.  (Whether it is treated as an error triple depends on the 
 programmer.)  Error triples are often denoted <span class="v">(<a href="ACL2____MV.html">mv</a> erp val state)</span>, and 
 common ACL2 programming idioms treat <span class="v">erp</span> as a flag indicating whether an 
 error is being signaled and <span class="v">val</span> as the ``value'' computed.  Also see 
 <a href="ACL2____ERROR-TRIPLE.html">error-triple</a>.</p> 
 
 <p>Even ACL2 users who are not programmers encounter error triples, because 
 these are the values returned by evaluation of ACL2 <a href="ACL2____EVENTS.html">events</a>.  Consider 
 the following log, where the only user input is the <span class="v">defun</span> form following 
 the <a href="ACL2____PROMPT.html">prompt</a>.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (x) x)

Since FOO is non-recursive, its admission is trivial.  We observe that
the type of FOO is described by the theorem (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (FOO X) X).

Summary
Form:  ( DEFUN FOO ...)
Rules: NIL
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 FOO
ACL2 !&gt;</pre> 
 
 <p>All output above results from explicit calls of output functions, except 
 for the next-to-last line, which contains <span class="v">FOO</span>.  Notice the single-space 
 indentation preceding <span class="v">FOO</span>.  That space indicates that in fact, the value 
 returned by evaluation of the <span class="v">defun</span> form is the error triple whose error 
 flag is <span class="v">nil</span> and whose computed value is <span class="v">FOO</span>.  By default, ACL2 
 prints any error triple <span class="v">(<a href="ACL2____MV.html">mv</a> nil val state)</span> by inserting a space before 
 printing <span class="v">val</span>.  You can change the default by setting state global <span class="tt"><a href="ACL2____LD-POST-EVAL-PRINT.html">ld-post-eval-print</a></span> to <span class="v">t</span>; notice how the same result is printed 
 below.</p> 
 
 <pre class="code">ACL2 !&gt;:u
          0:x(<a href="ACL2____EXIT-BOOT-STRAP-MODE.html">EXIT-BOOT-STRAP-MODE</a>)
ACL2 !&gt;(set-ld-post-eval-print t state)
(NIL T &lt;state&gt;)
ACL2 !&gt;(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (x) x)

Since FOO is non-recursive, its admission is trivial.  We observe that
the type of FOO is described by the theorem (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (FOO X) X).

Summary
Form:  ( DEFUN FOO ...)
Rules: NIL
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
(NIL FOO &lt;state&gt;)
ACL2 !&gt;</pre> 
 
 <p>The way error triples are printed by <span class="v">ld</span> is controlled not only by 
 state global <span class="v">ld-post-eval-print</span>, but also by state global 
 <span class="v">ld-error-triples</span>.  These are examples of ``ld specials''; see <a href="ACL2____LD.html">ld</a>, 
 see <a href="ACL2____LD-POST-EVAL-PRINT.html">ld-post-eval-print</a>, and see <a href="ACL2____LD-ERROR-TRIPLES.html">ld-error-triples</a>.</p> 
 
 <p>It is so common to produce an error triple whose first (error flag) 
 component is <span class="v">nil</span> that ACL2 provides a handy macro, <span class="v">value</span>, for this 
 purpose.  Thus, <span class="v">(<a href="ACL2____VALUE.html">value</a> &lt;expression&gt;)</span> is equivalent to <span class="v">(<a href="ACL2____MV.html">mv</a> nil
 &lt;expression&gt; state)</span>.  Also see <a href="ACL2____VALUE-TRIPLE.html">value-triple</a> for a similar construct 
 that is a legal event form.</p> 
 
 <p>We turn now to the topic of errors.  The macro <span class="tt"><a href="ACL2____ER.html">er</a></span> ``causes'' an 
 error, but there are really two quite different kinds of errors: ``soft'' and 
 ``hard'' errors.  We use the term ``soft error'' to refer to a form that 
 returns an error triple <span class="v">(<a href="ACL2____MV.html">mv</a> erp val state)</span> for which <span class="v">erp</span> is 
 non-<span class="v">nil</span>.  Soft errors do not interrupt the normal flow of evaluation: the 
 error triple is returned to the caller which interprets the <span class="v">erp</span> flag and 
 <span class="v">val</span> as directed by the programmer.  Macros discussed below make it 
 convenient to think about soft errors as short-circuiting the computation. 
 Hard errors, on the other hand, do actually rip control away from the current 
 evaluation and return it to the top-level loop.  Logically speaking, 
 expressions that cause hard errors return <span class="v">nil</span> in the error case, but the 
 <span class="v">nil</span> is never seen in actual evaluation because control does not return to 
 the caller.</p> 
 
 <p>Note that the function <span class="tt"><a href="ACL2____ABORT_12.html">abort!</a></span>, which you can invoke by typing 
 <span class="v">:</span><span class="tt"><a href="ACL2____A_12.html">a!</a></span>, always returns to the top level.  Note that ACL2 can prove 
 that <span class="v">(<a href="ACL2____ABORT_12.html">abort!</a>)</span> returns <span class="v">nil</span> but that this cannot be confirmed by 
 computation.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="ACL2____THM.html">thm</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____ABORT_12.html">abort!</a>) nil))

Q.E.D.

Summary
Form:  ( THM ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:TYPE-PRESCRIPTION ABORT!))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)

Proof succeeded.
ACL2 !&gt;(<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____ABORT_12.html">abort!</a>) nil)
Abort to ACL2 top-level
...
ACL2 !&gt;</pre> 
 
 <p>(What actually happens with a hard error, including non-default cases, is a 
 bit subtle; most readers will probably want to skip this paragraph.  The 
 read-eval-print loop implemented by <span class="tt"><a href="ACL2____LD.html">ld</a></span> is implemented by a call of the 
 ACL2 evaluator function, <span class="v">trans-eval</span>, on each input form.  If a hard error 
 occurs during evaluation of an input form, its <span class="v">trans-eval</span> call will 
 return with a soft error.  <span class="tt"><a href="ACL2____LD.html">Ld</a></span>, in turn handles that soft error 
 appropriately; see <a href="ACL2____LD-ERROR-ACTION.html">ld-error-action</a>.)</p> 
 
 <p>The most common way to signal errors is the macro <span class="tt"><a href="ACL2____ER.html">er</a></span>, which prints 
 a formatted error message and returns a soft or hard error as specified by the 
 call.  Note however that soft errors are signaled using <span class="v">:</span><span class="tt"><a href="ACL2____PROGRAM.html">program</a></span> 
 mode functions.</p> 
 
 <p>Since the output signatures of soft and hard errors are different — 
 hard errors ``return'' a single value while soft errors return a triple 
 — mixing them in an expression requires embedding the hard error form in 
 (an irrelevant) triple, as illustrated below.  All branches of the expression 
 must produce an error triple if any branch does.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="COMMON-LISP____DEFUN.html">defun</a> chk-find-or-abort (e x state)
         (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :mode :program))
         (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ENDP.html">endp</a> x)
             (<a href="ACL2____VALUE.html">value</a>                          ; Note use of VALUE!
               (<a href="ACL2____ER.html">er</a> hard 'chk-find-or-abort
                   "Did not find ~x0!"
                    e))
             (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____INTEGERP.html">integerp</a> (<a href="COMMON-LISP____CAR.html">car</a> x)))
                 (<a href="ACL2____ER.html">er</a> soft 'chk-find-or-abort
                     "Non-integer, ~x0, in list!"
                     (<a href="COMMON-LISP____CAR.html">car</a> x))
                 (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQL.html">eql</a> (<a href="COMMON-LISP____CAR.html">car</a> x) e)
                     (<a href="ACL2____VALUE.html">value</a> x)
                     (chk-find-or-abort e (<a href="COMMON-LISP____CDR.html">cdr</a> x) state)))))

Summary
Form:  ( DEFUN CHK-FIND-OR-ABORT ...)
Rules: NIL
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 CHK-FIND-OR-ABORT
ACL2 !&gt;(chk-find-or-abort 3 '(1 2 3 4 5) state)
 (3 4 5)
ACL2 !&gt;(chk-find-or-abort 3 '(1 A 3 4 5) state)

ACL2 Error in CHK-FIND-OR-ABORT:  Non-integer, A, in list!

ACL2 !&gt;(chk-find-or-abort 3 '(1 2 4 5) state)

HARD ACL2 ERROR in CHK-FIND-OR-ABORT:  Did not find 3!
...
ACL2 !&gt;</pre> 
 
 <p>See <a href="ACL2____ER.html">er</a> for further discussion of errors.  For some other individual 
 topics related to errors see <a href="ACL2____ASSERT_42.html">assert$</a>, see <a href="ACL2____BREAK-ON-ERROR.html">break-on-error</a>, see 
 <a href="ACL2____ERROR1.html">error1</a>, see <a href="ACL2____HARD-ERROR.html">hard-error</a>, see <a href="ACL2____ILLEGAL.html">illegal</a>, and see <a href="ACL2____LD-ERROR-TRIPLES.html">ld-error-triples</a>.</p> 
 
 <p>In the next section we discuss soft errors further, in the context of 
 programming.</p> 
 
 <p>SEQUENTIAL PROGRAMMING</p> 
 
 <p>This section describes handy ways to modify state in steps, using macros 
 that implement a sequence of <span class="tt"><a href="COMMON-LISP____LET.html">let</a></span> or <span class="tt"><a href="ACL2____MV-LET.html">mv-let</a></span> bindings.  For 
 example, suppose you want to assign the values 1 and 2 to two state globals 
 <span class="v">one-var</span> and <span class="v">two-var</span>, respectively.  Because of ACL2's syntactic 
 restrictions on <span class="tt"><a href="ACL2____STATE.html">state</a></span>, it is not legal simply to write 
 <span class="v">(<a href="ACL2____F-PUT-GLOBAL.html">f-put-global</a> 'two-var 2 (<a href="ACL2____F-PUT-GLOBAL.html">f-put-global</a> 'one-var 1 state))</span>.  However, 
 <span class="tt"><a href="COMMON-LISP____LET.html">let</a></span> comes to the rescue as follows.</p> 
 
 <pre class="code">(<a href="COMMON-LISP____LET.html">let</a> ((<a href="ACL2____STATE.html">state</a> (<a href="ACL2____F-PUT-GLOBAL.html">f-put-global</a> 'one-var 1 state)))
  (<a href="COMMON-LISP____LET.html">let</a> ((<a href="ACL2____STATE.html">state</a> (<a href="ACL2____F-PUT-GLOBAL.html">f-put-global</a> 'two-var 2 state)))
    state))</pre> 
 
 <p>It is so common to bind state successively in such a manner that ACL2 
 provides a macro, <span class="tt"><a href="ACL2____PPROGN.html">pprogn</a></span>, for this purpose.  Thus, an equivalent 
 solution to the problem above is</p> 
 
 <pre class="code">(<a href="ACL2____PPROGN.html">pprogn</a> (<a href="ACL2____F-PUT-GLOBAL.html">f-put-global</a> 'one-var 1 state)
        (<a href="ACL2____F-PUT-GLOBAL.html">f-put-global</a> 'two-var 2 state)
        state)</pre> 
 
 <p>or, more simply, as follows.</p> 
 
 <pre class="code">(<a href="ACL2____PPROGN.html">pprogn</a> (<a href="ACL2____F-PUT-GLOBAL.html">f-put-global</a> 'one-var 1 state)
        (<a href="ACL2____F-PUT-GLOBAL.html">f-put-global</a> 'two-var 2 state))</pre> 
 
 <p>See <a href="ACL2____PPROGN.html">pprogn</a>.  Note that the last form is allowed to return multiple 
 values; the only requirement on the last form is that its value include 
 <span class="v">state</span>.</p> 
 
 <p>It is also common to update the state using a sequence of forms such that 
 each returns an error triple, where the intention is for evaluation to 
 short-circuit immediately if a soft error is encountered.  Suppose 
 <span class="v">&lt;expr1&gt;</span> and <span class="v">&lt;expr2&gt;</span> are expressions that return error triples, where 
 the <span class="v">state</span> components of the error triples might be updated, and one 
 wishes to evaluate <span class="v">&lt;expr1&gt;</span> and then <span class="v">&lt;expr2&gt;</span>, returning the 
 (multiple) values returned by <span class="v">&lt;expr2&gt;</span> unless the error triple returned by 
 <span class="v">&lt;expr1&gt;</span> is a soft error, in which case that error triple is returned. 
 One can of course do so as follows.</p> 
 
 <pre class="code">(<a href="ACL2____MV-LET.html">mv-let</a> (erp val state)
        &lt;expr1&gt;
        (<a href="COMMON-LISP____COND.html">cond</a> (erp (<a href="ACL2____MV.html">mv</a> erp val state))
              (t &lt;expr2&gt;)))</pre> 
 
 <p>But ACL2 provides a handy macro, <span class="tt"><a href="ACL2____ER-PROGN.html">er-progn</a></span>, for this purpose.  The 
 following code is equivalent to the code just above.</p> 
 
 <pre class="code">(<a href="ACL2____ER-PROGN.html">er-progn</a> &lt;expr1&gt; &lt;expr2&gt;)</pre> 
 
 <p>See <a href="ACL2____ER-PROGN.html">er-progn</a> for more details.  Note that unlike <span class="tt"><a href="ACL2____PPROGN.html">pprogn</a></span>, the 
 return <a href="ACL2____SIGNATURE.html">signature</a> for the last expression must be the same as that of 
 the others: an error triple.</p> 
 
 <p>Let's consider how to use <span class="v">pprogn</span> and <span class="v">er-progn</span> together.  In the 
 following example <span class="v">f1</span> and <span class="v">f2</span> both return <span class="v">state</span>, while each of 
 <span class="v">g1</span> and <span class="v">g2</span> returns an error triple.  The following code modifies 
 state by executing these in the order <span class="v">f1</span>, <span class="v">g1</span>, <span class="v">f2</span>, and finally 
 <span class="v">g2</span>, returning <span class="v">(<a href="ACL2____MV.html">mv</a> nil val state)</span> where <span class="v">val</span> is the value 
 component of the error triple returned by <span class="v">g2</span> — except we return a 
 soft error if <span class="v">g1</span> or <span class="v">g2</span> returns a soft error.</p> 
 
 <pre class="code">(<a href="ACL2____PPROGN.html">pprogn</a> (f1 x state)
        (<a href="ACL2____ER-PROGN.html">er-progn</a> (g1 x state)
                  (<a href="ACL2____PPROGN.html">pprogn</a> (f2 x state)
                          (g2 x state))))</pre> 
 
 <p>Finally, consider the <a href="ACL2____EVENTS.html">events</a> <span class="tt"><a href="COMMON-LISP____PROGN.html">progn</a></span> and <span class="tt"><a href="ACL2____PROGN_12.html">progn!</a></span>. 
 These have similar behavior to that of <span class="tt"><a href="ACL2____ER-PROGN.html">er-progn</a></span>.  However, <span class="tt"><a href="COMMON-LISP____PROGN.html">progn</a></span> and <span class="tt"><a href="ACL2____PROGN_12.html">progn!</a></span> may only be used in event contexts, for example at 
 the top level or immediately underneath a call of <span class="tt"><a href="ACL2____ENCAPSULATE.html">encapsulate</a></span> or 
 <span class="tt"><a href="COMMON-LISP____PROGN.html">progn</a></span>, while <span class="tt"><a href="ACL2____ER-PROGN.html">er-progn</a></span> has no such restriction.  So when 
 writing code, use <span class="v">er-progn</span> rather than <span class="tt"><a href="COMMON-LISP____PROGN.html">progn</a></span> or <span class="tt"><a href="ACL2____PROGN_12.html">progn!</a></span>. 
 In particular, the body of a <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> must not have any calls of 
 <span class="v">progn</span> (or of <span class="v">progn!</span>  either), and the same restriction holds for any 
 code to be executed, such as the body of a <span class="tt"><a href="ACL2____MAKE-EVENT.html">make-event</a></span> form.</p> 
 
 <p>BINDING VARIABLES USING ERROR TRIPLES</p> 
 
 <p>In this section we discuss the macro <span class="v">er-let*</span>, which is a variant of 
 the special form, <span class="tt"><a href="COMMON-LISP____LET_A2.html">let*</a></span>, that is useful when programming with state.  A 
 related utility that avoids the use of state is <span class="v">er-let*-cmp</span>; see <a href="ACL2____CONTEXT-MESSAGE-PAIR.html">context-message-pair</a>.</p> 
 
 <p>The macro <span class="v">er-let*</span> is useful when binding variables to the value 
 components of error triples.  It is actually quite similar to <span class="v">er-progn</span>, 
 described above, except that <span class="v">er-let*</span> binds variables.  First consider the 
 following example.</p> 
 
 <pre class="code">(<a href="ACL2____ER-LET_A2.html">er-let*</a> ((x1 (f1 state))
          (x2 (f2 x1 state)))
  (<a href="ACL2____VALUE.html">value</a> (<a href="COMMON-LISP____CONS.html">cons</a> x1 x2)))</pre> 
 
 <p>The code just above is essentially equivalent to writing the following.</p> 
 
 <pre class="code">(<a href="ACL2____MV-LET.html">mv-let</a> (erp x1 state)
        (f1 state)
        (<a href="COMMON-LISP____COND.html">cond</a> (erp (<a href="ACL2____MV.html">mv</a> erp x1 state))
              (t (<a href="ACL2____MV-LET.html">mv-let</a> (erp x2 state)
                         (f2 x1 state)
                         (<a href="COMMON-LISP____COND.html">cond</a> (erp (<a href="ACL2____MV.html">mv</a> erp x2 state))
                               (t (<a href="ACL2____VALUE.html">value</a> (<a href="COMMON-LISP____CONS.html">cons</a> x1 x2))))))))</pre> 
 
 <p>As suggested by the example above, <span class="v">er-let*</span> has the same syntax as 
 <span class="v">let*</span>, except that declarations are not supported.  (But note that 
 <span class="v">ignore</span> declarations are not needed; all variables that are bound are also 
 used, at least in the error case.  Consider replacing <span class="v">(<a href="COMMON-LISP____CONS.html">cons</a> x1 x2)</span> by 
 <span class="v">nil</span> in the example displayed immediately above, and note that <span class="v">x1</span> and 
 <span class="v">x2</span> are still used.)  However, unlike <span class="v">let*</span>, <span class="v">er-let*</span> requires 
 that for each binding <span class="v">(var expr)</span>, the expression <span class="v">expr</span> must evaluate 
 to an error triple and, moreover, it requires that the second argument (the 
 ``body'') of <span class="v">er-let*</span> must evaluate to an error triple.  If one of the 
 variable expressions (e.g., the <span class="v">f1</span> and <span class="v">f2</span> calls above) signals an 
 error, its error triple is returned as the value of the <span class="v">er-let*</span>.</p> 
 
 <p>Of course, soft errors can be ``caught'' by using <span class="tt"><a href="ACL2____MV-LET.html">mv-let</a></span> instead of 
 <span class="v">er-let*</span> and simply ignoring the error flag or, more generally, by 
 returning a non-erroneous error triple even if the error flag was on.</p> 
 
 <p>BINDING STATE GLOBAL VARIABLES</p> 
 
 <p>In this section we introduce a utility, <span class="tt"><a href="ACL2____STATE-GLOBAL-LET_A2.html">state-global-let*</a></span>, that is 
 an analogue of <span class="v">let*</span> for state global variables.  Consider the following 
 example.</p> 
 
 <pre class="code">(<a href="ACL2____STATE-GLOBAL-LET_A2.html">state-global-let*</a>
 ((inhibit-output-lst (<a href="ACL2____ADD-TO-SET-EQ.html">add-to-set-eq</a> 'summary (<a href="ACL2_____04.html">@</a> inhibit-output-lst))))
 (<a href="ACL2____THM.html">thm</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> x x)))</pre> 
 
 <p>This form binds state global variable <span class="v">inhibit-output-lst</span> to the result 
 of adding the symbol, <span class="v">summary</span>, to the current value of that state global. 
 Thus (see <a href="ACL2____SET-INHIBIT-OUTPUT-LST.html">set-inhibit-output-lst</a>), the usual <a href="ACL2____SUMMARY.html">summary</a> is not 
 printed when evaluating this call of <span class="tt"><a href="ACL2____THM.html">thm</a></span>.</p> 
 
 <p>See <a href="ACL2____STATE-GLOBAL-LET_A2.html">state-global-let*</a> for more complete <a href="COMMON-LISP____DOCUMENTATION.html">documentation</a>.</p> 
 
 <p>INPUT AND OUTPUT</p> 
 
 <p>In ACL2, most input and output involves the ACL2 state.  See <a href="ACL2____IO.html">io</a>.</p> 
 
 <p>TIMINGS</p> 
 
 <p>For how to obtain the time elapsed since the start of the ACL2 session, see 
 <a href="ACL2____READ-RUN-TIME.html">read-run-time</a>.</p> 
 
 <p>For a utility for saving times into the ACL2 state and for printing those 
 saved times, see the community book <span class="v">misc/save-time.lisp</span>.</p> 
 
 <p>To time an evaluation (though this really isn't about state), see <a href="ACL2____TIME_42.html">time$</a>.</p> 
 
 <p>ENVIRONMENT AND SYSTEM</p> 
 
 <p>Next, we mention briefly some ways in which ACL2 interacts with its 
 environment using the ACL2 state.</p> 
 
 <p>For how to read and write environment variables, see <a href="ACL2____GETENV_42.html">getenv$</a> and see 
 <a href="ACL2____SETENV_42.html">setenv$</a>.</p> 
 
 <p>For how to run a command in the host operating system, see <a href="ACL2____SYS-CALL.html">sys-call</a>, <a href="ACL2____SYS-CALL_B2.html">sys-call+</a>, and <a href="ACL2____SYS-CALL_A2.html">sys-call*</a>.</p> 
 
 <p>REMARKS ON EVENTS AND LD</p> 
 
 <p>In general, undefined or surprising behavior may occur when using ACL2 
 <a href="ACL2____EVENTS.html">events</a> or calling <a href="ACL2____LD.html">ld</a> in your programs.  In some cases ACL2 
 enforces restrictions against these uses.  We strongly discourage using <span class="tt"><a href="ACL2____LD.html">ld</a></span> in programs, as it has been designed to be called only at the top level of 
 a read-eval-print loop.  However, you may wish to read or write <span class="tt"><a href="ACL2____LD.html">ld</a></span> 
 specials in your programs; see <a href="ACL2____LD.html">ld</a>.</p> 
 
 <p>There is also a restriction on contexts in which <span class="tt"><a href="ACL2____MAKE-EVENT.html">make-event</a></span> may be 
 called: it may only be called in a context where an event is expected, such as 
 the top level, in a book, or as an argument of <span class="tt"><a href="ACL2____ENCAPSULATE.html">encapsulate</a></span> or <span class="tt"><a href="COMMON-LISP____PROGN.html">progn</a></span>.  The reason is that ACL2 does very subtle and careful tracking of 
 <span class="tt"><a href="ACL2____MAKE-EVENT.html">make-event</a></span> expansions; and it is only able to do this in event 
 contexts, where it is able to carry out such tracking accurately.</p> 
 
 <p>ADVANCED TOPICS</p> 
 
 <p>ACL2 provides the function <span class="v">trans-eval</span> to evaluate an arbitrary form 
 (after translating it to a <a href="ACL2____TERM.html">term</a>, i.e., into internal form).  For more 
 information, we refer to reader to comments in the definition of 
 <span class="v">trans-eval</span> in the ACL2 source code.  There are also many examples of its 
 use in the ACL2 sources.</p> 
 
 <p>For a function that provides the true absolute filename, with soft links 
 resolved, see <a href="ACL2____CANONICAL-PATHNAME.html">canonical-pathname</a>.</p> 
 
 <p>For a function that returns a checksum on the characters in a channel, see 
 <a href="ACL2____CHECKSUM.html">checksum</a>.</p> 
 
 <p>To obtain a random number, see <a href="ACL2____RANDOM_42.html">random$</a>.</p> 
 
 <p>If you are programming in raw-mode (see <a href="ACL2____SET-RAW-MODE.html">set-raw-mode</a>) or in raw 
 Lisp, use the variable <span class="v">*the-live-state*</span> in place of the variable 
 <span class="v">state</span>.</p> 
 
 <p>We invite suggestions for additional advanced topics.</p>
</body>
</html>
