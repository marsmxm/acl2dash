<html>
<head>
<meta charset="UTF-8">
<title>Ld-redefinition-action</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____LD-REDEFINITION-ACTION">Click for Ld-redefinition-action in the Full Manual</a></h3>

<p>To allow redefinition without <a href="ACL2____UNDOING.html">undoing</a></p><p>The present topic discusses redefining functions, macros, and 
 constants, using a mechanism that may be convenient but also may be unsafe or 
 unsound.  See <a href="ACL2____UNDO.html">undo</a> for what is often a better way to carry out 
 redefinition.</p> 
 
 <p><span class="v">Ld-redefinition-action</span> is an <span class="tt"><a href="ACL2____LD.html">ld</a></span> special (see <a href="ACL2____LD.html">ld</a>).  The 
 accessor is <span class="v">(<a href="ACL2____LD-REDEFINITION-ACTION.html">ld-redefinition-action</a> state)</span> and the updater is 
 <span class="v">(<a href="ACL2____SET-LD-REDEFINITION-ACTION.html">set-ld-redefinition-action</a> val state)</span>.</p> 
 
 <p><b>WARNING!</b> If <span class="v">ld-redefinition-action</span> is non-<span class="v">nil</span> then ACL2 is 
 liable to be made unsafe or unsound, or behave in unexpected ways.  For 
 example, redefining a macro or inlined function called in the body of a 
 function, <span class="v">g</span>, may not cause the new definition to be called by <span class="v">g</span>. 
 Redefinition should be viewed as a way to facilitate unsafe, but potentially 
 useful, hacking.</p> 
 
 <p>The keyword command <span class="v">:</span><span class="tt"><a href="ACL2____REDEF.html">redef</a></span> will set 
 <span class="v">ld-redefinition-action</span> to a convenient setting allowing unsound 
 redefinition.  See below.</p> 
 
 <p>When <span class="v">ld-redefinition-action</span> is <span class="v">nil</span>, redefinition is prohibited. 
 In that case, an error message is printed upon any attempt to introduce a name 
 that is already in use.  There is one exception to this rule.  It is permitted 
 to redefine a function symbol in <span class="v">:</span><span class="tt"><a href="ACL2____PROGRAM.html">program</a></span> mode to be a function 
 symbol in <span class="v">:</span><span class="tt"><a href="ACL2____LOGIC.html">logic</a></span> mode provided the formals and body remain the 
 same.  This is the standard way a function ``comes into'' logical 
 existence.</p> 
 
 <p>Throughout the rest of this discussion we exclude from our meaning of 
 ``redefinition'' the case in which a function in <span class="v">:</span><span class="tt"><a href="ACL2____PROGRAM.html">program</a></span> mode is 
 identically redefined in <span class="v">:</span><span class="tt"><a href="ACL2____LOGIC.html">logic</a></span> mode.  At one time, ACL2 freely 
 permitted the <a href="ACL2____SIGNATURE.html">signature</a>-preserving redefinition of <span class="v">:</span><span class="tt"><a href="ACL2____PROGRAM.html">program</a></span> mode functions but it no longer does.  See <a href="ACL2____REDEFINING-PROGRAMS.html">redefining-programs</a>.</p> 
 
 <p>When <span class="v">ld-redefinition-action</span> is non-<span class="v">nil</span>, you are allowed to 
 redefine a name that is already in use.  <b>The system may be rendered 
 unsound</b> by such an act.  It is important to understand how dangerous 
 redefinition is.  Suppose <span class="v">fn</span> is a function symbol that is called from 
 within some other function, say <span class="v">g</span>.  Suppose <span class="v">fn</span> is redefined so that 
 its arity changes.  Then the definition of <span class="v">g</span> is rendered syntactically 
 ill-formed by the redefinition.  This can be devastating since the entire ACL2 
 system assumes that terms in its database are well-formed.  For example, if 
 ACL2 executes <span class="v">g</span> by running the corresponding function in raw Common Lisp 
 the redefinition of <span class="v">fn</span> may cause raw lisp to break in irreparable ways. 
 As Lisp programmers we live with this all the time by following the simple 
 rule: after changing the syntax of a function don't run any function that 
 calls it via its old syntax.  This rule also works in the context of the 
 evaluation of ACL2 functions, but it is harder to follow in the context of 
 ACL2 deductions, since it is hard to know whether the database contains a path 
 leading the theorem prover from facts about one function to facts about 
 another.  Finally, of course, even if the database is still syntactically 
 well-formed there is no assurance that all the rules stored in it are valid. 
 For example, theorems proved about <span class="v">g</span> survive the redefinition of <span class="v">fn</span> 
 but may have crucially depended on the properties of the old <span class="v">fn</span>.  In 
 summary, we repeat the warning: <b>all bets are off if you set</b> 
 <span class="v">ld-redefinition-action</span> to <b>non</b>-<span class="v">nil</span>.</p> 
 
 <p>ACL2 provides some enforcement of the concern above, by disabling <span class="tt"><a href="ACL2____CERTIFY-BOOK.html">certify-book</a></span> if any <a href="ACL2____WORLD.html">world</a>-changing <a href="ACL2____EVENTS.html">events</a> exist in the 
 certification <a href="ACL2____WORLD.html">world</a> that were executed with a non-<span class="v">nil</span> value of 
 <span class="v">'ld-redefinition-action</span>.  (This value is checked at the end of each 
 top-level command, but the value does not change during evaluation of embedded 
 event forms; see <a href="ACL2____EMBEDDED-EVENT-FORM.html">embedded-event-form</a>.)</p> 
 
 <p>If at any point in a session you wish to see the list of all names that 
 have been redefined, see <a href="ACL2____REDEFINED-NAMES.html">redefined-names</a>.</p> 
 
 <p>That said, we'll give you enough rope to hang yourself.  When 
 <span class="v">ld-redefinition-action</span> is non-<span class="v">nil</span>, it must be a pair, <span class="v">(a .  b)</span>. 
 The value of <span class="v">a</span> determines how the system interacts with you when a 
 redefinition is submitted.  The value of <span class="v">b</span> allows you to specify how the 
 property list of the redefined name is to be ``renewed'' before the 
 redefinition.</p> 
 
 <p>There are several dimensions to the space of possibilities controlled by 
 part a: Do you want to be queried each time you redefine a name, so you can 
 confirm your intention?  (We sometimes make typing mistakes or simply forget 
 we have used that name already.)  Do you want to see a warning stating that 
 the name has been redefined?  Do you want ACL2 system functions given special 
 protection from possible redefinition?  Below are the choices for part a:</p> 
 
 <blockquote> 
 
 <p><span class="v">:query</span> — every attempt to redefine a name will produce a query. 
 The query will allow you to abort the redefinition or proceed.  It will will 
 also allow you to specify the part <span class="v">b</span> for this redefinition.  <span class="v">:Query</span> 
 is the recommended setting for users who wish to dabble in redefinition.</p> 
 
 <p><span class="v">:warn</span> — any user-defined function may be redefined but a 
 post-redefinition warning is printed.  The attempt to redefine a system name 
 produces a query.  If you are prototyping and testing a big system in ACL2 
 this is probably the desired setting for part <span class="v">a</span>.</p> 
 
 <p><span class="v">:doit</span> — any user-defined function may be redefined silently 
 (without query or warning) but when an attempt is made to redefine a system 
 function, a query is made.  This setting is recommended when you start making 
 massive changes to your prototyped system (and tire of even the warning 
 messages issued by <span class="v">:warn</span>).</p> 
 
 </blockquote> 
 
 <p>In support of our own ACL2 systems <a href="ACL2____PROGRAMMING.html">programming</a> there are two other 
 settings.  We suggest ordinary users not use them.</p> 
 
 <blockquote> 
 
 <p><span class="v">:warn!</span> — every attempt to redefine a name produces a warning but 
 no query.  Since ACL2 system functions can be redefined this way, this setting 
 should be used by the only-slightly-less-than supremely confident ACL2 system 
 hacker.</p> 
 
 <p><span class="v">:doit!</span> — this setting allows any name to be redefined silently 
 (without query or warnings).  ACL2 system functions are fair game.  This 
 setting is reserved for the supremely confident ACL2 system hacker. 
 (Actually, this setting is used when we are loading massively modified 
 versions of the ACL2 source files.)</p> 
 
 </blockquote> 
 
 <p>Part <span class="v">b</span> of <span class="v">ld-redefinition-action</span> tells the system how to 
 ``renew'' the property list of the name being redefined.  There are two 
 choices:</p> 
 
 <blockquote> 
 
 <p><span class="v">:erase</span> — erase all properties stored under the name, or</p> 
 
 <p><span class="v">:overwrite</span> — preserve existing properties and let the redefining 
 overwrite them.</p> 
 
 </blockquote> 
 
 <p>It should be stressed that neither of these <span class="v">b</span> settings is guaranteed 
 to result in an entirely satisfactory state of affairs after the redefinition. 
 Roughly speaking, <span class="v">:erase</span> returns the property list of the name to the 
 state it was in when the name was first introduced.  Lemmas, type information, 
 etc., stored under that name are lost.  Is that what you wanted?  Sometimes it 
 is, as when the old definition is ``completely wrong.'' But other times the 
 old definition was ``almost right'' in the sense that some of the work done 
 with it is still (intended to be) valid.  In that case, <span class="v">:overwrite</span> might 
 be the correct <span class="v">b</span> setting.  For example if <span class="v">fn</span> was a function and is 
 being re-<span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span>'d with the same <a href="ACL2____SIGNATURE.html">signature</a>, then the properties 
 stored by the new <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> should overwrite those stored by the old 
 <span class="tt"><a href="COMMON-LISP____DEFUN.html">defun</a></span> but the properties stored by <span class="tt"><a href="ACL2____DEFTHM.html">defthm</a></span>s will be 
 preserved.</p> 
 
 <p>In addition, neither setting will cause ACL2 to erase properties stored 
 under other symbols!  Thus, if <span class="v">FOO</span> names a rewrite rule which rewrites a 
 term beginning with the function symbol <span class="v">BAR</span> and you then redefine 
 <span class="v">FOO</span> to rewrite a term beginning with the function symbol <span class="v">BAZ</span>, then 
 the old version of <span class="v">FOO</span> is still available (because the rule itself was 
 added to the rewrite rules for <span class="v">BAR</span>, whose property list was not cleared 
 by redefining <span class="v">FOO</span>).</p> 
 
 <p>The <span class="v">b</span> setting is only used as the default action when no query is 
 made.  If you choose a setting for part a that produces a query then you will 
 have the opportunity, for each redefinition, to specify whether the property 
 list is to be erased or overwritten.</p> 
 
 <p>The keyword command <span class="v">:</span><span class="tt"><a href="ACL2____REDEF.html">redef</a></span> sets <span class="v">ld-redefinition-action</span> to 
 the pair <span class="v">(:query . :overwrite)</span>.  Since the resulting query will give you 
 the chance to specify <span class="v">:erase</span> instead of <span class="v">:overwrite</span>, this setting is 
 quite convenient.  But when you are engaged in heavy-duty prototyping, you may 
 wish to use a setting such as <span class="v">:warn</span> or even <span class="v">:doit</span>.  For that you 
 will have to invoke a form such as:</p> 
 
 <pre class="code">(<a href="ACL2____SET-LD-REDEFINITION-ACTION.html">set-ld-redefinition-action</a> '(:doit . :overwrite) state) .</pre> 
 
 <p><span class="tt"><a href="ACL2____ENCAPSULATE.html">Encapsulate</a></span> causes somewhat odd interaction with the user if 
 redefinition occurs within the encapsulation because the <a href="ACL2____ENCAPSULATE.html">encapsulate</a>d 
 event list is processed several times.  For example, if the redefinition 
 action causes a query and a non-local definition is actually a redefinition, 
 then the query will be posed twice, once during each pass.  C'est la vie.</p> 
 
 <p>Finally, it should be stressed again that redefinition is dangerous because 
 not all of the rules about a name are stored on the property list of the name. 
 Thus, redefinition can render ill-formed terms stored elsewhere in the 
 database or can preserve now-invalid rules.  See <a href="ACL2____REDUNDANT-EVENTS.html">redundant-events</a>, in 
 particular the section ``Note About Unfortunate Redundancies,'' for more 
 discussion of potential pitfalls of redefinition.</p>
</body>
</html>
