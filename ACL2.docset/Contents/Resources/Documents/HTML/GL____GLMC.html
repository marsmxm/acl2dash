<html>
<head>
<meta charset="UTF-8">
<title>Glmc</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=GL____GLMC">Click for Glmc in the Full Manual</a></h3>

<p>ACL2 interface to AIG-based safety model checking</p><p>The GLMC package allows automated proving of safety properties of 
state machines defined in ACL2.  It uses GL to obtain a representation for the 
next-state function, property, etc. as AIGs, and calls on an AIG model checker 
such as ABC to verify the property.</p> 
 
<p>Here is a small example:</p> 
 
<pre class="code">(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "glmc")
(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "bfr-mcheck-abc")
(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "centaur/gl/bfr-satlink" :dir :system)

;; use abc as the model checking engine
(bfr-mcheck-use-abc-simple)
;; use satlink (glucose) as the SAT checker
(<a href="GL____GL-SATLINK-MODE.html">gl-satlink-mode</a>)

;; start the external shell interface
(<a href="ACL2____VALUE-TRIPLE.html">value-triple</a> (<a href="ACL2____TSHELL-START.html">acl2::tshell-start</a>))

;; Definition of a (very) simple machine: machine state is just a 4-bit natural
;; which can be reset to 0 or incremented, but when incremented to exactly 10
;; resets to 0.  This is the next-state function:
(<a href="COMMON-LISP____DEFUN.html">defun</a> my-nextst (st incr reset)
  (<a href="ACL2____B_A2.html">b*</a> (((when reset) 0)
       (st (<a href="ACL2____LNFIX.html">lnfix</a> st))
       ((unless incr) st)
       (next (<a href="COMMON-LISP____1_B2.html">1+</a> st))
       ((when (<a href="COMMON-LISP____EQL.html">eql</a> next 10)) 0))
    next))

;; We'll check that this machine never reaches a state equal to 14.  This function
;; checks the property for any finite run, where st is the initial state and ins
;; is the list of input pairs (incr . reset):
(<a href="ACL2____DEFUND.html">defund</a> my-run-prop (st ins)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :measure (<a href="ACL2____LEN.html">len</a> ins)))
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> ins)
      t
    (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> st 14))
         (my-run-prop (my-nextst st (<a href="COMMON-LISP____CAAR.html">caar</a> ins) (<a href="COMMON-LISP____CDAR.html">cdar</a> ins)) (<a href="COMMON-LISP____CDR.html">cdr</a> ins)))))

;; Here we prove that if the initial value of the machine state is less than
;; 5, then our property holds:
(<a href="ACL2____DEFTHM.html">defthm</a> my-run-prop-correct
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> st)
                (<a href="COMMON-LISP_____C3.html">&lt;</a> st 5))
           (my-run-prop st ins))
  :hints ((glmc-hint
           :shape-spec-bindings `((incr ,(g-var 'incr))
                                  (reset ,(g-var 'reset))
                                  (st ,(<a href="GL____G-INT.html">g-int</a> 0 1 5)))
           :state-var st
           :initstatep (<a href="COMMON-LISP_____C3.html">&lt;</a> st 5)
           :nextstate (my-nextst st incr reset)
           :frame-input-bindings ((incr (<a href="COMMON-LISP____CAAR.html">caar</a> ins))
                                  (reset (<a href="COMMON-LISP____CDAR.html">cdar</a> ins)))
           :rest-of-input-bindings ((ins (<a href="COMMON-LISP____CDR.html">cdr</a> ins)))
           :end-of-inputsp (<a href="COMMON-LISP____ATOM.html">atom</a> ins)
           :measure (<a href="ACL2____LEN.html">len</a> ins)
           :run (my-run-prop st ins)
           :state-hyp (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> st) (<a href="COMMON-LISP_____C3.html">&lt;</a> st 16))
           :prop (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> st 14))
           :run-check-hints ('(:expand ((my-run-prop st ins)))))))</pre> 
 
<p>The notable thing about this example is that the property, as stated, is not 
inductive.  The usual way to prove this in ACL2 would be to strengthen the 
property into an invariant that is inductive -- either weaken the initial state 
assumption so that it is inductive (assume <span class="v">(<a href="COMMON-LISP_____C3.html">&lt;</a> i 10)</span> instead of <span class="v">(<a href="COMMON-LISP_____C3.html">&lt;</a> i
5)</span>) or strengthen the property (check <span class="v">(<a href="COMMON-LISP_____C3.html">&lt;</a> st 10)</span> instead of 
<span class="v">(<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> st 14))</span>).  Instead, we leave that task to the external model 
checker (in this case ABC).  GL transforms the ACL2 conjecture into a 
finite-state machine safety property.  If we trust ABC when it says the 
property was proved, then this produces an ACL2 theorem.</p> 
 
 
<h3>Glmc-hint options</h3> 
 
<p>GLMC is invoked by the glmc-hint macro, which takes several keyword options:</p> 
 
<ul> 
 
<li>
<span class="v">:state-var</span> is the variable containing the current machine 
state (as distinguished from the inputs).</li> 
 
<li>
<span class="v">:body-bindings</span> is a list of <a href="ACL2____B_A2.html">b*</a> bindings under which to evaluate 
the <span class="v">:nextstate</span>, <span class="v">:initstatep</span> <span class="v">:prop</span>, and <span class="v">:constraint</span> terms. 
It should only use the state variable and frame inputs.</li> 
 
<li>
<span class="v">:initstatep</span> is a term that must be true for valid initial states, 
though it may reference any variables bound in <span class="v">:body-bindings</span> as well as 
the state and frame input variables.</li> 
 
<li>
<span class="v">:nextstate</span> is a term giving the next value of the state, in terms of 
the state variable, frame inputs, and variables bound by <span class="v">:body-bindings</span>.</li> 
 
<li>
<span class="v">:run</span> is a term calling some function that recursively checks the 
property on some finite run, i.e. it checks the property of the current state 
and input frame, then recurs after updating the state with the nextstate 
function.</li> 
 
<li>
<span class="v">:frame-input-bindings</span> is a binding list (such as in a <span class="v">let</span>), 
giving the current-frame inputs in terms of the inputs to the run 
function. We'll refer to (e.g.) the list of all remaining frame inputs as the 
"run inputs", versus (e.g.) a single element of that list as the "frame 
inputs". E.g., if the input to the run function is simply a list of frame 
inputs, then this binding might be <span class="v">((in (<a href="COMMON-LISP____CAR.html">car</a> ins)))</span>.  </li> 
 
<li>
<span class="v">:rest-of-input-bindings</span> is a binding list giving the rest of the 
inputs after the current frame, such as is passed to the recursive call of the 
run function -- e.g., <span class="v">((ins (<a href="COMMON-LISP____CDR.html">cdr</a> ins)))</span>.</li> 
 
<li>
<span class="v">:end-of-inputsp</span> is a term saying when to stop the run; the run 
function should always be true when <span class="v">:end-of-inputsp</span> holds, because that 
means it has failed to find a frame in which the property is violated.  In the 
case of a simple list of frame inputs, this would be <span class="v">(<a href="COMMON-LISP____ATOM.html">atom</a> ins)</span>.</li> 
 
<li>
<span class="v">:measure</span> gives a measure for the run function; for technical reasons, 
we must reprove the termination of the run function.</li> 
 
<li>
<span class="v">:shape-spec-bindings</span> gives a binding of the state variable and frame 
input variables to shape specifier objects; see <a href="GL____SHAPE-SPECS.html">shape-specs</a>.  Unlike the 
other arguments, this one is evaluated, so if you don't want to evaluate it, 
quote it.</li> 
 
<li>
<span class="v">:input-hyp</span> gives an assumption about the frame inputs that must hold 
in each frame or else the run function will return true. (If you want to have a 
separate theorem hypothesis saying that the assumption holds for each input, 
you may include this in the <span class="v">:run</span> term using <span class="v">implies</span>.)  This is used 
to prove that the shape-spec given for each non-state input is sufficient to 
cover all allowed inputs.</li> 
 
<li>
<span class="v">:state-hyp</span> gives an assumption that must hold of all valid states; it 
is used to prove that the shape-spec given for the state variable is sufficient 
to cover all possible states.  The goal to be proved must assume the state-hyp 
holds of the initial state, and it will be proven to hold of all other states 
by model checking or inductively; see the <span class="v">:state-hyp-method</span> option 
below.</li> 
 
<li>
<span class="v">:state-hyp-method</span> should be one of <span class="v">:inductive-sat</span>, 
<span class="v">:inductive-clause</span>, or <span class="v">:mcheck</span> (the default); this determines the 
method by which we show that the state hyp is invariant.  If it is 
<span class="v">:inductive-clause</span>, a proof obligation is generated saying that the state 
hyp holds of the next-state if the input hyp and state hyp hold of the current 
state.  If it is <span class="v">:inductive-sat</span>, a SAT check is issued which proves this 
at the Boolean level.  If it is <span class="v">:mcheck</span>, then the condition is ANDed with 
the property in the model checking problem.  This is a more flexible method 
 (though potentially slower) because the state hyp may be an invariant of all 
reachable states without being an inductive invariant.</li> 
 
<li>
<span class="v">:prop</span> gives the property that must be proven to hold in each 
frame (i.e., the run function returns false if it is ever violated).  It may 
reference the state and frame input variables as well as variables bound in the 
<span class="v">:body-bindings</span>.</li> 
 
<li>
<span class="v">:constraint</span> gives a constraint that is assumed to hold in each 
frame (i.e., the run function returns true if it is ever violated). (This may 
be omitted; its default is <span class="v">T</span>.)  It may reference the state and frame input 
variables as well as variables bound in the <span class="v">:body-bindings</span>.</li> 
 
<li>
<span class="v">:side-goals</span>, if set to <span class="v">T</span>, skips the actual model checking and 
simply returns the "side goals" such as coverage and the check that the run 
function and input clause are of the expected form. (A theorem with 
<span class="v">:side-goals t</span> will always fail to prove, but if everything is successful 
only a single subgoal of the form <span class="v">(<a href="COMMON-LISP____NOT.html">not</a> (gl-cp-hint 'side-goals-fake-goal))</span> 
will remain.)</li> 
 
<li>
<span class="v">:check-vacuity</span> is <span class="v">T</span> by default; when true, GLMC will check that 
the state-hyp, input-hyp, initial state predicate, constraint, and property are 
each separately satisfiable, since any of these being unsatisfiable likely 
indicates something unexpected.  Setting this to <span class="v">NIL</span> skips these 
checks.</li> 
 
<li>
<span class="v">:clause-check-hints</span>, <span class="v">:run-check-hints</span>, <span class="v">:measure-hints</span>, and 
<span class="v">:state-hyp-inductive-hints</span> provide computed hints to various side goals 
produced by the clause processor.  Each entry should be a list of hints like 
the usual <span class="v">:hints</span> provided to a defthm event, but all the hints should be 
computed hints, not subgoal hints.  The side goals are discussed below.</li> 
 
<li>
<span class="v">:do-not-expand</span>, <span class="v">:cov-theory-add</span>, <span class="v">:cov-hints</span>, and 
<span class="v">:cov-hints-position</span> affect the hints given to the coverage side goal; see 
<a href="GL____COVERAGE-PROBLEMS.html">coverage-problems</a>.  To provide your own hints, completely overriding the 
default hints provided for coverage, use <span class="v">:cov-hints</span> to give your hints and 
set <span class="v">:cov-hints-position :replace</span>.</li> 
 
</ul> 
 
<h3>Side goals</h3> 
 
<p>A few proof obligations are produced by a successful call of the GLMC clause 
processor.</p> 
 
<ul> 
 
<li>Coverage: Shows that the shape specifiers provided in the 
<span class="v">:shape-spec-bindings</span> argument are sufficient to cover all possible states 
and inputs allowed by the state and input hyps.  This goal has the same form as 
any GL coverage proof; see <a href="GL____SHAPE-SPECS.html">shape-specs</a> and <a href="GL____COVERAGE-PROBLEMS.html">coverage-problems</a>.</li> 
 
<li>Clause check: This simply shows that the goal clause is of the required 
form.  Specifically, the original goal must follow from this conjecture, which 
is what GLMC actually proves: 
<pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> &lt;initstp&gt; &lt;st-hyp&gt;)
         &lt;run&gt;)</pre>
</li> 
 
<li>Run check: This checks that the <span class="v">:run</span> term is implied by the recurrence 
that is proved by the model check, namely: 
<pre class="code">(<a href="COMMON-LISP____IF.html">if</a> &lt;end-of-inputs&gt;
    t
  (<a href="COMMON-LISP____LET.html">let</a> &lt;frame-input-bindings&gt;
    (<a href="COMMON-LISP____LET.html">let</a> &lt;rest-of-input-bindings&gt;
      (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____AND.html">and</a> &lt;input-hyp&gt;
                    (<a href="ACL2____B_A2.html">b*</a> &lt;body-bindings&gt; &lt;constraint&gt;)))
          t
        (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____B_A2.html">b*</a> &lt;body-bindings&gt; &lt;prop&gt;))
            nil
          (<a href="COMMON-LISP____LET.html">let</a> ((&lt;st-var&gt; (<a href="ACL2____B_A2.html">b*</a> &lt;body-bindings&gt; &lt;nextstate&gt;)))
            (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____NOT.html">not</a> &lt;state-hyp&gt;)
                'nil
              &lt;run&gt;)))))))</pre>
</li> 
 
<li>Measure check: This rechecks that the run function terminates, which is 
necessary for technical reasons.</li> 
 
<li>State-hyp-inductive check: This only occurs if the <span class="v">:state-hyp-method</span> 
is <span class="v">:inductive-clause</span>; it shows that the state hyp is invariant.</li> 
 
</ul> 
 
<h3>Backends</h3> 
 
<p>GLMC uses the same method as GL to solve combinational SAT problems, such as 
vacuity checks (see <a href="GL____MODES.html">modes</a>).  GLMC calls its model-checking backend 
through an attachable function called <a href="GL____BFR-MCHECK.html">bfr-mcheck</a>. The book 
"glmc/bfr-mcheck-abc.lisp" provides one backend that can be attached to 
<span class="v">bfr-mcheck</span> by calling the macro <span class="v">(bfr-mcheck-use-abc-simple)</span>.  That 
backend requires a trust tag because it calls out to ABC; it also simply trusts 
ABC when it claims the conjecture is proved.</p> 
 

</body>
</html>
