<html>
<head>
<meta charset="UTF-8">
<title>Instructions</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____INSTRUCTIONS">Click for Instructions in the Full Manual</a></h3>

<p>Instructions to the interactive proof-builder</p><p>See <a href="ACL2____PROOF-BUILDER.html">proof-builder</a> for an introduction to the interactive 
 ``proof-builder'' goal manager, which supports much more direct control of the 
 proof process than is available by direct calls to the prover (as are normally 
 made using <span class="tt"><a href="ACL2____DEFTHM.html">defthm</a></span> or <span class="tt"><a href="ACL2____THM.html">thm</a></span>).  In brief, typical use is to 
 evaluate the form <span class="v">(<a href="ACL2____VERIFY.html">verify</a> SOME-GOAL)</span>, where <span class="v">SOME-GOAL</span> is a 
 formula (i.e., term) that you would like to prove.  Various 
 commands (instructions) are available at the resulting prompt; see <a href="ACL2____PROOF-BUILDER-COMMANDS.html">proof-builder-commands</a>.  When the proof is completed, suitable invocation of 
 the <span class="v">exit</span> command will print out a form containing an <span class="v">:instructions</span> 
 field that provides the instructions that you gave interactively, so that this 
 form can be evaluated non-interactively.</p> 
 
 <p>Thus, also see <a href="ACL2____DEFTHM.html">defthm</a> for the role of <span class="v">:instructions</span> in place of 
 <span class="v">:</span><span class="tt"><a href="ACL2____HINTS.html">hints</a></span>.  As illustrated by the following example, the value 
 associated with <span class="v">:instructions</span> is a list of interactive <a href="ACL2____PROOF-BUILDER.html">proof-builder</a> commands.</p> 
 
 <pre class="code">Example:
(<a href="ACL2____DEFTHM.html">defthm</a> associativity-of-append
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="COMMON-LISP____APPEND.html">append</a> x y) z)
               (<a href="COMMON-LISP____APPEND.html">append</a> x (<a href="COMMON-LISP____APPEND.html">append</a> y z)))
        :instructions
        (:induct (:dv 1) (:dv 1) :x :up :x (:dv 2) := (:drop 2)
         :top (:dv 2) :x :top :s :bash))</pre> 
 
 <p>See <a href="ACL2____PROOF-BUILDER-COMMANDS.html">proof-builder-commands</a> for a list of supported interactive 
 proof-builder instructions and links to their documentation.</p> 
 
 <p>Below, we describe a capability for supplying <span class="v">:instructions</span> as 
 <span class="v">:</span><span class="tt"><a href="ACL2____HINTS.html">hints</a></span>.</p> 
 
 <p>The most basic utilities for directing the discharge of a proof obligation 
 are <span class="v">:</span><span class="tt"><a href="ACL2____HINTS.html">hints</a></span> and (less commonly) <span class="v">:instructions</span>.  Individual 
 instructions may call the prover with <span class="v">:hints</span>; in that sense, prover hints 
 may occur inside instructions.  We now describe how, on the other hand, 
 instructions may occur inside hints.</p> 
 
 <p>ACL2 supports <span class="v">:instructions</span> as a hints keyword.  The following example 
 forms the basis for our running example.  This example does not actually need 
 hints, but imagine that the inductive step — which is "Subgoal *1/2" 
 — was difficult.  You could submit that goal to <span class="tt"><a href="ACL2____VERIFY.html">verify</a></span>, do an 
 interactive proof, submit <span class="v">(<a href="ACL2____EXIT.html">exit</a> t)</span> to obtain the list of 
 <span class="v">:instructions</span>, and then paste in those instructions.  When you submit the 
 resulting event, you might see the following.  Below we'll explain the hint 
 processing.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="ACL2____THM.html">thm</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="COMMON-LISP____APPEND.html">append</a> x y) z)
                   (<a href="COMMON-LISP____APPEND.html">append</a> x (<a href="COMMON-LISP____APPEND.html">append</a> y z)))
            :hints (("Subgoal *1/2"
                     :instructions
                     (:promote (:dv 1) (:dv 1) :x :up :x (:dv 2) :=
                      (:drop 2) :top (:dv 2) :x :top :s))))

Name the formula above *1.

Perhaps we can prove *1 by induction.  Three induction schemes are
suggested by this conjecture.  Subsumption reduces that number to two.
However, one of these is flawed and so we are left with one viable
candidate.

We will induct according to a scheme suggested by (<a href="ACL2____BINARY-APPEND.html">BINARY-APPEND</a> X Y).
This suggestion was produced using the :induction rule BINARY-APPEND.
If we let (:P X Y Z) denote *1 above then the induction scheme we'll
use is
(<a href="COMMON-LISP____AND.html">AND</a> (<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____AND.html">AND</a> (<a href="COMMON-LISP____NOT.html">NOT</a> (<a href="COMMON-LISP____ENDP.html">ENDP</a> X)) (:P (<a href="COMMON-LISP____CDR.html">CDR</a> X) Y Z))
              (:P X Y Z))
     (<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____ENDP.html">ENDP</a> X) (:P X Y Z))).
This induction is justified by the same argument used to admit BINARY-APPEND.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

[Note:  A hint was supplied for our processing of the goal below.
Thanks!]

Subgoal *1/2
(<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____AND.html">AND</a> (<a href="COMMON-LISP____NOT.html">NOT</a> (<a href="COMMON-LISP____ENDP.html">ENDP</a> X))
              (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="COMMON-LISP____APPEND.html">APPEND</a> (<a href="COMMON-LISP____APPEND.html">APPEND</a> (<a href="COMMON-LISP____CDR.html">CDR</a> X) Y) Z)
                     (<a href="COMMON-LISP____APPEND.html">APPEND</a> (<a href="COMMON-LISP____CDR.html">CDR</a> X) Y Z)))
         (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="COMMON-LISP____APPEND.html">APPEND</a> (<a href="COMMON-LISP____APPEND.html">APPEND</a> X Y) Z)
                (<a href="COMMON-LISP____APPEND.html">APPEND</a> X Y Z))).

But the trusted :CLAUSE-PROCESSOR function PROOF-BUILDER-CL-PROC replaces
this goal by T.

Subgoal *1/1
(<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____ENDP.html">ENDP</a> X)
         (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="COMMON-LISP____APPEND.html">APPEND</a> (<a href="COMMON-LISP____APPEND.html">APPEND</a> X Y) Z)
                (<a href="COMMON-LISP____APPEND.html">APPEND</a> X Y Z))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/1'
(<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____NOT.html">NOT</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> X))
         (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="COMMON-LISP____APPEND.html">APPEND</a> (<a href="COMMON-LISP____APPEND.html">APPEND</a> X Y) Z)
                (<a href="COMMON-LISP____APPEND.html">APPEND</a> X Y Z))).

But simplification reduces this to T, using the :definition BINARY-APPEND
and primitive type reasoning.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( THM ...)
Rules: ((:DEFINITION BINARY-APPEND)
        (:DEFINITION ENDP)
        (:DEFINITION NOT)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION BINARY-APPEND))
Time:  0.02 seconds (prove: 0.01, print: 0.01, other: 0.00)

Proof succeeded.
ACL2 !&gt;</pre> 
 
 <p>To understand how the <span class="v">:instructions</span> supplied above were processed, 
 view the interactive proof-builder instruction interpreter as a 
 ``clause-processor'': a function that takes an input goal and returns a list 
 of goals (which can be the empty list).  Such a function has the property that 
 if all goals in that returned list are theorems, then so is the input goal. 
 This view of the interactive proof-builder instruction interpreter as a 
 clause-processor leads to the following crucial observation.</p> 
 
 <p><b>IMPORTANT!</b>.  Each call of the interactive proof-builder instruction 
 interpreter is treated as a standalone clause-processor that is insensitive to 
 the surrounding prover environment.  In particular:</p> 
 
 <ul> 
 
 <li>The interactive proof-builder's theory is not sensitive to <span class="v">:in-theory</span> 
 <a href="ACL2____HINTS.html">hints</a> already processed in the surrounding proof.  Indeed, the current 
 theory for which proof-builder commands are processed is just the current 
 theory of the ACL2 logical <a href="ACL2____WORLD.html">world</a>, i.e., the value of 
 <span class="v">(<a href="ACL2____CURRENT-THEORY.html">current-theory</a> :here)</span>.  Moreover, references to 
 <span class="v">(<a href="ACL2____CURRENT-THEORY.html">current-theory</a> :here)</span> in a proof-builder <span class="v">in-theory</span> command, even 
 implicit references such as provided by <span class="tt"><a href="ACL2____ENABLE.html">enable</a></span> and <span class="tt"><a href="ACL2____DISABLE.html">disable</a></span> 
 expressions, are also references to the current theory of the ACL2 logical 
 <a href="ACL2____WORLD.html">world</a>.</li> 
 
 <li>The <a href="ACL2____RUNE.html">rune</a>s used during an <span class="v">:instructions</span> hint are not tracked 
 beyond that hint, hence may not show up in the <a href="ACL2____SUMMARY.html">summary</a> of the overall 
 proof.  Again, think of the <span class="v">:instructions</span> hint as a <a href="ACL2____CLAUSE-PROCESSOR.html">clause-processor</a> call, which has some effect not tracked by the surrounding 
 proof other than for the child goals that it returns.</li> 
 
 </ul> 
 
 <p>We continue now with our discussion of the interactive proof-builder 
 instruction interpreter as a clause-processor.</p> 
 
 <p>In the example above, the input goal (<span class="v">"Subgoal *1/2"</span>) was processed 
 by the proof-builder instruction interpreter.  The result was the empty goal 
 stack, therefore proving the goal, as reported in the output, which we repeat 
 here.</p> 
 
 <pre class="code">[Note:  A hint was supplied for our processing of the goal below.
Thanks!]

Subgoal *1/2
(<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____AND.html">AND</a> (<a href="COMMON-LISP____NOT.html">NOT</a> (<a href="COMMON-LISP____ENDP.html">ENDP</a> X))
              (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="COMMON-LISP____APPEND.html">APPEND</a> (<a href="COMMON-LISP____APPEND.html">APPEND</a> (<a href="COMMON-LISP____CDR.html">CDR</a> X) Y) Z)
                     (<a href="COMMON-LISP____APPEND.html">APPEND</a> (<a href="COMMON-LISP____CDR.html">CDR</a> X) Y Z)))
         (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="COMMON-LISP____APPEND.html">APPEND</a> (<a href="COMMON-LISP____APPEND.html">APPEND</a> X Y) Z)
                (<a href="COMMON-LISP____APPEND.html">APPEND</a> X Y Z))).

But the trusted :CLAUSE-PROCESSOR function PROOF-BUILDER-CL-PROC replaces
this goal by T.</pre> 
 
 <p><b>Remark.</b> This brief remark can probably be ignored, but we include it 
 for completeness.  The <span class="v">:CLAUSE-PROCESSOR</span> message above may be surprising, 
 since the hint attached to <span class="v">"Subgoal *1/2"</span> is an <span class="v">:instructions</span> 
 hint, not a <span class="v">:clause-processor</span> hint.  But <span class="v">:instructions</span> is actually a 
 custom keyword hint (see <a href="ACL2____CUSTOM-KEYWORD-HINTS.html">custom-keyword-hints</a>), and may be thought of 
 as a macro that expands to a <span class="v">:</span><span class="tt"><a href="ACL2____CLAUSE-PROCESSOR.html">clause-processor</a></span> hint, one that 
 specifies <span class="v">proof-builder-cl-proc</span> as the clause-processor function.  The 
 keen observer may notice that the clause-processor is referred to as 
 ``trusted'' in the above output.  Normally one needs a trust tag (see <a href="ACL2____DEFTTAG.html">defttag</a>) to install a trusted clause-processor, but that is not the case for 
 the built-in clause-processor, <span class="v">proof-builder-cl-proc</span>.  Finally, we note 
 that <span class="v">:instructions</span> <a href="ACL2____HINTS.html">hints</a> are ``spliced'' into the hints as 
 follows: the appropriate <span class="v">:</span><span class="tt"><a href="ACL2____CLAUSE-PROCESSOR.html">clause-processor</a></span> hint replaces the 
 <span class="v">:instructions</span> hint, and the other hints remain intact.  It may seems 
 surprising that one can thus, for example, use <span class="v">:instructions</span> and 
 <span class="v">:in-theory</span> together; but although the <span class="v">:in-theory</span> hint will have no 
 effect on execution of the <span class="v">:instructions</span> (see first bullet above), the 
 <span class="v">:in-theory</span> hint will apply in the usual manner to any child goals (see 
 <a href="ACL2____HINTS-AND-THE-WATERFALL.html">hints-and-the-waterfall</a>).  End of Remark.</p> 
 
 <p>Now consider the case that the supplied instructions do not prove the goal. 
 That is, suppose that the execution of those instructions results in a 
 non-empty goal stack.  In that case, the resulting goals become children of 
 the input goals.  The following edited log provides an illustration using a 
 modification of the above example, this time with a single instruction that 
 splits into two cases.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="ACL2____THM.html">thm</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="COMMON-LISP____APPEND.html">append</a> x y) z)
                   (<a href="COMMON-LISP____APPEND.html">append</a> x (<a href="COMMON-LISP____APPEND.html">append</a> y z)))
            :hints (("Subgoal *1/2"
                     :instructions
                     ((:casesplit (<a href="COMMON-LISP____EQUAL.html">equal</a> x y))))))

[[ ... output omitted ... ]]

Subgoal *1/2
(<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____AND.html">AND</a> (<a href="COMMON-LISP____NOT.html">NOT</a> (<a href="COMMON-LISP____ENDP.html">ENDP</a> X))
              (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="COMMON-LISP____APPEND.html">APPEND</a> (<a href="COMMON-LISP____APPEND.html">APPEND</a> (<a href="COMMON-LISP____CDR.html">CDR</a> X) Y) Z)
                     (<a href="COMMON-LISP____APPEND.html">APPEND</a> (<a href="COMMON-LISP____CDR.html">CDR</a> X) Y Z)))
         (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="COMMON-LISP____APPEND.html">APPEND</a> (<a href="COMMON-LISP____APPEND.html">APPEND</a> X Y) Z)
                (<a href="COMMON-LISP____APPEND.html">APPEND</a> X Y Z))).

We now apply the trusted :CLAUSE-PROCESSOR function PROOF-BUILDER-CL-PROC
to produce two new subgoals.

Subgoal *1/2.2

[[ ... output omitted ... ]]

Subgoal *1/2.1

[[ ... output omitted ... ]]</pre> 
 
 <p>We have seen that an <span class="v">:instructions</span> hint may produce zero or more 
 subgoals.  There may be times where you wish to insist that it produce zero 
 subgoals, i.e., that it prove the desired goal.  The interactive 
 proof-builder's `<span class="v">finish</span>' command works nicely for this purpose.  For 
 example, the following form is successfully admitted, but if you delete some 
 of the commands (for example, the <span class="v">:s</span> command at the end), you will see an 
 informative error message.</p> 
 
 <pre class="code">(<a href="ACL2____THM.html">thm</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="COMMON-LISP____APPEND.html">append</a> x y) z)
            (<a href="COMMON-LISP____APPEND.html">append</a> x (<a href="COMMON-LISP____APPEND.html">append</a> y z)))
     :hints (("Subgoal *1/2"
              :instructions
              ((finish :promote (:dv 1) (:dv 1) :x :up :x (:dv 2) :=
                       (:drop 2) :top (:dv 2) :x :top :s)))))</pre> 
 
 <p>If an :instructions hint of the form <span class="v">((finish ...))</span> fails to prove the 
 goal, the clause-processor is deemed to have caused an error.  Indeed, any 
 ``failure'' of a supplied proof-builder instruction will be deemed to cause an 
 error.  In this case, you should see an error message such as the 
 following:</p> 
 
 <pre class="code">Saving proof-builder error state; see :DOC instructions.  To retrieve:

(<a href="ACL2____RETRIEVE.html">RETRIEVE</a> :ERROR1)</pre> 
 
 <p>In this case, you can evaluate the indicated <span class="tt"><a href="ACL2____RETRIEVE.html">retrieve</a></span> command in 
 the ACL2 read-eval-print loop, to get to the point of failure.</p> 
 
 <p>You may have noticed that there is no output from the interactive 
 proof-builder in the examples above.  This default behavior prevents confusion 
 that could arise from use of proof-builder commands that call the theorem 
 prover such as <span class="v">prove</span>, <span class="v">bash</span>, <span class="v">split</span>, and <span class="v">induct</span>.  These 
 commands produce output for what amounts to a fresh proof attempt, which could 
 confuse attempts to understand the surrounding proof log.  You can override 
 the default behavior by providing a command of the form</p> 
 
 <pre class="code"> <span class="v">(<a href="ACL2____COMMENT.html">comment</a> inhibit-output-lst VAL)</span> </pre> 
 
 <p>where <span class="v">VAL</span> is either the keyword <span class="v">:SAME</span> (indicating that no change 
 should be made to which output is inhibited) or else is a legal value for 
 inhibited output; see <a href="ACL2____SET-INHIBIT-OUTPUT-LST.html">set-inhibit-output-lst</a>.  The following two 
 variants of the immediately preceding <span class="v">THM</span> form will each produce output 
 from the interactive proof-builder commands, assuming in the first variant 
 that output hasn't already been inhibited.</p> 
 
 <pre class="code">(<a href="ACL2____THM.html">thm</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="COMMON-LISP____APPEND.html">append</a> x y) z)
                   (<a href="COMMON-LISP____APPEND.html">append</a> x (<a href="COMMON-LISP____APPEND.html">append</a> y z)))
            :hints (("Subgoal *1/2"
                     :instructions
                     ((<a href="ACL2____COMMENT.html">comment</a> inhibit-output-lst :same)
                      (:casesplit (<a href="COMMON-LISP____EQUAL.html">equal</a> x y))))))

(<a href="ACL2____THM.html">thm</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="COMMON-LISP____APPEND.html">append</a> x y) z)
                   (<a href="COMMON-LISP____APPEND.html">append</a> x (<a href="COMMON-LISP____APPEND.html">append</a> y z)))
            :hints (("Subgoal *1/2"
                     :instructions
                     ((<a href="ACL2____COMMENT.html">comment</a> inhibit-output-lst (<a href="ACL2____PROOF-TREE.html">proof-tree</a>))
                      (:casesplit (<a href="COMMON-LISP____EQUAL.html">equal</a> x y))))))</pre> 
 
 <p>Note that such a <span class="v">comment</span> instruction must be provided explicitly 
 (i.e., not by way of a proof-builder <a href="ACL2____MACRO-COMMAND.html">macro-command</a>) as the first 
 instruction, in order to have the effect on inhibited output that is described 
 above.</p> 
 
 <p>The following contrived example gives a sense of how one might want to use 
 <span class="v">:instructions</span> within <span class="v">:</span><span class="tt"><a href="ACL2____HINTS.html">hints</a></span>.  If you submit the following 
 theorem</p> 
 
 <pre class="code">(<a href="ACL2____THM.html">thm</a> (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> x)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____REVERSE.html">reverse</a> (<a href="COMMON-LISP____REVERSE.html">reverse</a> x)) x)))</pre> 
 
 <p>then you will see the following checkpoint printed with the <a href="ACL2____SUMMARY.html">summary</a>.</p> 
 
 <pre class="code">Subgoal *1/3''
(<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____AND.html">AND</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> X)
              (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="COMMON-LISP____REVAPPEND.html">REVAPPEND</a> (<a href="COMMON-LISP____REVAPPEND.html">REVAPPEND</a> (<a href="COMMON-LISP____CDR.html">CDR</a> X) NIL) NIL)
                     (<a href="COMMON-LISP____CDR.html">CDR</a> X))
              (<a href="ACL2____TRUE-LISTP.html">TRUE-LISTP</a> (<a href="COMMON-LISP____CDR.html">CDR</a> X)))
         (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="COMMON-LISP____REVAPPEND.html">REVAPPEND</a> (<a href="COMMON-LISP____REVAPPEND.html">REVAPPEND</a> (<a href="COMMON-LISP____CDR.html">CDR</a> X) (<a href="COMMON-LISP____LIST.html">LIST</a> (<a href="COMMON-LISP____CAR.html">CAR</a> X)))
                           NIL)
                X))</pre> 
 
 <p>This suggests proving the following theorem.  Here we state it using <span class="tt"><a href="ACL2____DEFTHMD.html">defthmd</a></span>, so that it is immediately disabled.  Normally disabling would be 
 unnecessary, but for our contrived example it is useful to imagine disabling 
 it, say because we are following a methodology that tends to keep <a href="ACL2____REWRITE.html">rewrite</a> rules disabled.</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHMD.html">defthmd</a> revappend-revappend
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____REVAPPEND.html">revappend</a> (<a href="COMMON-LISP____REVAPPEND.html">revappend</a> x y) z)
         (<a href="COMMON-LISP____REVAPPEND.html">revappend</a> y (<a href="COMMON-LISP____APPEND.html">append</a> x z))))</pre> 
 
 <p>We might then enter the interactive <a href="ACL2____PROOF-BUILDER.html">proof-builder</a> to prove the 
 original theorem interactively, as follows.</p> 
 
 <pre class="code">ACL2 !&gt;(<a href="ACL2____VERIFY.html">verify</a> (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> x)
                        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____REVERSE.html">reverse</a> (<a href="COMMON-LISP____REVERSE.html">reverse</a> x)) x)))
-&gt;: bash
***** Now entering the theorem prover *****
Goal'

([ A key checkpoint:

Goal'
(<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="ACL2____TRUE-LISTP.html">TRUE-LISTP</a> X)
         (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="COMMON-LISP____REVAPPEND.html">REVAPPEND</a> (<a href="COMMON-LISP____REVAPPEND.html">REVAPPEND</a> X NIL) NIL)
                X))

Goal' is subsumed by a goal yet to be proved.

])

Q.E.D.

Creating one new goal:  (MAIN . 1).

The proof of the current goal, MAIN, has been completed.  However,
the following subgoals remain to be proved:
  (MAIN . 1).
Now proving (MAIN . 1).
-&gt;: th ; show current goal ("th" for "theorem")
*** Top-level hypotheses:
1. (<a href="ACL2____TRUE-LISTP.html">TRUE-LISTP</a> X)

The current subterm is:
(<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="COMMON-LISP____REVAPPEND.html">REVAPPEND</a> (<a href="COMMON-LISP____REVAPPEND.html">REVAPPEND</a> X NIL) NIL)
       X)
-&gt;: p ; show current subterm only
(<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="COMMON-LISP____REVAPPEND.html">REVAPPEND</a> (<a href="COMMON-LISP____REVAPPEND.html">REVAPPEND</a> X NIL) NIL)
       X)
-&gt;: 1 ; dive to first argument
-&gt;: p
(<a href="COMMON-LISP____REVAPPEND.html">REVAPPEND</a> (<a href="COMMON-LISP____REVAPPEND.html">REVAPPEND</a> X NIL) NIL)
-&gt;: sr ; show-rewrites

1. REVAPPEND-REVAPPEND (disabled)
  New term: (<a href="COMMON-LISP____REVAPPEND.html">REVAPPEND</a> NIL (<a href="COMMON-LISP____APPEND.html">APPEND</a> X NIL))
  Hypotheses: &lt;none&gt;
  Equiv: EQUAL

2. REVAPPEND
  New term: (<a href="COMMON-LISP____AND.html">AND</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> (<a href="COMMON-LISP____REVAPPEND.html">REVAPPEND</a> X NIL))
                 (<a href="COMMON-LISP____REVAPPEND.html">REVAPPEND</a> (<a href="COMMON-LISP____CDR.html">CDR</a> (<a href="COMMON-LISP____REVAPPEND.html">REVAPPEND</a> X NIL))
                            (<a href="COMMON-LISP____LIST.html">LIST</a> (<a href="COMMON-LISP____CAR.html">CAR</a> (<a href="COMMON-LISP____REVAPPEND.html">REVAPPEND</a> X NIL)))))
  Hypotheses: &lt;none&gt;
  Equiv: EQUAL
-&gt;: (r 1) ; rewrite with rule #1 above
Rewriting with REVAPPEND-REVAPPEND.
-&gt;: p
(<a href="COMMON-LISP____REVAPPEND.html">REVAPPEND</a> NIL (<a href="COMMON-LISP____APPEND.html">APPEND</a> X NIL))
-&gt;: top ; move to the top of the conclusion, making it the current subterm
-&gt;: p
(<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="COMMON-LISP____REVAPPEND.html">REVAPPEND</a> NIL (<a href="COMMON-LISP____APPEND.html">APPEND</a> X NIL)) X)
-&gt;: prove ; finish the proof
***** Now entering the theorem prover *****

Q.E.D.

*!*!*!*!*!*!* All goals have been proved! *!*!*!*!*!*!*
You may wish to exit.
-&gt;: (<a href="ACL2____EXIT.html">exit</a> t) ; the argument, t, causes :instructions to be printed
(<a href="ACL2____DEFTHM.html">DEFTHM</a> T
        (<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="ACL2____TRUE-LISTP.html">TRUE-LISTP</a> X)
                 (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="COMMON-LISP____REVERSE.html">REVERSE</a> (<a href="COMMON-LISP____REVERSE.html">REVERSE</a> X)) X))
        :INSTRUCTIONS (:BASH (:DV 1)
                             (:REWRITE REVAPPEND-REVAPPEND)
                             :TOP :PROVE))
 NIL
ACL2 !&gt;(<a href="ACL2____THM.html">thm</a>
        (<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="ACL2____TRUE-LISTP.html">TRUE-LISTP</a> X)
                 (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="COMMON-LISP____REVERSE.html">REVERSE</a> (<a href="COMMON-LISP____REVERSE.html">REVERSE</a> X)) X))
        :hints (("Goal"
                 :INSTRUCTIONS ; copy what was printed above:
                 (:BASH (:DV 1)
                        (:REWRITE REVAPPEND-REVAPPEND)
                        :TOP :PROVE))))
Goal'

Q.E.D.

Q.E.D.

Q.E.D.

Summary
Form:  ( THM ...)
Rules: NIL
Hint-events: ((:CLAUSE-PROCESSOR PROOF-BUILDER-CL-PROC))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)

Proof succeeded.
ACL2 !&gt;</pre> 
 
 <p>Finally we present an even more contrived example, based on the one above. 
 This example illustrates that there is actually no limit imposed on the 
 nesting of <span class="v">:instructions</span> within <span class="v">:</span><span class="tt"><a href="ACL2____HINTS.html">hints</a></span> within 
 <span class="v">:instructions</span>, and so on.  Notice the indication of nesting levels: 
 ``<span class="v">1&gt;</span>'' to ``<span class="v">&lt;1</span>'' for output from nesting level 1, and ``<span class="v">2&gt;</span>'' to 
 ``<span class="v">&lt;2</span>'' for output from nesting level 2.</p> 
 
 <pre class="code">(<a href="ACL2____THM.html">thm</a> (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> x)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____REVERSE.html">reverse</a> (<a href="COMMON-LISP____REVERSE.html">reverse</a> x)) x))
     :hints (("Goal"
              :instructions
              ((<a href="ACL2____COMMENT.html">comment</a> inhibit-output-lst :same)
               (:prove
                :hints (("Goal" :in-theory (<a href="ACL2____DISABLE.html">disable</a> append))
                        ("Subgoal *1/3''"
                         :instructions
                         ((<a href="ACL2____COMMENT.html">comment</a> inhibit-output-lst :same)
                          :bash
                          (:dv 1)
                          (:rewrite revappend-revappend)))))))))</pre> 
 
 <p>Here is an edited version of the resulting log.</p> 
 
 <pre class="code">[Note:  A hint was supplied for our processing of the goal above.
Thanks!]

[[1&gt; Executing proof-builder instructions]]

-&gt;: (<a href="ACL2____COMMENT.html">COMMENT</a> INHIBIT-OUTPUT-LST :SAME)
-&gt;: (:PROVE
         :HINTS
         (("Goal" :IN-THEORY (<a href="ACL2____DISABLE.html">DISABLE</a> APPEND))
          ("Subgoal *1/3''" :INSTRUCTIONS ((<a href="ACL2____COMMENT.html">COMMENT</a> INHIBIT-OUTPUT-LST :SAME)
                                           :BASH (:DV 1)
                                           (:REWRITE REVAPPEND-REVAPPEND)))))
***** Now entering the theorem prover *****

[[ ... output omitted ... ]]

[Note:  A hint was supplied for our processing of the goal below.
Thanks!]

Subgoal *1/3''
(<a href="ACL2____IMPLIES.html">IMPLIES</a> (<a href="COMMON-LISP____AND.html">AND</a> (<a href="COMMON-LISP____CONSP.html">CONSP</a> X)
              (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="COMMON-LISP____REVAPPEND.html">REVAPPEND</a> (<a href="COMMON-LISP____REVAPPEND.html">REVAPPEND</a> (<a href="COMMON-LISP____CDR.html">CDR</a> X) NIL) NIL)
                     (<a href="COMMON-LISP____CDR.html">CDR</a> X))
              (<a href="ACL2____TRUE-LISTP.html">TRUE-LISTP</a> (<a href="COMMON-LISP____CDR.html">CDR</a> X)))
         (<a href="COMMON-LISP____EQUAL.html">EQUAL</a> (<a href="COMMON-LISP____REVAPPEND.html">REVAPPEND</a> (<a href="COMMON-LISP____REVAPPEND.html">REVAPPEND</a> (<a href="COMMON-LISP____CDR.html">CDR</a> X) (<a href="COMMON-LISP____LIST.html">LIST</a> (<a href="COMMON-LISP____CAR.html">CAR</a> X)))
                           NIL)
                X)).

[[2&gt; Executing proof-builder instructions]]

-&gt;: (<a href="ACL2____COMMENT.html">COMMENT</a> INHIBIT-OUTPUT-LST :SAME)
-&gt;: :BASH
***** Now entering the theorem prover *****

[Note:  A hint was supplied for our processing of the goal above.
Thanks!]

But we have been asked to pretend that this goal is subsumed by the
yet-to-be-proved |PROOF-BUILDER Goal|.

Q.E.D.

Creating one new goal:  (MAIN . 1).

The proof of the current goal, MAIN, has been completed.  However,
the following subgoals remain to be proved:
  (MAIN . 1).
Now proving (MAIN . 1).
-&gt;: (:DV 1)
-&gt;: (:REWRITE REVAPPEND-REVAPPEND)
Rewriting with REVAPPEND-REVAPPEND.

[[&lt;2 Completed proof-builder instructions]]

We now apply the trusted :CLAUSE-PROCESSOR function PROOF-BUILDER-CL-PROC
to produce one new subgoal.

Subgoal *1/3'''

[[ ... output omitted ... ]]

[[&lt;1 Completed proof-builder instructions]]</pre> 
 
 <p>The nesting levels are independent of whether or not output is enabled; for 
 example, if the first <span class="v">(<a href="ACL2____COMMENT.html">comment</a> ...)</span> form below is omitted, then we will 
 see only the output bracketed by ``<span class="v">2&gt;</span>'' to ``<span class="v">&lt;2</span>''.  Note also that 
 these levels are part of the error states saved for access by <span class="tt"><a href="ACL2____RETRIEVE.html">retrieve</a></span> 
 (as indicated above); for example, a failure at level 1 would be associated 
 with symbol <span class="v">:ERROR1</span> as indicated above, while a failure at level 2 would 
 be associated with symbol <span class="v">:ERROR2</span>.</p>
</body>
</html>
