<html>
<head>
<meta charset="UTF-8">
<title>Check-safe-path</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=YUL____CHECK-SAFE-PATH">Click for Check-safe-path in the Full Manual</a></h3>

<p>Check if a path is safe.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(check-safe-path path varset) → _</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">path</span> — <font color="#606060">Guard <span class="v">(<a href="YUL____PATHP.html">pathp</a> path)</span>.</font>
</dd> 
  <dd>
<span class="tt">varset</span> — <font color="#606060">Guard <span class="v">(<a href="YUL____IDENTIFIER-SETP.html">identifier-setp</a> varset)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">_</span> — <font color="#606060">Type <span class="v">(<a href="FTY____RESULTERR-OPTIONP.html">resulterr-optionp</a> _)</span>.</font>
</dd> 
 
</dl></div> 
<p>As a structural condition, 
     a path must consists of one or more identifiers. 
     More importantly, it must refer to an existing variable. 
     It is not yet clear how paths with more than one identifier 
     come about in generic Yul: 
     variable declarations are for single identifiers 
     (whether one single identifier, 
     or two or more single identifiers), 
     so it seems that singleton paths would always suffice to reference them 
     in expressions and statements. 
     For now we only regard singleton paths as safe, 
     provided they are part of the accessible variables.</p><p>We may move the non-emptiness requirement 
     into an invariant of <span class="tt"><a href="YUL____PATH.html">path</a></span>, 
     but for now we state it as part of the static semantics.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>check-safe-path</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> check-safe-path (<a href="YUL____PATH.html">path</a> varset)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="YUL____PATHP.html">pathp</a> path)
                                   (<a href="YUL____IDENTIFIER-SETP.html">identifier-setp</a> varset))))
       (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'check-safe-path))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
            (<a href="ACL2____B_A2.html">b*</a> ((idens (<a href="YUL____PATH-_E3GET.html">path-&gt;get</a> path))
                 ((unless (<a href="COMMON-LISP____CONSP.html">consp</a> idens))
                  (<a href="FTY____ERR.html">err</a> (<a href="COMMON-LISP____LIST.html">list</a> :empty-path (<a href="YUL____PATH-FIX.html">path-fix</a> path))))
                 ((unless (<a href="COMMON-LISP____ENDP.html">endp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> idens)))
                  (<a href="FTY____ERR.html">err</a> (<a href="COMMON-LISP____LIST.html">list</a> :non-singleton-path (<a href="YUL____PATH-FIX.html">path-fix</a> path))))
                 (var (<a href="COMMON-LISP____CAR.html">car</a> idens))
                 ((unless (<a href="YUL____CHECK-VAR.html">check-var</a> var varset))
                  (<a href="FTY____ERR.html">err</a> (<a href="COMMON-LISP____LIST.html">list</a> :variable-not-found var))))
                nil)))</pre> 
<p><b>Theorem: </b>resulterr-optionp-of-check-safe-path</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> resulterr-optionp-of-check-safe-path
        (<a href="ACL2____B_A2.html">b*</a> ((_ (<a href="YUL____CHECK-SAFE-PATH.html">check-safe-path</a> path varset)))
            (<a href="FTY____RESULTERR-OPTIONP.html">resulterr-optionp</a> _))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>check-safe-path-of-path-fix-path</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> check-safe-path-of-path-fix-path
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="YUL____CHECK-SAFE-PATH.html">check-safe-path</a> (<a href="YUL____PATH-FIX.html">path-fix</a> path) varset)
               (<a href="YUL____CHECK-SAFE-PATH.html">check-safe-path</a> path varset)))</pre> 
<p><b>Theorem: </b>check-safe-path-path-equiv-congruence-on-path</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> check-safe-path-path-equiv-congruence-on-path
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="YUL____PATH-EQUIV.html">path-equiv</a> path path-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="YUL____CHECK-SAFE-PATH.html">check-safe-path</a> path varset)
                        (<a href="YUL____CHECK-SAFE-PATH.html">check-safe-path</a> path-equiv varset)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>check-safe-path-of-identifier-set-fix-varset</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> check-safe-path-of-identifier-set-fix-varset
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="YUL____CHECK-SAFE-PATH.html">check-safe-path</a> path (<a href="YUL____IDENTIFIER-SET-FIX.html">identifier-set-fix</a> varset))
               (<a href="YUL____CHECK-SAFE-PATH.html">check-safe-path</a> path varset)))</pre> 
<p><b>Theorem: </b>check-safe-path-identifier-set-equiv-congruence-on-varset</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> check-safe-path-identifier-set-equiv-congruence-on-varset
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="YUL____IDENTIFIER-SET-EQUIV.html">identifier-set-equiv</a> varset varset-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="YUL____CHECK-SAFE-PATH.html">check-safe-path</a> path varset)
                        (<a href="YUL____CHECK-SAFE-PATH.html">check-safe-path</a> path varset-equiv)))
        :rule-classes :congruence)</pre> 

</body>
</html>
