<html>
<head>
<meta charset="UTF-8">
<title>Mmp-encode-c-max</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ETHEREUM____MMP-ENCODE-C-MAX">Click for Mmp-encode-c-max in the Full Manual</a></h3>

<p>Value of the maximum operator 
          in the second case of the definition of c [YP:(194)].</p><p>This is used in the definition of <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C.html">mmp-encode-c</a></span>, 
     hence the name.</p><p>The x in the set being maximized is a natural number, 
     because it is equated to a length. 
     Therefore, we use <span class="tt"><a href="ACL2____DEFMAX-NAT.html">defmax-nat</a></span> to introduce this maximum.</p><p>This maximum always exists if the map is not empty. 
     We can establish this by showing that:</p><ol>
<li>The set \{x\mid\ldots\} being maximized is never empty 
      because 0 is always in the set. 
      This is expressed by theorem <span class="v">mmp-encode-c-max-set-nonempty</span> below, 
      which does not actually need the map to be non-empty.</li>
<li>The elements of the set cannot exceed 
      the maximum length of the keys of the map, 
      which is returned by <span class="tt"><a href="ETHEREUM____NIBBLELIST-BYTELIST-MAP-SUP-LEN-KEY.html">nibblelist-bytelist-map-sup-len-key</a></span>. 
      This is expressed by theorem <span class="v">mmp-encode-c-max-set-bounded</span> below. 
      The reason why this theorem holds is that 
      the elements of the set are 
      the <span class="v">x</span>s that are lengths of prefixes of the keys in the map, 
      which are therefore no larger than the lengths of the whole keys, 
      which are no larger than their maximum. 
      Here the non-emptiness of the map is needed: 
      without it, <span class="v">x</span> could be arbitrarily large 
      because there would be no keys to take the prefix of, 
      <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C-FORALL.html">mmp-encode-c-forall</a></span> would be trivially true, 
      <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C-EXISTS.html">mmp-encode-c-exists</a></span> would be also true because 
      there is always an <span class="v">l</span> of any length. 
      Concretely, in the proof of the theorem, 
      we need to instantiate the <span class="v">key</span> variable 
      in both the linear rule of <span class="tt"><a href="ETHEREUM____NIBBLELIST-BYTELIST-MAP-SUP-LEN-KEY.html">nibblelist-bytelist-map-sup-len-key</a></span> 
      and the inequality theorem about <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C-EXISTS.html">mmp-encode-c-exists</a></span>, 
      which we do with the key returned by <span class="tt"><a href="OMAP____HEAD.html">omap::head</a></span>: 
      any other key in the map would have worked, 
      but the point is that the map must be non-empty for a key to exist.</li>
</ol><p>With these two theorems in hand, 
     we use a suitable instance of the helper theorem 
     <span class="v">mmp-encode-c-max.existsp-when-nonempty-and-bounded</span> 
     generated by <span class="tt"><a href="ACL2____DEFMAX-NAT.html">defmax-nat</a></span>, 
     whose proof uses the two theorems as rewrite rules.</p><p>Since <span class="tt"><a href="ETHEREUM____NIBBLELIST-BYTELIST-MAP-SUP-LEN-KEY.html">nibblelist-bytelist-map-sup-len-key</a></span> is an upper bound, 
     it is greater than or equal to <span class="tt"><a href="ETHEREUM____MMP-ENCODE-C-MAX.html">mmp-encode-c-max</a></span> 
     and any element in the set. 
     This is expressed by two additional linear rules below, 
     whose hypotheses match the ones under which 
     <span class="tt"><a href="ETHEREUM____NIBBLELIST-BYTELIST-MAP-SUP-LEN-KEY.html">nibblelist-bytelist-map-sup-len-key</a></span> is an upper bound.</p><p>When the map has two or more keys, 
     <span class="tt"><a href="ETHEREUM____NIBBLELIST-BYTELIST-MAP-SUP-LEN-KEY.html">nibblelist-bytelist-map-sup-len-key</a></span> is a strict upper bound, 
     i.e. it is not equal to any element in the set. 
     This is proved below by taking the first two keys in the map, 
     called <span class="v">key1</span> and <span class="v">key2</span> in the lemmas, 
     and showing that:</p><ol>
<li>The two keys differ, because they are strictly ordered in the map.</li>
<li>If <span class="tt"><a href="ETHEREUM____NIBBLELIST-BYTELIST-MAP-SUP-LEN-KEY.html">nibblelist-bytelist-map-sup-len-key</a></span> were an element of the set, 
      then the two keys would have the same prefix, 
      of length <span class="tt"><a href="ETHEREUM____NIBBLELIST-BYTELIST-MAP-SUP-LEN-KEY.html">nibblelist-bytelist-map-sup-len-key</a></span>.</li>
<li>
<span class="tt"><a href="ETHEREUM____NIBBLELIST-BYTELIST-MAP-SUP-LEN-KEY.html">nibblelist-bytelist-map-sup-len-key</a></span> is an upper bound 
      of the lengths of the keys, 
      by its definition.</li>
<li>If <span class="tt"><a href="ETHEREUM____NIBBLELIST-BYTELIST-MAP-SUP-LEN-KEY.html">nibblelist-bytelist-map-sup-len-key</a></span> were an element of the set, 
      then it would also be an upper bound of the lengths of the keys, 
      by the definition of the set.</li>
<li>If <span class="tt"><a href="ETHEREUM____NIBBLELIST-BYTELIST-MAP-SUP-LEN-KEY.html">nibblelist-bytelist-map-sup-len-key</a></span> were an element of the set, 
      then by (2), (3), and (4) above it would be the length of both keys 
      and thus the two keys would be equal. 
      But this contradicts (1) above, 
      and thus <span class="tt"><a href="ETHEREUM____NIBBLELIST-BYTELIST-MAP-SUP-LEN-KEY.html">nibblelist-bytelist-map-sup-len-key</a></span> must differ 
      from any element <span class="v">i</span> of the set.</li>
</ol><p>Every element of the set, including the maximum if it exists, 
     is less than or equal to the length of every key in the map.</p><p>If the map is empty, 
     then all the natural numbers are in the set.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>mmp-encode-c-max.elementp</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> mmp-encode-c-max.elementp (map x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MAPP.html">nibblelist-bytelist-mapp</a> map)
                                   (<a href="ACL2____NATP.html">natp</a> x))))
       (<a href="ETHEREUM____MMP-ENCODE-C-EXISTS.html">mmp-encode-c-exists</a> map x))</pre> 
<p><b>Theorem: </b>mmp-encode-c-max.uboundp-necc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-c-max.uboundp-necc
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (mmp-encode-c-max.uboundp map x)
                      (<a href="ACL2____NATP.html">natp</a> x1)
                      (mmp-encode-c-max.elementp map x1))
                 (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> (<a href="ACL2____NFIX.html">nfix</a> x) x1)))</pre> 
<p><b>Theorem: </b>booleanp-ofmmp-encode-c-max.uboundp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> booleanp-ofmmp-encode-c-max.uboundp
        (<a href="ACL2____BOOLEANP.html">booleanp</a> (mmp-encode-c-max.uboundp map x)))</pre> 
<p><b>Theorem: </b>mmp-encode-c-max.existsp-suff</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-c-max.existsp-suff
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> x)
                      (mmp-encode-c-max.elementp map x)
                      (mmp-encode-c-max.uboundp map x))
                 (mmp-encode-c-max.existsp map)))</pre> 
<p><b>Theorem: </b>booleanp-ofmmp-encode-c-max.existsp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> booleanp-ofmmp-encode-c-max.existsp
        (<a href="ACL2____BOOLEANP.html">booleanp</a> (mmp-encode-c-max.existsp map)))</pre> 
<p><b>Function: </b>mmp-encode-c-max</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> mmp-encode-c-max (map)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MAPP.html">nibblelist-bytelist-mapp</a> map)))
       (<a href="COMMON-LISP____IF.html">if</a> (mmp-encode-c-max.existsp map)
           (mmp-encode-c-max.existsp-witness map)
           nil))</pre> 
<p><b>Theorem: </b>maybe-natp-of-mmp-encode-c-max</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> maybe-natp-of-mmp-encode-c-max
        (<a href="ACL2____MAYBE-NATP.html">acl2::maybe-natp</a> (<a href="ETHEREUM____MMP-ENCODE-C-MAX.html">mmp-encode-c-max</a> map)))</pre> 
<p><b>Theorem: </b>natp-of-mmp-encode-c-max-equal-mmp-encode-c-max.existsp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> natp-of-mmp-encode-c-max-equal-mmp-encode-c-max.existsp
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____NATP.html">natp</a> (<a href="ETHEREUM____MMP-ENCODE-C-MAX.html">mmp-encode-c-max</a> map))
               (mmp-encode-c-max.existsp map)))</pre> 
<p><b>Theorem: </b>natp-of-mmp-encode-c-max-when-mmp-encode-c-max.existsp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> natp-of-mmp-encode-c-max-when-mmp-encode-c-max.existsp
        (<a href="ACL2____IMPLIES.html">implies</a> (mmp-encode-c-max.existsp map)
                 (<a href="ACL2____NATP.html">natp</a> (<a href="ETHEREUM____MMP-ENCODE-C-MAX.html">mmp-encode-c-max</a> map)))
        :rule-classes :type-prescription)</pre> 
<p><b>Theorem: </b>mmp-encode-c-max-iff-mmp-encode-c-max.existsp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-c-max-iff-mmp-encode-c-max.existsp
        (<a href="ACL2____IFF.html">iff</a> (<a href="ETHEREUM____MMP-ENCODE-C-MAX.html">mmp-encode-c-max</a> map)
             (mmp-encode-c-max.existsp map)))</pre> 
<p><b>Theorem: </b>not-mmp-encode-c-max-when-not-mmp-encode-c-max.existsp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> not-mmp-encode-c-max-when-not-mmp-encode-c-max.existsp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (mmp-encode-c-max.existsp map))
                 (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ETHEREUM____MMP-ENCODE-C-MAX.html">mmp-encode-c-max</a> map)))
        :rule-classes :type-prescription)</pre> 
<p><b>Theorem: </b>mmp-encode-c-max.elementp-of-mmp-encode-c-max-when-mmp-encode-c-max.existsp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 mmp-encode-c-max.elementp-of-mmp-encode-c-max-when-mmp-encode-c-max.existsp
 (<a href="ACL2____IMPLIES.html">implies</a> (mmp-encode-c-max.existsp map)
          (mmp-encode-c-max.elementp map (<a href="ETHEREUM____MMP-ENCODE-C-MAX.html">mmp-encode-c-max</a> map))))</pre> 
<p><b>Theorem: </b>mmp-encode-c-max.uboundp-of-mmp-encode-c-max-when-existsp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    mmp-encode-c-max.uboundp-of-mmp-encode-c-max-when-existsp
    (<a href="ACL2____IMPLIES.html">implies</a> (mmp-encode-c-max.existsp map)
             (mmp-encode-c-max.uboundp map (<a href="ETHEREUM____MMP-ENCODE-C-MAX.html">mmp-encode-c-max</a> map))))</pre> 
<p><b>Theorem: </b>mmp-encode-c-max-geq-when-mmp-encode-c-max.existsp-linear</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-c-max-geq-when-mmp-encode-c-max.existsp-linear
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (mmp-encode-c-max.existsp map)
                      (mmp-encode-c-max.elementp map x1)
                      (<a href="ACL2____NATP.html">natp</a> x1))
                 (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> (<a href="ETHEREUM____MMP-ENCODE-C-MAX.html">mmp-encode-c-max</a> map) x1))
        :rule-classes :linear)</pre> 
<p><b>Theorem: </b>mmp-encode-c-max-geq-when-mmp-encode-c-max.existsp-rewrite</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-c-max-geq-when-mmp-encode-c-max.existsp-rewrite
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (mmp-encode-c-max.existsp map)
                      (mmp-encode-c-max.elementp map x1)
                      (<a href="ACL2____NATP.html">natp</a> x1))
                 (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> (<a href="ETHEREUM____MMP-ENCODE-C-MAX.html">mmp-encode-c-max</a> map) x1)))</pre> 
<p><b>Theorem: </b>mmp-encode-c-max-leq-when-mmp-encode-c-max.existsp-linear</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-c-max-leq-when-mmp-encode-c-max.existsp-linear
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (mmp-encode-c-max.existsp map)
                      (mmp-encode-c-max.uboundp map x1)
                      (<a href="ACL2____NATP.html">natp</a> x1))
                 (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ETHEREUM____MMP-ENCODE-C-MAX.html">mmp-encode-c-max</a> map) x1))
        :rule-classes :linear)</pre> 
<p><b>Theorem: </b>mmp-encode-c-max-leq-when-mmp-encode-c-max.existsp-rewrite</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-c-max-leq-when-mmp-encode-c-max.existsp-rewrite
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (mmp-encode-c-max.existsp map)
                      (mmp-encode-c-max.uboundp map x1)
                      (<a href="ACL2____NATP.html">natp</a> x1))
                 (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ETHEREUM____MMP-ENCODE-C-MAX.html">mmp-encode-c-max</a> map) x1)))</pre> 
<p><b>Theorem: </b>mmp-encode-c-max.existsp-when-nonempty-and-bounded</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-c-max.existsp-when-nonempty-and-bounded
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> x0)
                      (mmp-encode-c-max.elementp map x0)
                      (<a href="ACL2____NATP.html">natp</a> x1)
                      (mmp-encode-c-max.uboundp map x1))
                 (mmp-encode-c-max.existsp map))
        :rule-classes nil)</pre> 
<p><b>Theorem: </b>mmp-encode-c-max.equal-when-member-and-ubound</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-c-max.equal-when-member-and-ubound
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____NATP.html">natp</a> x)
                      (mmp-encode-c-max.elementp map x)
                      (mmp-encode-c-max.uboundp map x))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ETHEREUM____MMP-ENCODE-C-MAX.html">mmp-encode-c-max</a> map) x))
        :rule-classes nil)</pre> 
<p><b>Theorem: </b>mmp-encode-c-max.elementp-of-nibblelist-bytelist-mfix-map</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    mmp-encode-c-max.elementp-of-nibblelist-bytelist-mfix-map
    (<a href="COMMON-LISP____EQUAL.html">equal</a> (mmp-encode-c-max.elementp (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MFIX.html">nibblelist-bytelist-mfix</a> map)
                                      x)
           (mmp-encode-c-max.elementp map x)))</pre> 
<p><b>Theorem: </b>mmp-encode-c-max.elementp-nibblelist-bytelist-mequiv-congruence-on-map</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 mmp-encode-c-max.elementp-nibblelist-bytelist-mequiv-congruence-on-map
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MEQUIV.html">nibblelist-bytelist-mequiv</a> map map-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (mmp-encode-c-max.elementp map x)
                 (mmp-encode-c-max.elementp map-equiv x)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>mmp-encode-c-max.elementp-of-nfix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-c-max.elementp-of-nfix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (mmp-encode-c-max.elementp map (<a href="ACL2____NFIX.html">nfix</a> x))
               (mmp-encode-c-max.elementp map x)))</pre> 
<p><b>Theorem: </b>mmp-encode-c-max.elementp-nat-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-c-max.elementp-nat-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____NAT-EQUIV.html">acl2::nat-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (mmp-encode-c-max.elementp map x)
                        (mmp-encode-c-max.elementp map x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>mmp-encode-c-max.elementp-when-not-natp-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-c-max.elementp-when-not-natp-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SYNTAXP.html">syntaxp</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> x ''0)))
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____NATP.html">natp</a> x)))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (mmp-encode-c-max.elementp map x)
                        (mmp-encode-c-max.elementp map 0))))</pre> 
<p><b>Theorem: </b>mmp-encode-c-max.uboundp-of-nibblelist-bytelist-mfix-map</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     mmp-encode-c-max.uboundp-of-nibblelist-bytelist-mfix-map
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (mmp-encode-c-max.uboundp (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MFIX.html">nibblelist-bytelist-mfix</a> map)
                                      x)
            (mmp-encode-c-max.uboundp map x)))</pre> 
<p><b>Theorem: </b>mmp-encode-c-max.uboundp-nibblelist-bytelist-mequiv-congruence-on-map</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 mmp-encode-c-max.uboundp-nibblelist-bytelist-mequiv-congruence-on-map
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MEQUIV.html">nibblelist-bytelist-mequiv</a> map map-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (mmp-encode-c-max.uboundp map x)
                 (mmp-encode-c-max.uboundp map-equiv x)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>mmp-encode-c-max.uboundp-of-nfix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-c-max.uboundp-of-nfix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (mmp-encode-c-max.uboundp map (<a href="ACL2____NFIX.html">nfix</a> x))
               (mmp-encode-c-max.uboundp map x)))</pre> 
<p><b>Theorem: </b>mmp-encode-c-max.uboundp-nat-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-c-max.uboundp-nat-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____NAT-EQUIV.html">acl2::nat-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (mmp-encode-c-max.uboundp map x)
                        (mmp-encode-c-max.uboundp map x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>mmp-encode-c-max.existsp-of-nibblelist-bytelist-mfix-map</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    mmp-encode-c-max.existsp-of-nibblelist-bytelist-mfix-map
    (<a href="COMMON-LISP____EQUAL.html">equal</a> (mmp-encode-c-max.existsp (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MFIX.html">nibblelist-bytelist-mfix</a> map))
           (mmp-encode-c-max.existsp map)))</pre> 
<p><b>Theorem: </b>mmp-encode-c-max.existsp-nibblelist-bytelist-mequiv-congruence-on-map</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 mmp-encode-c-max.existsp-nibblelist-bytelist-mequiv-congruence-on-map
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MEQUIV.html">nibblelist-bytelist-mequiv</a> map map-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (mmp-encode-c-max.existsp map)
                 (mmp-encode-c-max.existsp map-equiv)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>mmp-encode-c-max-set-nonempty</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-c-max-set-nonempty
        (mmp-encode-c-max.elementp map 0))</pre> 
<p><b>Theorem: </b>mmp-encode-c-max-set-bounded</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-c-max-set-bounded
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MAPP.html">nibblelist-bytelist-mapp</a> map)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="OMAP____EMPTY.html">omap::empty</a> map)))
                 (mmp-encode-c-max.uboundp
                      map
                      (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MAP-SUP-LEN-KEY.html">nibblelist-bytelist-map-sup-len-key</a> map))))</pre> 
<p><b>Theorem: </b>mmp-encode-c-max-exists</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-c-max-exists
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MAPP.html">nibblelist-bytelist-mapp</a> map)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="OMAP____EMPTY.html">omap::empty</a> map)))
                 (mmp-encode-c-max.existsp map)))</pre> 
<p><b>Theorem: </b>nibblelist-bytelist-map-sup-len-key-geq-mmp-encode-c-max</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nibblelist-bytelist-map-sup-len-key-geq-mmp-encode-c-max
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MAPP.html">nibblelist-bytelist-mapp</a> map)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="OMAP____EMPTY.html">omap::empty</a> map)))
                 (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MAP-SUP-LEN-KEY.html">nibblelist-bytelist-map-sup-len-key</a> map)
                     (<a href="ETHEREUM____MMP-ENCODE-C-MAX.html">mmp-encode-c-max</a> map)))
        :rule-classes :linear)</pre> 
<p><b>Theorem: </b>nibblelist-bytelist-map-sup-len-key-geq-element</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nibblelist-bytelist-map-sup-len-key-geq-element
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MAPP.html">nibblelist-bytelist-mapp</a> map)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="OMAP____EMPTY.html">omap::empty</a> map))
                      (mmp-encode-c-max.elementp map x))
                 (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MAP-SUP-LEN-KEY.html">nibblelist-bytelist-map-sup-len-key</a> map)
                     (<a href="ACL2____NFIX.html">nfix</a> x)))
        :rule-classes :linear)</pre> 
<p><b>Theorem: </b>nibblelist-bytelist-map-sup-len-key-neq-element-when-2+-keys</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     nibblelist-bytelist-map-sup-len-key-neq-element-when-2+-keys
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MAPP.html">nibblelist-bytelist-mapp</a> map)
                   (<a href="COMMON-LISP____NOT.html">not</a> (<a href="OMAP____EMPTY.html">omap::empty</a> map))
                   (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="OMAP____SIZE.html">omap::size</a> map) 1))
                   (<a href="ACL2____NATP.html">natp</a> x)
                   (mmp-encode-c-max.elementp map x))
              (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MAP-SUP-LEN-KEY.html">nibblelist-bytelist-map-sup-len-key</a> map)
                          x))))</pre> 
<p><b>Theorem: </b>mmp-encode-c-max-element-leq-len-key</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     mmp-encode-c-max-element-leq-len-key
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MAPP.html">nibblelist-bytelist-mapp</a> map)
                   (<a href="ACL2____NATP.html">natp</a> x)
                   (mmp-encode-c-max.elementp map x)
                   (<a href="OMAP____IN.html">omap::in</a> key map))
              (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> x (<a href="ACL2____LEN.html">len</a> key)))
     :rule-classes
     ((:linear :trigger-terms ((mmp-encode-c-max.elementp map x)))))</pre> 
<p><b>Theorem: </b>mmp-encode-c-max-leq-len-key</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  mmp-encode-c-max-leq-len-key
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MAPP.html">nibblelist-bytelist-mapp</a> map)
                (<a href="COMMON-LISP____NOT.html">not</a> (<a href="OMAP____EMPTY.html">omap::empty</a> map))
                (<a href="OMAP____IN.html">omap::in</a> key map))
           (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ETHEREUM____MMP-ENCODE-C-MAX.html">mmp-encode-c-max</a> map) (<a href="ACL2____LEN.html">len</a> key)))
  :rule-classes ((:linear :trigger-terms ((<a href="ETHEREUM____MMP-ENCODE-C-MAX.html">mmp-encode-c-max</a> map)))))</pre> 
<p><b>Theorem: </b>mmp-encode-c-max.elementp-of-empty-map</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> mmp-encode-c-max.elementp-of-empty-map
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ETHEREUM____NIBBLELIST-BYTELIST-MAPP.html">nibblelist-bytelist-mapp</a> map)
                      (<a href="OMAP____EMPTY.html">omap::empty</a> map))
                 (mmp-encode-c-max.elementp map x)))</pre> 

</body>
</html>
