<html>
<head>
<meta charset="UTF-8">
<title>Eval-hex-string-literal</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=YUL____EVAL-HEX-STRING-LITERAL">Click for Eval-hex-string-literal in the Full Manual</a></h3>

<p>Evaluate a hex string literal to a value.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(eval-hex-string-literal hstring) → val</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">hstring</span> — <font color="#606060">Guard <span class="v">(<a href="YUL____HEX-STRINGP.html">hex-stringp</a> hstring)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">val</span> — <font color="#606060">Type <span class="v">(<a href="YUL____VALUE-RESULTP.html">value-resultp</a> val)</span>.</font>
</dd> 
 
</dl></div> 
<p>We convert the list of hex pairs to a list of bytes. 
     If the resulting bytes exceed 32 in number, it is an error. 
     Otherwise, we pad the list with zeros (bytes of value 0) 
     on the right to reach 32 bytes, 
     and we turn the resulting list of 32 bytes to a 256-bit word, 
     interpreting the bytes in big endian form, 
     i.e. the first byte contains the most significant bits of the word. 
     This evaluation is not described in detail in [Yul], 
     but it was explained via discussions on Gitter, 
     and [Yul] is being extended with these explanations.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>eval-hex-string-literal</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     eval-hex-string-literal (hstring)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="YUL____HEX-STRINGP.html">hex-stringp</a> hstring)))
     (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'eval-hex-string-literal))
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
          (<a href="ACL2____B_A2.html">b*</a> ((content (<a href="YUL____HEX-STRING-_E3CONTENT.html">hex-string-&gt;content</a> hstring))
               (bytes (<a href="YUL____EVAL-HEX-PAIR-LIST.html">eval-hex-pair-list</a> content))
               ((unless (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____LEN.html">len</a> bytes) 32))
                (<a href="FTY____ERR.html">err</a> (<a href="COMMON-LISP____LIST.html">list</a> :hex-string-too-long bytes)))
               (bytes (<a href="COMMON-LISP____APPEND.html">append</a> bytes (<a href="ACL2____REPEAT.html">repeat</a> (<a href="COMMON-LISP____-.html">-</a> 32 (<a href="ACL2____LEN.html">len</a> bytes)) 0))))
              (<a href="YUL____VALUE.html">value</a> (<a href="ACL2____BEBYTES_D3_E3NAT.html">acl2::bebytes=&gt;nat</a> bytes)))))</pre> 
<p><b>Theorem: </b>value-resultp-of-eval-hex-string-literal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> value-resultp-of-eval-hex-string-literal
        (<a href="ACL2____B_A2.html">b*</a> ((val (<a href="YUL____EVAL-HEX-STRING-LITERAL.html">eval-hex-string-literal</a> hstring)))
            (<a href="YUL____VALUE-RESULTP.html">value-resultp</a> val))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>error-info-wfp-of-eval-hex-string-literal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> error-info-wfp-of-eval-hex-string-literal
        (<a href="ACL2____B_A2.html">b*</a> ((?val (<a href="YUL____EVAL-HEX-STRING-LITERAL.html">eval-hex-string-literal</a> hstring)))
            (<a href="ACL2____IMPLIES.html">implies</a> (<a href="FTY____RESULTERRP.html">resulterrp</a> val)
                     (<a href="YUL____ERROR-INFO-WFP.html">error-info-wfp</a> val))))</pre> 
<p><b>Theorem: </b>eval-hex-string-literal-of-hex-string-fix-hstring</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> eval-hex-string-literal-of-hex-string-fix-hstring
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="YUL____EVAL-HEX-STRING-LITERAL.html">eval-hex-string-literal</a> (<a href="YUL____HEX-STRING-FIX.html">hex-string-fix</a> hstring))
               (<a href="YUL____EVAL-HEX-STRING-LITERAL.html">eval-hex-string-literal</a> hstring)))</pre> 
<p><b>Theorem: </b>eval-hex-string-literal-hex-string-equiv-congruence-on-hstring</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     eval-hex-string-literal-hex-string-equiv-congruence-on-hstring
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="YUL____HEX-STRING-EQUIV.html">hex-string-equiv</a> hstring hstring-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="YUL____EVAL-HEX-STRING-LITERAL.html">eval-hex-string-literal</a> hstring)
                     (<a href="YUL____EVAL-HEX-STRING-LITERAL.html">eval-hex-string-literal</a> hstring-equiv)))
     :rule-classes :congruence)</pre> 

</body>
</html>
