<html>
<head>
<meta charset="UTF-8">
<title>Further-information-on-rewriting</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____FURTHER-INFORMATION-ON-REWRITING">Click for Further-information-on-rewriting in the Full Manual</a></h3>

<p>A grab bag of advice and information on rewriting</p><p>In the following paragraphs we give some links to advanced topics, 
 marked with ``<a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a>''.  If you are reading this topic as part of the 
 tutorial on the theorem prover, do not follow these links upon your first 
 reading.  Just take note of the existence of the facilities and ideas 
 mentioned.</p> 
 
 <p><a href="ACL2____ARITHMETIC.html">Arithmetic</a>: If your goal theorem involves even trivial arithmetic, 
 such as adding or subtracting <span class="v">1</span>, we recommend that you do</p> 
 
 <pre class="code">(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "arithmetic/top-with-meta" :dir :system)</pre> 
 
 <p>which loads into ACL2 all the rules in one of the so-called ACL2 
 ``community books''.  (<i>Books</i> are certified files of definitions, 
 lemmas, etc., usually prepared by other ACL2 users and explicitly shared with 
 the community.  The ACL2 installation instructions suggest downloading the 
 community books.)  The book "top-with-meta" is the most elementary and most 
 widely used arithmetic book.  Other community books include 
 "arithmetic-5/top" and various hardware and floating-point arithmetic books; 
 if including "arithmetic/top-with-meta" isn't sufficient, you could try 
 <span class="v">(<a href="ACL2____INCLUDE-BOOK.html">include-book</a> "arithmetic-5/top" :dir :system)</span>.</p> 
 
 <p><b>Rules Concluding with Arithmetic Inequalities</b>: If you are tempted to 
 create a rewrite rule with an arithmetic inequality as its conclusion or 
 left-hand side, think again.  Inequalities such as</p> 
 
 <pre class="code">(<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____LEN.html">len</a> (delete e x)) (<a href="ACL2____LEN.html">len</a> x))</pre> 
 
 <p>make poor left-hand sides for rewrite rules.  For example, the inequality 
 above does not match the target</p> 
 
 <pre class="code">(<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____LEN.html">LEN</a> (DELETE E X)) (<a href="COMMON-LISP_____B2.html">+</a> 1 (<a href="ACL2____LEN.html">LEN</a> X)))</pre> 
 
 <p>even though it is sufficient to prove the target (given some simple 
 arithmetic).  We recommend that if you have a theorem that establishes an 
 arithmetic inequality, you make it a <i>linear</i> rule.  See <a href="ACL2____LINEAR.html">linear</a> 
 <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a>.</p> 
 
 <p><b>Rearranging Formulas Before Making Rules</b>: It is possible to 
 rearrange the propositional structure of a proved formula before processing it 
 as a rule.  This allows you to state a theorem one way ``for publication'' and 
 rearrange it to be stored as a more effective rule.  See <a href="ACL2____INTRODUCTION-TO-THE-DATABASE.html">introduction-to-the-database</a> (a tutorial topic you'll come to later) and its 
 discussion of the concept of <span class="v">corollary</span>.  Also, see the discussion of 
 <span class="v">corollary</span> in <span class="tt"><a href="ACL2____RULE-CLASSES.html">rule-classes</a></span> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a>.</p> 
 
 <p><b>Rewriting with New Equivalence Relations</b>: You may introduce new 
 <i>equivalence</i> relations, like ``set-equal'' or ``is-a-permutation'' and 
 cause the rewriter to replace equivalents by equivalents in suitable contexts, 
 where you use <i>congruence</i> rules to inform ACL2 of where these more 
 relaxed notions of equivalence may be used; see <a href="ACL2____EQUIVALENCE.html">equivalence</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a> and 
 see <a href="ACL2____CONGRUENCE.html">congruence</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a>.</p> 
 
 <p><b>Pragmatic Advice to Control Rules</b>: You may attach various 
 <i>pragmas</i> to a rule that allow you rather fine heuristic control over 
 whether and how the rule is applied.  For example, you may mark a hypothesis 
 to be <i>forced</i> (see <a href="ACL2____FORCE.html">force</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a>) 
 meaning that the rule is to be applied even if that hypothesis is not relieved 
 â€” but if the proof is successful the system will turn its attention to 
 all forced subgoals.  You may similarly mark a hypothesis so as to cause a 
 case split, allowing the relief of the hypothesis on one branch and spawning 
 another branch explicitly denying the hypothesis; see <a href="ACL2____CASE-SPLIT.html">case-split</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a>. 
 You may add a bogus hypothesis that looks at the intended application of the 
 rule and decides whether to apply the rule or not, performing an arbitrary 
 computation on the syntactic context of the application; see <a href="ACL2____SYNTAXP.html">syntaxp</a> 
 <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a>.  By providing a <span class="v">:match-free</span> modifier to the 
 <span class="v">:rewrite</span> rule declaration in your rule-classes, you may tell ACL2 to try 
 all or only the first free variable value it guesses (see <a href="ACL2____RULE-CLASSES.html">rule-classes</a> 
 <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a>).  You may provide a bogus hypothesis that computes 
 from the syntactic environment the values to guess for the free variables in a 
 rule; see <a href="ACL2____BIND-FREE.html">bind-free</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a>. 
 You may mark a term so that the rewriter does not dive into it; see <a href="ACL2____HIDE.html">hide</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a>.</p> 
 
 <p><b>Programming Your Own Rewriter</b>: If you cannot find a way to use 
 rewrite rules to make the transformations you desire, you might investigate 
 the use of <i>metafunctions</i>.  A metafunction is just a little theorem 
 prover of your own design.  It takes as input a list structure representing a 
 term and returns a list structure representing a term.  If you can prove that 
 the meaning of the input and output terms are equivalent, you can extend the 
 ACL2 simplifier to call your metafunction.  See <a href="ACL2____META.html">meta</a> <a href="ACL2____A_02Tiny_02Warning_02Sign.html"><img src="../res/tours/twarning.gif"></a>.</p> 
 
 <p><b>The Order in which Targets are Rewritten</b>: The rewriter sweeps 
 through terms ``inside-out'' otherwise known as ``left-most innermost first''. 
 Thus, before trying to apply rewrite rules to <span class="v">(</span><i>f a1 ... an</i><span class="v">)</span>, 
 rules are applied to the <i>ai</i>.  This has the good effect of normalizing 
 the <i>ai</i>.</p> 
 
 <p>This fact might help you understand why sometimes your rules ``don't seem 
 to fire.''  For example, suppose you have a rule for rewriting <span class="v">(<a href="ACL2____LEN.html">len</a> (<a href="ACL2____REV.html">rev</a>
 x))</span> to <span class="v">(<a href="ACL2____LEN.html">len</a> x)</span> and suppose you wish to prove a theorem about <span class="v">(<a href="ACL2____LEN.html">LEN</a>
 (<a href="ACL2____REV.html">REV</a> (<a href="COMMON-LISP____CONS.html">CONS</a> A B)))</span>.  Suppose <span class="v">rev</span> is defined in terms of <span class="v">append</span>, as 
 shown in <a href="ACL2____PROGRAMMING-KNOWLEDGE-TAKEN-FOR-GRANTED.html">programming-knowledge-taken-for-granted</a>.  Then you might see a 
 checkpoint in which the <span class="v">(<a href="ACL2____LEN.html">LEN</a> (<a href="ACL2____REV.html">REV</a> ...))</span> above has been simplified to 
 <span class="v">(<a href="ACL2____LEN.html">LEN</a> (<a href="COMMON-LISP____APPEND.html">APPEND</a> (<a href="ACL2____REV.html">REV</a> B) (<a href="COMMON-LISP____LIST.html">LIST</a> A)))</span> instead of to <span class="v">(<a href="ACL2____LEN.html">LEN</a> (<a href="COMMON-LISP____CONS.html">CONS</a> A B))</span>.  Why 
 wasn't your rule about <span class="v">(<a href="ACL2____LEN.html">len</a> (<a href="ACL2____REV.html">rev</a> x))</span> applied?  The reason is that <span class="v">(<a href="ACL2____REV.html">REV</a>
 (<a href="COMMON-LISP____CONS.html">CONS</a> A B))</span> rewrote to <span class="v">(<a href="COMMON-LISP____APPEND.html">APPEND</a> (<a href="ACL2____REV.html">REV</a> B) (<a href="COMMON-LISP____LIST.html">LIST</a> A))</span> before rules were 
 applied to <span class="v">(<a href="ACL2____LEN.html">LEN</a> (<a href="ACL2____REV.html">REV</a> ...))</span>.  You need a rule about <span class="v">(<a href="ACL2____LEN.html">len</a> (<a href="COMMON-LISP____APPEND.html">append</a> x
 y))</span>, as you will see from the checkpoint.</p> 
 
 <p><b>The Order in which Rules are Tried</b>: The rewriter tries the most 
 recently proved rules first.  For example, suppose <span class="v">f</span>, <span class="v">g</span>, and <span class="v">h</span> 
 are functions defined so that the following two theorems are provable and 
 suppose you executed the following two events in the order shown:</p> 
 
 <pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> rule1 (<a href="COMMON-LISP____EQUAL.html">equal</a> (f (<a href="ACL2____G.html">g</a> x)) (h 1 x)))
(<a href="ACL2____DEFTHM.html">defthm</a> rule2 (<a href="COMMON-LISP____EQUAL.html">equal</a> (f (<a href="ACL2____G.html">g</a> x)) (h 2 X)))</pre> 
 
 <p>Then if rewrite rules are applied to <span class="v">(F (<a href="ACL2____G.html">G</a> A))</span>, the result will be 
 <span class="v">(H 2 A)</span>, because the latter rule, <span class="v">rule2</span>, is applied first.  It is 
 generally best not to have conflicting rules or, at least, to understand how 
 such conflicts are resolved.  The system will warn you when you propose a rule 
 that conflicts with an existing one.</p> 
 
 <p>If you were reading this topic as part of the tutorial introduction to the 
 theorem prover, use your browser's <b>Back Button</b> now to return to <a href="ACL2____INTRODUCTION-TO-REWRITE-RULES-PART-2.html">introduction-to-rewrite-rules-part-2</a>.</p>
</body>
</html>
