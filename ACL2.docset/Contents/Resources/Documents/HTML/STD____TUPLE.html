<html>
<head>
<meta charset="UTF-8">
<title>Tuple</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=STD____TUPLE">Click for Tuple in the Full Manual</a></h3>

<p>A way to use <span class="tt"><a href="ACL2____MV.html">mv</a></span>-like return specifiers for tuples.</p><p><a href="STD____RETURNS-SPECIFIERS.html">Return specifiers</a> support individual names and types (and hypothes, etc.) 
     for components of <span class="tt"><a href="ACL2____MV.html">mv</a></span> results. 
     However, when a function returns an <a href="ACL2____ERROR-TRIPLE.html">error triple</a> whose value (i.e. middle component) consists of multiple results, 
     given that the error triple already consists of multiple results 
     (three: the error, the value, and the state), 
     it is not possible to use the <span class="tt"><a href="ACL2____MV.html">mv</a></span> return specifier notation 
     for the value of the error triple.</p><p>So here we provide a macro, called <span class="v">tuple</span>, 
     to mimic the <span class="tt"><a href="ACL2____MV.html">mv</a></span> return specifier notation 
     for a single value, such as the middle component of an error triple.</p><p>The macro call</p><pre class="code">(<a href="STD____TUPLE.html">tuple</a> (var1 type1)
       ...
       (varn typen)
       x)</pre><p>where each <span class="v">vari</span> is a variable symbol, 
     each <span class="v">typei</span> is a predicate symbol or a term over <span class="v">vari</span>, 
     and <span class="v">x</span> is a variable symbol, 
     expands to</p><pre class="code">(<a href="COMMON-LISP____AND.html">and</a> (<a href="STD____TUPLEP.html">tuplep</a> n x)
     (<a href="ACL2____B_A2.html">b*</a> (((<a href="COMMON-LISP____LIST.html">list</a> var1 ... varn) x))
       (<a href="COMMON-LISP____AND.html">and</a> (type1 var1)
            ...
            (typen varn))))</pre><p>where each <span class="v">(typei vari)</span> is as shown if <span class="v">typei</span> is a symbol, 
     otherwise we use the term <span class="v">typei</span> instead.</p><p>This lets us write return specifiers of the form</p><pre class="code">:returns (<a href="ACL2____MV.html">mv</a> erp
             (val (<a href="STD____TUPLE.html">tuple</a> (var1 type1) ... (varn typen) val))
             state)</pre><p>where we can use the call <span class="v">(<a href="STD____TUPLE.html">tuple</a> ...)</span> as the type of <span class="v">val</span>, 
     so that the expansion will express that <span class="v">val</span> is an <span class="v">n</span>-tuple 
     whose components have the specified types.</p><p>We may extend this macro with support for 
     <span class="v">:hyp</span> and other features of return specifiers.</p><p>The macro is in the <span class="v">STD</span> package, 
     but we also add a synonym in the <span class="v">ACL2</span> package.</p><p><b>Macro: </b>tuple</p><pre class="code">(<a href="COMMON-LISP____DEFMACRO.html">defmacro</a>
 tuple (<a href="COMMON-LISP_____62REST.html">&amp;rest</a> args)
 (<a href="ACL2____B_A2.html">b*</a>
  ((var (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____LAST.html">last</a> args)))
   (comps (<a href="COMMON-LISP____BUTLAST.html">butlast</a> args 1))
   ((<a href="ACL2____MV.html">mv</a> vars conjuncts) (tuple-fn comps)))
  (<a href="COMMON-LISP____CONS.html">cons</a>
   'and
   (<a href="COMMON-LISP____CONS.html">cons</a>
    (<a href="COMMON-LISP____CONS.html">cons</a> 'tuplep
          (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="ACL2____LEN.html">len</a> comps) (<a href="COMMON-LISP____CONS.html">cons</a> var 'nil)))
    (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'b*
                (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'list vars) (<a href="COMMON-LISP____CONS.html">cons</a> var 'nil))
                            'nil)
                      (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'and conjuncts) 'nil)))
          'nil)))))</pre><p><b>Macro: </b>tuple</p><pre class="code">(<a href="COMMON-LISP____DEFMACRO.html">defmacro</a> acl2::tuple (<a href="COMMON-LISP_____62REST.html">&amp;rest</a> args)
          (<a href="COMMON-LISP____CONS.html">cons</a> 'tuple args))</pre> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>tuple-fn</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> tuple-fn (<a href="ACL2____ARGS.html">args</a>)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____TRUE-LISTP.html">true-listp</a> args)))
       (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'tuple-fn))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
            (<a href="ACL2____B_A2.html">b*</a> (((when (<a href="COMMON-LISP____ENDP.html">endp</a> args)) (<a href="ACL2____MV.html">mv</a> nil nil))
                 (arg (<a href="COMMON-LISP____CAR.html">car</a> args))
                 ((unless (<a href="STD____TUPLEP.html">tuplep</a> 2 arg)) (<a href="ACL2____MV.html">mv</a> nil nil))
                 (var (<a href="COMMON-LISP____FIRST.html">first</a> arg))
                 (<a href="COMMON-LISP____TYPE.html">type</a> (<a href="COMMON-LISP____SECOND.html">second</a> arg))
                 (conjunct (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> type)
                               (<a href="COMMON-LISP____LIST.html">list</a> type var)
                               type))
                 ((<a href="ACL2____MV.html">mv</a> vars conjuncts)
                  (tuple-fn (<a href="COMMON-LISP____CDR.html">cdr</a> args))))
                (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____CONS.html">cons</a> var vars)
                    (<a href="COMMON-LISP____CONS.html">cons</a> conjunct conjuncts)))))</pre> 

</body>
</html>
