<html>
<head>
<meta charset="UTF-8">
<title>Uninterpreted-fn-cp</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=SMT____UNINTERPRETED-FN-CP">Click for Uninterpreted-fn-cp in the Full Manual</a></h3>

<p>Verified clause-processor for proving return types of uninterpreted 
  functions.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Theorem: </b>ev-uninterpreted-constraint-0</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 ev-uninterpreted-constraint-0
 (<a href="ACL2____IMPLIES.html">implies</a>
    (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x)
         (<a href="ACL2____SYNTAXP.html">syntaxp</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> acl2::a ''nil)))
         (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::x) 'quote)))
    (<a href="COMMON-LISP____EQUAL.html">equal</a> (ev-uninterpreted acl2::x acl2::a)
           (ev-uninterpreted
                (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::x)
                      (<a href="ACL2____KWOTE-LST.html">kwote-lst</a> (ev-lst-uninterpreted (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::x)
                                                       acl2::a)))
                nil))))</pre> 
<p><b>Theorem: </b>ev-uninterpreted-constraint-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ev-uninterpreted-constraint-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> acl2::x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (ev-uninterpreted acl2::x acl2::a)
                        (<a href="COMMON-LISP____AND.html">and</a> acl2::x
                             (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> acl2::x acl2::a))))))</pre> 
<p><b>Theorem: </b>ev-uninterpreted-constraint-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ev-uninterpreted-constraint-2
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x)
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::x) 'quote))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (ev-uninterpreted acl2::x acl2::a)
                        (<a href="COMMON-LISP____CADR.html">cadr</a> acl2::x))))</pre> 
<p><b>Theorem: </b>ev-uninterpreted-constraint-3</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 ev-uninterpreted-constraint-3
 (<a href="ACL2____IMPLIES.html">implies</a>
  (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x)
       (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::x)))
  (<a href="COMMON-LISP____EQUAL.html">equal</a>
     (ev-uninterpreted acl2::x acl2::a)
     (ev-uninterpreted (<a href="COMMON-LISP____CADDR.html">caddr</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::x))
                       (<a href="ACL2____PAIRLIS_42.html">pairlis$</a> (<a href="COMMON-LISP____CADR.html">cadr</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::x))
                                 (ev-lst-uninterpreted (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::x)
                                                       acl2::a))))))</pre> 
<p><b>Theorem: </b>ev-uninterpreted-constraint-4</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ev-uninterpreted-constraint-4
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x-lst))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (ev-lst-uninterpreted acl2::x-lst acl2::a)
                        nil)))</pre> 
<p><b>Theorem: </b>ev-uninterpreted-constraint-5</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     ev-uninterpreted-constraint-5
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x-lst)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (ev-lst-uninterpreted acl2::x-lst acl2::a)
                     (<a href="COMMON-LISP____CONS.html">cons</a> (ev-uninterpreted (<a href="COMMON-LISP____CAR.html">car</a> acl2::x-lst)
                                             acl2::a)
                           (ev-lst-uninterpreted (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::x-lst)
                                                 acl2::a)))))</pre> 
<p><b>Theorem: </b>ev-uninterpreted-constraint-6</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ev-uninterpreted-constraint-6
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x))
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> acl2::x)))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (ev-uninterpreted acl2::x acl2::a)
                        nil)))</pre> 
<p><b>Theorem: </b>ev-uninterpreted-constraint-7</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ev-uninterpreted-constraint-7
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x)
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::x)))
                      (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::x))))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (ev-uninterpreted acl2::x acl2::a)
                        nil)))</pre> 
<p><b>Theorem: </b>ev-uninterpreted-constraint-8</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ev-uninterpreted-constraint-8
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x)
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::x) 'not))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (ev-uninterpreted acl2::x acl2::a)
                        (<a href="COMMON-LISP____NOT.html">not</a> (ev-uninterpreted (<a href="COMMON-LISP____CADR.html">cadr</a> acl2::x)
                                               acl2::a)))))</pre> 
<p><b>Theorem: </b>ev-uninterpreted-constraint-9</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ev-uninterpreted-constraint-9
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x)
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::x) 'if))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (ev-uninterpreted acl2::x acl2::a)
                        (<a href="COMMON-LISP____IF.html">if</a> (ev-uninterpreted (<a href="COMMON-LISP____CADR.html">cadr</a> acl2::x)
                                              acl2::a)
                            (ev-uninterpreted (<a href="COMMON-LISP____CADDR.html">caddr</a> acl2::x)
                                              acl2::a)
                            (ev-uninterpreted (<a href="COMMON-LISP____CADDDR.html">cadddr</a> acl2::x)
                                              acl2::a)))))</pre> 
<p><b>Theorem: </b>ev-uninterpreted-constraint-10</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     ev-uninterpreted-constraint-10
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x)
                   (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::x) 'hint-please))
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (ev-uninterpreted acl2::x acl2::a)
                     (hint-please (ev-uninterpreted (<a href="COMMON-LISP____CADR.html">cadr</a> acl2::x)
                                                    acl2::a)))))</pre> 
<p><b>Theorem: </b>ev-uninterpreted-disjoin-cons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ev-uninterpreted-disjoin-cons
        (<a href="ACL2____IFF.html">iff</a> (ev-uninterpreted (<a href="ACL2____DISJOIN.html">disjoin</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y))
                               acl2::a)
             (<a href="COMMON-LISP____OR.html">or</a> (ev-uninterpreted acl2::x acl2::a)
                 (ev-uninterpreted (<a href="ACL2____DISJOIN.html">disjoin</a> acl2::y)
                                   acl2::a))))</pre> 
<p><b>Theorem: </b>ev-uninterpreted-disjoin-when-consp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ev-uninterpreted-disjoin-when-consp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x)
                 (<a href="ACL2____IFF.html">iff</a> (ev-uninterpreted (<a href="ACL2____DISJOIN.html">disjoin</a> acl2::x)
                                        acl2::a)
                      (<a href="COMMON-LISP____OR.html">or</a> (ev-uninterpreted (<a href="COMMON-LISP____CAR.html">car</a> acl2::x) acl2::a)
                          (ev-uninterpreted (<a href="ACL2____DISJOIN.html">disjoin</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::x))
                                            acl2::a)))))</pre> 
<p><b>Theorem: </b>ev-uninterpreted-disjoin-atom</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ev-uninterpreted-disjoin-atom
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (ev-uninterpreted (<a href="ACL2____DISJOIN.html">disjoin</a> acl2::x)
                                          acl2::a)
                        nil))
        :rule-classes ((:rewrite :backchain-limit-lst 0)))</pre> 
<p><b>Theorem: </b>ev-uninterpreted-disjoin-append</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ev-uninterpreted-disjoin-append
        (<a href="ACL2____IFF.html">iff</a> (ev-uninterpreted (<a href="ACL2____DISJOIN.html">disjoin</a> (<a href="COMMON-LISP____APPEND.html">append</a> acl2::x acl2::y))
                               acl2::a)
             (<a href="COMMON-LISP____OR.html">or</a> (ev-uninterpreted (<a href="ACL2____DISJOIN.html">disjoin</a> acl2::x)
                                   acl2::a)
                 (ev-uninterpreted (<a href="ACL2____DISJOIN.html">disjoin</a> acl2::y)
                                   acl2::a))))</pre> 
<p><b>Theorem: </b>ev-uninterpreted-conjoin-cons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ev-uninterpreted-conjoin-cons
        (<a href="ACL2____IFF.html">iff</a> (ev-uninterpreted (<a href="ACL2____CONJOIN.html">conjoin</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y))
                               acl2::a)
             (<a href="COMMON-LISP____AND.html">and</a> (ev-uninterpreted acl2::x acl2::a)
                  (ev-uninterpreted (<a href="ACL2____CONJOIN.html">conjoin</a> acl2::y)
                                    acl2::a))))</pre> 
<p><b>Theorem: </b>ev-uninterpreted-conjoin-when-consp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ev-uninterpreted-conjoin-when-consp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x)
                 (<a href="ACL2____IFF.html">iff</a> (ev-uninterpreted (<a href="ACL2____CONJOIN.html">conjoin</a> acl2::x)
                                        acl2::a)
                      (<a href="COMMON-LISP____AND.html">and</a> (ev-uninterpreted (<a href="COMMON-LISP____CAR.html">car</a> acl2::x) acl2::a)
                           (ev-uninterpreted (<a href="ACL2____CONJOIN.html">conjoin</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::x))
                                             acl2::a)))))</pre> 
<p><b>Theorem: </b>ev-uninterpreted-conjoin-atom</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ev-uninterpreted-conjoin-atom
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (ev-uninterpreted (<a href="ACL2____CONJOIN.html">conjoin</a> acl2::x)
                                          acl2::a)
                        t))
        :rule-classes ((:rewrite :backchain-limit-lst 0)))</pre> 
<p><b>Theorem: </b>ev-uninterpreted-conjoin-append</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ev-uninterpreted-conjoin-append
        (<a href="ACL2____IFF.html">iff</a> (ev-uninterpreted (<a href="ACL2____CONJOIN.html">conjoin</a> (<a href="COMMON-LISP____APPEND.html">append</a> acl2::x acl2::y))
                               acl2::a)
             (<a href="COMMON-LISP____AND.html">and</a> (ev-uninterpreted (<a href="ACL2____CONJOIN.html">conjoin</a> acl2::x)
                                    acl2::a)
                  (ev-uninterpreted (<a href="ACL2____CONJOIN.html">conjoin</a> acl2::y)
                                    acl2::a))))</pre> 
<p><b>Theorem: </b>ev-uninterpreted-conjoin-clauses-cons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     ev-uninterpreted-conjoin-clauses-cons
     (<a href="ACL2____IFF.html">iff</a> (ev-uninterpreted (conjoin-clauses (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y))
                            acl2::a)
          (<a href="COMMON-LISP____AND.html">and</a> (ev-uninterpreted (<a href="ACL2____DISJOIN.html">disjoin</a> acl2::x)
                                 acl2::a)
               (ev-uninterpreted (conjoin-clauses acl2::y)
                                 acl2::a))))</pre> 
<p><b>Theorem: </b>ev-uninterpreted-conjoin-clauses-when-consp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    ev-uninterpreted-conjoin-clauses-when-consp
    (<a href="ACL2____IMPLIES.html">implies</a>
         (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x)
         (<a href="ACL2____IFF.html">iff</a> (ev-uninterpreted (conjoin-clauses acl2::x)
                                acl2::a)
              (<a href="COMMON-LISP____AND.html">and</a> (ev-uninterpreted (<a href="ACL2____DISJOIN.html">disjoin</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::x))
                                     acl2::a)
                   (ev-uninterpreted (conjoin-clauses (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::x))
                                     acl2::a)))))</pre> 
<p><b>Theorem: </b>ev-uninterpreted-conjoin-clauses-atom</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> ev-uninterpreted-conjoin-clauses-atom
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (ev-uninterpreted (conjoin-clauses acl2::x)
                                          acl2::a)
                        t))
        :rule-classes ((:rewrite :backchain-limit-lst 0)))</pre> 
<p><b>Theorem: </b>ev-uninterpreted-conjoin-clauses-append</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   ev-uninterpreted-conjoin-clauses-append
   (<a href="ACL2____IFF.html">iff</a> (ev-uninterpreted (conjoin-clauses (<a href="COMMON-LISP____APPEND.html">append</a> acl2::x acl2::y))
                          acl2::a)
        (<a href="COMMON-LISP____AND.html">and</a> (ev-uninterpreted (conjoin-clauses acl2::x)
                               acl2::a)
             (ev-uninterpreted (conjoin-clauses acl2::y)
                               acl2::a))))</pre> 
<p><b>Function: </b>lambda-&gt;actuals-fix</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> lambda-&gt;actuals-fix (<a href="ACL2____FORMALS.html">formals</a> actuals)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> formals)
                                   (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> actuals))))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'lambda-&gt;actuals-fix))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____B_A2.html">b*</a> ((<a href="ACL2____FORMALS.html">formals</a> (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> formals))
                 (actuals (pseudo-term-list-fix actuals))
                 (len-formals (<a href="ACL2____LEN.html">len</a> formals))
                 (len-actuals (<a href="ACL2____LEN.html">len</a> actuals))
                 ((<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> len-formals len-actuals))
                  actuals))
                nil)))</pre> 
<p><b>Theorem: </b>pseudo-term-listp-of-lambda-&gt;actuals-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-listp-of-lambda-&gt;actuals-fix
        (<a href="ACL2____B_A2.html">b*</a> ((new-actuals (lambda-&gt;actuals-fix formals actuals)))
            (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> new-actuals))
        :rule-classes :rewrite)</pre> 
<p><b>Function: </b>lambda-&gt;formals-fix</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> lambda-&gt;formals-fix (<a href="ACL2____FORMALS.html">formals</a> actuals)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> formals)
                                   (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> actuals))))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'lambda-&gt;formals-fix))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____B_A2.html">b*</a> ((<a href="ACL2____FORMALS.html">formals</a> (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> formals))
                 (actuals (pseudo-term-list-fix actuals))
                 (len-formals (<a href="ACL2____LEN.html">len</a> formals))
                 (len-actuals (<a href="ACL2____LEN.html">len</a> actuals))
                 ((<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> len-formals len-actuals))
                  formals))
                nil)))</pre> 
<p><b>Theorem: </b>symbol-listp-of-lambda-&gt;formals-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-listp-of-lambda-&gt;formals-fix
        (<a href="ACL2____B_A2.html">b*</a> ((new-formals (lambda-&gt;formals-fix formals actuals)))
            (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> new-formals))
        :rule-classes :rewrite)</pre> 
<p><b>Function: </b>lambda-binding-p</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
  lambda-binding-p (x)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
  (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'lambda-binding-p))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
       (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____ALISTP.html">alistp</a> x)
                             (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____STRIP-CARS.html">strip-cars</a> x)
                                    '(<a href="ACL2____FORMALS.html">formals</a> actuals)))
                 :exec (fty::alist-with-carsp x '(<a href="ACL2____FORMALS.html">formals</a> actuals)))
            (<a href="ACL2____B_A2.html">b*</a> ((<a href="ACL2____FORMALS.html">formals</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x)))
                 (actuals (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x))))
                (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> formals)
                     (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> actuals)
                     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> formals) (<a href="ACL2____LEN.html">len</a> actuals)))))))</pre> 
<p><b>Theorem: </b>consp-when-lambda-binding-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> consp-when-lambda-binding-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-P.html">lambda-binding-p</a> x) (<a href="COMMON-LISP____CONSP.html">consp</a> x))
        :rule-classes :compound-recognizer)</pre> 
<p><b>Function: </b>lambda-binding-fix$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 lambda-binding-fix$inline (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____LAMBDA-BINDING-P.html">lambda-binding-p</a> x)))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'lambda-binding-fix))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____MBE.html">mbe</a>
      :logic
      (<a href="ACL2____B_A2.html">b*</a> ((<a href="ACL2____FORMALS.html">formals</a> (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x))))
           (actuals (pseudo-term-list-fix (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x)))))
          (<a href="COMMON-LISP____LET.html">let</a> ((<a href="ACL2____FORMALS.html">formals</a> (lambda-&gt;formals-fix formals actuals))
                (actuals (lambda-&gt;actuals-fix formals actuals)))
               (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'formals formals)
                     (<a href="COMMON-LISP____CONS.html">cons</a> 'actuals actuals))))
      :exec x)))</pre> 
<p><b>Theorem: </b>lambda-binding-p-of-lambda-binding-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-p-of-lambda-binding-fix
        (<a href="ACL2____B_A2.html">b*</a> ((new-x (lambda-binding-fix$inline x)))
            (<a href="SMT____LAMBDA-BINDING-P.html">lambda-binding-p</a> new-x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>lambda-binding-fix-when-lambda-binding-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-fix-when-lambda-binding-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-P.html">lambda-binding-p</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING-FIX.html">lambda-binding-fix</a> x) x)))</pre> 
<p><b>Function: </b>lambda-binding-equiv$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> lambda-binding-equiv$inline
       (acl2::x acl2::y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____LAMBDA-BINDING-P.html">lambda-binding-p</a> acl2::x)
                                   (<a href="SMT____LAMBDA-BINDING-P.html">lambda-binding-p</a> acl2::y))))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING-FIX.html">lambda-binding-fix</a> acl2::x)
              (<a href="SMT____LAMBDA-BINDING-FIX.html">lambda-binding-fix</a> acl2::y)))</pre> 
<p><b>Theorem: </b>lambda-binding-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="SMT____LAMBDA-BINDING-EQUIV.html">lambda-binding-equiv</a> x y))
             (<a href="SMT____LAMBDA-BINDING-EQUIV.html">lambda-binding-equiv</a> x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-EQUIV.html">lambda-binding-equiv</a> x y)
                      (<a href="SMT____LAMBDA-BINDING-EQUIV.html">lambda-binding-equiv</a> y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____LAMBDA-BINDING-EQUIV.html">lambda-binding-equiv</a> x y)
                           (<a href="SMT____LAMBDA-BINDING-EQUIV.html">lambda-binding-equiv</a> y z))
                      (<a href="SMT____LAMBDA-BINDING-EQUIV.html">lambda-binding-equiv</a> x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>lambda-binding-equiv-implies-equal-lambda-binding-fix-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-equiv-implies-equal-lambda-binding-fix-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-EQUIV.html">lambda-binding-equiv</a> acl2::x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING-FIX.html">lambda-binding-fix</a> acl2::x)
                        (<a href="SMT____LAMBDA-BINDING-FIX.html">lambda-binding-fix</a> x-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>lambda-binding-fix-under-lambda-binding-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-fix-under-lambda-binding-equiv
        (<a href="SMT____LAMBDA-BINDING-EQUIV.html">lambda-binding-equiv</a> (<a href="SMT____LAMBDA-BINDING-FIX.html">lambda-binding-fix</a> acl2::x)
                              acl2::x)
        :rule-classes (:rewrite :rewrite-quoted-constant))</pre> 
<p><b>Theorem: </b>equal-of-lambda-binding-fix-1-forward-to-lambda-binding-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     equal-of-lambda-binding-fix-1-forward-to-lambda-binding-equiv
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING-FIX.html">lambda-binding-fix</a> acl2::x)
                     acl2::y)
              (<a href="SMT____LAMBDA-BINDING-EQUIV.html">lambda-binding-equiv</a> acl2::x acl2::y))
     :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>equal-of-lambda-binding-fix-2-forward-to-lambda-binding-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     equal-of-lambda-binding-fix-2-forward-to-lambda-binding-equiv
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> acl2::x (<a href="SMT____LAMBDA-BINDING-FIX.html">lambda-binding-fix</a> acl2::y))
              (<a href="SMT____LAMBDA-BINDING-EQUIV.html">lambda-binding-equiv</a> acl2::x acl2::y))
     :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>lambda-binding-equiv-of-lambda-binding-fix-1-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-equiv-of-lambda-binding-fix-1-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-EQUIV.html">lambda-binding-equiv</a> (<a href="SMT____LAMBDA-BINDING-FIX.html">lambda-binding-fix</a> acl2::x)
                                       acl2::y)
                 (<a href="SMT____LAMBDA-BINDING-EQUIV.html">lambda-binding-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>lambda-binding-equiv-of-lambda-binding-fix-2-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    lambda-binding-equiv-of-lambda-binding-fix-2-forward
    (<a href="ACL2____IMPLIES.html">implies</a>
         (<a href="SMT____LAMBDA-BINDING-EQUIV.html">lambda-binding-equiv</a> acl2::x (<a href="SMT____LAMBDA-BINDING-FIX.html">lambda-binding-fix</a> acl2::y))
         (<a href="SMT____LAMBDA-BINDING-EQUIV.html">lambda-binding-equiv</a> acl2::x acl2::y))
    :rule-classes :forward-chaining)</pre> 
<p><b>Function: </b>lambda-binding-&gt;formals$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 lambda-binding-&gt;formals$inline (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____LAMBDA-BINDING-P.html">lambda-binding-p</a> x)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'lambda-binding-&gt;formals))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____MBE.html">mbe</a>
      :logic
      (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x))
           (<a href="ACL2____FORMALS.html">formals</a> (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x))))
           (actuals (pseudo-term-list-fix (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x)))))
          (lambda-&gt;formals-fix formals actuals))
      :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x)))))</pre> 
<p><b>Theorem: </b>symbol-listp-of-lambda-binding-&gt;formals</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-listp-of-lambda-binding-&gt;formals
        (<a href="ACL2____B_A2.html">b*</a> ((<a href="ACL2____FORMALS.html">formals</a> (lambda-binding-&gt;formals$inline x)))
            (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> formals))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>lambda-binding-&gt;formals$inline-of-lambda-binding-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     lambda-binding-&gt;formals$inline-of-lambda-binding-fix-x
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (lambda-binding-&gt;formals$inline (<a href="SMT____LAMBDA-BINDING-FIX.html">lambda-binding-fix</a> x))
            (lambda-binding-&gt;formals$inline x)))</pre> 
<p><b>Theorem: </b>lambda-binding-&gt;formals$inline-lambda-binding-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 lambda-binding-&gt;formals$inline-lambda-binding-equiv-congruence-on-x
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-EQUIV.html">lambda-binding-equiv</a> x x-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (lambda-binding-&gt;formals$inline x)
                 (lambda-binding-&gt;formals$inline x-equiv)))
 :rule-classes :congruence)</pre> 
<p><b>Function: </b>lambda-binding-&gt;actuals$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 lambda-binding-&gt;actuals$inline (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____LAMBDA-BINDING-P.html">lambda-binding-p</a> x)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'lambda-binding-&gt;actuals))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____MBE.html">mbe</a>
      :logic
      (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x))
           (<a href="ACL2____FORMALS.html">formals</a> (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x))))
           (actuals (pseudo-term-list-fix (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x)))))
          (lambda-&gt;actuals-fix formals actuals))
      :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x)))))</pre> 
<p><b>Theorem: </b>pseudo-term-listp-of-lambda-binding-&gt;actuals</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-listp-of-lambda-binding-&gt;actuals
        (<a href="ACL2____B_A2.html">b*</a> ((actuals (lambda-binding-&gt;actuals$inline x)))
            (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> actuals))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>lambda-binding-&gt;actuals$inline-of-lambda-binding-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     lambda-binding-&gt;actuals$inline-of-lambda-binding-fix-x
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (lambda-binding-&gt;actuals$inline (<a href="SMT____LAMBDA-BINDING-FIX.html">lambda-binding-fix</a> x))
            (lambda-binding-&gt;actuals$inline x)))</pre> 
<p><b>Theorem: </b>lambda-binding-&gt;actuals$inline-lambda-binding-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 lambda-binding-&gt;actuals$inline-lambda-binding-equiv-congruence-on-x
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-EQUIV.html">lambda-binding-equiv</a> x x-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (lambda-binding-&gt;actuals$inline x)
                 (lambda-binding-&gt;actuals$inline x-equiv)))
 :rule-classes :congruence)</pre> 
<p><b>Function: </b>lambda-binding</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 lambda-binding (<a href="ACL2____FORMALS.html">formals</a> actuals)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> formals)
                             (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> actuals))))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> formals) (<a href="ACL2____LEN.html">len</a> actuals))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'lambda-binding))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____B_A2.html">b*</a>
    ((<a href="ACL2____FORMALS.html">formals</a> (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> formals)
                   :exec formals))
     (actuals (<a href="ACL2____MBE.html">mbe</a> :logic (pseudo-term-list-fix actuals)
                   :exec actuals)))
    (<a href="COMMON-LISP____LET.html">let</a> ((<a href="ACL2____FORMALS.html">formals</a> (<a href="ACL2____MBE.html">mbe</a> :logic (lambda-&gt;formals-fix formals actuals)
                        :exec formals))
          (actuals (<a href="ACL2____MBE.html">mbe</a> :logic (lambda-&gt;actuals-fix formals actuals)
                        :exec actuals)))
         (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'formals formals)
               (<a href="COMMON-LISP____CONS.html">cons</a> 'actuals actuals))))))</pre> 
<p><b>Theorem: </b>lambda-binding-p-of-lambda-binding</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-p-of-lambda-binding
        (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="SMT____LAMBDA-BINDING.html">lambda-binding</a> formals actuals)))
            (<a href="SMT____LAMBDA-BINDING-P.html">lambda-binding-p</a> x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>lambda-binding-&gt;formals-of-lambda-binding</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   lambda-binding-&gt;formals-of-lambda-binding
   (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING-_E3FORMALS.html">lambda-binding-&gt;formals</a> (<a href="SMT____LAMBDA-BINDING.html">lambda-binding</a> formals actuals))
          (<a href="ACL2____B_A2.html">b*</a> ((acl2::?formals (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> formals))
               (?actuals (pseudo-term-list-fix actuals)))
              (lambda-&gt;formals-fix formals actuals))))</pre> 
<p><b>Theorem: </b>lambda-binding-&gt;actuals-of-lambda-binding</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   lambda-binding-&gt;actuals-of-lambda-binding
   (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING-_E3ACTUALS.html">lambda-binding-&gt;actuals</a> (<a href="SMT____LAMBDA-BINDING.html">lambda-binding</a> formals actuals))
          (<a href="ACL2____B_A2.html">b*</a> ((acl2::?formals (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> formals))
               (?actuals (pseudo-term-list-fix actuals)))
              (lambda-&gt;actuals-fix formals actuals))))</pre> 
<p><b>Theorem: </b>lambda-binding-requirements</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-requirements
        (<a href="ACL2____B_A2.html">b*</a> ((acl2::?formals (<a href="SMT____LAMBDA-BINDING-_E3FORMALS.html">lambda-binding-&gt;formals</a> x))
             (?actuals (<a href="SMT____LAMBDA-BINDING-_E3ACTUALS.html">lambda-binding-&gt;actuals</a> x)))
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> formals) (<a href="ACL2____LEN.html">len</a> actuals))))</pre> 
<p><b>Theorem: </b>lambda-binding-of-fields</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-of-fields
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING.html">lambda-binding</a> (<a href="SMT____LAMBDA-BINDING-_E3FORMALS.html">lambda-binding-&gt;formals</a> x)
                               (<a href="SMT____LAMBDA-BINDING-_E3ACTUALS.html">lambda-binding-&gt;actuals</a> x))
               (<a href="SMT____LAMBDA-BINDING-FIX.html">lambda-binding-fix</a> x)))</pre> 
<p><b>Theorem: </b>lambda-binding-fix-when-lambda-binding</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-fix-when-lambda-binding
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING-FIX.html">lambda-binding-fix</a> x)
               (<a href="SMT____LAMBDA-BINDING.html">lambda-binding</a> (<a href="SMT____LAMBDA-BINDING-_E3FORMALS.html">lambda-binding-&gt;formals</a> x)
                               (<a href="SMT____LAMBDA-BINDING-_E3ACTUALS.html">lambda-binding-&gt;actuals</a> x))))</pre> 
<p><b>Theorem: </b>equal-of-lambda-binding</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  equal-of-lambda-binding
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING.html">lambda-binding</a> formals actuals)
                x)
         (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____LAMBDA-BINDING-P.html">lambda-binding-p</a> x)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING-_E3FORMALS.html">lambda-binding-&gt;formals</a> x)
                     (<a href="ACL2____B_A2.html">b*</a> ((acl2::?formals (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> formals))
                          (?actuals (pseudo-term-list-fix actuals)))
                         (lambda-&gt;formals-fix formals actuals)))
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING-_E3ACTUALS.html">lambda-binding-&gt;actuals</a> x)
                     (<a href="ACL2____B_A2.html">b*</a> ((acl2::?formals (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> formals))
                          (?actuals (pseudo-term-list-fix actuals)))
                         (lambda-&gt;actuals-fix formals actuals))))))</pre> 
<p><b>Theorem: </b>lambda-binding-of-symbol-list-fix-formals</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-of-symbol-list-fix-formals
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING.html">lambda-binding</a> (<a href="ACL2____SYMBOL-LIST-FIX.html">symbol-list-fix</a> formals)
                               actuals)
               (<a href="SMT____LAMBDA-BINDING.html">lambda-binding</a> formals actuals)))</pre> 
<p><b>Theorem: </b>lambda-binding-symbol-list-equiv-congruence-on-formals</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-symbol-list-equiv-congruence-on-formals
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____SYMBOL-LIST-EQUIV.html">acl2::symbol-list-equiv</a> formals formals-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING.html">lambda-binding</a> formals actuals)
                        (<a href="SMT____LAMBDA-BINDING.html">lambda-binding</a> formals-equiv actuals)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>lambda-binding-of-pseudo-term-list-fix-actuals</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     lambda-binding-of-pseudo-term-list-fix-actuals
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING.html">lambda-binding</a> formals (pseudo-term-list-fix actuals))
            (<a href="SMT____LAMBDA-BINDING.html">lambda-binding</a> formals actuals)))</pre> 
<p><b>Theorem: </b>lambda-binding-pseudo-term-list-equiv-congruence-on-actuals</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-pseudo-term-list-equiv-congruence-on-actuals
        (<a href="ACL2____IMPLIES.html">implies</a> (pseudo-term-list-equiv actuals actuals-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING.html">lambda-binding</a> formals actuals)
                        (<a href="SMT____LAMBDA-BINDING.html">lambda-binding</a> formals actuals-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>lambda-binding-fix-redef</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-fix-redef
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING-FIX.html">lambda-binding-fix</a> x)
               (<a href="SMT____LAMBDA-BINDING.html">lambda-binding</a> (<a href="SMT____LAMBDA-BINDING-_E3FORMALS.html">lambda-binding-&gt;formals</a> x)
                               (<a href="SMT____LAMBDA-BINDING-_E3ACTUALS.html">lambda-binding-&gt;actuals</a> x)))
        :rule-classes :definition)</pre> 
<p><b>Function: </b>lambda-binding-listp</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> lambda-binding-listp (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'lambda-binding-listp))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)
                (<a href="COMMON-LISP____EQ.html">eq</a> x nil)
                (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____LAMBDA-BINDING-P.html">lambda-binding-p</a> (<a href="COMMON-LISP____CAR.html">car</a> x))
                     (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x))))))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-cons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-listp-of-cons
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::a acl2::x))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____LAMBDA-BINDING-P.html">lambda-binding-p</a> acl2::a)
                    (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-cdr-when-lambda-binding-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-listp-of-cdr-when-lambda-binding-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-when-not-consp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-listp-when-not-consp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x))
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> acl2::x)
                        (<a href="COMMON-LISP____NOT.html">not</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-p-of-car-when-lambda-binding-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-p-of-car-when-lambda-binding-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> acl2::x)
                 (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____LAMBDA-BINDING-P.html">lambda-binding-p</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::x))
                      (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x)
                          (<a href="SMT____LAMBDA-BINDING-P.html">lambda-binding-p</a> nil))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>true-listp-when-lambda-binding-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> true-listp-when-lambda-binding-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> acl2::x)
                 (<a href="ACL2____TRUE-LISTP.html">true-listp</a> acl2::x))
        :rule-classes :compound-recognizer)</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-listp-of-list-fix
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> acl2::x)
                 (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-sfix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-listp-of-sfix
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::x))
             (<a href="COMMON-LISP____OR.html">or</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> acl2::x)
                 (<a href="COMMON-LISP____NOT.html">not</a> (<a href="SET____SETP.html">set::setp</a> acl2::x))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-insert</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-listp-of-insert
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="SET____INSERT.html">set::insert</a> acl2::a acl2::x))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::x))
                  (<a href="SMT____LAMBDA-BINDING-P.html">lambda-binding-p</a> acl2::a)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-delete</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     lambda-binding-listp-of-delete
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> acl2::x)
              (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="SET____DELETE.html">set::delete</a> acl2::k acl2::x)))
     :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-mergesort</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-listp-of-mergesort
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="SET____MERGESORT.html">set::mergesort</a> acl2::x))
             (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-union</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-listp-of-union
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="SET____UNION.html">set::union</a> acl2::x acl2::y))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::x))
                  (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="SET____SFIX.html">set::sfix</a> acl2::y))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-intersect-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   lambda-binding-listp-of-intersect-1
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> acl2::x)
            (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="SET____INTERSECT.html">set::intersect</a> acl2::x acl2::y)))
   :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-intersect-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   lambda-binding-listp-of-intersect-2
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> acl2::y)
            (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="SET____INTERSECT.html">set::intersect</a> acl2::x acl2::y)))
   :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-difference</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  lambda-binding-listp-of-difference
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> acl2::x)
           (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="SET____DIFFERENCE.html">set::difference</a> acl2::x acl2::y)))
  :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-duplicated-members</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 lambda-binding-listp-of-duplicated-members
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> acl2::x)
          (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (acl2::duplicated-members acl2::x)))
 :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-rev</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-listp-of-rev
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="ACL2____REV.html">acl2::rev</a> acl2::x))
               (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-append</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-listp-of-append
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="COMMON-LISP____APPEND.html">append</a> acl2::a acl2::b))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::a))
                    (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> acl2::b)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-rcons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-listp-of-rcons
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="ACL2____RCONS.html">acl2::rcons</a> acl2::a acl2::x))
             (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____LAMBDA-BINDING-P.html">lambda-binding-p</a> acl2::a)
                  (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-p-when-member-equal-of-lambda-binding-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-p-when-member-equal-of-lambda-binding-listp
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> acl2::a acl2::x)
                           (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> acl2::x))
                      (<a href="SMT____LAMBDA-BINDING-P.html">lambda-binding-p</a> acl2::a))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> acl2::x)
                           (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> acl2::a acl2::x))
                      (<a href="SMT____LAMBDA-BINDING-P.html">lambda-binding-p</a> acl2::a)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-when-subsetp-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-listp-when-subsetp-equal
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____SUBSETP-EQUAL.html">subsetp-equal</a> acl2::x acl2::y)
                           (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> acl2::y))
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> acl2::x)
                             (<a href="ACL2____TRUE-LISTP.html">true-listp</a> acl2::x)))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> acl2::y)
                           (<a href="ACL2____SUBSETP-EQUAL.html">subsetp-equal</a> acl2::x acl2::y))
                      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> acl2::x)
                             (<a href="ACL2____TRUE-LISTP.html">true-listp</a> acl2::x))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-set-difference-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 lambda-binding-listp-of-set-difference-equal
 (<a href="ACL2____IMPLIES.html">implies</a>
      (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> acl2::x)
      (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="ACL2____SET-DIFFERENCE-EQUAL.html">set-difference-equal</a> acl2::x acl2::y)))
 :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-intersection-equal-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   lambda-binding-listp-of-intersection-equal-1
   (<a href="ACL2____IMPLIES.html">implies</a>
        (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
        (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="ACL2____INTERSECTION-EQUAL.html">intersection-equal</a> acl2::x acl2::y)))
   :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-intersection-equal-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   lambda-binding-listp-of-intersection-equal-2
   (<a href="ACL2____IMPLIES.html">implies</a>
        (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::y))
        (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="ACL2____INTERSECTION-EQUAL.html">intersection-equal</a> acl2::x acl2::y)))
   :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-union-equal</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     lambda-binding-listp-of-union-equal
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="ACL2____UNION-EQUAL.html">union-equal</a> acl2::x acl2::y))
            (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x))
                 (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::y))))
     :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-take</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-listp-of-take
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="ACL2____TAKE.html">take</a> acl2::n acl2::x))
                      (<a href="COMMON-LISP____OR.html">or</a> (<a href="SMT____LAMBDA-BINDING-P.html">lambda-binding-p</a> nil)
                          (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____NFIX.html">nfix</a> acl2::n) (<a href="ACL2____LEN.html">len</a> acl2::x)))))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-repeat</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-listp-of-repeat
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="ACL2____REPEAT.html">acl2::repeat</a> acl2::n acl2::x))
             (<a href="COMMON-LISP____OR.html">or</a> (<a href="SMT____LAMBDA-BINDING-P.html">lambda-binding-p</a> acl2::x)
                 (<a href="ACL2____ZP.html">zp</a> acl2::n)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-p-of-nth-when-lambda-binding-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-p-of-nth-when-lambda-binding-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> acl2::x)
                      (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____NFIX.html">nfix</a> acl2::n) (<a href="ACL2____LEN.html">len</a> acl2::x)))
                 (<a href="SMT____LAMBDA-BINDING-P.html">lambda-binding-p</a> (<a href="COMMON-LISP____NTH.html">nth</a> acl2::n acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-update-nth</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 lambda-binding-listp-of-update-nth
 (<a href="ACL2____IMPLIES.html">implies</a>
    (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
    (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="ACL2____UPDATE-NTH.html">update-nth</a> acl2::n acl2::y acl2::x))
         (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____LAMBDA-BINDING-P.html">lambda-binding-p</a> acl2::y)
              (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____NFIX.html">nfix</a> acl2::n) (<a href="ACL2____LEN.html">len</a> acl2::x))
                  (<a href="SMT____LAMBDA-BINDING-P.html">lambda-binding-p</a> nil)))))
 :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-butlast</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-listp-of-butlast
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="COMMON-LISP____BUTLAST.html">butlast</a> acl2::x acl2::n)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-nthcdr</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-listp-of-nthcdr
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> acl2::n acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-last</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-listp-of-last
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="ACL2____DOUBLE-REWRITE.html">double-rewrite</a> acl2::x))
                 (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="COMMON-LISP____LAST.html">last</a> acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-remove</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-listp-of-remove
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> acl2::x)
                 (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="COMMON-LISP____REMOVE.html">remove</a> acl2::a acl2::x)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-revappend</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-listp-of-revappend
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="COMMON-LISP____REVAPPEND.html">revappend</a> acl2::x acl2::y))
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> (<a href="ACL2____LIST-FIX.html">acl2::list-fix</a> acl2::x))
                    (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> acl2::y)))
        :rule-classes ((:rewrite)))</pre> 
<p><b>Function: </b>lambda-binding-list-fix$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     lambda-binding-list-fix$inline (x)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> x)))
     (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'lambda-binding-list-fix))
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
          (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)
                          nil
                          (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="SMT____LAMBDA-BINDING-FIX.html">lambda-binding-fix</a> (<a href="COMMON-LISP____CAR.html">car</a> x))
                                (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x))))
               :exec x)))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-lambda-binding-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-listp-of-lambda-binding-list-fix
        (<a href="ACL2____B_A2.html">b*</a> ((fty::newx (lambda-binding-list-fix$inline x)))
            (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> fty::newx))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>lambda-binding-list-fix-when-lambda-binding-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-list-fix-when-lambda-binding-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> x) x)))</pre> 
<p><b>Function: </b>lambda-binding-list-equiv$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> lambda-binding-list-equiv$inline
       (acl2::x acl2::y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> acl2::x)
                                   (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> acl2::y))))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> acl2::x)
              (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> acl2::y)))</pre> 
<p><b>Theorem: </b>lambda-binding-list-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-list-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> x y))
             (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> x y)
                      (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> x y)
                           (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> y z))
                      (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>lambda-binding-list-equiv-implies-equal-lambda-binding-list-fix-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   lambda-binding-list-equiv-implies-equal-lambda-binding-list-fix-1
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> acl2::x x-equiv)
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> acl2::x)
                   (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> x-equiv)))
   :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>lambda-binding-list-fix-under-lambda-binding-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-list-fix-under-lambda-binding-list-equiv
        (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> acl2::x)
                                   acl2::x)
        :rule-classes (:rewrite :rewrite-quoted-constant))</pre> 
<p><b>Theorem: </b>equal-of-lambda-binding-list-fix-1-forward-to-lambda-binding-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 equal-of-lambda-binding-list-fix-1-forward-to-lambda-binding-list-equiv
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> acl2::x)
                 acl2::y)
          (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> acl2::x acl2::y))
 :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>equal-of-lambda-binding-list-fix-2-forward-to-lambda-binding-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 equal-of-lambda-binding-list-fix-2-forward-to-lambda-binding-list-equiv
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> acl2::x
                 (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> acl2::y))
          (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> acl2::x acl2::y))
 :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>lambda-binding-list-equiv-of-lambda-binding-list-fix-1-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   lambda-binding-list-equiv-of-lambda-binding-list-fix-1-forward
   (<a href="ACL2____IMPLIES.html">implies</a>
        (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> acl2::x)
                                   acl2::y)
        (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> acl2::x acl2::y))
   :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>lambda-binding-list-equiv-of-lambda-binding-list-fix-2-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  lambda-binding-list-equiv-of-lambda-binding-list-fix-2-forward
  (<a href="ACL2____IMPLIES.html">implies</a>
       (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> acl2::x
                                  (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> acl2::y))
       (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> acl2::x acl2::y))
  :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>car-of-lambda-binding-list-fix-x-under-lambda-binding-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     car-of-lambda-binding-list-fix-x-under-lambda-binding-equiv
     (<a href="SMT____LAMBDA-BINDING-EQUIV.html">lambda-binding-equiv</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> acl2::x))
                           (<a href="COMMON-LISP____CAR.html">car</a> acl2::x)))</pre> 
<p><b>Theorem: </b>car-lambda-binding-list-equiv-congruence-on-x-under-lambda-binding-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 car-lambda-binding-list-equiv-congruence-on-x-under-lambda-binding-equiv
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> acl2::x x-equiv)
          (<a href="SMT____LAMBDA-BINDING-EQUIV.html">lambda-binding-equiv</a> (<a href="COMMON-LISP____CAR.html">car</a> acl2::x)
                                (<a href="COMMON-LISP____CAR.html">car</a> x-equiv)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>cdr-of-lambda-binding-list-fix-x-under-lambda-binding-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  cdr-of-lambda-binding-list-fix-x-under-lambda-binding-list-equiv
  (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> acl2::x))
                             (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::x)))</pre> 
<p><b>Theorem: </b>cdr-lambda-binding-list-equiv-congruence-on-x-under-lambda-binding-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 cdr-lambda-binding-list-equiv-congruence-on-x-under-lambda-binding-list-equiv
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> acl2::x x-equiv)
          (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> (<a href="COMMON-LISP____CDR.html">cdr</a> acl2::x)
                                     (<a href="COMMON-LISP____CDR.html">cdr</a> x-equiv)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>cons-of-lambda-binding-fix-x-under-lambda-binding-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     cons-of-lambda-binding-fix-x-under-lambda-binding-list-equiv
     (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="SMT____LAMBDA-BINDING-FIX.html">lambda-binding-fix</a> acl2::x)
                                      acl2::y)
                                (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y)))</pre> 
<p><b>Theorem: </b>cons-lambda-binding-equiv-congruence-on-x-under-lambda-binding-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 cons-lambda-binding-equiv-congruence-on-x-under-lambda-binding-list-equiv
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-EQUIV.html">lambda-binding-equiv</a> acl2::x x-equiv)
          (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y)
                                     (<a href="COMMON-LISP____CONS.html">cons</a> x-equiv acl2::y)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>cons-of-lambda-binding-list-fix-y-under-lambda-binding-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 cons-of-lambda-binding-list-fix-y-under-lambda-binding-list-equiv
 (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x
                                  (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> acl2::y))
                            (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y)))</pre> 
<p><b>Theorem: </b>cons-lambda-binding-list-equiv-congruence-on-y-under-lambda-binding-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 cons-lambda-binding-list-equiv-congruence-on-y-under-lambda-binding-list-equiv
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> acl2::y y-equiv)
          (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x acl2::y)
                                     (<a href="COMMON-LISP____CONS.html">cons</a> acl2::x y-equiv)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>consp-of-lambda-binding-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> consp-of-lambda-binding-list-fix
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> acl2::x))
               (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x)))</pre> 
<p><b>Theorem: </b>lambda-binding-list-fix-under-iff</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-list-fix-under-iff
        (<a href="ACL2____IFF.html">iff</a> (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> acl2::x)
             (<a href="COMMON-LISP____CONSP.html">consp</a> acl2::x)))</pre> 
<p><b>Theorem: </b>lambda-binding-list-fix-of-cons</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-list-fix-of-cons
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> (<a href="COMMON-LISP____CONS.html">cons</a> a x))
               (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="SMT____LAMBDA-BINDING-FIX.html">lambda-binding-fix</a> a)
                     (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> x))))</pre> 
<p><b>Theorem: </b>len-of-lambda-binding-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> len-of-lambda-binding-list-fix
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> acl2::x))
               (<a href="ACL2____LEN.html">len</a> acl2::x)))</pre> 
<p><b>Theorem: </b>lambda-binding-list-fix-of-append</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-list-fix-of-append
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> (<a href="COMMON-LISP____APPEND.html">append</a> std::a std::b))
               (<a href="COMMON-LISP____APPEND.html">append</a> (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> std::a)
                       (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> std::b))))</pre> 
<p><b>Theorem: </b>lambda-binding-list-fix-of-repeat</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     lambda-binding-list-fix-of-repeat
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> (<a href="ACL2____REPEAT.html">acl2::repeat</a> acl2::n acl2::x))
            (<a href="ACL2____REPEAT.html">acl2::repeat</a> acl2::n (<a href="SMT____LAMBDA-BINDING-FIX.html">lambda-binding-fix</a> acl2::x))))</pre> 
<p><b>Theorem: </b>list-equiv-refines-lambda-binding-list-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> list-equiv-refines-lambda-binding-list-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____LIST-EQUIV.html">acl2::list-equiv</a> acl2::x acl2::y)
                 (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> acl2::x acl2::y))
        :rule-classes :refinement)</pre> 
<p><b>Theorem: </b>nth-of-lambda-binding-list-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nth-of-lambda-binding-list-fix
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____NTH.html">nth</a> acl2::n
                    (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> acl2::x))
               (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____NFIX.html">nfix</a> acl2::n) (<a href="ACL2____LEN.html">len</a> acl2::x))
                   (<a href="SMT____LAMBDA-BINDING-FIX.html">lambda-binding-fix</a> (<a href="COMMON-LISP____NTH.html">nth</a> acl2::n acl2::x))
                   nil)))</pre> 
<p><b>Theorem: </b>lambda-binding-list-equiv-implies-lambda-binding-list-equiv-append-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 lambda-binding-list-equiv-implies-lambda-binding-list-equiv-append-1
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> acl2::x fty::x-equiv)
          (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> (<a href="COMMON-LISP____APPEND.html">append</a> acl2::x acl2::y)
                                     (<a href="COMMON-LISP____APPEND.html">append</a> fty::x-equiv acl2::y)))
 :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>lambda-binding-list-equiv-implies-lambda-binding-list-equiv-append-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 lambda-binding-list-equiv-implies-lambda-binding-list-equiv-append-2
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> acl2::y fty::y-equiv)
          (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> (<a href="COMMON-LISP____APPEND.html">append</a> acl2::x acl2::y)
                                     (<a href="COMMON-LISP____APPEND.html">append</a> acl2::x fty::y-equiv)))
 :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>lambda-binding-list-equiv-implies-lambda-binding-list-equiv-nthcdr-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 lambda-binding-list-equiv-implies-lambda-binding-list-equiv-nthcdr-2
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> acl2::l l-equiv)
          (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> acl2::n acl2::l)
                                     (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> acl2::n l-equiv)))
 :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>lambda-binding-list-equiv-implies-lambda-binding-list-equiv-take-2</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  lambda-binding-list-equiv-implies-lambda-binding-list-equiv-take-2
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> acl2::l l-equiv)
           (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> (<a href="ACL2____TAKE.html">take</a> acl2::n acl2::l)
                                      (<a href="ACL2____TAKE.html">take</a> acl2::n l-equiv)))
  :rule-classes (:congruence))</pre> 
<p><b>Function: </b>fhg-single-args-p</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 fhg-single-args-p (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'fhg-single-args-p))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="COMMON-LISP____AND.html">and</a>
   (<a href="ACL2____MBE.html">mbe</a>
      :logic (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____ALISTP.html">alistp</a> x)
                  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____STRIP-CARS.html">strip-cars</a> x)
                         '(fn actuals fn-returns-hint-acc
                              fn-more-returns-hint-acc lambda-acc)))
      :exec (fty::alist-with-carsp
                 x
                 '(fn actuals fn-returns-hint-acc
                      fn-more-returns-hint-acc lambda-acc)))
   (<a href="ACL2____B_A2.html">b*</a> ((fn (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x)))
        (actuals (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x)))
        (fn-returns-hint-acc (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 2 x)))
        (fn-more-returns-hint-acc (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 3 x)))
        (lambda-acc (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 4 x))))
       (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-P.html">func-p</a> fn)
            (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> actuals)
            (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> fn-returns-hint-acc)
            (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> fn-more-returns-hint-acc)
            (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> lambda-acc))))))</pre> 
<p><b>Theorem: </b>consp-when-fhg-single-args-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> consp-when-fhg-single-args-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FHG-SINGLE-ARGS-P.html">fhg-single-args-p</a> x)
                 (<a href="COMMON-LISP____CONSP.html">consp</a> x))
        :rule-classes :compound-recognizer)</pre> 
<p><b>Function: </b>fhg-single-args-fix$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 fhg-single-args-fix$inline (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____FHG-SINGLE-ARGS-P.html">fhg-single-args-p</a> x)))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'fhg-single-args-fix))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____MBE.html">mbe</a>
   :logic
   (<a href="ACL2____B_A2.html">b*</a>
    ((fn (<a href="SMT____FUNC-FIX.html">func-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x))))
     (actuals (pseudo-term-list-fix (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x))))
     (fn-returns-hint-acc
          (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 2 x))))
     (fn-more-returns-hint-acc
          (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 3 x))))
     (lambda-acc (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 4 x)))))
    (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'fn fn)
          (<a href="COMMON-LISP____CONS.html">cons</a> 'actuals actuals)
          (<a href="COMMON-LISP____CONS.html">cons</a> 'fn-returns-hint-acc
                fn-returns-hint-acc)
          (<a href="COMMON-LISP____CONS.html">cons</a> 'fn-more-returns-hint-acc
                fn-more-returns-hint-acc)
          (<a href="COMMON-LISP____CONS.html">cons</a> 'lambda-acc lambda-acc)))
   :exec x)))</pre> 
<p><b>Theorem: </b>fhg-single-args-p-of-fhg-single-args-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-single-args-p-of-fhg-single-args-fix
        (<a href="ACL2____B_A2.html">b*</a> ((new-x (fhg-single-args-fix$inline x)))
            (<a href="SMT____FHG-SINGLE-ARGS-P.html">fhg-single-args-p</a> new-x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>fhg-single-args-fix-when-fhg-single-args-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-single-args-fix-when-fhg-single-args-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FHG-SINGLE-ARGS-P.html">fhg-single-args-p</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-SINGLE-ARGS-FIX.html">fhg-single-args-fix</a> x) x)))</pre> 
<p><b>Function: </b>fhg-single-args-equiv$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> fhg-single-args-equiv$inline
       (acl2::x acl2::y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FHG-SINGLE-ARGS-P.html">fhg-single-args-p</a> acl2::x)
                                   (<a href="SMT____FHG-SINGLE-ARGS-P.html">fhg-single-args-p</a> acl2::y))))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-SINGLE-ARGS-FIX.html">fhg-single-args-fix</a> acl2::x)
              (<a href="SMT____FHG-SINGLE-ARGS-FIX.html">fhg-single-args-fix</a> acl2::y)))</pre> 
<p><b>Theorem: </b>fhg-single-args-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-single-args-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="SMT____FHG-SINGLE-ARGS-EQUIV.html">fhg-single-args-equiv</a> x y))
             (<a href="SMT____FHG-SINGLE-ARGS-EQUIV.html">fhg-single-args-equiv</a> x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FHG-SINGLE-ARGS-EQUIV.html">fhg-single-args-equiv</a> x y)
                      (<a href="SMT____FHG-SINGLE-ARGS-EQUIV.html">fhg-single-args-equiv</a> y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FHG-SINGLE-ARGS-EQUIV.html">fhg-single-args-equiv</a> x y)
                           (<a href="SMT____FHG-SINGLE-ARGS-EQUIV.html">fhg-single-args-equiv</a> y z))
                      (<a href="SMT____FHG-SINGLE-ARGS-EQUIV.html">fhg-single-args-equiv</a> x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>fhg-single-args-equiv-implies-equal-fhg-single-args-fix-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-single-args-equiv-implies-equal-fhg-single-args-fix-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FHG-SINGLE-ARGS-EQUIV.html">fhg-single-args-equiv</a> acl2::x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-SINGLE-ARGS-FIX.html">fhg-single-args-fix</a> acl2::x)
                        (<a href="SMT____FHG-SINGLE-ARGS-FIX.html">fhg-single-args-fix</a> x-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>fhg-single-args-fix-under-fhg-single-args-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-single-args-fix-under-fhg-single-args-equiv
        (<a href="SMT____FHG-SINGLE-ARGS-EQUIV.html">fhg-single-args-equiv</a> (<a href="SMT____FHG-SINGLE-ARGS-FIX.html">fhg-single-args-fix</a> acl2::x)
                               acl2::x)
        :rule-classes (:rewrite :rewrite-quoted-constant))</pre> 
<p><b>Theorem: </b>equal-of-fhg-single-args-fix-1-forward-to-fhg-single-args-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     equal-of-fhg-single-args-fix-1-forward-to-fhg-single-args-equiv
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-SINGLE-ARGS-FIX.html">fhg-single-args-fix</a> acl2::x)
                     acl2::y)
              (<a href="SMT____FHG-SINGLE-ARGS-EQUIV.html">fhg-single-args-equiv</a> acl2::x acl2::y))
     :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>equal-of-fhg-single-args-fix-2-forward-to-fhg-single-args-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     equal-of-fhg-single-args-fix-2-forward-to-fhg-single-args-equiv
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> acl2::x (<a href="SMT____FHG-SINGLE-ARGS-FIX.html">fhg-single-args-fix</a> acl2::y))
              (<a href="SMT____FHG-SINGLE-ARGS-EQUIV.html">fhg-single-args-equiv</a> acl2::x acl2::y))
     :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>fhg-single-args-equiv-of-fhg-single-args-fix-1-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     fhg-single-args-equiv-of-fhg-single-args-fix-1-forward
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FHG-SINGLE-ARGS-EQUIV.html">fhg-single-args-equiv</a> (<a href="SMT____FHG-SINGLE-ARGS-FIX.html">fhg-single-args-fix</a> acl2::x)
                                     acl2::y)
              (<a href="SMT____FHG-SINGLE-ARGS-EQUIV.html">fhg-single-args-equiv</a> acl2::x acl2::y))
     :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>fhg-single-args-equiv-of-fhg-single-args-fix-2-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  fhg-single-args-equiv-of-fhg-single-args-fix-2-forward
  (<a href="ACL2____IMPLIES.html">implies</a>
       (<a href="SMT____FHG-SINGLE-ARGS-EQUIV.html">fhg-single-args-equiv</a> acl2::x (<a href="SMT____FHG-SINGLE-ARGS-FIX.html">fhg-single-args-fix</a> acl2::y))
       (<a href="SMT____FHG-SINGLE-ARGS-EQUIV.html">fhg-single-args-equiv</a> acl2::x acl2::y))
  :rule-classes :forward-chaining)</pre> 
<p><b>Function: </b>fhg-single-args-&gt;fn$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> fhg-single-args-&gt;fn$inline (x)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____FHG-SINGLE-ARGS-P.html">fhg-single-args-p</a> x)))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'fhg-single-args-&gt;fn))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                            (<a href="SMT____FUNC-FIX.html">func-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x))))
                 :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x)))))</pre> 
<p><b>Theorem: </b>func-p-of-fhg-single-args-&gt;fn</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-p-of-fhg-single-args-&gt;fn
        (<a href="ACL2____B_A2.html">b*</a> ((fn (fhg-single-args-&gt;fn$inline x)))
            (<a href="SMT____FUNC-P.html">func-p</a> fn))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>fhg-single-args-&gt;fn$inline-of-fhg-single-args-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-single-args-&gt;fn$inline-of-fhg-single-args-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (fhg-single-args-&gt;fn$inline (<a href="SMT____FHG-SINGLE-ARGS-FIX.html">fhg-single-args-fix</a> x))
               (fhg-single-args-&gt;fn$inline x)))</pre> 
<p><b>Theorem: </b>fhg-single-args-&gt;fn$inline-fhg-single-args-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    fhg-single-args-&gt;fn$inline-fhg-single-args-equiv-congruence-on-x
    (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FHG-SINGLE-ARGS-EQUIV.html">fhg-single-args-equiv</a> x x-equiv)
             (<a href="COMMON-LISP____EQUAL.html">equal</a> (fhg-single-args-&gt;fn$inline x)
                    (fhg-single-args-&gt;fn$inline x-equiv)))
    :rule-classes :congruence)</pre> 
<p><b>Function: </b>fhg-single-args-&gt;actuals$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 fhg-single-args-&gt;actuals$inline (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____FHG-SINGLE-ARGS-P.html">fhg-single-args-p</a> x)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
     ((acl2::__function__ 'fhg-single-args-&gt;actuals))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
     (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                     (pseudo-term-list-fix (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x))))
          :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x)))))</pre> 
<p><b>Theorem: </b>pseudo-term-listp-of-fhg-single-args-&gt;actuals</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-listp-of-fhg-single-args-&gt;actuals
        (<a href="ACL2____B_A2.html">b*</a> ((actuals (fhg-single-args-&gt;actuals$inline x)))
            (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> actuals))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>fhg-single-args-&gt;actuals$inline-of-fhg-single-args-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    fhg-single-args-&gt;actuals$inline-of-fhg-single-args-fix-x
    (<a href="COMMON-LISP____EQUAL.html">equal</a> (fhg-single-args-&gt;actuals$inline (<a href="SMT____FHG-SINGLE-ARGS-FIX.html">fhg-single-args-fix</a> x))
           (fhg-single-args-&gt;actuals$inline x)))</pre> 
<p><b>Theorem: </b>fhg-single-args-&gt;actuals$inline-fhg-single-args-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 fhg-single-args-&gt;actuals$inline-fhg-single-args-equiv-congruence-on-x
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FHG-SINGLE-ARGS-EQUIV.html">fhg-single-args-equiv</a> x x-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (fhg-single-args-&gt;actuals$inline x)
                 (fhg-single-args-&gt;actuals$inline x-equiv)))
 :rule-classes :congruence)</pre> 
<p><b>Function: </b>fhg-single-args-&gt;fn-returns-hint-acc$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
  fhg-single-args-&gt;fn-returns-hint-acc$inline
  (x)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____FHG-SINGLE-ARGS-P.html">fhg-single-args-p</a> x)))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
  (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'fhg-single-args-&gt;fn-returns-hint-acc))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
       (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                       (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 2 x))))
            :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 2 x)))))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-fhg-single-args-&gt;fn-returns-hint-acc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-fhg-single-args-&gt;fn-returns-hint-acc
        (<a href="ACL2____B_A2.html">b*</a> ((fn-returns-hint-acc
                  (fhg-single-args-&gt;fn-returns-hint-acc$inline x)))
            (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> fn-returns-hint-acc))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>fhg-single-args-&gt;fn-returns-hint-acc$inline-of-fhg-single-args-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 fhg-single-args-&gt;fn-returns-hint-acc$inline-of-fhg-single-args-fix-x
 (<a href="COMMON-LISP____EQUAL.html">equal</a> (fhg-single-args-&gt;fn-returns-hint-acc$inline
             (<a href="SMT____FHG-SINGLE-ARGS-FIX.html">fhg-single-args-fix</a> x))
        (fhg-single-args-&gt;fn-returns-hint-acc$inline x)))</pre> 
<p><b>Theorem: </b>fhg-single-args-&gt;fn-returns-hint-acc$inline-fhg-single-args-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 fhg-single-args-&gt;fn-returns-hint-acc$inline-fhg-single-args-equiv-congruence-on-x
 (<a href="ACL2____IMPLIES.html">implies</a>
      (<a href="SMT____FHG-SINGLE-ARGS-EQUIV.html">fhg-single-args-equiv</a> x x-equiv)
      (<a href="COMMON-LISP____EQUAL.html">equal</a> (fhg-single-args-&gt;fn-returns-hint-acc$inline x)
             (fhg-single-args-&gt;fn-returns-hint-acc$inline x-equiv)))
 :rule-classes :congruence)</pre> 
<p><b>Function: </b>fhg-single-args-&gt;fn-more-returns-hint-acc$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 fhg-single-args-&gt;fn-more-returns-hint-acc$inline
 (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____FHG-SINGLE-ARGS-P.html">fhg-single-args-p</a> x)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
   ((acl2::__function__ 'fhg-single-args-&gt;fn-more-returns-hint-acc))
   (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
   (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                   (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 3 x))))
        :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 3 x)))))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-fhg-single-args-&gt;fn-more-returns-hint-acc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    hint-pair-listp-of-fhg-single-args-&gt;fn-more-returns-hint-acc
    (<a href="ACL2____B_A2.html">b*</a> ((fn-more-returns-hint-acc
              (fhg-single-args-&gt;fn-more-returns-hint-acc$inline x)))
        (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> fn-more-returns-hint-acc))
    :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>fhg-single-args-&gt;fn-more-returns-hint-acc$inline-of-fhg-single-args-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 fhg-single-args-&gt;fn-more-returns-hint-acc$inline-of-fhg-single-args-fix-x
 (<a href="COMMON-LISP____EQUAL.html">equal</a> (fhg-single-args-&gt;fn-more-returns-hint-acc$inline
             (<a href="SMT____FHG-SINGLE-ARGS-FIX.html">fhg-single-args-fix</a> x))
        (fhg-single-args-&gt;fn-more-returns-hint-acc$inline x)))</pre> 
<p><b>Theorem: </b>fhg-single-args-&gt;fn-more-returns-hint-acc$inline-fhg-single-args-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 fhg-single-args-&gt;fn-more-returns-hint-acc$inline-fhg-single-args-equiv-congruence-on-x
 (<a href="ACL2____IMPLIES.html">implies</a>
   (<a href="SMT____FHG-SINGLE-ARGS-EQUIV.html">fhg-single-args-equiv</a> x x-equiv)
   (<a href="COMMON-LISP____EQUAL.html">equal</a>
        (fhg-single-args-&gt;fn-more-returns-hint-acc$inline x)
        (fhg-single-args-&gt;fn-more-returns-hint-acc$inline x-equiv)))
 :rule-classes :congruence)</pre> 
<p><b>Function: </b>fhg-single-args-&gt;lambda-acc$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 fhg-single-args-&gt;lambda-acc$inline (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____FHG-SINGLE-ARGS-P.html">fhg-single-args-p</a> x)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'fhg-single-args-&gt;lambda-acc))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                  (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 4 x))))
       :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 4 x)))))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-fhg-single-args-&gt;lambda-acc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-listp-of-fhg-single-args-&gt;lambda-acc
        (<a href="ACL2____B_A2.html">b*</a> ((lambda-acc (fhg-single-args-&gt;lambda-acc$inline x)))
            (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> lambda-acc))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>fhg-single-args-&gt;lambda-acc$inline-of-fhg-single-args-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 fhg-single-args-&gt;lambda-acc$inline-of-fhg-single-args-fix-x
 (<a href="COMMON-LISP____EQUAL.html">equal</a> (fhg-single-args-&gt;lambda-acc$inline (<a href="SMT____FHG-SINGLE-ARGS-FIX.html">fhg-single-args-fix</a> x))
        (fhg-single-args-&gt;lambda-acc$inline x)))</pre> 
<p><b>Theorem: </b>fhg-single-args-&gt;lambda-acc$inline-fhg-single-args-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 fhg-single-args-&gt;lambda-acc$inline-fhg-single-args-equiv-congruence-on-x
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FHG-SINGLE-ARGS-EQUIV.html">fhg-single-args-equiv</a> x x-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (fhg-single-args-&gt;lambda-acc$inline x)
                 (fhg-single-args-&gt;lambda-acc$inline x-equiv)))
 :rule-classes :congruence)</pre> 
<p><b>Function: </b>fhg-single-args</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 fhg-single-args
 (fn actuals fn-returns-hint-acc
     fn-more-returns-hint-acc lambda-acc)
 (<a href="COMMON-LISP____DECLARE.html">declare</a>
      (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FUNC-P.html">func-p</a> fn)
                         (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> actuals)
                         (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> fn-returns-hint-acc)
                         (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> fn-more-returns-hint-acc)
                         (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> lambda-acc))))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'fhg-single-args))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____B_A2.html">b*</a>
     ((fn (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____FUNC-FIX.html">func-fix</a> fn) :exec fn))
      (actuals (<a href="ACL2____MBE.html">mbe</a> :logic (pseudo-term-list-fix actuals)
                    :exec actuals))
      (fn-returns-hint-acc
           (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> fn-returns-hint-acc)
                :exec fn-returns-hint-acc))
      (fn-more-returns-hint-acc
           (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> fn-more-returns-hint-acc)
                :exec fn-more-returns-hint-acc))
      (lambda-acc (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> lambda-acc)
                       :exec lambda-acc)))
     (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'fn fn)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'actuals actuals)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'fn-returns-hint-acc
                 fn-returns-hint-acc)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'fn-more-returns-hint-acc
                 fn-more-returns-hint-acc)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'lambda-acc lambda-acc)))))</pre> 
<p><b>Theorem: </b>fhg-single-args-p-of-fhg-single-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     fhg-single-args-p-of-fhg-single-args
     (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> fn actuals fn-returns-hint-acc
                              fn-more-returns-hint-acc lambda-acc)))
         (<a href="SMT____FHG-SINGLE-ARGS-P.html">fhg-single-args-p</a> x))
     :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>fhg-single-args-&gt;fn-of-fhg-single-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  fhg-single-args-&gt;fn-of-fhg-single-args
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-SINGLE-ARGS-_E3FN.html">fhg-single-args-&gt;fn</a>
              (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> fn actuals fn-returns-hint-acc
                               fn-more-returns-hint-acc lambda-acc))
         (<a href="SMT____FUNC-FIX.html">func-fix</a> fn)))</pre> 
<p><b>Theorem: </b>fhg-single-args-&gt;actuals-of-fhg-single-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  fhg-single-args-&gt;actuals-of-fhg-single-args
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-SINGLE-ARGS-_E3ACTUALS.html">fhg-single-args-&gt;actuals</a>
              (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> fn actuals fn-returns-hint-acc
                               fn-more-returns-hint-acc lambda-acc))
         (pseudo-term-list-fix actuals)))</pre> 
<p><b>Theorem: </b>fhg-single-args-&gt;fn-returns-hint-acc-of-fhg-single-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  fhg-single-args-&gt;fn-returns-hint-acc-of-fhg-single-args
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-SINGLE-ARGS-_E3FN-RETURNS-HINT-ACC.html">fhg-single-args-&gt;fn-returns-hint-acc</a>
              (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> fn actuals fn-returns-hint-acc
                               fn-more-returns-hint-acc lambda-acc))
         (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> fn-returns-hint-acc)))</pre> 
<p><b>Theorem: </b>fhg-single-args-&gt;fn-more-returns-hint-acc-of-fhg-single-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  fhg-single-args-&gt;fn-more-returns-hint-acc-of-fhg-single-args
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-SINGLE-ARGS-_E3FN-MORE-RETURNS-HINT-ACC.html">fhg-single-args-&gt;fn-more-returns-hint-acc</a>
              (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> fn actuals fn-returns-hint-acc
                               fn-more-returns-hint-acc lambda-acc))
         (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> fn-more-returns-hint-acc)))</pre> 
<p><b>Theorem: </b>fhg-single-args-&gt;lambda-acc-of-fhg-single-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  fhg-single-args-&gt;lambda-acc-of-fhg-single-args
  (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-SINGLE-ARGS-_E3LAMBDA-ACC.html">fhg-single-args-&gt;lambda-acc</a>
              (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> fn actuals fn-returns-hint-acc
                               fn-more-returns-hint-acc lambda-acc))
         (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> lambda-acc)))</pre> 
<p><b>Theorem: </b>fhg-single-args-of-fields</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 fhg-single-args-of-fields
 (<a href="COMMON-LISP____EQUAL.html">equal</a>
      (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> (<a href="SMT____FHG-SINGLE-ARGS-_E3FN.html">fhg-single-args-&gt;fn</a> x)
                       (<a href="SMT____FHG-SINGLE-ARGS-_E3ACTUALS.html">fhg-single-args-&gt;actuals</a> x)
                       (<a href="SMT____FHG-SINGLE-ARGS-_E3FN-RETURNS-HINT-ACC.html">fhg-single-args-&gt;fn-returns-hint-acc</a> x)
                       (<a href="SMT____FHG-SINGLE-ARGS-_E3FN-MORE-RETURNS-HINT-ACC.html">fhg-single-args-&gt;fn-more-returns-hint-acc</a> x)
                       (<a href="SMT____FHG-SINGLE-ARGS-_E3LAMBDA-ACC.html">fhg-single-args-&gt;lambda-acc</a> x))
      (<a href="SMT____FHG-SINGLE-ARGS-FIX.html">fhg-single-args-fix</a> x)))</pre> 
<p><b>Theorem: </b>fhg-single-args-fix-when-fhg-single-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 fhg-single-args-fix-when-fhg-single-args
 (<a href="COMMON-LISP____EQUAL.html">equal</a>
      (<a href="SMT____FHG-SINGLE-ARGS-FIX.html">fhg-single-args-fix</a> x)
      (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> (<a href="SMT____FHG-SINGLE-ARGS-_E3FN.html">fhg-single-args-&gt;fn</a> x)
                       (<a href="SMT____FHG-SINGLE-ARGS-_E3ACTUALS.html">fhg-single-args-&gt;actuals</a> x)
                       (<a href="SMT____FHG-SINGLE-ARGS-_E3FN-RETURNS-HINT-ACC.html">fhg-single-args-&gt;fn-returns-hint-acc</a> x)
                       (<a href="SMT____FHG-SINGLE-ARGS-_E3FN-MORE-RETURNS-HINT-ACC.html">fhg-single-args-&gt;fn-more-returns-hint-acc</a> x)
                       (<a href="SMT____FHG-SINGLE-ARGS-_E3LAMBDA-ACC.html">fhg-single-args-&gt;lambda-acc</a> x))))</pre> 
<p><b>Theorem: </b>equal-of-fhg-single-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 equal-of-fhg-single-args
 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> fn actuals fn-returns-hint-acc
                                fn-more-returns-hint-acc lambda-acc)
               x)
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FHG-SINGLE-ARGS-P.html">fhg-single-args-p</a> x)
             (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-SINGLE-ARGS-_E3FN.html">fhg-single-args-&gt;fn</a> x)
                    (<a href="SMT____FUNC-FIX.html">func-fix</a> fn))
             (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-SINGLE-ARGS-_E3ACTUALS.html">fhg-single-args-&gt;actuals</a> x)
                    (pseudo-term-list-fix actuals))
             (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-SINGLE-ARGS-_E3FN-RETURNS-HINT-ACC.html">fhg-single-args-&gt;fn-returns-hint-acc</a> x)
                    (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> fn-returns-hint-acc))
             (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-SINGLE-ARGS-_E3FN-MORE-RETURNS-HINT-ACC.html">fhg-single-args-&gt;fn-more-returns-hint-acc</a> x)
                    (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> fn-more-returns-hint-acc))
             (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-SINGLE-ARGS-_E3LAMBDA-ACC.html">fhg-single-args-&gt;lambda-acc</a> x)
                    (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> lambda-acc)))))</pre> 
<p><b>Theorem: </b>fhg-single-args-of-func-fix-fn</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     fhg-single-args-of-func-fix-fn
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> (<a href="SMT____FUNC-FIX.html">func-fix</a> fn)
                             actuals fn-returns-hint-acc
                             fn-more-returns-hint-acc lambda-acc)
            (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> fn actuals fn-returns-hint-acc
                             fn-more-returns-hint-acc lambda-acc)))</pre> 
<p><b>Theorem: </b>fhg-single-args-func-equiv-congruence-on-fn</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 fhg-single-args-func-equiv-congruence-on-fn
 (<a href="ACL2____IMPLIES.html">implies</a>
      (<a href="SMT____FUNC-EQUIV.html">func-equiv</a> fn fn-equiv)
      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> fn actuals fn-returns-hint-acc
                              fn-more-returns-hint-acc lambda-acc)
             (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> fn-equiv actuals fn-returns-hint-acc
                              fn-more-returns-hint-acc lambda-acc)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>fhg-single-args-of-pseudo-term-list-fix-actuals</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     fhg-single-args-of-pseudo-term-list-fix-actuals
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> fn (pseudo-term-list-fix actuals)
                             fn-returns-hint-acc
                             fn-more-returns-hint-acc lambda-acc)
            (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> fn actuals fn-returns-hint-acc
                             fn-more-returns-hint-acc lambda-acc)))</pre> 
<p><b>Theorem: </b>fhg-single-args-pseudo-term-list-equiv-congruence-on-actuals</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 fhg-single-args-pseudo-term-list-equiv-congruence-on-actuals
 (<a href="ACL2____IMPLIES.html">implies</a>
      (pseudo-term-list-equiv actuals actuals-equiv)
      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> fn actuals fn-returns-hint-acc
                              fn-more-returns-hint-acc lambda-acc)
             (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> fn actuals-equiv fn-returns-hint-acc
                              fn-more-returns-hint-acc lambda-acc)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>fhg-single-args-of-hint-pair-list-fix-fn-returns-hint-acc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    fhg-single-args-of-hint-pair-list-fix-fn-returns-hint-acc
    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> fn actuals
                            (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> fn-returns-hint-acc)
                            fn-more-returns-hint-acc lambda-acc)
           (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> fn actuals fn-returns-hint-acc
                            fn-more-returns-hint-acc lambda-acc)))</pre> 
<p><b>Theorem: </b>fhg-single-args-hint-pair-list-equiv-congruence-on-fn-returns-hint-acc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 fhg-single-args-hint-pair-list-equiv-congruence-on-fn-returns-hint-acc
 (<a href="ACL2____IMPLIES.html">implies</a>
      (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> fn-returns-hint-acc
                            fn-returns-hint-acc-equiv)
      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> fn actuals fn-returns-hint-acc
                              fn-more-returns-hint-acc lambda-acc)
             (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> fn actuals fn-returns-hint-acc-equiv
                              fn-more-returns-hint-acc lambda-acc)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>fhg-single-args-of-hint-pair-list-fix-fn-more-returns-hint-acc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 fhg-single-args-of-hint-pair-list-fix-fn-more-returns-hint-acc
 (<a href="COMMON-LISP____EQUAL.html">equal</a>
      (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> fn actuals fn-returns-hint-acc
                       (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> fn-more-returns-hint-acc)
                       lambda-acc)
      (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> fn actuals fn-returns-hint-acc
                       fn-more-returns-hint-acc lambda-acc)))</pre> 
<p><b>Theorem: </b>fhg-single-args-hint-pair-list-equiv-congruence-on-fn-more-returns-hint-acc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 fhg-single-args-hint-pair-list-equiv-congruence-on-fn-more-returns-hint-acc
 (<a href="ACL2____IMPLIES.html">implies</a>
      (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> fn-more-returns-hint-acc
                            fn-more-returns-hint-acc-equiv)
      (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> fn actuals fn-returns-hint-acc
                              fn-more-returns-hint-acc lambda-acc)
             (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> fn actuals fn-returns-hint-acc
                              fn-more-returns-hint-acc-equiv
                              lambda-acc)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>fhg-single-args-of-lambda-binding-list-fix-lambda-acc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     fhg-single-args-of-lambda-binding-list-fix-lambda-acc
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> fn actuals fn-returns-hint-acc
                             fn-more-returns-hint-acc
                             (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> lambda-acc))
            (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> fn actuals fn-returns-hint-acc
                             fn-more-returns-hint-acc lambda-acc)))</pre> 
<p><b>Theorem: </b>fhg-single-args-lambda-binding-list-equiv-congruence-on-lambda-acc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  fhg-single-args-lambda-binding-list-equiv-congruence-on-lambda-acc
  (<a href="ACL2____IMPLIES.html">implies</a>
       (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> lambda-acc lambda-acc-equiv)
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> fn actuals fn-returns-hint-acc
                               fn-more-returns-hint-acc lambda-acc)
              (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> fn actuals fn-returns-hint-acc
                               fn-more-returns-hint-acc
                               lambda-acc-equiv)))
  :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>fhg-single-args-fix-redef</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 fhg-single-args-fix-redef
 (<a href="COMMON-LISP____EQUAL.html">equal</a>
      (<a href="SMT____FHG-SINGLE-ARGS-FIX.html">fhg-single-args-fix</a> x)
      (<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> (<a href="SMT____FHG-SINGLE-ARGS-_E3FN.html">fhg-single-args-&gt;fn</a> x)
                       (<a href="SMT____FHG-SINGLE-ARGS-_E3ACTUALS.html">fhg-single-args-&gt;actuals</a> x)
                       (<a href="SMT____FHG-SINGLE-ARGS-_E3FN-RETURNS-HINT-ACC.html">fhg-single-args-&gt;fn-returns-hint-acc</a> x)
                       (<a href="SMT____FHG-SINGLE-ARGS-_E3FN-MORE-RETURNS-HINT-ACC.html">fhg-single-args-&gt;fn-more-returns-hint-acc</a> x)
                       (<a href="SMT____FHG-SINGLE-ARGS-_E3LAMBDA-ACC.html">fhg-single-args-&gt;lambda-acc</a> x)))
 :rule-classes :definition)</pre> 
<p><b>Function: </b>generate-fn-hint-pair</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 generate-fn-hint-pair (hypo args flag)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> hypo)
                             (<a href="SMT____FHG-SINGLE-ARGS-P.html">fhg-single-args-p</a> args)
                             (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> flag))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'generate-fn-hint-pair))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____B_A2.html">b*</a>
   ((hypo (<a href="SMT____HINT-PAIR-FIX.html">hint-pair-fix</a> hypo))
    (<a href="ACL2____ARGS.html">args</a> (<a href="SMT____FHG-SINGLE-ARGS-FIX.html">fhg-single-args-fix</a> args))
    (flag (<a href="ACL2____SYMBOL-FIX.html">symbol-fix</a> flag))
    ((<a href="SMT____HINT-PAIR.html">hint-pair</a> h) hypo)
    ((<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> a) args)
    ((<a href="SMT____FUNC.html">func</a> f) a.fn)
    (<a href="ACL2____FORMALS.html">formals</a> f.flattened-formals)
    (returns f.flattened-returns)
    ((unless (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> returns) 1))
     (<a href="ACL2____PROG2_42.html">prog2$</a>
      (<a href="ACL2____ER.html">er</a>
       hard?
       'smt-goal-generator=&gt;generate-fn-hint-pair
       "User ~
                defined function with more than one returns is not supported ~
                currently. ~%The function ~q0 has returns ~q1."
       f.name returns)
      (<a href="SMT____MAKE-HINT-PAIR.html">make-hint-pair</a>)))
    ((unless (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> formals) (<a href="ACL2____LEN.html">len</a> a.actuals)))
     (<a href="ACL2____PROG2_42.html">prog2$</a>
      (<a href="ACL2____ER.html">er</a>
       hard?
       'smt-goal-generator=&gt;generate-fn-hint-pair
       "Number ~
                of formals and actuals don't match. ~%Formals: ~q0, actuals: ~q1."
       formals a.actuals)
      (<a href="SMT____MAKE-HINT-PAIR.html">make-hint-pair</a>)))
    ((<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> f.name 'quote))
     (<a href="ACL2____PROG2_42.html">prog2$</a> (<a href="ACL2____ER.html">er</a> hard?
                 'smt-goal-generator=&gt;generate-fn-hint-pair
                 "Function name can't be 'quote.")
             (<a href="SMT____MAKE-HINT-PAIR.html">make-hint-pair</a>)))
    ((unless (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> flag 'more-returns)
                 (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> h.thm)
                      (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> h.thm)))))
     (<a href="ACL2____PROG2_42.html">prog2$</a> (<a href="ACL2____ER.html">er</a> hard?
                 'smt-goal-generator=&gt;generate-fn-hint-pair
                 "Returns should have consp h.thm.~%")
             (<a href="SMT____MAKE-HINT-PAIR.html">make-hint-pair</a>)))
    (<a href="ACL2____THM.html">thm</a> (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> flag 'more-returns)
             (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'lambda
                         (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____APPEND.html">append</a> formals returns)
                               (<a href="COMMON-LISP____CONS.html">cons</a> h.thm 'nil)))
                   (<a href="COMMON-LISP____APPEND.html">append</a> a.actuals
                           (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> f.name a.actuals) 'nil)))
             (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CAR.html">car</a> h.thm)
                   (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> f.name a.actuals) 'nil)))))
   (<a href="SMT____CHANGE-HINT-PAIR.html">change-hint-pair</a> h :thm thm))))</pre> 
<p><b>Theorem: </b>hint-pair-p-of-generate-fn-hint-pair</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-p-of-generate-fn-hint-pair
        (<a href="ACL2____B_A2.html">b*</a> ((fn-hint-pair (generate-fn-hint-pair hypo args flag)))
            (<a href="SMT____HINT-PAIR-P.html">hint-pair-p</a> fn-hint-pair))
        :rule-classes :rewrite)</pre> 
<p><b>Function: </b>generate-fn-returns-hint</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 generate-fn-returns-hint (returns args)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____DECL-LISTP.html">decl-listp</a> returns)
                             (<a href="SMT____FHG-SINGLE-ARGS-P.html">fhg-single-args-p</a> args))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'generate-fn-returns-hint))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____B_A2.html">b*</a>
    ((returns (<a href="SMT____DECL-LIST-FIX.html">decl-list-fix</a> returns))
     (<a href="ACL2____ARGS.html">args</a> (<a href="SMT____FHG-SINGLE-ARGS-FIX.html">fhg-single-args-fix</a> args))
     ((<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> a) args)
     ((unless (<a href="COMMON-LISP____CONSP.html">consp</a> returns))
      a.fn-returns-hint-acc)
     ((<a href="COMMON-LISP____CONS.html">cons</a> first rest) returns)
     ((<a href="SMT____DECL.html">decl</a> d) first)
     ((<a href="SMT____HINT-PAIR.html">hint-pair</a> h) d.type)
     (hypo (<a href="SMT____CHANGE-HINT-PAIR.html">change-hint-pair</a> h
                             :thm (<a href="COMMON-LISP____CONS.html">cons</a> h.thm (<a href="COMMON-LISP____CONS.html">cons</a> d.name 'nil))))
     (first-hint-pair (generate-fn-hint-pair hypo args 'returns)))
    (generate-fn-returns-hint
         rest
         (<a href="SMT____CHANGE-FHG-SINGLE-ARGS.html">change-fhg-single-args</a>
              a
              :fn-returns-hint-acc (<a href="COMMON-LISP____CONS.html">cons</a> first-hint-pair
                                         a.fn-returns-hint-acc))))))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-generate-fn-returns-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-generate-fn-returns-hint
        (<a href="ACL2____B_A2.html">b*</a> ((fn-hint-lst (generate-fn-returns-hint returns args)))
            (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> fn-hint-lst))
        :rule-classes :rewrite)</pre> 
<p><b>Function: </b>generate-fn-more-returns-hint</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 generate-fn-more-returns-hint
 (<a href="ACL2____MORE-RETURNS.html">more-returns</a> args)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> more-returns)
                             (<a href="SMT____FHG-SINGLE-ARGS-P.html">fhg-single-args-p</a> args))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'generate-fn-more-returns-hint))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____B_A2.html">b*</a>
   ((<a href="ACL2____MORE-RETURNS.html">more-returns</a> (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> more-returns))
    (<a href="ACL2____ARGS.html">args</a> (<a href="SMT____FHG-SINGLE-ARGS-FIX.html">fhg-single-args-fix</a> args))
    ((<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> a) args)
    ((unless (<a href="COMMON-LISP____CONSP.html">consp</a> more-returns))
     a.fn-more-returns-hint-acc)
    ((<a href="COMMON-LISP____CONS.html">cons</a> first rest) more-returns)
    (first-hint-pair
         (generate-fn-hint-pair first args 'more-returns)))
   (generate-fn-more-returns-hint
      rest
      (<a href="SMT____CHANGE-FHG-SINGLE-ARGS.html">change-fhg-single-args</a> a
                              :fn-more-returns-hint-acc
                              (<a href="COMMON-LISP____CONS.html">cons</a> first-hint-pair
                                    a.fn-more-returns-hint-acc))))))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-generate-fn-more-returns-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 hint-pair-listp-of-generate-fn-more-returns-hint
 (<a href="ACL2____B_A2.html">b*</a>
   ((fn-hint-lst (generate-fn-more-returns-hint more-returns args)))
   (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> fn-hint-lst))
 :rule-classes :rewrite)</pre> 
<p><b>Function: </b>generate-fn-hint</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 generate-fn-hint (<a href="ACL2____ARGS.html">args</a>)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____FHG-SINGLE-ARGS-P.html">fhg-single-args-p</a> args)))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'generate-fn-hint))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____B_A2.html">b*</a>
    ((<a href="ACL2____ARGS.html">args</a> (<a href="SMT____FHG-SINGLE-ARGS-FIX.html">fhg-single-args-fix</a> args))
     ((<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> a) args)
     ((<a href="SMT____FUNC.html">func</a> f) a.fn))
    (<a href="SMT____CHANGE-FHG-SINGLE-ARGS.html">change-fhg-single-args</a>
         a
         :fn-returns-hint-acc (generate-fn-returns-hint f.returns a)
         :fn-more-returns-hint-acc
         (generate-fn-more-returns-hint f.more-returns a)))))</pre> 
<p><b>Theorem: </b>fhg-single-args-p-of-generate-fn-hint</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-single-args-p-of-generate-fn-hint
        (<a href="ACL2____B_A2.html">b*</a> ((fn-hint-lst (generate-fn-hint args)))
            (<a href="SMT____FHG-SINGLE-ARGS-P.html">fhg-single-args-p</a> fn-hint-lst))
        :rule-classes :rewrite)</pre> 
<p><b>Function: </b>fhg-args-p</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 fhg-args-p (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'fhg-args-p))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="COMMON-LISP____AND.html">and</a>
   (<a href="ACL2____MBE.html">mbe</a>
       :logic
       (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____ALISTP.html">alistp</a> x)
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____STRIP-CARS.html">strip-cars</a> x)
                   '(term-lst fn-lst fn-returns-hint-acc
                              fn-more-returns-hint-acc lambda-acc)))
       :exec (fty::alist-with-carsp
                  x
                  '(term-lst fn-lst fn-returns-hint-acc
                             fn-more-returns-hint-acc lambda-acc)))
   (<a href="ACL2____B_A2.html">b*</a> ((term-lst (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x)))
        (fn-lst (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x)))
        (fn-returns-hint-acc (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 2 x)))
        (fn-more-returns-hint-acc (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 3 x)))
        (lambda-acc (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 4 x))))
       (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> term-lst)
            (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> fn-lst)
            (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> fn-returns-hint-acc)
            (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> fn-more-returns-hint-acc)
            (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> lambda-acc))))))</pre> 
<p><b>Theorem: </b>consp-when-fhg-args-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> consp-when-fhg-args-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FHG-ARGS-P.html">fhg-args-p</a> x) (<a href="COMMON-LISP____CONSP.html">consp</a> x))
        :rule-classes :compound-recognizer)</pre> 
<p><b>Function: </b>fhg-args-fix$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 fhg-args-fix$inline (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____FHG-ARGS-P.html">fhg-args-p</a> x)))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'fhg-args-fix))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____MBE.html">mbe</a>
   :logic
   (<a href="ACL2____B_A2.html">b*</a>
    ((term-lst (pseudo-term-list-fix (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x))))
     (fn-lst (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x))))
     (fn-returns-hint-acc
          (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 2 x))))
     (fn-more-returns-hint-acc
          (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 3 x))))
     (lambda-acc (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 4 x)))))
    (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'term-lst term-lst)
          (<a href="COMMON-LISP____CONS.html">cons</a> 'fn-lst fn-lst)
          (<a href="COMMON-LISP____CONS.html">cons</a> 'fn-returns-hint-acc
                fn-returns-hint-acc)
          (<a href="COMMON-LISP____CONS.html">cons</a> 'fn-more-returns-hint-acc
                fn-more-returns-hint-acc)
          (<a href="COMMON-LISP____CONS.html">cons</a> 'lambda-acc lambda-acc)))
   :exec x)))</pre> 
<p><b>Theorem: </b>fhg-args-p-of-fhg-args-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-args-p-of-fhg-args-fix
        (<a href="ACL2____B_A2.html">b*</a> ((new-x (fhg-args-fix$inline x)))
            (<a href="SMT____FHG-ARGS-P.html">fhg-args-p</a> new-x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>fhg-args-fix-when-fhg-args-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-args-fix-when-fhg-args-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FHG-ARGS-P.html">fhg-args-p</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-ARGS-FIX.html">fhg-args-fix</a> x) x)))</pre> 
<p><b>Function: </b>fhg-args-equiv$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> fhg-args-equiv$inline (acl2::x acl2::y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FHG-ARGS-P.html">fhg-args-p</a> acl2::x)
                                   (<a href="SMT____FHG-ARGS-P.html">fhg-args-p</a> acl2::y))))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-ARGS-FIX.html">fhg-args-fix</a> acl2::x)
              (<a href="SMT____FHG-ARGS-FIX.html">fhg-args-fix</a> acl2::y)))</pre> 
<p><b>Theorem: </b>fhg-args-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-args-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="SMT____FHG-ARGS-EQUIV.html">fhg-args-equiv</a> x y))
             (<a href="SMT____FHG-ARGS-EQUIV.html">fhg-args-equiv</a> x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FHG-ARGS-EQUIV.html">fhg-args-equiv</a> x y)
                      (<a href="SMT____FHG-ARGS-EQUIV.html">fhg-args-equiv</a> y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FHG-ARGS-EQUIV.html">fhg-args-equiv</a> x y)
                           (<a href="SMT____FHG-ARGS-EQUIV.html">fhg-args-equiv</a> y z))
                      (<a href="SMT____FHG-ARGS-EQUIV.html">fhg-args-equiv</a> x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>fhg-args-equiv-implies-equal-fhg-args-fix-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-args-equiv-implies-equal-fhg-args-fix-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FHG-ARGS-EQUIV.html">fhg-args-equiv</a> acl2::x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-ARGS-FIX.html">fhg-args-fix</a> acl2::x)
                        (<a href="SMT____FHG-ARGS-FIX.html">fhg-args-fix</a> x-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>fhg-args-fix-under-fhg-args-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-args-fix-under-fhg-args-equiv
        (<a href="SMT____FHG-ARGS-EQUIV.html">fhg-args-equiv</a> (<a href="SMT____FHG-ARGS-FIX.html">fhg-args-fix</a> acl2::x)
                        acl2::x)
        :rule-classes (:rewrite :rewrite-quoted-constant))</pre> 
<p><b>Theorem: </b>equal-of-fhg-args-fix-1-forward-to-fhg-args-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-fhg-args-fix-1-forward-to-fhg-args-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-ARGS-FIX.html">fhg-args-fix</a> acl2::x) acl2::y)
                 (<a href="SMT____FHG-ARGS-EQUIV.html">fhg-args-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>equal-of-fhg-args-fix-2-forward-to-fhg-args-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-fhg-args-fix-2-forward-to-fhg-args-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> acl2::x (<a href="SMT____FHG-ARGS-FIX.html">fhg-args-fix</a> acl2::y))
                 (<a href="SMT____FHG-ARGS-EQUIV.html">fhg-args-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>fhg-args-equiv-of-fhg-args-fix-1-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-args-equiv-of-fhg-args-fix-1-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FHG-ARGS-EQUIV.html">fhg-args-equiv</a> (<a href="SMT____FHG-ARGS-FIX.html">fhg-args-fix</a> acl2::x)
                                 acl2::y)
                 (<a href="SMT____FHG-ARGS-EQUIV.html">fhg-args-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>fhg-args-equiv-of-fhg-args-fix-2-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-args-equiv-of-fhg-args-fix-2-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FHG-ARGS-EQUIV.html">fhg-args-equiv</a> acl2::x (<a href="SMT____FHG-ARGS-FIX.html">fhg-args-fix</a> acl2::y))
                 (<a href="SMT____FHG-ARGS-EQUIV.html">fhg-args-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Function: </b>fhg-args-&gt;term-lst$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 fhg-args-&gt;term-lst$inline (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____FHG-ARGS-P.html">fhg-args-p</a> x)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
     ((acl2::__function__ 'fhg-args-&gt;term-lst))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
     (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                     (pseudo-term-list-fix (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x))))
          :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x)))))</pre> 
<p><b>Theorem: </b>pseudo-term-listp-of-fhg-args-&gt;term-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-listp-of-fhg-args-&gt;term-lst
        (<a href="ACL2____B_A2.html">b*</a> ((term-lst (fhg-args-&gt;term-lst$inline x)))
            (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> term-lst))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>fhg-args-&gt;term-lst$inline-of-fhg-args-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-args-&gt;term-lst$inline-of-fhg-args-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (fhg-args-&gt;term-lst$inline (<a href="SMT____FHG-ARGS-FIX.html">fhg-args-fix</a> x))
               (fhg-args-&gt;term-lst$inline x)))</pre> 
<p><b>Theorem: </b>fhg-args-&gt;term-lst$inline-fhg-args-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-args-&gt;term-lst$inline-fhg-args-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FHG-ARGS-EQUIV.html">fhg-args-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (fhg-args-&gt;term-lst$inline x)
                        (fhg-args-&gt;term-lst$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>fhg-args-&gt;fn-lst$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     fhg-args-&gt;fn-lst$inline (x)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____FHG-ARGS-P.html">fhg-args-p</a> x)))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
     (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'fhg-args-&gt;fn-lst))
          (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
          (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                          (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x))))
               :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x)))))</pre> 
<p><b>Theorem: </b>func-alistp-of-fhg-args-&gt;fn-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> func-alistp-of-fhg-args-&gt;fn-lst
        (<a href="ACL2____B_A2.html">b*</a> ((fn-lst (fhg-args-&gt;fn-lst$inline x)))
            (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> fn-lst))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>fhg-args-&gt;fn-lst$inline-of-fhg-args-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-args-&gt;fn-lst$inline-of-fhg-args-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (fhg-args-&gt;fn-lst$inline (<a href="SMT____FHG-ARGS-FIX.html">fhg-args-fix</a> x))
               (fhg-args-&gt;fn-lst$inline x)))</pre> 
<p><b>Theorem: </b>fhg-args-&gt;fn-lst$inline-fhg-args-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-args-&gt;fn-lst$inline-fhg-args-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FHG-ARGS-EQUIV.html">fhg-args-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (fhg-args-&gt;fn-lst$inline x)
                        (fhg-args-&gt;fn-lst$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>fhg-args-&gt;fn-returns-hint-acc$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
  fhg-args-&gt;fn-returns-hint-acc$inline (x)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____FHG-ARGS-P.html">fhg-args-p</a> x)))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
  (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'fhg-args-&gt;fn-returns-hint-acc))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
       (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                       (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 2 x))))
            :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 2 x)))))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-fhg-args-&gt;fn-returns-hint-acc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 hint-pair-listp-of-fhg-args-&gt;fn-returns-hint-acc
 (<a href="ACL2____B_A2.html">b*</a>
    ((fn-returns-hint-acc (fhg-args-&gt;fn-returns-hint-acc$inline x)))
    (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> fn-returns-hint-acc))
 :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>fhg-args-&gt;fn-returns-hint-acc$inline-of-fhg-args-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     fhg-args-&gt;fn-returns-hint-acc$inline-of-fhg-args-fix-x
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (fhg-args-&gt;fn-returns-hint-acc$inline (<a href="SMT____FHG-ARGS-FIX.html">fhg-args-fix</a> x))
            (fhg-args-&gt;fn-returns-hint-acc$inline x)))</pre> 
<p><b>Theorem: </b>fhg-args-&gt;fn-returns-hint-acc$inline-fhg-args-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 fhg-args-&gt;fn-returns-hint-acc$inline-fhg-args-equiv-congruence-on-x
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FHG-ARGS-EQUIV.html">fhg-args-equiv</a> x x-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (fhg-args-&gt;fn-returns-hint-acc$inline x)
                 (fhg-args-&gt;fn-returns-hint-acc$inline x-equiv)))
 :rule-classes :congruence)</pre> 
<p><b>Function: </b>fhg-args-&gt;fn-more-returns-hint-acc$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
  fhg-args-&gt;fn-more-returns-hint-acc$inline
  (x)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____FHG-ARGS-P.html">fhg-args-p</a> x)))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
  (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'fhg-args-&gt;fn-more-returns-hint-acc))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
       (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                       (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 3 x))))
            :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 3 x)))))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-fhg-args-&gt;fn-more-returns-hint-acc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-fhg-args-&gt;fn-more-returns-hint-acc
        (<a href="ACL2____B_A2.html">b*</a> ((fn-more-returns-hint-acc
                  (fhg-args-&gt;fn-more-returns-hint-acc$inline x)))
            (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> fn-more-returns-hint-acc))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>fhg-args-&gt;fn-more-returns-hint-acc$inline-of-fhg-args-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 fhg-args-&gt;fn-more-returns-hint-acc$inline-of-fhg-args-fix-x
 (<a href="COMMON-LISP____EQUAL.html">equal</a> (fhg-args-&gt;fn-more-returns-hint-acc$inline (<a href="SMT____FHG-ARGS-FIX.html">fhg-args-fix</a> x))
        (fhg-args-&gt;fn-more-returns-hint-acc$inline x)))</pre> 
<p><b>Theorem: </b>fhg-args-&gt;fn-more-returns-hint-acc$inline-fhg-args-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 fhg-args-&gt;fn-more-returns-hint-acc$inline-fhg-args-equiv-congruence-on-x
 (<a href="ACL2____IMPLIES.html">implies</a>
      (<a href="SMT____FHG-ARGS-EQUIV.html">fhg-args-equiv</a> x x-equiv)
      (<a href="COMMON-LISP____EQUAL.html">equal</a> (fhg-args-&gt;fn-more-returns-hint-acc$inline x)
             (fhg-args-&gt;fn-more-returns-hint-acc$inline x-equiv)))
 :rule-classes :congruence)</pre> 
<p><b>Function: </b>fhg-args-&gt;lambda-acc$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 fhg-args-&gt;lambda-acc$inline (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____FHG-ARGS-P.html">fhg-args-p</a> x)))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'fhg-args-&gt;lambda-acc))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                  (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 4 x))))
       :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 4 x)))))</pre> 
<p><b>Theorem: </b>lambda-binding-listp-of-fhg-args-&gt;lambda-acc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> lambda-binding-listp-of-fhg-args-&gt;lambda-acc
        (<a href="ACL2____B_A2.html">b*</a> ((lambda-acc (fhg-args-&gt;lambda-acc$inline x)))
            (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> lambda-acc))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>fhg-args-&gt;lambda-acc$inline-of-fhg-args-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-args-&gt;lambda-acc$inline-of-fhg-args-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (fhg-args-&gt;lambda-acc$inline (<a href="SMT____FHG-ARGS-FIX.html">fhg-args-fix</a> x))
               (fhg-args-&gt;lambda-acc$inline x)))</pre> 
<p><b>Theorem: </b>fhg-args-&gt;lambda-acc$inline-fhg-args-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-args-&gt;lambda-acc$inline-fhg-args-equiv-congruence-on-x
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FHG-ARGS-EQUIV.html">fhg-args-equiv</a> x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (fhg-args-&gt;lambda-acc$inline x)
                        (fhg-args-&gt;lambda-acc$inline x-equiv)))
        :rule-classes :congruence)</pre> 
<p><b>Function: </b>fhg-args</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 fhg-args
 (term-lst fn-lst fn-returns-hint-acc
           fn-more-returns-hint-acc lambda-acc)
 (<a href="COMMON-LISP____DECLARE.html">declare</a>
      (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> term-lst)
                         (<a href="SMT____FUNC-ALISTP.html">func-alistp</a> fn-lst)
                         (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> fn-returns-hint-acc)
                         (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> fn-more-returns-hint-acc)
                         (<a href="SMT____LAMBDA-BINDING-LISTP.html">lambda-binding-listp</a> lambda-acc))))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'fhg-args))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____B_A2.html">b*</a>
     ((term-lst (<a href="ACL2____MBE.html">mbe</a> :logic (pseudo-term-list-fix term-lst)
                     :exec term-lst))
      (fn-lst (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> fn-lst)
                   :exec fn-lst))
      (fn-returns-hint-acc
           (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> fn-returns-hint-acc)
                :exec fn-returns-hint-acc))
      (fn-more-returns-hint-acc
           (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> fn-more-returns-hint-acc)
                :exec fn-more-returns-hint-acc))
      (lambda-acc (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> lambda-acc)
                       :exec lambda-acc)))
     (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'term-lst term-lst)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'fn-lst fn-lst)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'fn-returns-hint-acc
                 fn-returns-hint-acc)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'fn-more-returns-hint-acc
                 fn-more-returns-hint-acc)
           (<a href="COMMON-LISP____CONS.html">cons</a> 'lambda-acc lambda-acc)))))</pre> 
<p><b>Theorem: </b>fhg-args-p-of-fhg-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-args-p-of-fhg-args
        (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="SMT____FHG-ARGS.html">fhg-args</a> term-lst fn-lst fn-returns-hint-acc
                          fn-more-returns-hint-acc lambda-acc)))
            (<a href="SMT____FHG-ARGS-P.html">fhg-args-p</a> x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>fhg-args-&gt;term-lst-of-fhg-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-args-&gt;term-lst-of-fhg-args
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-ARGS-_E3TERM-LST.html">fhg-args-&gt;term-lst</a>
                    (<a href="SMT____FHG-ARGS.html">fhg-args</a> term-lst fn-lst fn-returns-hint-acc
                              fn-more-returns-hint-acc lambda-acc))
               (pseudo-term-list-fix term-lst)))</pre> 
<p><b>Theorem: </b>fhg-args-&gt;fn-lst-of-fhg-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 fhg-args-&gt;fn-lst-of-fhg-args
 (<a href="COMMON-LISP____EQUAL.html">equal</a>
   (<a href="SMT____FHG-ARGS-_E3FN-LST.html">fhg-args-&gt;fn-lst</a> (<a href="SMT____FHG-ARGS.html">fhg-args</a> term-lst fn-lst fn-returns-hint-acc
                               fn-more-returns-hint-acc lambda-acc))
   (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> fn-lst)))</pre> 
<p><b>Theorem: </b>fhg-args-&gt;fn-returns-hint-acc-of-fhg-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-args-&gt;fn-returns-hint-acc-of-fhg-args
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-ARGS-_E3FN-RETURNS-HINT-ACC.html">fhg-args-&gt;fn-returns-hint-acc</a>
                    (<a href="SMT____FHG-ARGS.html">fhg-args</a> term-lst fn-lst fn-returns-hint-acc
                              fn-more-returns-hint-acc lambda-acc))
               (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> fn-returns-hint-acc)))</pre> 
<p><b>Theorem: </b>fhg-args-&gt;fn-more-returns-hint-acc-of-fhg-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-args-&gt;fn-more-returns-hint-acc-of-fhg-args
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-ARGS-_E3FN-MORE-RETURNS-HINT-ACC.html">fhg-args-&gt;fn-more-returns-hint-acc</a>
                    (<a href="SMT____FHG-ARGS.html">fhg-args</a> term-lst fn-lst fn-returns-hint-acc
                              fn-more-returns-hint-acc lambda-acc))
               (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> fn-more-returns-hint-acc)))</pre> 
<p><b>Theorem: </b>fhg-args-&gt;lambda-acc-of-fhg-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-args-&gt;lambda-acc-of-fhg-args
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-ARGS-_E3LAMBDA-ACC.html">fhg-args-&gt;lambda-acc</a>
                    (<a href="SMT____FHG-ARGS.html">fhg-args</a> term-lst fn-lst fn-returns-hint-acc
                              fn-more-returns-hint-acc lambda-acc))
               (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> lambda-acc)))</pre> 
<p><b>Theorem: </b>fhg-args-of-fields</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-args-of-fields
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-ARGS.html">fhg-args</a> (<a href="SMT____FHG-ARGS-_E3TERM-LST.html">fhg-args-&gt;term-lst</a> x)
                         (<a href="SMT____FHG-ARGS-_E3FN-LST.html">fhg-args-&gt;fn-lst</a> x)
                         (<a href="SMT____FHG-ARGS-_E3FN-RETURNS-HINT-ACC.html">fhg-args-&gt;fn-returns-hint-acc</a> x)
                         (<a href="SMT____FHG-ARGS-_E3FN-MORE-RETURNS-HINT-ACC.html">fhg-args-&gt;fn-more-returns-hint-acc</a> x)
                         (<a href="SMT____FHG-ARGS-_E3LAMBDA-ACC.html">fhg-args-&gt;lambda-acc</a> x))
               (<a href="SMT____FHG-ARGS-FIX.html">fhg-args-fix</a> x)))</pre> 
<p><b>Theorem: </b>fhg-args-fix-when-fhg-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-args-fix-when-fhg-args
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-ARGS-FIX.html">fhg-args-fix</a> x)
               (<a href="SMT____FHG-ARGS.html">fhg-args</a> (<a href="SMT____FHG-ARGS-_E3TERM-LST.html">fhg-args-&gt;term-lst</a> x)
                         (<a href="SMT____FHG-ARGS-_E3FN-LST.html">fhg-args-&gt;fn-lst</a> x)
                         (<a href="SMT____FHG-ARGS-_E3FN-RETURNS-HINT-ACC.html">fhg-args-&gt;fn-returns-hint-acc</a> x)
                         (<a href="SMT____FHG-ARGS-_E3FN-MORE-RETURNS-HINT-ACC.html">fhg-args-&gt;fn-more-returns-hint-acc</a> x)
                         (<a href="SMT____FHG-ARGS-_E3LAMBDA-ACC.html">fhg-args-&gt;lambda-acc</a> x))))</pre> 
<p><b>Theorem: </b>equal-of-fhg-args</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   equal-of-fhg-args
   (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-ARGS.html">fhg-args</a> term-lst fn-lst fn-returns-hint-acc
                           fn-more-returns-hint-acc lambda-acc)
                 x)
          (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FHG-ARGS-P.html">fhg-args-p</a> x)
               (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-ARGS-_E3TERM-LST.html">fhg-args-&gt;term-lst</a> x)
                      (pseudo-term-list-fix term-lst))
               (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-ARGS-_E3FN-LST.html">fhg-args-&gt;fn-lst</a> x)
                      (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> fn-lst))
               (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-ARGS-_E3FN-RETURNS-HINT-ACC.html">fhg-args-&gt;fn-returns-hint-acc</a> x)
                      (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> fn-returns-hint-acc))
               (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-ARGS-_E3FN-MORE-RETURNS-HINT-ACC.html">fhg-args-&gt;fn-more-returns-hint-acc</a> x)
                      (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> fn-more-returns-hint-acc))
               (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-ARGS-_E3LAMBDA-ACC.html">fhg-args-&gt;lambda-acc</a> x)
                      (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> lambda-acc)))))</pre> 
<p><b>Theorem: </b>fhg-args-of-pseudo-term-list-fix-term-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-args-of-pseudo-term-list-fix-term-lst
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-ARGS.html">fhg-args</a> (pseudo-term-list-fix term-lst)
                         fn-lst fn-returns-hint-acc
                         fn-more-returns-hint-acc lambda-acc)
               (<a href="SMT____FHG-ARGS.html">fhg-args</a> term-lst fn-lst fn-returns-hint-acc
                         fn-more-returns-hint-acc lambda-acc)))</pre> 
<p><b>Theorem: </b>fhg-args-pseudo-term-list-equiv-congruence-on-term-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    fhg-args-pseudo-term-list-equiv-congruence-on-term-lst
    (<a href="ACL2____IMPLIES.html">implies</a> (pseudo-term-list-equiv term-lst term-lst-equiv)
             (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-ARGS.html">fhg-args</a> term-lst fn-lst fn-returns-hint-acc
                              fn-more-returns-hint-acc lambda-acc)
                    (<a href="SMT____FHG-ARGS.html">fhg-args</a> term-lst-equiv
                              fn-lst fn-returns-hint-acc
                              fn-more-returns-hint-acc lambda-acc)))
    :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>fhg-args-of-func-alist-fix-fn-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-args-of-func-alist-fix-fn-lst
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-ARGS.html">fhg-args</a> term-lst (<a href="SMT____FUNC-ALIST-FIX.html">func-alist-fix</a> fn-lst)
                         fn-returns-hint-acc
                         fn-more-returns-hint-acc lambda-acc)
               (<a href="SMT____FHG-ARGS.html">fhg-args</a> term-lst fn-lst fn-returns-hint-acc
                         fn-more-returns-hint-acc lambda-acc)))</pre> 
<p><b>Theorem: </b>fhg-args-func-alist-equiv-congruence-on-fn-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    fhg-args-func-alist-equiv-congruence-on-fn-lst
    (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____FUNC-ALIST-EQUIV.html">func-alist-equiv</a> fn-lst fn-lst-equiv)
             (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-ARGS.html">fhg-args</a> term-lst fn-lst fn-returns-hint-acc
                              fn-more-returns-hint-acc lambda-acc)
                    (<a href="SMT____FHG-ARGS.html">fhg-args</a> term-lst
                              fn-lst-equiv fn-returns-hint-acc
                              fn-more-returns-hint-acc lambda-acc)))
    :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>fhg-args-of-hint-pair-list-fix-fn-returns-hint-acc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-args-of-hint-pair-list-fix-fn-returns-hint-acc
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-ARGS.html">fhg-args</a> term-lst fn-lst
                         (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> fn-returns-hint-acc)
                         fn-more-returns-hint-acc lambda-acc)
               (<a href="SMT____FHG-ARGS.html">fhg-args</a> term-lst fn-lst fn-returns-hint-acc
                         fn-more-returns-hint-acc lambda-acc)))</pre> 
<p><b>Theorem: </b>fhg-args-hint-pair-list-equiv-congruence-on-fn-returns-hint-acc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    fhg-args-hint-pair-list-equiv-congruence-on-fn-returns-hint-acc
    (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> fn-returns-hint-acc
                                   fn-returns-hint-acc-equiv)
             (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-ARGS.html">fhg-args</a> term-lst fn-lst fn-returns-hint-acc
                              fn-more-returns-hint-acc lambda-acc)
                    (<a href="SMT____FHG-ARGS.html">fhg-args</a> term-lst
                              fn-lst fn-returns-hint-acc-equiv
                              fn-more-returns-hint-acc lambda-acc)))
    :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>fhg-args-of-hint-pair-list-fix-fn-more-returns-hint-acc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     fhg-args-of-hint-pair-list-fix-fn-more-returns-hint-acc
     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-ARGS.html">fhg-args</a> term-lst fn-lst fn-returns-hint-acc
                      (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> fn-more-returns-hint-acc)
                      lambda-acc)
            (<a href="SMT____FHG-ARGS.html">fhg-args</a> term-lst fn-lst fn-returns-hint-acc
                      fn-more-returns-hint-acc lambda-acc)))</pre> 
<p><b>Theorem: </b>fhg-args-hint-pair-list-equiv-congruence-on-fn-more-returns-hint-acc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 fhg-args-hint-pair-list-equiv-congruence-on-fn-more-returns-hint-acc
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> fn-more-returns-hint-acc
                                fn-more-returns-hint-acc-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-ARGS.html">fhg-args</a> term-lst fn-lst fn-returns-hint-acc
                           fn-more-returns-hint-acc lambda-acc)
                 (<a href="SMT____FHG-ARGS.html">fhg-args</a> term-lst fn-lst fn-returns-hint-acc
                           fn-more-returns-hint-acc-equiv
                           lambda-acc)))
 :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>fhg-args-of-lambda-binding-list-fix-lambda-acc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-args-of-lambda-binding-list-fix-lambda-acc
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-ARGS.html">fhg-args</a> term-lst fn-lst fn-returns-hint-acc
                         fn-more-returns-hint-acc
                         (<a href="SMT____LAMBDA-BINDING-LIST-FIX.html">lambda-binding-list-fix</a> lambda-acc))
               (<a href="SMT____FHG-ARGS.html">fhg-args</a> term-lst fn-lst fn-returns-hint-acc
                         fn-more-returns-hint-acc lambda-acc)))</pre> 
<p><b>Theorem: </b>fhg-args-lambda-binding-list-equiv-congruence-on-lambda-acc</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    fhg-args-lambda-binding-list-equiv-congruence-on-lambda-acc
    (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____LAMBDA-BINDING-LIST-EQUIV.html">lambda-binding-list-equiv</a> lambda-acc lambda-acc-equiv)
             (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-ARGS.html">fhg-args</a> term-lst fn-lst fn-returns-hint-acc
                              fn-more-returns-hint-acc lambda-acc)
                    (<a href="SMT____FHG-ARGS.html">fhg-args</a> term-lst fn-lst fn-returns-hint-acc
                              fn-more-returns-hint-acc
                              lambda-acc-equiv)))
    :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>fhg-args-fix-redef</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-args-fix-redef
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____FHG-ARGS-FIX.html">fhg-args-fix</a> x)
               (<a href="SMT____FHG-ARGS.html">fhg-args</a> (<a href="SMT____FHG-ARGS-_E3TERM-LST.html">fhg-args-&gt;term-lst</a> x)
                         (<a href="SMT____FHG-ARGS-_E3FN-LST.html">fhg-args-&gt;fn-lst</a> x)
                         (<a href="SMT____FHG-ARGS-_E3FN-RETURNS-HINT-ACC.html">fhg-args-&gt;fn-returns-hint-acc</a> x)
                         (<a href="SMT____FHG-ARGS-_E3FN-MORE-RETURNS-HINT-ACC.html">fhg-args-&gt;fn-more-returns-hint-acc</a> x)
                         (<a href="SMT____FHG-ARGS-_E3LAMBDA-ACC.html">fhg-args-&gt;lambda-acc</a> x)))
        :rule-classes :definition)</pre> 
<p><b>Theorem: </b>not-symbolp-then-consp-of-car-of-fhg-args-&gt;term-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     not-symbolp-then-consp-of-car-of-fhg-args-&gt;term-lst
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FHG-ARGS-P.html">fhg-args-p</a> args)
                   (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____FHG-ARGS-_E3TERM-LST.html">fhg-args-&gt;term-lst</a> args))
                   (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____FHG-ARGS-_E3TERM-LST.html">fhg-args-&gt;term-lst</a> args)))))
              (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____FHG-ARGS-_E3TERM-LST.html">fhg-args-&gt;term-lst</a> args)))))</pre> 
<p><b>Theorem: </b>pseudo-term-listp-of-cdr-of-fhg-args-&gt;term-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     pseudo-term-listp-of-cdr-of-fhg-args-&gt;term-lst
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FHG-ARGS-P.html">fhg-args-p</a> args)
                   (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____FHG-ARGS-_E3TERM-LST.html">fhg-args-&gt;term-lst</a> args)))
              (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="SMT____FHG-ARGS-_E3TERM-LST.html">fhg-args-&gt;term-lst</a> args)))))</pre> 
<p><b>Theorem: </b>pseudo-term-listp-of-cdar-of-fhg-args-&gt;term-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
    pseudo-term-listp-of-cdar-of-fhg-args-&gt;term-lst
    (<a href="ACL2____IMPLIES.html">implies</a>
         (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FHG-ARGS-P.html">fhg-args-p</a> args)
              (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____FHG-ARGS-_E3TERM-LST.html">fhg-args-&gt;term-lst</a> args))
              (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____FHG-ARGS-_E3TERM-LST.html">fhg-args-&gt;term-lst</a> args))))
              (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____FHG-ARGS-_E3TERM-LST.html">fhg-args-&gt;term-lst</a> args)))
                          'quote)))
         (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____FHG-ARGS-_E3TERM-LST.html">fhg-args-&gt;term-lst</a> args))))))</pre> 
<p><b>Theorem: </b>symbolp-of-caar-of-fhg-args-&gt;term-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 symbolp-of-caar-of-fhg-args-&gt;term-lst
 (<a href="ACL2____IMPLIES.html">implies</a>
  (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FHG-ARGS-P.html">fhg-args-p</a> args)
       (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____FHG-ARGS-_E3TERM-LST.html">fhg-args-&gt;term-lst</a> args))
       (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____FHG-ARGS-_E3TERM-LST.html">fhg-args-&gt;term-lst</a> args))))
       (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____PSEUDO-LAMBDAP.html">pseudo-lambdap</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____FHG-ARGS-_E3TERM-LST.html">fhg-args-&gt;term-lst</a> args))))))
  (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____FHG-ARGS-_E3TERM-LST.html">fhg-args-&gt;term-lst</a> args))))))</pre> 
<p><b>Theorem: </b>len-equal-of-formals-of-pseudo-lambdap-and-actuals</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   len-equal-of-formals-of-pseudo-lambdap-and-actuals
   (<a href="ACL2____IMPLIES.html">implies</a>
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FHG-ARGS-P.html">fhg-args-p</a> args)
             (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____FHG-ARGS-_E3TERM-LST.html">fhg-args-&gt;term-lst</a> args))
             (<a href="ACL2____PSEUDO-LAMBDAP.html">pseudo-lambdap</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____FHG-ARGS-_E3TERM-LST.html">fhg-args-&gt;term-lst</a> args)))))
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> (<a href="COMMON-LISP____CADR.html">cadr</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____FHG-ARGS-_E3TERM-LST.html">fhg-args-&gt;term-lst</a> args)))))
               (<a href="ACL2____LEN.html">len</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____FHG-ARGS-_E3TERM-LST.html">fhg-args-&gt;term-lst</a> args)))))))</pre> 
<p><b>Theorem: </b>lemma-8</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 lemma-8
 (<a href="ACL2____IMPLIES.html">implies</a>
     (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FHG-ARGS-P.html">fhg-args-p</a> args)
          (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____FHG-ARGS-_E3TERM-LST.html">fhg-args-&gt;term-lst</a> args))
          (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____FHG-ARGS-_E3TERM-LST.html">fhg-args-&gt;term-lst</a> args)))
                       (<a href="SMT____FHG-ARGS-_E3FN-LST.html">fhg-args-&gt;fn-lst</a> args)))
     (<a href="SMT____FUNC-P.html">func-p</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____FHG-ARGS-_E3TERM-LST.html">fhg-args-&gt;term-lst</a> args)))
                               (<a href="SMT____FHG-ARGS-_E3FN-LST.html">fhg-args-&gt;fn-lst</a> args))))))</pre> 
<p><b>Theorem: </b>lemma-10</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  lemma-10
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____FHG-ARGS-P.html">fhg-args-p</a> args)
                (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="SMT____FHG-ARGS-_E3TERM-LST.html">fhg-args-&gt;term-lst</a> args))
                (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____FHG-ARGS-_E3TERM-LST.html">fhg-args-&gt;term-lst</a> args)))
                             (<a href="SMT____FHG-ARGS-_E3FN-LST.html">fhg-args-&gt;fn-lst</a> args)))
           (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="COMMON-LISP____CAR.html">car</a> (<a href="SMT____FHG-ARGS-_E3TERM-LST.html">fhg-args-&gt;term-lst</a> args)))
                               (<a href="SMT____FHG-ARGS-_E3FN-LST.html">fhg-args-&gt;fn-lst</a> args)))))</pre> 
<p><b>Function: </b>generate-fn-hint-lst</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 generate-fn-hint-lst (<a href="ACL2____ARGS.html">args</a>)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____FHG-ARGS-P.html">fhg-args-p</a> args)))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'generate-fn-hint-lst))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____B_A2.html">b*</a>
   ((<a href="ACL2____ARGS.html">args</a> (<a href="SMT____FHG-ARGS-FIX.html">fhg-args-fix</a> args))
    ((<a href="SMT____FHG-ARGS.html">fhg-args</a> a) args)
    ((unless (<a href="COMMON-LISP____CONSP.html">consp</a> a.term-lst)) a)
    ((<a href="COMMON-LISP____CONS.html">cons</a> term rest) a.term-lst)
    ((<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> term))
     (<a href="SMT____GENERATE-FN-HINT-LST.html">generate-fn-hint-lst</a> (<a href="SMT____CHANGE-FHG-ARGS.html">change-fhg-args</a> a :term-lst rest)))
    ((<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> term) 'quote))
     (<a href="SMT____GENERATE-FN-HINT-LST.html">generate-fn-hint-lst</a> (<a href="SMT____CHANGE-FHG-ARGS.html">change-fhg-args</a> a :term-lst rest)))
    ((<a href="COMMON-LISP____CONS.html">cons</a> fn-call fn-actuals) term)
    ((<a href="COMMON-LISP____IF.html">if</a> (<a href="ACL2____PSEUDO-LAMBDAP.html">pseudo-lambdap</a> fn-call))
     (<a href="ACL2____B_A2.html">b*</a>
       ((<a href="ACL2____LAMBDA-FORMALS.html">lambda-formals</a> (<a href="ACL2____LAMBDA-FORMALS.html">lambda-formals</a> fn-call))
        (<a href="ACL2____LAMBDA-BODY.html">lambda-body</a> (<a href="ACL2____LAMBDA-BODY.html">lambda-body</a> fn-call))
        (lambda-actuals fn-actuals)
        (lambda-bd (<a href="SMT____MAKE-LAMBDA-BINDING.html">make-lambda-binding</a> :formals lambda-formals
                                        :actuals lambda-actuals))
        ((unless (<a href="ACL2____MBT.html">mbt</a> (<a href="SMT____LAMBDA-BINDING-P.html">lambda-binding-p</a> lambda-bd)))
         a)
        (a-1 (<a href="SMT____GENERATE-FN-HINT-LST.html">generate-fn-hint-lst</a>
                  (<a href="SMT____CHANGE-FHG-ARGS.html">change-fhg-args</a>
                       a
                       :term-lst (<a href="COMMON-LISP____LIST.html">list</a> lambda-body)
                       :lambda-acc (<a href="COMMON-LISP____CONS.html">cons</a> lambda-bd a.lambda-acc))))
        (a-2 (<a href="SMT____GENERATE-FN-HINT-LST.html">generate-fn-hint-lst</a>
                  (<a href="SMT____CHANGE-FHG-ARGS.html">change-fhg-args</a> a-1
                                   :term-lst lambda-actuals))))
       (<a href="SMT____GENERATE-FN-HINT-LST.html">generate-fn-hint-lst</a> (<a href="SMT____CHANGE-FHG-ARGS.html">change-fhg-args</a> a-2 :term-lst rest))))
    ((unless (<a href="ACL2____MBT.html">mbt</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> fn-call))) a)
    (fn (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> fn-call a.fn-lst))
    ((unless fn)
     (<a href="ACL2____B_A2.html">b*</a>
       ((a-1 (<a href="SMT____GENERATE-FN-HINT-LST.html">generate-fn-hint-lst</a>
                  (<a href="SMT____CHANGE-FHG-ARGS.html">change-fhg-args</a> a
                                   :term-lst fn-actuals))))
       (<a href="SMT____GENERATE-FN-HINT-LST.html">generate-fn-hint-lst</a> (<a href="SMT____CHANGE-FHG-ARGS.html">change-fhg-args</a> a-1 :term-lst rest))))
    (f (<a href="COMMON-LISP____CDR.html">cdr</a> fn))
    (as-1
      (generate-fn-hint
           (<a href="SMT____MAKE-FHG-SINGLE-ARGS.html">make-fhg-single-args</a>
                :fn f
                :actuals fn-actuals
                :fn-returns-hint-acc a.fn-returns-hint-acc
                :fn-more-returns-hint-acc a.fn-more-returns-hint-acc
                :lambda-acc a.lambda-acc)))
    ((<a href="SMT____FHG-SINGLE-ARGS.html">fhg-single-args</a> as-1) as-1)
    (a-1
      (<a href="SMT____CHANGE-FHG-ARGS.html">change-fhg-args</a>
           a
           :fn-returns-hint-acc as-1.fn-returns-hint-acc
           :fn-more-returns-hint-acc as-1.fn-more-returns-hint-acc))
    (a-2
     (<a href="SMT____GENERATE-FN-HINT-LST.html">generate-fn-hint-lst</a> (<a href="SMT____CHANGE-FHG-ARGS.html">change-fhg-args</a> a-1
                                            :term-lst fn-actuals))))
   (<a href="SMT____GENERATE-FN-HINT-LST.html">generate-fn-hint-lst</a> (<a href="SMT____CHANGE-FHG-ARGS.html">change-fhg-args</a> a-2 :term-lst rest)))))</pre> 
<p><b>Theorem: </b>fhg-args-p-of-generate-fn-hint-lst</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> fhg-args-p-of-generate-fn-hint-lst
        (<a href="ACL2____B_A2.html">b*</a> ((fn-hint-lst (<a href="SMT____GENERATE-FN-HINT-LST.html">generate-fn-hint-lst</a> args)))
            (<a href="SMT____FHG-ARGS-P.html">fhg-args-p</a> fn-hint-lst))
        :rule-classes :rewrite)</pre> 
<p><b>Function: </b>uninterpreted-p</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 uninterpreted-p (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'uninterpreted-p))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____ALISTP.html">alistp</a> x)
                        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____STRIP-CARS.html">strip-cars</a> x)
                               '(returns more-returns)))
            :exec (fty::alist-with-carsp x '(returns more-returns)))
       (<a href="ACL2____B_A2.html">b*</a> ((returns (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x)))
            (<a href="ACL2____MORE-RETURNS.html">more-returns</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x))))
           (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> returns)
                (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> more-returns))))))</pre> 
<p><b>Theorem: </b>consp-when-uninterpreted-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> consp-when-uninterpreted-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____UNINTERPRETED-P.html">uninterpreted-p</a> x) (<a href="COMMON-LISP____CONSP.html">consp</a> x))
        :rule-classes :compound-recognizer)</pre> 
<p><b>Function: </b>uninterpreted-fix$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 uninterpreted-fix$inline (x)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____UNINTERPRETED-P.html">uninterpreted-p</a> x)))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'uninterpreted-fix))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____MBE.html">mbe</a>
   :logic
   (<a href="ACL2____B_A2.html">b*</a> ((returns (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x))))
        (<a href="ACL2____MORE-RETURNS.html">more-returns</a> (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x)))))
       (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'returns returns)
             (<a href="COMMON-LISP____CONS.html">cons</a> 'more-returns more-returns)))
   :exec x)))</pre> 
<p><b>Theorem: </b>uninterpreted-p-of-uninterpreted-fix</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> uninterpreted-p-of-uninterpreted-fix
        (<a href="ACL2____B_A2.html">b*</a> ((new-x (uninterpreted-fix$inline x)))
            (<a href="SMT____UNINTERPRETED-P.html">uninterpreted-p</a> new-x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>uninterpreted-fix-when-uninterpreted-p</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> uninterpreted-fix-when-uninterpreted-p
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____UNINTERPRETED-P.html">uninterpreted-p</a> x)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____UNINTERPRETED-FIX.html">uninterpreted-fix</a> x) x)))</pre> 
<p><b>Function: </b>uninterpreted-equiv$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> uninterpreted-equiv$inline
       (acl2::x acl2::y)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____UNINTERPRETED-P.html">uninterpreted-p</a> acl2::x)
                                   (<a href="SMT____UNINTERPRETED-P.html">uninterpreted-p</a> acl2::y))))
       (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____UNINTERPRETED-FIX.html">uninterpreted-fix</a> acl2::x)
              (<a href="SMT____UNINTERPRETED-FIX.html">uninterpreted-fix</a> acl2::y)))</pre> 
<p><b>Theorem: </b>uninterpreted-equiv-is-an-equivalence</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> uninterpreted-equiv-is-an-equivalence
        (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____BOOLEANP.html">booleanp</a> (<a href="SMT____UNINTERPRETED-EQUIV.html">uninterpreted-equiv</a> x y))
             (<a href="SMT____UNINTERPRETED-EQUIV.html">uninterpreted-equiv</a> x x)
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____UNINTERPRETED-EQUIV.html">uninterpreted-equiv</a> x y)
                      (<a href="SMT____UNINTERPRETED-EQUIV.html">uninterpreted-equiv</a> y x))
             (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____UNINTERPRETED-EQUIV.html">uninterpreted-equiv</a> x y)
                           (<a href="SMT____UNINTERPRETED-EQUIV.html">uninterpreted-equiv</a> y z))
                      (<a href="SMT____UNINTERPRETED-EQUIV.html">uninterpreted-equiv</a> x z)))
        :rule-classes (:equivalence))</pre> 
<p><b>Theorem: </b>uninterpreted-equiv-implies-equal-uninterpreted-fix-1</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> uninterpreted-equiv-implies-equal-uninterpreted-fix-1
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____UNINTERPRETED-EQUIV.html">uninterpreted-equiv</a> acl2::x x-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____UNINTERPRETED-FIX.html">uninterpreted-fix</a> acl2::x)
                        (<a href="SMT____UNINTERPRETED-FIX.html">uninterpreted-fix</a> x-equiv)))
        :rule-classes (:congruence))</pre> 
<p><b>Theorem: </b>uninterpreted-fix-under-uninterpreted-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> uninterpreted-fix-under-uninterpreted-equiv
        (<a href="SMT____UNINTERPRETED-EQUIV.html">uninterpreted-equiv</a> (<a href="SMT____UNINTERPRETED-FIX.html">uninterpreted-fix</a> acl2::x)
                             acl2::x)
        :rule-classes (:rewrite :rewrite-quoted-constant))</pre> 
<p><b>Theorem: </b>equal-of-uninterpreted-fix-1-forward-to-uninterpreted-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-uninterpreted-fix-1-forward-to-uninterpreted-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____UNINTERPRETED-FIX.html">uninterpreted-fix</a> acl2::x)
                        acl2::y)
                 (<a href="SMT____UNINTERPRETED-EQUIV.html">uninterpreted-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>equal-of-uninterpreted-fix-2-forward-to-uninterpreted-equiv</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-uninterpreted-fix-2-forward-to-uninterpreted-equiv
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> acl2::x (<a href="SMT____UNINTERPRETED-FIX.html">uninterpreted-fix</a> acl2::y))
                 (<a href="SMT____UNINTERPRETED-EQUIV.html">uninterpreted-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>uninterpreted-equiv-of-uninterpreted-fix-1-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> uninterpreted-equiv-of-uninterpreted-fix-1-forward
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____UNINTERPRETED-EQUIV.html">uninterpreted-equiv</a> (<a href="SMT____UNINTERPRETED-FIX.html">uninterpreted-fix</a> acl2::x)
                                      acl2::y)
                 (<a href="SMT____UNINTERPRETED-EQUIV.html">uninterpreted-equiv</a> acl2::x acl2::y))
        :rule-classes :forward-chaining)</pre> 
<p><b>Theorem: </b>uninterpreted-equiv-of-uninterpreted-fix-2-forward</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  uninterpreted-equiv-of-uninterpreted-fix-2-forward
  (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____UNINTERPRETED-EQUIV.html">uninterpreted-equiv</a> acl2::x (<a href="SMT____UNINTERPRETED-FIX.html">uninterpreted-fix</a> acl2::y))
           (<a href="SMT____UNINTERPRETED-EQUIV.html">uninterpreted-equiv</a> acl2::x acl2::y))
  :rule-classes :forward-chaining)</pre> 
<p><b>Function: </b>uninterpreted-&gt;returns$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
  uninterpreted-&gt;returns$inline (x)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____UNINTERPRETED-P.html">uninterpreted-p</a> x)))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
  (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'uninterpreted-&gt;returns))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
       (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                       (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x))))
            :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 0 x)))))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-uninterpreted-&gt;returns</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-uninterpreted-&gt;returns
        (<a href="ACL2____B_A2.html">b*</a> ((returns (uninterpreted-&gt;returns$inline x)))
            (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> returns))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>uninterpreted-&gt;returns$inline-of-uninterpreted-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> uninterpreted-&gt;returns$inline-of-uninterpreted-fix-x
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (uninterpreted-&gt;returns$inline (<a href="SMT____UNINTERPRETED-FIX.html">uninterpreted-fix</a> x))
               (uninterpreted-&gt;returns$inline x)))</pre> 
<p><b>Theorem: </b>uninterpreted-&gt;returns$inline-uninterpreted-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   uninterpreted-&gt;returns$inline-uninterpreted-equiv-congruence-on-x
   (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____UNINTERPRETED-EQUIV.html">uninterpreted-equiv</a> x x-equiv)
            (<a href="COMMON-LISP____EQUAL.html">equal</a> (uninterpreted-&gt;returns$inline x)
                   (uninterpreted-&gt;returns$inline x-equiv)))
   :rule-classes :congruence)</pre> 
<p><b>Function: </b>uninterpreted-&gt;more-returns$inline</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
  uninterpreted-&gt;more-returns$inline (x)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="SMT____UNINTERPRETED-P.html">uninterpreted-p</a> x)))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
  (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'uninterpreted-&gt;more-returns))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
       (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="COMMON-LISP____AND.html">and</a> t x)))
                       (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x))))
            :exec (<a href="COMMON-LISP____CDR.html">cdr</a> (std::da-nth 1 x)))))</pre> 
<p><b>Theorem: </b>hint-pair-listp-of-uninterpreted-&gt;more-returns</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> hint-pair-listp-of-uninterpreted-&gt;more-returns
        (<a href="ACL2____B_A2.html">b*</a> ((<a href="ACL2____MORE-RETURNS.html">more-returns</a> (uninterpreted-&gt;more-returns$inline x)))
            (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> more-returns))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>uninterpreted-&gt;more-returns$inline-of-uninterpreted-fix-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
   uninterpreted-&gt;more-returns$inline-of-uninterpreted-fix-x
   (<a href="COMMON-LISP____EQUAL.html">equal</a> (uninterpreted-&gt;more-returns$inline (<a href="SMT____UNINTERPRETED-FIX.html">uninterpreted-fix</a> x))
          (uninterpreted-&gt;more-returns$inline x)))</pre> 
<p><b>Theorem: </b>uninterpreted-&gt;more-returns$inline-uninterpreted-equiv-congruence-on-x</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 uninterpreted-&gt;more-returns$inline-uninterpreted-equiv-congruence-on-x
 (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____UNINTERPRETED-EQUIV.html">uninterpreted-equiv</a> x x-equiv)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (uninterpreted-&gt;more-returns$inline x)
                 (uninterpreted-&gt;more-returns$inline x-equiv)))
 :rule-classes :congruence)</pre> 
<p><b>Function: </b>uninterpreted</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 uninterpreted (returns more-returns)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> returns)
                             (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> more-returns))))
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard t))
 (<a href="COMMON-LISP____LET.html">let</a>
    ((acl2::__function__ 'uninterpreted))
    (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
    (<a href="ACL2____B_A2.html">b*</a> ((returns (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> returns)
                       :exec returns))
         (<a href="ACL2____MORE-RETURNS.html">more-returns</a> (<a href="ACL2____MBE.html">mbe</a> :logic (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> more-returns)
                            :exec more-returns)))
        (<a href="COMMON-LISP____LIST.html">list</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'returns returns)
              (<a href="COMMON-LISP____CONS.html">cons</a> 'more-returns more-returns)))))</pre> 
<p><b>Theorem: </b>uninterpreted-p-of-uninterpreted</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> uninterpreted-p-of-uninterpreted
        (<a href="ACL2____B_A2.html">b*</a> ((x (<a href="SMT____UNINTERPRETED.html">uninterpreted</a> returns more-returns)))
            (<a href="SMT____UNINTERPRETED-P.html">uninterpreted-p</a> x))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>uninterpreted-&gt;returns-of-uninterpreted</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
  uninterpreted-&gt;returns-of-uninterpreted
  (<a href="COMMON-LISP____EQUAL.html">equal</a>
       (<a href="SMT____UNINTERPRETED-_E3RETURNS.html">uninterpreted-&gt;returns</a> (<a href="SMT____UNINTERPRETED.html">uninterpreted</a> returns more-returns))
       (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> returns)))</pre> 
<p><b>Theorem: </b>uninterpreted-&gt;more-returns-of-uninterpreted</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 uninterpreted-&gt;more-returns-of-uninterpreted
 (<a href="COMMON-LISP____EQUAL.html">equal</a>
  (<a href="SMT____UNINTERPRETED-_E3MORE-RETURNS.html">uninterpreted-&gt;more-returns</a> (<a href="SMT____UNINTERPRETED.html">uninterpreted</a> returns more-returns))
  (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> more-returns)))</pre> 
<p><b>Theorem: </b>uninterpreted-of-fields</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> uninterpreted-of-fields
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____UNINTERPRETED.html">uninterpreted</a> (<a href="SMT____UNINTERPRETED-_E3RETURNS.html">uninterpreted-&gt;returns</a> x)
                              (<a href="SMT____UNINTERPRETED-_E3MORE-RETURNS.html">uninterpreted-&gt;more-returns</a> x))
               (<a href="SMT____UNINTERPRETED-FIX.html">uninterpreted-fix</a> x)))</pre> 
<p><b>Theorem: </b>uninterpreted-fix-when-uninterpreted</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> uninterpreted-fix-when-uninterpreted
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____UNINTERPRETED-FIX.html">uninterpreted-fix</a> x)
               (<a href="SMT____UNINTERPRETED.html">uninterpreted</a> (<a href="SMT____UNINTERPRETED-_E3RETURNS.html">uninterpreted-&gt;returns</a> x)
                              (<a href="SMT____UNINTERPRETED-_E3MORE-RETURNS.html">uninterpreted-&gt;more-returns</a> x))))</pre> 
<p><b>Theorem: </b>equal-of-uninterpreted</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> equal-of-uninterpreted
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____UNINTERPRETED.html">uninterpreted</a> returns more-returns)
                      x)
               (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____UNINTERPRETED-P.html">uninterpreted-p</a> x)
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____UNINTERPRETED-_E3RETURNS.html">uninterpreted-&gt;returns</a> x)
                           (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> returns))
                    (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____UNINTERPRETED-_E3MORE-RETURNS.html">uninterpreted-&gt;more-returns</a> x)
                           (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> more-returns)))))</pre> 
<p><b>Theorem: </b>uninterpreted-of-hint-pair-list-fix-returns</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> uninterpreted-of-hint-pair-list-fix-returns
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____UNINTERPRETED.html">uninterpreted</a> (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> returns)
                              more-returns)
               (<a href="SMT____UNINTERPRETED.html">uninterpreted</a> returns more-returns)))</pre> 
<p><b>Theorem: </b>uninterpreted-hint-pair-list-equiv-congruence-on-returns</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> uninterpreted-hint-pair-list-equiv-congruence-on-returns
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> returns returns-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____UNINTERPRETED.html">uninterpreted</a> returns more-returns)
                        (<a href="SMT____UNINTERPRETED.html">uninterpreted</a> returns-equiv more-returns)))
        :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>uninterpreted-of-hint-pair-list-fix-more-returns</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> uninterpreted-of-hint-pair-list-fix-more-returns
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____UNINTERPRETED.html">uninterpreted</a> returns
                              (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> more-returns))
               (<a href="SMT____UNINTERPRETED.html">uninterpreted</a> returns more-returns)))</pre> 
<p><b>Theorem: </b>uninterpreted-hint-pair-list-equiv-congruence-on-more-returns</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     uninterpreted-hint-pair-list-equiv-congruence-on-more-returns
     (<a href="ACL2____IMPLIES.html">implies</a> (<a href="SMT____HINT-PAIR-LIST-EQUIV.html">hint-pair-list-equiv</a> more-returns more-returns-equiv)
              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____UNINTERPRETED.html">uninterpreted</a> returns more-returns)
                     (<a href="SMT____UNINTERPRETED.html">uninterpreted</a> returns more-returns-equiv)))
     :rule-classes :congruence)</pre> 
<p><b>Theorem: </b>uninterpreted-fix-redef</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> uninterpreted-fix-redef
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="SMT____UNINTERPRETED-FIX.html">uninterpreted-fix</a> x)
               (<a href="SMT____UNINTERPRETED.html">uninterpreted</a> (<a href="SMT____UNINTERPRETED-_E3RETURNS.html">uninterpreted-&gt;returns</a> x)
                              (<a href="SMT____UNINTERPRETED-_E3MORE-RETURNS.html">uninterpreted-&gt;more-returns</a> x)))
        :rule-classes :definition)</pre> 
<p><b>Function: </b>uninterpreted-fn-helper</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 uninterpreted-fn-helper
 (cl smtlink-hint)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> cl)
                             (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> smtlink-hint))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'uninterpreted-fn-helper))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____B_A2.html">b*</a> ((cl (pseudo-term-list-fix cl))
       (<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> (<a href="SMT____SMTLINK-HINT-FIX.html">smtlink-hint-fix</a> smtlink-hint))
       ((<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> h) smtlink-hint)
       (fn-lst (<a href="SMT____MAKE-ALIST-FN-LST.html">make-alist-fn-lst</a> h.functions))
       (g (<a href="ACL2____DISJOIN.html">disjoin</a> cl))
       (<a href="ACL2____ARGS.html">args</a> (<a href="SMT____GENERATE-FN-HINT-LST.html">generate-fn-hint-lst</a>
                  (<a href="SMT____MAKE-FHG-ARGS.html">make-fhg-args</a> :term-lst (<a href="COMMON-LISP____LIST.html">list</a> g)
                                 :fn-lst fn-lst
                                 :fn-returns-hint-acc nil
                                 :fn-more-returns-hint-acc nil
                                 :lambda-acc nil)))
       ((<a href="SMT____FHG-ARGS.html">fhg-args</a> a) args)
       (fn-returns-hint-lst a.fn-returns-hint-acc)
       (fn-more-returns-hint-lst a.fn-more-returns-hint-acc))
      (<a href="SMT____MAKE-UNINTERPRETED.html">make-uninterpreted</a> :returns fn-returns-hint-lst
                          :more-returns fn-more-returns-hint-lst))))</pre> 
<p><b>Theorem: </b>uninterpreted-p-of-uninterpreted-fn-helper</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     uninterpreted-p-of-uninterpreted-fn-helper
     (<a href="ACL2____B_A2.html">b*</a> ((<a href="SMT____UNINTERPRETED.html">uninterpreted</a> (uninterpreted-fn-helper cl smtlink-hint)))
         (<a href="SMT____UNINTERPRETED-P.html">uninterpreted-p</a> uninterpreted))
     :rule-classes :rewrite)</pre> 
<p><b>Function: </b>uninterpreted-subgoals</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 uninterpreted-subgoals
 (hint-pair-lst g tag)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> hint-pair-lst)
                             (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> g)
                             (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> tag))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'uninterpreted-subgoals))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____B_A2.html">b*</a>
   ((hint-pair-lst (<a href="SMT____HINT-PAIR-LIST-FIX.html">hint-pair-list-fix</a> hint-pair-lst))
    (g (pseudo-term-fix g))
    ((unless (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> tag :return)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> tag :more-return)))
     (<a href="ACL2____PROG2_42.html">prog2$</a> (<a href="ACL2____ER.html">er</a> hard?
                 'uninterpreted-fn-cp=&gt;uninterpreted-subgoals
                 "Tag not supported: ~q0" tag)
             (<a href="ACL2____MV.html">mv</a> nil nil)))
    ((unless (<a href="COMMON-LISP____CONSP.html">consp</a> hint-pair-lst))
     (<a href="ACL2____MV.html">mv</a> nil nil))
    ((<a href="COMMON-LISP____CONS.html">cons</a> first-hinted-h rest-hinted-hs)
     hint-pair-lst)
    (h (<a href="SMT____HINT-PAIR-_E3THM.html">hint-pair-&gt;thm</a> first-hinted-h))
    (h-hint (<a href="SMT____HINT-PAIR-_E3HINTS.html">hint-pair-&gt;hints</a> first-hinted-h))
    (merged-hint-please-in-theory
         (treat-in-theory-hint '(hint-please)
                               h-hint))
    (merged-type-hyp-in-theory
         (treat-in-theory-hint '(type-hyp)
                               merged-hint-please-in-theory))
    (merged-expand (treat-expand-hint '((:free (x) (<a href="ACL2____HIDE.html">hide</a> x)))
                                      merged-type-hyp-in-theory))
    (first-h-thm
     (<a href="COMMON-LISP____IF.html">if</a>
      (<a href="COMMON-LISP____EQUAL.html">equal</a> tag :return)
      (<a href="COMMON-LISP____CONS.html">cons</a>
       (<a href="COMMON-LISP____CONS.html">cons</a> 'hint-please
             (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'quote (<a href="COMMON-LISP____CONS.html">cons</a> merged-expand 'nil))
                   'nil))
       (<a href="COMMON-LISP____CONS.html">cons</a>
        (<a href="COMMON-LISP____CONS.html">cons</a>
         'type-hyp
         (<a href="COMMON-LISP____CONS.html">cons</a>
          (<a href="COMMON-LISP____CONS.html">cons</a>
              'hide
              (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'cons
                          (<a href="COMMON-LISP____CONS.html">cons</a> h
                                (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'quote (<a href="COMMON-LISP____CONS.html">cons</a> 'nil 'nil))
                                      'nil)))
                    'nil))
          (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'quote (<a href="COMMON-LISP____CONS.html">cons</a> tag 'nil))
                'nil)))
        (<a href="COMMON-LISP____CONS.html">cons</a> g 'nil)))
      (<a href="COMMON-LISP____CONS.html">cons</a>
         (<a href="COMMON-LISP____CONS.html">cons</a> 'hint-please
               (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'quote
                           (<a href="COMMON-LISP____CONS.html">cons</a> merged-hint-please-in-theory 'nil))
                     'nil))
         (<a href="COMMON-LISP____CONS.html">cons</a> h (<a href="COMMON-LISP____CONS.html">cons</a> g 'nil)))))
    (first-not-h-clause
     (<a href="COMMON-LISP____IF.html">if</a>
      (<a href="COMMON-LISP____EQUAL.html">equal</a> tag :return)
      (<a href="COMMON-LISP____CONS.html">cons</a>
       'not
       (<a href="COMMON-LISP____CONS.html">cons</a>
        (<a href="COMMON-LISP____CONS.html">cons</a>
         'type-hyp
         (<a href="COMMON-LISP____CONS.html">cons</a>
          (<a href="COMMON-LISP____CONS.html">cons</a>
              'hide
              (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'cons
                          (<a href="COMMON-LISP____CONS.html">cons</a> h
                                (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'quote (<a href="COMMON-LISP____CONS.html">cons</a> 'nil 'nil))
                                      'nil)))
                    'nil))
          (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'quote (<a href="COMMON-LISP____CONS.html">cons</a> tag 'nil))
                'nil)))
        'nil))
      (<a href="COMMON-LISP____CONS.html">cons</a> 'not (<a href="COMMON-LISP____CONS.html">cons</a> h 'nil))))
    ((<a href="ACL2____MV.html">mv</a> rest-h-thms rest-not-h-clauses)
     (uninterpreted-subgoals rest-hinted-hs g tag)))
   (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____CONS.html">cons</a> first-h-thm rest-h-thms)
       (<a href="COMMON-LISP____CONS.html">cons</a> first-not-h-clause
             rest-not-h-clauses)))))</pre> 
<p><b>Theorem: </b>pseudo-term-list-listp-of-uninterpreted-subgoals.list-of-h-thm</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
     pseudo-term-list-listp-of-uninterpreted-subgoals.list-of-h-thm
     (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?list-of-h-thm ?list-of-not-hs)
           (uninterpreted-subgoals hint-pair-lst g tag)))
         (pseudo-term-list-listp list-of-h-thm))
     :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>pseudo-term-listp-of-uninterpreted-subgoals.list-of-not-hs</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-listp-of-uninterpreted-subgoals.list-of-not-hs
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?list-of-h-thm ?list-of-not-hs)
              (uninterpreted-subgoals hint-pair-lst g tag)))
            (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> list-of-not-hs))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>uninterpreted-subgoals-correctness</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 uninterpreted-subgoals-correctness
 (<a href="ACL2____IMPLIES.html">implies</a>
  (<a href="COMMON-LISP____AND.html">and</a>
   (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> g)
   (<a href="ACL2____ALISTP.html">alistp</a> b)
   (<a href="SMT____HINT-PAIR-LISTP.html">hint-pair-listp</a> hint-pair-lst)
   (ev-uninterpreted
     (<a href="ACL2____DISJOIN.html">disjoin</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> 1
                      (uninterpreted-subgoals hint-pair-lst g tag)))
     b)
   (ev-uninterpreted
        (conjoin-clauses
             (<a href="ACL2____MV-NTH.html">mv-nth</a> 0
                     (uninterpreted-subgoals hint-pair-lst g tag)))
        b))
  (ev-uninterpreted g b)))</pre> 
<p><b>Function: </b>uninterpreted-fn-cp</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 uninterpreted-fn-cp (cl smtlink-hint)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> cl)))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'uninterpreted-fn-cp))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____B_A2.html">b*</a>
   (((unless (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> cl)) nil)
    ((unless (<a href="SMT____SMTLINK-HINT-P.html">smtlink-hint-p</a> smtlink-hint))
     (<a href="COMMON-LISP____LIST.html">list</a> cl))
    (g (<a href="ACL2____DISJOIN.html">disjoin</a> cl))
    ((<a href="SMT____SMTLINK-HINT.html">smtlink-hint</a> h) smtlink-hint)
    (<a href="SMT____UNINTERPRETED.html">uninterpreted</a> (uninterpreted-fn-helper cl h))
    (hinted-ts-returns (<a href="SMT____UNINTERPRETED-_E3RETURNS.html">uninterpreted-&gt;returns</a> uninterpreted))
    (hinted-ts-more-returns
         (<a href="SMT____UNINTERPRETED-_E3MORE-RETURNS.html">uninterpreted-&gt;more-returns</a> uninterpreted))
    ((<a href="ACL2____MV.html">mv</a> list-of-returns-t-thm
         list-of-returns-not-ts)
     (uninterpreted-subgoals hinted-ts-returns g :return))
    ((<a href="ACL2____MV.html">mv</a> list-of-more-returns-t-thm
         list-of-more-returns-not-ts)
     (uninterpreted-subgoals hinted-ts-more-returns g :more-return))
    (list-of-t-thm (<a href="COMMON-LISP____APPEND.html">append</a> list-of-returns-t-thm
                           list-of-more-returns-t-thm))
    (list-of-not-ts (<a href="COMMON-LISP____APPEND.html">append</a> list-of-returns-not-ts
                            list-of-more-returns-not-ts))
    (next-cp (<a href="COMMON-LISP____IF.html">if</a> h.custom-p
                 (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> 'uninterpreted-custom
                                   *smt-architecture*))
                 (<a href="COMMON-LISP____CDR.html">cdr</a> (<a href="ACL2____ASSOC-EQUAL.html">assoc-equal</a> 'uninterpreted
                                   *smt-architecture*))))
    ((<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____NULL.html">null</a> next-cp)) (<a href="COMMON-LISP____LIST.html">list</a> cl))
    (the-hint
         (<a href="COMMON-LISP____CONS.html">cons</a> ':clause-processor
               (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> next-cp
                           (<a href="COMMON-LISP____CONS.html">cons</a> 'clause
                                 (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'quote (<a href="COMMON-LISP____CONS.html">cons</a> h 'nil))
                                       (<a href="COMMON-LISP____CONS.html">cons</a> 'state 'nil))))
                     'nil)))
    (cl0 (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'hint-please
                     (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'quote (<a href="COMMON-LISP____CONS.html">cons</a> the-hint 'nil))
                           'nil))
               (<a href="COMMON-LISP____APPEND.html">append</a> list-of-not-ts (<a href="COMMON-LISP____CONS.html">cons</a> g 'nil)))))
   (<a href="COMMON-LISP____CONS.html">cons</a> cl0 list-of-t-thm))))</pre> 
<p><b>Theorem: </b>pseudo-term-list-listp-of-uninterpreted-fn-cp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-list-listp-of-uninterpreted-fn-cp
        (<a href="ACL2____B_A2.html">b*</a> ((subgoal-lst (<a href="SMT____UNINTERPRETED-FN-CP.html">uninterpreted-fn-cp</a> cl smtlink-hint)))
            (pseudo-term-list-listp subgoal-lst))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>correctness-of-uninterpreted-fn-cp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a>
 correctness-of-uninterpreted-fn-cp
 (<a href="ACL2____IMPLIES.html">implies</a>
   (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> cl)
        (<a href="ACL2____ALISTP.html">alistp</a> b)
        (ev-uninterpreted
             (conjoin-clauses (<a href="SMT____UNINTERPRETED-FN-CP.html">uninterpreted-fn-cp</a> cl smtlink-hint))
             b))
   (ev-uninterpreted (<a href="ACL2____DISJOIN.html">disjoin</a> cl) b))
 :rule-classes :clause-processor)</pre> 

</body>
</html>
