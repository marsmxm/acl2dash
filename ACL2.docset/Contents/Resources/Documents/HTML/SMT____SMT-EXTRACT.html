<html>
<head>
<meta charset="UTF-8">
<title>Smt-extract</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=SMT____SMT-EXTRACT">Click for Smt-extract in the Full Manual</a></h3>

<p>SMT-extract extracts type hypotheses from the clause. The SMT solver requires knowing type declarations.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>is-type-hyp-decl</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> is-type-hyp-decl (expr)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> expr)))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'is-type-hyp-decl))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____B_A2.html">b*</a> (((unless (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> expr) 3)) nil)
                 (fn-name (<a href="COMMON-LISP____CAR.html">car</a> expr))
                 ((unless (<a href="COMMON-LISP____EQUAL.html">equal</a> fn-name 'type-hyp))
                  nil))
                t)))</pre> 
<p><b>Theorem: </b>booleanp-of-is-type-hyp-decl</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> booleanp-of-is-type-hyp-decl
        (<a href="ACL2____B_A2.html">b*</a> ((is-type-hyp? (is-type-hyp-decl expr)))
            (<a href="ACL2____BOOLEANP.html">booleanp</a> is-type-hyp?))
        :rule-classes :rewrite)</pre> 
<p><b>Function: </b>extract-is-decl</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 extract-is-decl (expr fty-info abs)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> expr)
                             (<a href="SMT____FTY-INFO-ALIST-P.html">fty-info-alist-p</a> fty-info)
                             (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> abs))))
 (<a href="COMMON-LISP____LET.html">let</a>
   ((acl2::__function__ 'extract-is-decl))
   (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
   (<a href="ACL2____B_A2.html">b*</a> (((<a href="COMMON-LISP____IF.html">if</a> (is-type-hyp-decl expr)) t)
        ((unless (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> expr) 2)) nil)
        (fn-name (<a href="COMMON-LISP____CAR.html">car</a> expr))
        ((unless (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> fn-name)) nil)
        ((unless (<a href="COMMON-LISP____OR.html">or</a> (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> fn-name (<a href="ACL2____STRIP-CARS.html">strip-cars</a> *smt-types*))
                     (<a href="ACL2____MEMBER-EQUAL.html">member-equal</a> fn-name abs)
                     (typedecl-of-flextype fn-name fty-info)))
         nil)
        ((unless (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> (<a href="COMMON-LISP____CADR.html">cadr</a> expr)) (<a href="COMMON-LISP____CADR.html">cadr</a> expr)))
         nil))
       t)))</pre> 
<p><b>Theorem: </b>booleanp-of-extract-is-decl</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> booleanp-of-extract-is-decl
        (<a href="ACL2____B_A2.html">b*</a> ((is-decl? (extract-is-decl expr fty-info abs)))
            (<a href="ACL2____BOOLEANP.html">booleanp</a> is-decl?))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>pseudo-term-listp-of-append-of-pseudo-term-listp</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-listp-of-append-of-pseudo-term-listp
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> x)
                      (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> y))
                 (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> (<a href="COMMON-LISP____APPEND.html">append</a> x y))))</pre> 
<p><b>Function: </b>extract-disjunct</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 extract-disjunct (term fty-info abs)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> term)
                             (<a href="SMT____FTY-INFO-ALIST-P.html">fty-info-alist-p</a> fty-info)
                             (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> abs))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'extract-disjunct))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____B_A2.html">b*</a>
   ((term (pseudo-term-fix term)))
   (<a href="COMMON-LISP____COND.html">cond</a>
    ((<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> term)) (<a href="ACL2____MV.html">mv</a> nil term))
    ((<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> term) 'if)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CADDR.html">caddr</a> term) ''t))
     (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> decl1 term1)
           (<a href="SMT____EXTRACT-DISJUNCT.html">extract-disjunct</a> (<a href="COMMON-LISP____CADR.html">cadr</a> term)
                             fty-info abs))
          ((<a href="ACL2____MV.html">mv</a> decl2 term2)
           (<a href="SMT____EXTRACT-DISJUNCT.html">extract-disjunct</a> (<a href="COMMON-LISP____CADDDR.html">cadddr</a> term)
                             fty-info abs)))
         (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____APPEND.html">append</a> decl1 decl2)
             (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> term1 ''t) (<a href="COMMON-LISP____EQUAL.html">equal</a> term2 ''t))
                    ''t)
                   ((<a href="COMMON-LISP____EQUAL.html">equal</a> term1 ''nil) term2)
                   ((<a href="COMMON-LISP____EQUAL.html">equal</a> term2 ''nil) term1)
                   (t (<a href="COMMON-LISP____CONS.html">cons</a> 'if
                            (<a href="COMMON-LISP____CONS.html">cons</a> term1
                                  (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'quote (<a href="COMMON-LISP____CONS.html">cons</a> 't 'nil))
                                        (<a href="COMMON-LISP____CONS.html">cons</a> term2 'nil)))))))))
    ((<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> term) 'not)
     (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> decl0 term0)
           (<a href="SMT____EXTRACT-CONJUNCT.html">extract-conjunct</a> (<a href="COMMON-LISP____CADR.html">cadr</a> term)
                             fty-info abs)))
         (<a href="ACL2____MV.html">mv</a> decl0
             (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____EQUAL.html">equal</a> term0 ''nil) ''t)
                   ((<a href="COMMON-LISP____EQUAL.html">equal</a> term0 ''t) ''nil)
                   (t (<a href="COMMON-LISP____CONS.html">cons</a> 'not (<a href="COMMON-LISP____CONS.html">cons</a> term0 'nil)))))))
    ((<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> term) 'implies)
     (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> decl1 term1)
           (<a href="SMT____EXTRACT-CONJUNCT.html">extract-conjunct</a> (<a href="COMMON-LISP____CADR.html">cadr</a> term)
                             fty-info abs))
          ((<a href="ACL2____MV.html">mv</a> decl2 term2)
           (<a href="SMT____EXTRACT-DISJUNCT.html">extract-disjunct</a> (<a href="COMMON-LISP____CADDR.html">caddr</a> term)
                             fty-info abs)))
         (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____APPEND.html">append</a> decl1 decl2)
             (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> term1 ''nil)
                        (<a href="COMMON-LISP____EQUAL.html">equal</a> term2 ''t))
                    ''t)
                   ((<a href="COMMON-LISP____EQUAL.html">equal</a> term1 ''t) term2)
                   ((<a href="COMMON-LISP____EQUAL.html">equal</a> term2 ''nil)
                    (<a href="COMMON-LISP____CONS.html">cons</a> 'not (<a href="COMMON-LISP____CONS.html">cons</a> term1 'nil)))
                   (t (<a href="COMMON-LISP____CONS.html">cons</a> 'implies
                            (<a href="COMMON-LISP____CONS.html">cons</a> term1 (<a href="COMMON-LISP____CONS.html">cons</a> term2 'nil))))))))
    (t (<a href="ACL2____MV.html">mv</a> nil term))))))</pre> 
<p><b>Function: </b>extract-conjunct</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
 extract-conjunct (term fty-info abs)
 (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> term)
                             (<a href="SMT____FTY-INFO-ALIST-P.html">fty-info-alist-p</a> fty-info)
                             (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> abs))))
 (<a href="COMMON-LISP____LET.html">let</a>
  ((acl2::__function__ 'extract-conjunct))
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
  (<a href="ACL2____B_A2.html">b*</a>
   ((term (pseudo-term-fix term)))
   (<a href="COMMON-LISP____COND.html">cond</a>
    ((<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> term)) (<a href="ACL2____MV.html">mv</a> nil term))
    ((<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> term) 'if)
          (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CADDDR.html">cadddr</a> term) ''nil))
     (<a href="ACL2____B_A2.html">b*</a>
      (((<a href="ACL2____MV.html">mv</a> decl1 term1)
        (<a href="SMT____EXTRACT-CONJUNCT.html">extract-conjunct</a> (<a href="COMMON-LISP____CADR.html">cadr</a> term)
                          fty-info abs))
       ((<a href="ACL2____MV.html">mv</a> decl2 term2)
        (<a href="SMT____EXTRACT-CONJUNCT.html">extract-conjunct</a> (<a href="COMMON-LISP____CADDR.html">caddr</a> term)
                          fty-info abs)))
      (<a href="ACL2____MV.html">mv</a>
       (<a href="COMMON-LISP____APPEND.html">append</a> decl1 decl2)
       (<a href="COMMON-LISP____COND.html">cond</a>
           ((<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP____EQUAL.html">equal</a> term1 ''nil)
                (<a href="COMMON-LISP____EQUAL.html">equal</a> term2 ''nil))
            ''nil)
           ((<a href="COMMON-LISP____EQUAL.html">equal</a> term1 ''t) term2)
           ((<a href="COMMON-LISP____EQUAL.html">equal</a> term2 ''t) term1)
           (t (<a href="COMMON-LISP____CONS.html">cons</a> 'if
                    (<a href="COMMON-LISP____CONS.html">cons</a> term1
                          (<a href="COMMON-LISP____CONS.html">cons</a> term2
                                (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP____CONS.html">cons</a> 'quote (<a href="COMMON-LISP____CONS.html">cons</a> 'nil 'nil))
                                      'nil)))))))))
    ((<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="COMMON-LISP____CAR.html">car</a> term) 'not)
     (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> decl0 term0)
           (<a href="SMT____EXTRACT-DISJUNCT.html">extract-disjunct</a> (<a href="COMMON-LISP____CADR.html">cadr</a> term)
                             fty-info abs)))
         (<a href="ACL2____MV.html">mv</a> decl0
             (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____EQUAL.html">equal</a> term0 ''nil) ''t)
                   ((<a href="COMMON-LISP____EQUAL.html">equal</a> term0 ''t) ''nil)
                   (t (<a href="COMMON-LISP____CONS.html">cons</a> 'not (<a href="COMMON-LISP____CONS.html">cons</a> term0 'nil)))))))
    ((extract-is-decl term fty-info abs)
     (<a href="ACL2____MV.html">mv</a> (<a href="COMMON-LISP____LIST.html">list</a> term) ''t))
    (t (<a href="ACL2____MV.html">mv</a> nil term))))))</pre> 
<p><b>Theorem: </b>return-type-of-extract-disjunct.decl-list</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> return-type-of-extract-disjunct.decl-list
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?decl-list ?theorem)
              (<a href="SMT____EXTRACT-DISJUNCT.html">extract-disjunct</a> term fty-info abs)))
            (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> decl-list))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>return-type-of-extract-disjunct.theorem</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> return-type-of-extract-disjunct.theorem
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?decl-list ?theorem)
              (<a href="SMT____EXTRACT-DISJUNCT.html">extract-disjunct</a> term fty-info abs)))
            (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> theorem))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>return-type-of-extract-conjunct.decl-list</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> return-type-of-extract-conjunct.decl-list
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?decl-list ?theorem)
              (<a href="SMT____EXTRACT-CONJUNCT.html">extract-conjunct</a> term fty-info abs)))
            (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> decl-list))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>return-type-of-extract-conjunct.theorem</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> return-type-of-extract-conjunct.theorem
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?decl-list ?theorem)
              (<a href="SMT____EXTRACT-CONJUNCT.html">extract-conjunct</a> term fty-info abs)))
            (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> theorem))
        :rule-classes :rewrite)</pre> 
<p><b>Function: </b>smt-extract</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> smt-extract (term fty-info abs)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> term)
                                   (<a href="SMT____FTY-INFO-ALIST-P.html">fty-info-alist-p</a> fty-info)
                                   (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> abs))))
       (<a href="COMMON-LISP____LET.html">let</a> ((acl2::__function__ 'smt-extract))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> acl2::__function__))
            (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> decl-list theorem)
                  (<a href="SMT____EXTRACT-DISJUNCT.html">extract-disjunct</a> term fty-info abs)))
                (<a href="ACL2____MV.html">mv</a> decl-list theorem))))</pre> 
<p><b>Theorem: </b>pseudo-term-listp-of-smt-extract.decl-list</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-term-listp-of-smt-extract.decl-list
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?decl-list ?theorem)
              (<a href="SMT____SMT-EXTRACT.html">smt-extract</a> term fty-info abs)))
            (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> decl-list))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>pseudo-termp-of-smt-extract.theorem</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-termp-of-smt-extract.theorem
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?decl-list ?theorem)
              (<a href="SMT____SMT-EXTRACT.html">smt-extract</a> term fty-info abs)))
            (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> theorem))
        :rule-classes :rewrite)</pre> 

</body>
</html>
