<html>
<head>
<meta charset="UTF-8">
<title>Guards-for-specification</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____GUARDS-FOR-SPECIFICATION">Click for Guards-for-specification in the Full Manual</a></h3>

<p>Guards as a specification device</p><p>A use of guard verification that has nothing to do with efficiency 
 is as a way to gain confidence in specifications.  This use has the feel of 
 ``types'' in many traditional <a href="ACL2____PROGRAMMING.html">programming</a> languages, though guards 
 allow much greater expressiveness than most systems of types 
 (and unfortunately, as a result they are not syntactically checkable).</p> 
 
 <p>For more discussion of guards in general, see <a href="ACL2____GUARD.html">guard</a>.</p> 
 
 <p>Suppose you have written a collection of function definitions that are 
 intended to specify the behavior of some system.  Perhaps certain functions 
 are only intended to be called on certain sorts of inputs, so you attach 
 guards to those functions in order to ``enforce'' that requirement.  And then, 
 you verify the guards for all those functions.</p> 
 
 <p>Then what have you gained, other than somewhat increased efficiency of 
 execution (as explained above), which quite possibly isn't your main concern? 
 You have gained the confidence that when evaluating any call of a 
 (specification) function whose arguments satisfy that function's guard, all 
 subsequent function calls during the course of evaluation will have this same 
 property, that the arguments satisfy the guard of the calling function.</p> 
 
 <p>The rest of this topic addresses those who wish to understand <a href="ACL2____GUARD.html">guard</a>s 
 from a proof-theoretic perspective instead of (or in addition to) the 
 evaluation perspective given above.  In logical terms, we can say that the 
 equality of the original call with the returned value is provable from 
 weakened versions of the definitions, where each definitional axiom is 
 replaced by an implication whose antecedent is the requirement that the 
 arguments satisfy the guard and whose consequent is the original axiom.  For 
 example,</p> 
 
 <pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> foo (x)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____CONSP.html">consp</a> x)))
  (<a href="COMMON-LISP____CONS.html">cons</a> 1 (<a href="COMMON-LISP____CDR.html">cdr</a> x)))</pre> 
 
 <p>originally generates the axiom</p> 
 
 <pre class="code">(<a href="COMMON-LISP____EQUAL.html">equal</a> (foo x)
       (<a href="COMMON-LISP____CONS.html">cons</a> 1 (<a href="COMMON-LISP____CDR.html">cdr</a> x)))</pre> 
 
 <p>but in fact, when evaluation involves no guard violation then the following 
 weaker axiom suffices in the justification of the evaluation.</p> 
 
 <pre class="code">(<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____CONSP.html">consp</a> x)
         (<a href="COMMON-LISP____EQUAL.html">equal</a> (foo x)
                (<a href="COMMON-LISP____CONS.html">cons</a> 1 (<a href="COMMON-LISP____CDR.html">cdr</a> x))))</pre> 
 
 <p>So for example, suppose we evaluate <span class="v">(foo '(a b c))</span> and get <span class="v">'(1 b
 c)</span>.  Then of course the equality of these two terms is provable from the 
 original axiom.  The point here is that it's even provable from the weaker 
 axiom.</p> 
 
 <p>If you are following links to read this documentation as a hypertext style 
 document, then please see <a href="ACL2____GUARD-MISCELLANY.html">guard-miscellany</a>.  This concludes our 
 discussion of guards with miscellaneous remarks, and also contains pointers to 
 related topics.</p>
</body>
</html>
