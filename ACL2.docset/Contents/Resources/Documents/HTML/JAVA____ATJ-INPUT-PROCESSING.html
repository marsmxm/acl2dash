<html>
<head>
<meta charset="UTF-8">
<title>Atj-input-processing</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=JAVA____ATJ-INPUT-PROCESSING">Click for Atj-input-processing in the Full Manual</a></h3>

<p>Input processing performed by <span class="tt"><a href="JAVA____ATJ.html">atj</a></span>.</p><p>See <a href="ACL2____EVENT-MACRO-INPUT-PROCESSING.html">input processing</a> for general background.</p><p>As part of input processing, 
   we collect the names of all the ACL2 functions to be translated to Java, 
   as determined by <span class="v">fn1</span>, ..., <span class="v">fnp</span>. 
   As we do that, 
   we also check that they satisfy the constraints 
   stated in the user documentation.</p><p>This collection and checking of the ACL2 functions 
   is realized via a worklist algorithm. 
   The worklist is initialized with <span class="v">fn1</span>, ..., <span class="v">fnp</span>. 
   At each step, a function <span class="v">fn</span> is taken from the worklist and processed. 
   If <span class="v">fn</span> satisfies all the necessary constraints, 
   it is added to a list of collected functions (which is initially empty); 
   otherwise, we stop with an error. 
   If <span class="v">fn</span> is defined, 
   we collect the functions that occur in its defining body 
   and add them to the worklist, 
   except for those that are already in the worklist or in the collected list 
   (so that we do not process the same function twice). 
   Note that by adding <span class="v">fn</span> to the collected list 
   before examining the functions that occur in its defining body, 
   we ensure termination in the presence of 
   (singly or mutually) recursive functions. 
   We proceed like this until the worklist is empty (or an error occurs). 
   If there are no errors, at the end 
   we will have checked all the functions 
   transitively called by <span class="v">fn1</span>, ..., <span class="v">fnp</span>, 
   and the collected list will contain all the functions 
   that must be translated to Java. 
   This is the basic algorithm, but there are some complications, 
   described in the following.</p><p>A complication arises from 
   calls of <span class="tt"><a href="ACL2____RETURN-LAST.html">return-last</a></span> whose first argument is <span class="v">'acl2::mbe1-raw</span>, 
   which are calls of <span class="tt"><a href="ACL2____MBE.html">mbe</a></span> in translated form. 
   As explained in the user documentation, 
   when the <span class="v">:guards</span> input of ATJ is <span class="v">nil</span>, 
   the Java code generated by ATJ executes ``in the logic'', 
   and in particular executes the <span class="v">:logic</span> parts of <span class="tt"><a href="ACL2____MBE.html">mbe</a></span>s; 
   when instead the <span class="v">:guards</span> input of ATJ is <span class="v">t</span>, 
   the Java code generated by ATJ assumes the satisfaction of the guards, 
   and in particular executes the <span class="v">:exec</span> parts of <span class="tt"><a href="ACL2____MBE.html">mbe</a></span>s. 
   Thus, when we recursively collect the functions 
   from the body of a defined function, 
   when we encounter these calls of <span class="tt"><a href="ACL2____RETURN-LAST.html">return-last</a></span>, 
   we selectively descend into the <span class="v">:logic</span> or <span class="v">:exec</span> part 
   (based on the value of the <span class="v">:guards</span> input), 
   ignoring the other part.</p><p>Another complication arises from 
   calls of <span class="tt"><a href="ACL2____RETURN-LAST.html">return-last</a></span> whose first argument is <span class="v">'acl2::progn</span>, 
   which are calls of <span class="tt"><a href="ACL2____PROG2_42.html">prog2$</a></span> and <span class="tt"><a href="ACL2____PROGN_42.html">progn$</a></span> in translated form. 
   As explained in the documentation, 
   code is generated from the last argument only, 
   but the other arguments must be checked to satisfy constraints as well. 
   Thus, we use two worklists and two collected lists: 
   one worklist and one collected list for the functions 
   for which Java code must be generated, 
   and one worklist and one collected list for the functions 
   that must be only checked to satisfy the constraints. 
   At the end of the iteration, 
   the first collected list is used to generate Java code, 
   while the second collected list is discarded; 
   however, this second collected list is used during the iteration, 
   to keep track of the functions already checked 
   that do not appear in the worklists or in the first collected list. 
   The function <span class="v">fn</span> is always taken from the first worklist, 
   unless this worklist is empty, in which case it is taken from the second: 
   in other words, the first worklist is processed first, 
   and then the second one; 
   the iteration terminates when both worklists are empty.</p><p>Yet another complication arises from 
   calls of functions in 
   <span class="tt"><a href="JAVA_____A2ATJ-JPRIM-FNS_A2.html">*atj-jprim-fns*</a></span> and <span class="tt"><a href="JAVA_____A2ATJ-JPRIMARR-FNS_A2.html">*atj-jprimarr-fns*</a></span>, 
   which are translated directly to suitable Java constructs 
   when <span class="v">:deep</span> is <span class="v">nil</span> and <span class="v">:guards</span> is <span class="v">t</span>. 
   Under these conditions, when <span class="v">fn</span> is taken from a worklist, 
   its defining body is not examined; 
   i.e. it is treated like a natively implemented function, 
   which it is in some sense.</p><p>Further details and complications of the worklist algorithm 
   are explained in the implementing functions.</p>
</body>
</html>
