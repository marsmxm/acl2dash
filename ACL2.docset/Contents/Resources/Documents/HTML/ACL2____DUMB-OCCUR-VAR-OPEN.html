<html>
<head>
<meta charset="UTF-8">
<title>Dumb-occur-var-open</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____DUMB-OCCUR-VAR-OPEN">Click for Dumb-occur-var-open in the Full Manual</a></h3>

<p>Check if a variable occurs free in a term 
          that may contain non-closed (i.e. open) lambda expressions.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(dumb-occur-var-open var term) → yes/no</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">var</span> — <font color="#606060">Guard <span class="v">(<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> var)</span>.</font>
</dd> 
  <dd>
<span class="tt">term</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> term)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">yes/no</span> — <font color="#606060">Type <span class="v">(<a href="ACL2____BOOLEANP.html">booleanp</a> yes/no)</span>.</font>
</dd> 
 
</dl></div> 
<p>When trivial lambda-bound variables are removed from a term 
     via <span class="tt"><a href="ACL2____REMOVE-TRIVIAL-VARS.html">remove-trivial-vars</a></span>, 
     some lambda expressions may not be closed. 
     For checking whether a variable occurs free in this kind of terms, 
     the system utility <span class="tt"><a href="ACL2____DUMB-OCCUR-VAR.html">dumb-occur-var</a></span> is inadequate, 
     because it skips over lambda expressions, assuming they are closed, 
     as is the case in ACL2's internal translated form.</p><p>Thus, we define a utility similar to <span class="tt"><a href="ACL2____DUMB-OCCUR-VAR.html">dumb-occur-var</a></span> 
     that does not just skip over lambda expressions. 
     Instead, it skips over lambda expressions only if 
     the variable is among the formal parameters of the lambda expression, 
     because in that case the variable is bound in the lambda expression. 
     Otherwise, it examines the body of the lambda expression. 
     This is the standard treatment of lambda expressions 
     in languages where lambda expressions are not necessarily closed.</p><p><b>Function: </b>dumb-occur-var-open</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
   dumb-occur-var-open (var term)
   (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> var)
                               (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> term))))
   (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'dumb-occur-var-open))
        (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
        (<a href="ACL2____B_A2.html">b*</a> (((when (<a href="COMMON-LISP____EQ.html">eq</a> var term)) t)
             ((when (<a href="ACL2____VARIABLEP.html">variablep</a> term)) nil)
             ((when (<a href="ACL2____FQUOTEP.html">fquotep</a> term)) nil)
             (fn (<a href="ACL2____FFN-SYMB.html">ffn-symb</a> term)))
            (<a href="COMMON-LISP____OR.html">or</a> (<a href="ACL2____DUMB-OCCUR-VAR-OPEN-LST.html">dumb-occur-var-open-lst</a> var (<a href="ACL2____FARGS.html">fargs</a> term))
                (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____FLAMBDAP.html">flambdap</a> fn)
                     (<a href="COMMON-LISP____NOT.html">not</a> (<a href="ACL2____MEMBER-EQ.html">member-eq</a> var (<a href="ACL2____LAMBDA-FORMALS.html">lambda-formals</a> fn)))
                     (<a href="ACL2____DUMB-OCCUR-VAR-OPEN.html">dumb-occur-var-open</a> var (<a href="ACL2____LAMBDA-BODY.html">lambda-body</a> fn)))))))</pre><p><b>Function: </b>dumb-occur-var-open-lst</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
    dumb-occur-var-open-lst (var terms)
    (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> var)
                                (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> terms))))
    (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'dumb-occur-var-open-lst))
         (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
         (<a href="COMMON-LISP____COND.html">cond</a> ((<a href="COMMON-LISP____ENDP.html">endp</a> terms) nil)
               (t (<a href="COMMON-LISP____OR.html">or</a> (<a href="ACL2____DUMB-OCCUR-VAR-OPEN.html">dumb-occur-var-open</a> var (<a href="COMMON-LISP____CAR.html">car</a> terms))
                      (<a href="ACL2____DUMB-OCCUR-VAR-OPEN-LST.html">dumb-occur-var-open-lst</a> var (<a href="COMMON-LISP____CDR.html">cdr</a> terms)))))))</pre> 
 
 
 
<p><b>Theorem: </b>return-type-of-dumb-occur-var-open.yes/no</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> return-type-of-dumb-occur-var-open.yes/no
        (<a href="ACL2____B_A2.html">b*</a> ((?yes/no (<a href="ACL2____DUMB-OCCUR-VAR-OPEN.html">dumb-occur-var-open</a> var term)))
            (<a href="ACL2____BOOLEANP.html">booleanp</a> yes/no))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>return-type-of-dumb-occur-var-open-lst.yes/no</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> return-type-of-dumb-occur-var-open-lst.yes/no
        (<a href="ACL2____B_A2.html">b*</a> ((?yes/no (<a href="ACL2____DUMB-OCCUR-VAR-OPEN-LST.html">dumb-occur-var-open-lst</a> var terms)))
            (<a href="ACL2____BOOLEANP.html">booleanp</a> yes/no))
        :rule-classes :rewrite)</pre> 

</body>
</html>
