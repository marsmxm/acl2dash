<html>
<head>
<meta charset="UTF-8">
<title>Check-mv-let-call</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=ACL2____CHECK-MV-LET-CALL">Click for Check-mv-let-call in the Full Manual</a></h3>

<p>Check if a term is a (translated) call of <span class="tt"><a href="ACL2____MV-LET.html">mv-let</a></span>.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(check-mv-let-call term) 
   
(mv yes/no mv-var vars indices hides mv-term body-term)</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">term</span>  <font color="#606060">Guard <span class="v">(<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> term)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">yes/no</span>  <font color="#606060">Type <span class="v">(<a href="ACL2____BOOLEANP.html">booleanp</a> yes/no)</span>.</font>
</dd> 
<dd>
<span class="tt">mv-var</span>  <font color="#606060">Type <span class="v">(<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> mv-var)</span>, given the <a href="ACL2____GUARD.html">guard</a>.</font>
</dd> 
<dd>
<span class="tt">vars</span>  <font color="#606060">Type <span class="v">(<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> vars)</span>, given the <a href="ACL2____GUARD.html">guard</a>.</font>
</dd> 
<dd>
<span class="tt">indices</span>  <font color="#606060">Type <span class="v">(<a href="ACL2____NAT-LISTP.html">nat-listp</a> indices)</span>.</font>
</dd> 
<dd>
<span class="tt">hides</span>  <font color="#606060">Type <span class="v">(<a href="ACL2____BOOLEAN-LISTP.html">boolean-listp</a> hides)</span>.</font>
</dd> 
<dd>
<span class="tt">mv-term</span>  <font color="#606060">Type <span class="v">(<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> mv-term)</span>, given the <a href="ACL2____GUARD.html">guard</a>.</font>
</dd> 
<dd>
<span class="tt">body-term</span>  <font color="#606060">Type <span class="v">(<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> body-term)</span>, given the <a href="ACL2____GUARD.html">guard</a>.</font>
</dd> 
 
</dl></div> 
<p>In translated form, <span class="v">(<a href="ACL2____MV-LET.html">mv-let</a> (var1 ... varn) mv-term body-term)</span> is</p><pre class="code">((<a href="COMMON-LISP____LAMBDA.html">lambda</a> (<a href="ACL2____MV.html">mv</a>)
         ((<a href="COMMON-LISP____LAMBDA.html">lambda</a> (var1 ... varn) body-term-trans)
          (<a href="ACL2____MV-NTH.html">mv-nth</a> '0 mv)
          ...
          (<a href="ACL2____MV-NTH.html">mv-nth</a> 'n-1 mv)))
 mv-term-trans)</pre><p>where <span class="v">mv-term-trans</span> and <span class="v">body-term-trans</span> are 
     the translations of <span class="v">mv-term</span> and <span class="v">body-term</span>.</p><p>This utility checks if a translated term has the form above; 
     it also checks that <span class="v">mv</span> does not occur free in <span class="v">body-term</span> 
     (via <span class="tt"><a href="ACL2____DUMB-OCCUR-VAR-OPEN.html">dumb-occur-var-open</a></span> for greater flexibility). 
     If all these checks pass, it returns <span class="v">t</span> as first result, 
     and additionally the variable <span class="v">mv</span>, 
     the list <span class="v">(var1 ... varn)</span>, 
     the term <span class="v">mv-term-trans</span>, 
     and the term <span class="v">body-term-trans</span>. 
     If the input term does not have that form, 
     this utility returns <span class="v">nil</span> for each result.</p><p>If the input term has the form above, 
     it is not necessarily the result of translating <span class="tt"><a href="ACL2____MV-LET.html">mv-let</a></span>. 
     It could be the translation of 
     <span class="v">(<a href="COMMON-LISP____LET.html">let</a> ((<a href="ACL2____MV.html">mv</a> mv-term))
          (<a href="COMMON-LISP____LET.html">let</a> ((var1 (<a href="ACL2____MV-NTH.html">mv-nth</a> 0 mv)) ... (varn (<a href="ACL2____MV-NTH.html">mv-nth</a> n-1 mv)))
            mv-body))</span> 
     instead; 
     it depends on whether <span class="v">mv-term</span> is single-valued or multi-valued, 
     and also on whether the term is translated for execution or not. 
     However, the result of translating <span class="tt"><a href="ACL2____MV-LET.html">mv-let</a></span> 
     necessarily has the form above.</p><p>Note, however, that lambda expressions are always closed 
     in translated terms directly obtained from untranslated terms. 
     ACL2 accomplishes this closure 
     by adding formal paramaters to the lambda expressions 
     for the otherwise free variables, 
     and adding actual arguments identical to those variables; 
     see <span class="tt"><a href="ACL2____REMOVE-TRIVIAL-VARS.html">remove-trivial-vars</a></span>. 
     This means that the lambda expressions above may have extra variables. 
     To ``correct'' for this, before examining the two lambda expressions, 
     we remove all their formal parameters 
     that are identical to the corresponding arguments, 
     via <span class="tt"><a href="ACL2____REMOVE-TRIVIAL-VARS.html">remove-trivial-vars</a></span>'s auxiliary function 
     <span class="tt"><a href="ACL2____REMOVE-EQUAL-FORMALS-ACTUALS.html">remove-equal-formals-actuals</a></span>, which does exactly that. 
     We do not use <span class="tt"><a href="ACL2____REMOVE-TRIVIAL-VARS.html">remove-trivial-vars</a></span> because that one 
     removes the trivial variables at all levels, 
     while here we only want to remove the ones 
     from the two lambda expressions being examined.</p><p>Note also that, due to this lambda expression closure, 
     the <span class="v">mv</span> variable is not always the symbol `<span class="v">mv</span>': 
     if that symbol happens to be a free variable, 
     ACL2's translation picks a different symbol 
     for the first formal argument of the outer lambda expression above. 
     For instance,</p><pre class="code">:trans (<a href="COMMON-LISP____LET.html">let</a> ((<a href="ACL2____MV.html">mv</a> 0)) (<a href="ACL2____MV-LET.html">mv-let</a> (x y) (f mv) (<a href="COMMON-LISP____LIST.html">list</a> x y mv)))</pre><p>produces a translated term with the symbol `<span class="v">mv0</span>' 
     as the variable bound to the multiple value. 
     This is why this utility returns this variable 
     as one of its results.</p><p>In translated terms directly obtained from untranslated terms, 
     <span class="tt"><a href="ACL2____MV-LET.html">mv-let</a></span>s always have <span class="v">(<a href="ACL2____MV-NTH.html">mv-nth</a> i ...)</span> calls 
     for all contiguous indices <span class="v">i</span> from 0 to 
     the number of <span class="tt"><a href="ACL2____MV-LET.html">mv-let</a></span>-bound variables minus 1, 
     corresponding to all the bound variables (0-based). 
     However, if a term is subjected to 
     transformations like <span class="tt"><a href="ACL2____REMOVE-UNUSED-VARS.html">remove-unused-vars</a></span>, 
     some of those <span class="tt"><a href="ACL2____MV-NTH.html">mv-nth</a></span> calls may disappear 
     (if they are not used in the body of the <span class="tt"><a href="ACL2____MV-LET.html">mv-let</a></span>). 
     Thus, for wider usability, 
     this utility does not require all the <span class="tt"><a href="ACL2____MV-NTH.html">mv-nth</a></span> calls to be present. 
     It only requires calls with strictly increasing indices, allowing gaps. 
     The ordered list of indices actually present is returned, 
     so that a caller can indipendently check that there are no gaps, 
     if the term is not supposed to have any such gaps.</p><p>An additional complication derives from the fact that <span class="tt"><a href="ACL2____MV-LET.html">mv-let</a></span> 
     allows the declaration of ignored variables within, e.g. 
     <span class="v">(<a href="ACL2____MV-LET.html">mv-let</a> (x y z) (<a href="ACL2____MV.html">mv</a> 1 2 3) (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORE.html">ignore</a> x y)) z)</span>. 
     In translated terms, this manifests in the addition of <span class="tt"><a href="ACL2____HIDE.html">hide</a></span> 
     around the <span class="tt"><a href="ACL2____MV-NTH.html">mv-nth</a></span> terms, which in this example is</p><pre class="code">((<a href="COMMON-LISP____LAMBDA.html">lambda</a> (<a href="ACL2____MV.html">mv</a>)
         ((<a href="COMMON-LISP____LAMBDA.html">lambda</a> (x y z) z)
          (<a href="ACL2____HIDE.html">hide</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> '0 mv))
          (<a href="ACL2____HIDE.html">hide</a> (<a href="ACL2____MV-NTH.html">mv-nth</a> '1 mv))
          (<a href="ACL2____MV-NTH.html">mv-nth</a> '2 mv)))
 (<a href="COMMON-LISP____CONS.html">cons</a> '1 (<a href="COMMON-LISP____CONS.html">cons</a> '2 (<a href="COMMON-LISP____CONS.html">cons</a> '3 'nil))))</pre><p>This utility takes this possibility into account, 
     and returns, as an additional result, 
     a list of booleans, of the same length as variables and indices, 
     that says whether the corresponding <span class="tt"><a href="ACL2____MV-NTH.html">mv-nth</a></span> 
     is wrapped by <span class="tt"><a href="ACL2____HIDE.html">hide</a></span> or not. 
     This way, the utility returns all the information about the term, 
     which the caller may use as desired.</p><p><span class="tt"><a href="ACL2____MV-LET.html">mv-let</a></span> also support the declaration of ignorable variables. 
     But these declarations do not introduce any <span class="tt"><a href="ACL2____HIDE.html">hide</a></span> wrapper 
     or other change into the translated term.</p><p>This utility is a left inverse of <span class="tt"><a href="ACL2____MAKE-MV-LET-CALL.html">make-mv-let-call</a></span>.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>check-mv-let-call-aux</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> check-mv-let-call-aux
       (terms min-index mv-var)
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERM-LISTP.html">pseudo-term-listp</a> terms)
                                   (<a href="ACL2____NATP.html">natp</a> min-index)
                                   (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> mv-var))))
       (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'check-mv-let-call-aux))
            (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
            (<a href="ACL2____B_A2.html">b*</a> (((when (<a href="COMMON-LISP____ENDP.html">endp</a> terms)) (<a href="ACL2____MV.html">mv</a> t nil nil))
                 (<a href="ACL2____TERM.html">term</a> (<a href="COMMON-LISP____CAR.html">car</a> terms))
                 ((<a href="ACL2____MV.html">mv</a> hide term)
                  (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> term)
                           (<a href="COMMON-LISP____CONSP.html">consp</a> term)
                           (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> term))
                           (<a href="COMMON-LISP____ATOM.html">atom</a> (<a href="COMMON-LISP____CDDR.html">cddr</a> term))
                           (<a href="COMMON-LISP____EQ.html">eq</a> (<a href="COMMON-LISP____CAR.html">car</a> term) 'hide))
                      (<a href="ACL2____MV.html">mv</a> t (<a href="COMMON-LISP____CADR.html">cadr</a> term))
                      (<a href="ACL2____MV.html">mv</a> nil term)))
                 ((unless (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____TRUE-LISTP.html">true-listp</a> term)
                               (<a href="COMMON-LISP____CONSP.html">consp</a> term)
                               (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> term))
                               (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CDDR.html">cddr</a> term))
                               (<a href="COMMON-LISP____ATOM.html">atom</a> (<a href="COMMON-LISP____CDDDR.html">cdddr</a> term))))
                  (<a href="ACL2____MV.html">mv</a> nil nil nil))
                 ((unless (<a href="COMMON-LISP____EQ.html">eq</a> (<a href="COMMON-LISP____CAR.html">car</a> term) 'mv-nth))
                  (<a href="ACL2____MV.html">mv</a> nil nil nil))
                 (index-term (<a href="COMMON-LISP____CADR.html">cadr</a> term))
                 ((unless (<a href="COMMON-LISP____EQ.html">eq</a> (<a href="COMMON-LISP____CADDR.html">caddr</a> term) mv-var))
                  (<a href="ACL2____MV.html">mv</a> nil nil nil))
                 ((unless (<a href="ACL2____QUOTEP.html">quotep</a> index-term))
                  (<a href="ACL2____MV.html">mv</a> nil nil nil))
                 (index (<a href="ACL2____UNQUOTE.html">unquote</a> index-term))
                 ((unless (<a href="ACL2____NATP.html">natp</a> index)) (<a href="ACL2____MV.html">mv</a> nil nil nil))
                 ((unless (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> index min-index))
                  (<a href="ACL2____MV.html">mv</a> nil nil nil))
                 ((<a href="ACL2____MV.html">mv</a> yes/no indices hides)
                  (check-mv-let-call-aux (<a href="COMMON-LISP____CDR.html">cdr</a> terms)
                                         (<a href="COMMON-LISP____1_B2.html">1+</a> index)
                                         mv-var))
                 ((unless yes/no) (<a href="ACL2____MV.html">mv</a> nil nil nil)))
                (<a href="ACL2____MV.html">mv</a> t (<a href="COMMON-LISP____CONS.html">cons</a> index indices)
                    (<a href="COMMON-LISP____CONS.html">cons</a> hide hides)))))</pre> 
<p><b>Theorem: </b>booleanp-of-check-mv-let-call-aux.yes/no</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> booleanp-of-check-mv-let-call-aux.yes/no
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?yes/no ?indices ?hides)
              (check-mv-let-call-aux terms min-index mv-var)))
            (<a href="ACL2____BOOLEANP.html">booleanp</a> yes/no))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>nat-listp-of-check-mv-let-call-aux.indices</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nat-listp-of-check-mv-let-call-aux.indices
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?yes/no ?indices ?hides)
              (check-mv-let-call-aux terms min-index mv-var)))
            (<a href="ACL2____NAT-LISTP.html">nat-listp</a> indices))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>boolean-listp-of-check-mv-let-call-aux.hides</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> boolean-listp-of-check-mv-let-call-aux.hides
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?yes/no ?indices ?hides)
              (check-mv-let-call-aux terms min-index mv-var)))
            (<a href="ACL2____BOOLEAN-LISTP.html">boolean-listp</a> hides))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>len-of-check-mv-let-call-aux.indices</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> len-of-check-mv-let-call-aux.indices
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?yes/no ?indices ?hides)
              (check-mv-let-call-aux terms min-index mv-var)))
            (<a href="ACL2____IMPLIES.html">implies</a> yes/no
                     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> indices) (<a href="ACL2____LEN.html">len</a> terms)))))</pre> 
<p><b>Theorem: </b>len-of-check-mv-let-call-aux.hides</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> len-of-check-mv-let-call-aux.hides
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?yes/no ?indices ?hides)
              (check-mv-let-call-aux terms min-index mv-var)))
            (<a href="ACL2____IMPLIES.html">implies</a> yes/no
                     (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> hides) (<a href="ACL2____LEN.html">len</a> terms)))))</pre> 
<p><b>Function: </b>check-mv-let-call</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
  check-mv-let-call (<a href="ACL2____TERM.html">term</a>)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> term)))
  (<a href="COMMON-LISP____LET.html">let</a> ((__function__ 'check-mv-let-call))
       (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> __function__))
       (<a href="ACL2____B_A2.html">b*</a> (((when (<a href="ACL2____VARIABLEP.html">variablep</a> term))
             (<a href="ACL2____MV.html">mv</a> nil nil nil nil nil nil nil))
            ((when (<a href="ACL2____FQUOTEP.html">fquotep</a> term))
             (<a href="ACL2____MV.html">mv</a> nil nil nil nil nil nil nil))
            ((unless (<a href="ACL2____FLAMBDA-APPLICATIONP.html">flambda-applicationp</a> term))
             (<a href="ACL2____MV.html">mv</a> nil nil nil nil nil nil nil))
            (outer-lambda-expr (<a href="ACL2____FFN-SYMB.html">ffn-symb</a> term))
            (<a href="ACL2____FORMALS.html">formals</a> (<a href="ACL2____LAMBDA-FORMALS.html">lambda-formals</a> outer-lambda-expr))
            (actuals (<a href="ACL2____FARGS.html">fargs</a> term))
            ((<a href="ACL2____MV.html">mv</a> list-mv list-mv-term)
             (<a href="ACL2____REMOVE-EQUAL-FORMALS-ACTUALS.html">remove-equal-formals-actuals</a> formals actuals))
            ((unless (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> list-mv)
                          (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> list-mv)))))
             (<a href="ACL2____MV.html">mv</a> nil nil nil nil nil nil nil))
            (mv-var (<a href="COMMON-LISP____CAR.html">car</a> list-mv))
            ((unless (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> list-mv-term)
                          (<a href="COMMON-LISP____NOT.html">not</a> (<a href="COMMON-LISP____CONSP.html">consp</a> (<a href="COMMON-LISP____CDR.html">cdr</a> list-mv-term)))))
             (<a href="ACL2____MV.html">mv</a> nil nil nil nil nil nil nil))
            (mv-term (<a href="COMMON-LISP____CAR.html">car</a> list-mv-term))
            (inner-lambda-expr-call (<a href="ACL2____LAMBDA-BODY.html">lambda-body</a> outer-lambda-expr))
            ((when (<a href="ACL2____VARIABLEP.html">variablep</a> inner-lambda-expr-call))
             (<a href="ACL2____MV.html">mv</a> nil nil nil nil nil nil nil))
            ((when (<a href="ACL2____FQUOTEP.html">fquotep</a> inner-lambda-expr-call))
             (<a href="ACL2____MV.html">mv</a> nil nil nil nil nil nil nil))
            ((unless (<a href="ACL2____FLAMBDA-APPLICATIONP.html">flambda-applicationp</a> inner-lambda-expr-call))
             (<a href="ACL2____MV.html">mv</a> nil nil nil nil nil nil nil))
            (inner-lambda-expr (<a href="ACL2____FFN-SYMB.html">ffn-symb</a> inner-lambda-expr-call))
            (<a href="ACL2____FORMALS.html">formals</a> (<a href="ACL2____LAMBDA-FORMALS.html">lambda-formals</a> inner-lambda-expr))
            (actuals (<a href="ACL2____FARGS.html">fargs</a> inner-lambda-expr-call))
            ((<a href="ACL2____MV.html">mv</a> vars mv-nths)
             (<a href="ACL2____REMOVE-EQUAL-FORMALS-ACTUALS.html">remove-equal-formals-actuals</a> formals actuals))
            (body-term (<a href="ACL2____LAMBDA-BODY.html">lambda-body</a> inner-lambda-expr))
            ((when (<a href="ACL2____DUMB-OCCUR-VAR-OPEN.html">dumb-occur-var-open</a> mv-var body-term))
             (<a href="ACL2____MV.html">mv</a> nil nil nil nil nil nil nil))
            ((<a href="ACL2____MV.html">mv</a> okp indices hides)
             (check-mv-let-call-aux mv-nths 0 mv-var))
            ((unless okp)
             (<a href="ACL2____MV.html">mv</a> nil nil nil nil nil nil nil)))
           (<a href="ACL2____MV.html">mv</a> t mv-var
               vars indices hides mv-term body-term))))</pre> 
<p><b>Theorem: </b>booleanp-of-check-mv-let-call.yes/no</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> booleanp-of-check-mv-let-call.yes/no
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?yes/no ?mv-var ?vars
                  ?indices ?hides ?mv-term ?body-term)
              (<a href="ACL2____CHECK-MV-LET-CALL.html">check-mv-let-call</a> term)))
            (<a href="ACL2____BOOLEANP.html">booleanp</a> yes/no))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>symbolp-of-check-mv-let-call.mv-var</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbolp-of-check-mv-let-call.mv-var
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> term))
                 (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?yes/no ?mv-var ?vars
                           ?indices ?hides ?mv-term ?body-term)
                       (<a href="ACL2____CHECK-MV-LET-CALL.html">check-mv-let-call</a> term)))
                     (<a href="COMMON-LISP____SYMBOLP.html">symbolp</a> mv-var)))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>symbol-listp-of-check-mv-let-call.vars</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> symbol-listp-of-check-mv-let-call.vars
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> term))
                 (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?yes/no ?mv-var ?vars
                           ?indices ?hides ?mv-term ?body-term)
                       (<a href="ACL2____CHECK-MV-LET-CALL.html">check-mv-let-call</a> term)))
                     (<a href="ACL2____SYMBOL-LISTP.html">symbol-listp</a> vars)))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>nat-listp-of-check-mv-let-call.indices</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> nat-listp-of-check-mv-let-call.indices
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?yes/no ?mv-var ?vars
                  ?indices ?hides ?mv-term ?body-term)
              (<a href="ACL2____CHECK-MV-LET-CALL.html">check-mv-let-call</a> term)))
            (<a href="ACL2____NAT-LISTP.html">nat-listp</a> indices))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>boolean-listp-of-check-mv-let-call.hides</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> boolean-listp-of-check-mv-let-call.hides
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?yes/no ?mv-var ?vars
                  ?indices ?hides ?mv-term ?body-term)
              (<a href="ACL2____CHECK-MV-LET-CALL.html">check-mv-let-call</a> term)))
            (<a href="ACL2____BOOLEAN-LISTP.html">boolean-listp</a> hides))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>pseudo-termp-of-check-mv-let-call.mv-term</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-termp-of-check-mv-let-call.mv-term
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> term))
                 (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?yes/no ?mv-var ?vars
                           ?indices ?hides ?mv-term ?body-term)
                       (<a href="ACL2____CHECK-MV-LET-CALL.html">check-mv-let-call</a> term)))
                     (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> mv-term)))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>pseudo-termp-of-check-mv-let-call.body-term</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> pseudo-termp-of-check-mv-let-call.body-term
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> term))
                 (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?yes/no ?mv-var ?vars
                           ?indices ?hides ?mv-term ?body-term)
                       (<a href="ACL2____CHECK-MV-LET-CALL.html">check-mv-let-call</a> term)))
                     (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> body-term)))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>len-of-check-mv-let-call.indices/vars</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> len-of-check-mv-let-call.indices/vars
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> term))
                 (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?yes/no ?mv-var ?vars
                           ?indices ?hides ?mv-term ?body-term)
                       (<a href="ACL2____CHECK-MV-LET-CALL.html">check-mv-let-call</a> term)))
                     (<a href="ACL2____IMPLIES.html">implies</a> yes/no
                              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> indices) (<a href="ACL2____LEN.html">len</a> vars))))))</pre> 
<p><b>Theorem: </b>len-of-check-mv-let-call.hides/vars</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> len-of-check-mv-let-call.hides/vars
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="COMMON-LISP____AND.html">and</a> (<a href="ACL2____PSEUDO-TERMP.html">pseudo-termp</a> term))
                 (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?yes/no ?mv-var ?vars
                           ?indices ?hides ?mv-term ?body-term)
                       (<a href="ACL2____CHECK-MV-LET-CALL.html">check-mv-let-call</a> term)))
                     (<a href="ACL2____IMPLIES.html">implies</a> yes/no
                              (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____LEN.html">len</a> hides) (<a href="ACL2____LEN.html">len</a> vars))))))</pre> 
<p><b>Theorem: </b>acl2-count-of-check-mv-let-call.mv-term</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> acl2-count-of-check-mv-let-call.mv-term
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?yes/no ?mv-var ?vars
                  ?indices ?hides ?mv-term ?body-term)
              (<a href="ACL2____CHECK-MV-LET-CALL.html">check-mv-let-call</a> term)))
            (<a href="ACL2____IMPLIES.html">implies</a> yes/no
                     (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> mv-term)
                        (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> term))))
        :rule-classes :linear)</pre> 
<p><b>Theorem: </b>acl2-count-of-check-mv-let-call.body-term</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> acl2-count-of-check-mv-let-call.body-term
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?yes/no ?mv-var ?vars
                  ?indices ?hides ?mv-term ?body-term)
              (<a href="ACL2____CHECK-MV-LET-CALL.html">check-mv-let-call</a> term)))
            (<a href="ACL2____IMPLIES.html">implies</a> yes/no
                     (<a href="COMMON-LISP_____C3.html">&lt;</a> (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> body-term)
                        (<a href="ACL2____ACL2-COUNT.html">acl2-count</a> term))))
        :rule-classes :linear)</pre> 

</body>
</html>
