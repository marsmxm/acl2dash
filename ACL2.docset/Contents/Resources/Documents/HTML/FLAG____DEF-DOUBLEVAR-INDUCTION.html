<html>
<head>
<meta charset="UTF-8">
<title>Def-doublevar-induction</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=FLAG____DEF-DOUBLEVAR-INDUCTION">Click for Def-doublevar-induction in the Full Manual</a></h3>

<p>Create an induction scheme that adds a duplicate variable to the substitution.</p><p>Certain types of proofs require inductions that are rather simple 
modifications of existing induction schemes.  For example, to prove a 
congruence on some recursive function, typically you want to induct 
almost on that function, but with the simple modification that for 
each substitution in the induction scheme, you want to basically copy the 
substitution of an existing variable into a new variable.</p> 
 
<p>For example, consider our attempt to prove that sum-pairs-list is nat-list congruent:</p> 
<pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> nat-list-equiv (x y)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)
      (<a href="COMMON-LISP____ATOM.html">atom</a> y)
    (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP____CONSP.html">consp</a> y)
         (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="ACL2____NFIX.html">nfix</a> (<a href="COMMON-LISP____CAR.html">car</a> x)) (<a href="ACL2____NFIX.html">nfix</a> (<a href="COMMON-LISP____CAR.html">car</a> y)))
         (nat-list-equiv (<a href="COMMON-LISP____CDR.html">cdr</a> x) (<a href="COMMON-LISP____CDR.html">cdr</a> y)))))

(<a href="COMMON-LISP____DEFUN.html">defun</a> sum-pairs-list (x)
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)
      nil
    (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x))
        (<a href="COMMON-LISP____LIST.html">list</a> (<a href="ACL2____NFIX.html">nfix</a> (<a href="COMMON-LISP____CAR.html">car</a> x)))
      (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP_____B2.html">+</a> (<a href="ACL2____NFIX.html">nfix</a> (<a href="COMMON-LISP____CAR.html">car</a> x)) (<a href="ACL2____NFIX.html">nfix</a> (<a href="COMMON-LISP____CADR.html">cadr</a> x)))
            (sum-pairs-list (<a href="COMMON-LISP____CDDR.html">cddr</a> x))))))

(<a href="ACL2____DEFEQUIV.html">defequiv</a> nat-list-equiv)

(<a href="ACL2____DEFTHM.html">defthm</a> sum-pairs-list-nat-list-equiv-congruence
  (<a href="ACL2____IMPLIES.html">implies</a> (nat-list-equiv x y)
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (sum-pairs-list x) (sum-pairs-list y)))
  :rule-classes :congruence)</pre> 
 
<p>The proof of the congruence rule fails with no hint, and neither of the 
following induction hints don't help either:</p> 
 
<pre class="code">:hints (("goal" :induct (nat-list-equiv x y))))
:hints (("goal" :induct (<a href="COMMON-LISP____LIST.html">list</a> (sum-pairs-list x)
                                (sum-pairs-list y))))</pre> 
 
<p>What we really want is an induction scheme that inducts as sum-pairs-list 
on (say) x, but does a similar substitution on y, e.g.,</p> 
 
<pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a> sum-pairs-list-double-manual (x y)
  (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="COMMON-LISP____IGNORABLE.html">ignorable</a> y))
  (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> x)
      nil
    (<a href="COMMON-LISP____IF.html">if</a> (<a href="COMMON-LISP____ATOM.html">atom</a> (<a href="COMMON-LISP____CDR.html">cdr</a> x))
        (<a href="COMMON-LISP____LIST.html">list</a> (<a href="ACL2____NFIX.html">nfix</a> (<a href="COMMON-LISP____CAR.html">car</a> x)))
      (<a href="COMMON-LISP____CONS.html">cons</a> (<a href="COMMON-LISP_____B2.html">+</a> (<a href="ACL2____NFIX.html">nfix</a> (<a href="COMMON-LISP____CAR.html">car</a> x)) (<a href="ACL2____NFIX.html">nfix</a> (<a href="COMMON-LISP____CADR.html">cadr</a> x)))
            (sum-pairs-list-double-manual (<a href="COMMON-LISP____CDDR.html">cddr</a> x) (<a href="COMMON-LISP____CDDR.html">cddr</a> y))))))

(<a href="ACL2____DEFTHM.html">defthm</a> sum-pairs-list-nat-list-equiv-congruence ;; sum-pairs-list-double-manual works
  (<a href="ACL2____IMPLIES.html">implies</a> (nat-list-equiv x y)
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (sum-pairs-list x) (sum-pairs-list y)))
  :hints (("goal" :induct (sum-pairs-list-double-manual x y)))
  :rule-classes :congruence)</pre> 
 
<p>Def-doublevar-ind automatically generates a function like this, e.g.:</p> 
 
<pre class="code">(<a href="FLAG____DEF-DOUBLEVAR-INDUCTION.html">def-doublevar-induction</a> sum-pairs-list-double
  :orig-fn sum-pairs-list
  :old-var x :new-var y)

(<a href="ACL2____DEFTHM.html">defthm</a> sum-pairs-list-nat-list-equiv-congruence ;; sum-pairs-list-double works
  (<a href="ACL2____IMPLIES.html">implies</a> (nat-list-equiv x y)
           (<a href="COMMON-LISP____EQUAL.html">equal</a> (sum-pairs-list x) (sum-pairs-list y)))
  :hints (("goal" :induct (sum-pairs-list-double x y)))
  :rule-classes :congruence)</pre> 
 
<p>This can be used with flag functions and their defthm macros (see <a href="ACL2____MAKE-FLAG.html">make-flag</a>): use def-doublevar-ind to define a new induction scheme based on the flag function, and give a hint to the flag defthm macro to use that induction scheme. For example,</p> 
<pre class="code">(<a href="ACL2____MAKE-FLAG.html">flag::make-flag</a> foo-flag foo-mutualrec ...)

(flag::def-doublevar-ind foo-doublevar-ind
  :orig-fn foo-flag
  :old-var x :new-var y)

(defthm-foo-flag
 (<a href="ACL2____DEFTHM.html">defthm</a> foo1-thm ...)
 (<a href="ACL2____DEFTHM.html">defthm</a> foo2-thm ...)
 :hints (("goal" :induct (foo-doublevar-ind flag x a b y))))</pre> 

</body>
</html>
