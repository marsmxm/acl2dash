<html>
<head>
<meta charset="UTF-8">
<title>Bip32-master-key</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=BITCOIN____BIP32-MASTER-KEY">Click for Bip32-master-key in the Full Manual</a></h3>

<p>Generate a master key from a seed.</p><div class="box"><dl> 
  <dt>Signature</dt>
<dt><pre class="code">(bip32-master-key seed) → (mv error? key)</pre></dt>  <dt>Arguments</dt>  <dd>
<span class="tt">seed</span> — <font color="#606060">Guard <span class="v">(<a href="ACL2____BYTE-LISTP.html">byte-listp</a> seed)</span>.</font>
</dd> 
<dt>Returns</dt>
<dd>
<span class="tt">error?</span> — <font color="#606060">Type <span class="v">(<a href="ACL2____BOOLEANP.html">booleanp</a> error?)</span>.</font>
</dd> 
<dd>
<span class="tt">key</span> — <font color="#606060">Type <span class="v">(<a href="BITCOIN____BIP32-EXT-PRIV-KEY-P.html">bip32-ext-priv-key-p</a> key)</span>.</font>
</dd> 
 
</dl></div> 
<p>The exact generation of the seed is not specified in [BIP32], 
     so it is an input to this function.</p><p>[BIP32] constrains the length of the seed in bits, 
     namely to be between 128 and 512 bits. 
     In principle, the seed could consist of a number of bits 
     that is not a multiple of 8, 
     but this seems unlikely in practice: 
     that is, the seed will likey consist of a number of whole bytes. 
     The number of whole bytes must be therefore between 16 and 64.</p><p>The key for HMAC-SHA-512 is shown as the string 
     <span class="v">"Bitcoin seed"</span> in [BIP32]. 
     It seems reasonable to regard that as the list of bytes 
     consisting of the ASCII codes of the characters in the string, 
     in the order in which they appear in the string.</p><p>If the calculated private key is invalid as specified in [BIP32], 
     we return an error flag as the first result; 
     in this case, the second result (the key) is irrelevant). 
     Otherwise, the first result is <span class="v">nil</span>, i.e. no error.</p> 
 
<h3>Definitions and Theorems</h3><p><b>Function: </b>bip32-master-key</p><pre class="code">(<a href="COMMON-LISP____DEFUN.html">defun</a>
     bip32-master-key (seed)
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="ACL2____BYTE-LISTP.html">byte-listp</a> seed)))
     (<a href="COMMON-LISP____DECLARE.html">declare</a> (<a href="ACL2____XARGS.html">xargs</a> :guard (<a href="COMMON-LISP____AND.html">and</a> (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> 16 (<a href="ACL2____LEN.html">len</a> seed))
                                 (<a href="COMMON-LISP_____C3_D3.html">&lt;=</a> (<a href="ACL2____LEN.html">len</a> seed) 64))))
     (<a href="ACL2____B_A2.html">b*</a> ((hmac-key (<a href="ACL2____STRING_D3_E3NATS.html">string=&gt;nats</a> "Bitcoin seed"))
          (hmac-data seed)
          (big-i (hmac-sha-512 hmac-key hmac-data))
          (big-i-l (<a href="ACL2____TAKE.html">take</a> 32 big-i))
          (big-i-r (<a href="COMMON-LISP____NTHCDR.html">nthcdr</a> 32 big-i))
          (parsed-big-i-l (<a href="ACL2____BEBYTES_D3_E3NAT.html">bebytes=&gt;nat</a> big-i-l))
          (n (<a href="PRIMES____SECP256K1-GROUP-PRIME.html">secp256k1-group-prime</a>))
          ((when (<a href="COMMON-LISP____OR.html">or</a> (<a href="COMMON-LISP_____D3.html">=</a> parsed-big-i-l 0)
                     (<a href="COMMON-LISP_____E3_D3.html">&gt;=</a> parsed-big-i-l n)))
           (<a href="ACL2____B_A2.html">b*</a> ((irrelevant-ext-key (<a href="BITCOIN____BIP32-EXT-PRIV-KEY.html">bip32-ext-priv-key</a> 1 big-i-r)))
               (<a href="ACL2____MV.html">mv</a> t irrelevant-ext-key)))
          (ext-key (<a href="BITCOIN____BIP32-EXT-PRIV-KEY.html">bip32-ext-priv-key</a> parsed-big-i-l big-i-r)))
         (<a href="ACL2____MV.html">mv</a> nil ext-key)))</pre> 
<p><b>Theorem: </b>booleanp-of-bip32-master-key.error?</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> booleanp-of-bip32-master-key.error?
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?error? ?key)
              (<a href="BITCOIN____BIP32-MASTER-KEY.html">bip32-master-key</a> seed)))
            (<a href="ACL2____BOOLEANP.html">booleanp</a> error?))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>bip32-ext-priv-key-p-of-bip32-master-key.key</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bip32-ext-priv-key-p-of-bip32-master-key.key
        (<a href="ACL2____B_A2.html">b*</a> (((<a href="ACL2____MV.html">mv</a> ?error? ?key)
              (<a href="BITCOIN____BIP32-MASTER-KEY.html">bip32-master-key</a> seed)))
            (<a href="BITCOIN____BIP32-EXT-PRIV-KEY-P.html">bip32-ext-priv-key-p</a> key))
        :rule-classes :rewrite)</pre> 
<p><b>Theorem: </b>bip32-master-key-of-byte-list-fix-seed</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bip32-master-key-of-byte-list-fix-seed
        (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="BITCOIN____BIP32-MASTER-KEY.html">bip32-master-key</a> (<a href="ACL2____BYTE-LIST-FIX.html">byte-list-fix</a> seed))
               (<a href="BITCOIN____BIP32-MASTER-KEY.html">bip32-master-key</a> seed)))</pre> 
<p><b>Theorem: </b>bip32-master-key-byte-list-equiv-congruence-on-seed</p><pre class="code">(<a href="ACL2____DEFTHM.html">defthm</a> bip32-master-key-byte-list-equiv-congruence-on-seed
        (<a href="ACL2____IMPLIES.html">implies</a> (<a href="ACL2____BYTE-LIST-EQUIV.html">byte-list-equiv</a> seed seed-equiv)
                 (<a href="COMMON-LISP____EQUAL.html">equal</a> (<a href="BITCOIN____BIP32-MASTER-KEY.html">bip32-master-key</a> seed)
                        (<a href="BITCOIN____BIP32-MASTER-KEY.html">bip32-master-key</a> seed-equiv)))
        :rule-classes :congruence)</pre> 

</body>
</html>
