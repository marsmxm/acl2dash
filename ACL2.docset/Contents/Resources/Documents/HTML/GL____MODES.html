<html>
<head>
<meta charset="UTF-8">
<title>Modes</title>
<link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>

<h3><a href="../index.html?topic=GL____MODES">Click for Modes in the Full Manual</a></h3>

<p>GL modes allow you to control major aspects of how GL carries out its 
symbolic simulation and how it should solve Boolean formulas that arise during 
proofs.</p><p>For some general background, see section 
<a href="GL____4._02Proving_02Theorems_02by_02Symbolic_02Execution.html">4. Proving Theorems by Symbolic Execution</a> of the <a href="GL____BASIC-TUTORIAL.html">basic-tutorial</a>.</p> 
 
<p>By default, GL operates in <a href="ACL2____GL-BDD-MODE.html">gl-bdd-mode</a>.  In this mode, the Boolean 
formulas within <a href="GL____SYMBOLIC-OBJECTS.html">symbolic-objects</a> are represented using <a href="ACL2____UBDDS.html">ubdds</a>, and 
questions about these formulas are resolved using BDD operations.</p> 
 
<p>But GL also supports other modes, and you can easily switch between modes on 
a proof-by-proof basis.  Typically this looks like:</p> 
 
<pre class="code">(<a href="ACL2____LOCAL.html">local</a> (<a href="ACL2____GL-BDD-MODE.html">gl::gl-bdd-mode</a>))
(<a href="ACL2____DEF-GL-THM.html">def-gl-thm</a> foo ...)

(<a href="ACL2____LOCAL.html">local</a> (<a href="GL____GL-SATLINK-MODE.html">gl::gl-satlink-mode</a>))
(<a href="ACL2____DEF-GL-THM.html">def-gl-thm</a> bar ...)</pre> 
 
<p>GL's other modes use And-Inverter Graphs (<a href="ACL2____AIG.html">aig</a>s) as the Boolean 
function representation.  Unlike BDDs, AIGs are non-canonical, and this affects 
performance in fundamental ways: AIGs are generally much cheaper to construct 
than BDDs, but it can be hard to determine whether AIGs are equivalent, whereas 
with BDDs this is just a pointer-equality check.</p> 
 
<p>A very convenient feature of AIGs is that you do not have to come up with a 
good variable orderingâ€”this may be especially helpful on problems where 
<a href="GL____CASE-SPLITTING.html">case-splitting</a> would be necessary because there's not a universally good 
BDD ordering.  On the other hand, BDDs can provide especially nice 
counterexamples, whereas with AIGs we typically get just one, essentially 
random counterexample.</p> 
 
<p>Performance-wise, AIGs are better for some problems and BDDs for others. 
Many operations combine bits from data buses in a regular, orderly way; in 
these cases, there is often a good BDD ordering and BDDs may be faster than our 
AIG modes.  But when the operations are less regular, when no good BDD ordering 
is apparent, or when case-splitting seems necessary to get good BDD 
performance, the AIG modes may do better.  For many of our proofs, AIG mode 
performs well and saves us the trouble of finding a good BDD ordering.</p> 
 
<h4>Solving AIGs</h4> 
 
<p>When AIGs are used to carry out GL proofs, we need some way to answer 
whether the final AIG is satisfiable.  To do this, GL can use one of two 
back-end solvers.</p> 
 
<p>Usually the better and higher-performance option is to send the AIG to an 
external SAT solver; see <a href="GL____GL-SATLINK-MODE.html">gl-satlink-mode</a>.  In this mode, GL uses the 
<a href="ACL2____SATLINK.html">satlink</a> library to call upon an off-the-shelf SAT solver.  Using 
external SAT solvers raises questions of trust, and GL does not yet implement 
any sort of proof-checking for the SAT solver's output.  But pragmatically, for 
most verification efforts, it is probably reasonable to trust a SAT solver.</p> 
 
<p>Another option is to simply convert the AIG into BDDs; see <a href="GL____GL-AIG-BDDIFY-MODE.html">gl-aig-bddify-mode</a>.  This isn't necessarily a good idea, and you still have to 
worry about the variable order in this case.  Occasionally this <i>may</i> 
out-perform just using BDDs to begin with, because there are certain 
optimizations you can make when converting from AIGs to BDDs that aren't 
possible when you just use BDDs for everything.  This is also a high-confidence 
mode, where the whole proof is carried out within ACL2, with just some minimal 
trust-tags to boost performance.</p> 
 

</body>
</html>
